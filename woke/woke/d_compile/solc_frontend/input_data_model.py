from typing import Optional, List, Dict

from strenum import StrEnum
from pydantic import BaseModel, Field, root_validator

__doc__ = """Solc standard JSON input data model as described by https://docs.soliditylang.org/en/v0.8.12/using-the-compiler.html#input-description"""


class EvmVersionEnum(StrEnum):
    HOMESTEAD = "homestead"
    TANGERINE_WHISTLE = "tangerineWhistle"
    SPURIOUS_DRAGON = "spuriousDragon"
    BYZANTIUM = "byzantium"
    CONSTANTINOPLE = "constantinople"
    PETERSBURG = "petersburg"
    ISTANBUL = "istanbul"
    BERLIN = "berlin"
    LONDON = "london"


class SolcStopAfterEnum(StrEnum):
    PARSING = "parsing"


class MetadataBytecodeHashEnum(StrEnum):
    NONE = "none"
    IPFS = "ipfs"
    BZZR1 = "bzzr1"


class OutputSelectionEnum(StrEnum):
    AST = "ast"
    ABI = "abi"
    DEVDOC = "devdoc"
    """Developer documentation (natspec)"""
    USERDOC = "userdoc"
    """User documentation (natspec)"""
    METADATA = "metadata"
    IR = "ir"
    """Yul intermediate representation of the code before optimization"""
    IR_OPTIMIZED = "irOptimized"
    """Intermediate representation after optimization"""
    STORAGE_LAYOUT = "storageLayout"
    """Slots, offsets and types of the contract's state variables"""
    EVM_ASSEMBLY = "evm.assembly"
    """New assembly format"""
    EVM_LEGACY_ASSEMBLY = "evm.legacyAssembly"
    """Old-style assembly format in JSON"""
    EVM_BYTECODE_FUNCTION_DEBUG_DATA = "evm.bytecode.functionDebugData"
    """Debugging information at function level"""
    EVM_BYTECODE_OBJECT = "evm.bytecode.object"
    """Bytecode object"""
    EVM_BYTECODE_OPCODES = "evm.bytecode.opcodes"
    """Opcodes list"""
    EVM_BYTECODE_SOURCE_MAP = "evm.bytecode.sourceMap"
    """Source mapping (useful for debugging)"""
    EVM_BYTECODE_LINK_REFERENCES = "evm.bytecode.linkReferences"
    """Link references (if unlinked object)"""
    EVM_BYTECODE_GENERATED_SOURCES = "evm.bytecode.generatedSources"
    """Sources generated by the compiler"""
    EVM_DEPLOYED_BYTECODE = "evm.deployedBytecode"
    """Deployed bytecode (has all the options that evm.bytecode has)"""
    EVM_DEPLOYED_BYTECODE_IMMUTABLE_REFERENCES = (
        "evm.deployedBytecode.immutableReferences"
    )
    """Map from AST ids to bytecode ranges that reference immutables"""
    EVM_METHOD_IDENTIFIERS = "evm.methodIdentifiers"
    """The list of function hashes"""
    EVM_GAS_ESTIMATES = "evm.gasEstimates"
    """Function gas estimates"""
    EWASM_WAST = "ewasm.wast"
    """Ewasm in WebAssembly S-expressions format"""
    EWASM_WASM = "ewasm.wasm"
    """Ewasm in WebAssembly binary format"""


class ModelCheckerEngineEnum(StrEnum):
    ALL = "all"
    BMC = "bmc"
    CHC = "chc"
    NONE = "none"


class ModelCheckerInvariantsEnum(StrEnum):
    CONTRACT = "contract"
    REENTRANCY = "reentrancy"


class ModelCheckerSolversEnum(StrEnum):
    CVC4 = "cvc4"
    SMTLIB2 = "smtlib2"
    Z3 = "z3"


class ModelCheckerTargetsEnum(StrEnum):
    CONSTANT_CONDITION = "constantCondition"
    UNDERFLOW = "underflow"
    OVERFLOW = "overflow"
    DIV_BY_ZERO = "divByZero"
    BALANCE = "balance"
    ASSERT = "assert"
    POP_EMPTY_ARRAY = "popEmptyArray"
    OUT_OF_BOUNDS = "outOfBounds"


def _to_camel(s: str) -> str:
    split = s.split("_")
    return split[0].lower() + "".join([w.capitalize() for w in split[1:]])


class SolcInputModel(BaseModel):
    class Config:
        alias_generator = _to_camel


class SolcInputSource(SolcInputModel):
    keccak256: Optional[str] = None
    content: Optional[str] = None
    urls: Optional[List[str]] = None

    @root_validator
    def content_or_urls_set(cls, values):
        content, urls = values.get("content"), values.get("urls")
        assert (content is None) != (
            urls is None
        ), "SolcInputSource: exactly one of `content`, `urls` must be set"
        return values


class SolcInputOptimizerYulDetailsSettings(SolcInputModel):
    stack_allocation: bool = True
    optimizer_steps: Optional[str]


class SolcInputOptimizerDetailsSettings(SolcInputModel):
    peephole: bool = True
    inliner: bool = True
    jumpdest_remover: bool = True
    order_literals: bool = False
    deduplicate: bool = False
    cse: bool = False
    constant_optimizer: bool = False
    yul: bool = False
    yul_details: Optional[SolcInputOptimizerYulDetailsSettings]


class SolcInputOptimizerSettings(SolcInputModel):
    enabled: bool = False
    runs: int
    details: Optional[SolcInputOptimizerDetailsSettings]


class SolcInputDebugRevertStringsSettingsEnum(StrEnum):
    """How to treat revert (and require) reason strings."""

    DEFAULT = "default"
    """Do not inject compiler-generated revert strings and keep user-supplied ones."""
    STRIP = "strip"
    """Remove all revert strings (if possible, i.e. if literals are used) keeping side-effects"""
    DEBUG = "debug"
    """Inject strings for compiler-generated internal reverts, implemented for ABI encoders V1 and V2 for now."""
    VERBOSE_DEBUG = "verboseDebug"
    """Even append further information to user-supplied revert strings (not yet implemented)"""


class SolcInputDebugInfoSettingsEnum(StrEnum):
    """How much extra debug information to include in comments in the produced EVM assembly and Yul code."""

    LOCATION = "location"
    """
    Annotations of the form `@src <index>:<start>:<end>` indicating the location of the corresponding element in the original Solidity file, where:
    * `<index>` is the file index matching the `@use-src` annotation,
    * `<start>` is the index of the first byte at that location,
    * `<end>` is the index of the first byte after that location.
    """
    SNIPPET = "snippet"
    """A single-line code snippet from the location indicated by `@src`. The snippet is quoted and follows the corresponding `@src` annotation."""


class SolcInputDebugSettings(SolcInputModel):
    revert_strings: SolcInputDebugRevertStringsSettingsEnum
    debug_info: Optional[List[SolcInputDebugInfoSettingsEnum]]


class SolcInputMetadataSettings(SolcInputModel):
    use_literal_content: bool = False
    bytecode_hash: MetadataBytecodeHashEnum = Field(MetadataBytecodeHashEnum.IPFS)


class SolcInputModelCheckerSettings(SolcInputModel):
    contracts: Dict[str, List[str]]  # source unit name -> list of contract names
    div_mod_with_slacks: bool = True
    engine: ModelCheckerEngineEnum = Field(ModelCheckerEngineEnum.ALL)
    invariants: List[ModelCheckerInvariantsEnum]
    show_unproved: bool = False
    solvers: List[ModelCheckerSolversEnum]
    targets: List[ModelCheckerTargetsEnum]
    timeout: Optional[int]


class SolcInputSettings(SolcInputModel):
    stop_after: Optional[SolcStopAfterEnum] = None
    remappings: Optional[List[str]] = None
    optimizer: Optional[SolcInputOptimizerSettings] = None
    evm_version: Optional[EvmVersionEnum] = None
    via_IR: bool = Field(False, alias="viaIR")
    debug: Optional[SolcInputDebugSettings] = None
    metadata: Optional[SolcInputMetadataSettings] = None
    libraries: Optional[
        Dict[str, Dict[str, str]]
    ] = None  # source unit name -> (lib name -> address)
    output_selection: Optional[
        Dict[str, Dict[str, List[OutputSelectionEnum]]]
    ] = None  # source unit name -> (contract name / empty for whole file / start for all contracts ->
    model_checker: Optional[SolcInputModelCheckerSettings] = None


class SolcInput(SolcInputModel):
    language = "Solidity"
    sources: Dict[str, SolcInputSource] = {}
    settings: Optional[SolcInputSettings] = None
