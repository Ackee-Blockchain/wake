from __future__ import annotations

import dataclasses
import functools
import importlib
import json
import math
import re
import sys
from abc import ABC, abstractmethod
from bdb import BdbQuit
from collections import ChainMap, defaultdict
from contextlib import contextmanager
from copy import deepcopy
from enum import Enum, IntEnum
from os import PathLike
from pathlib import Path
from typing import (
    TYPE_CHECKING,
    Any,
    Callable,
    DefaultDict,
    Dict,
    Iterable,
    List,
    Optional,
    Sequence,
    Set,
    Tuple,
    Type,
    Union,
    cast,
    overload,
)
from urllib.error import HTTPError

import eth_utils
from Crypto.Hash import BLAKE2b, keccak
from typing_extensions import (
    Annotated,
    Literal,
    TypedDict,
    get_args,
    get_origin,
    get_type_hints,
)

from wake_rs import (
    Abi,
    Account,
    Address,
    Contract,
    Library,
    abi,
    encode_eip712_data,
    encode_eip712_type,
)

from ..utils import StrEnum
from ..utils.keyed_default_dict import KeyedDefaultDict
from . import hardhat_console
from .blocks import ChainBlocks
from .chain_interfaces import (
    AnvilChainInterface,
    ChainInterfaceAbc,
    GethLikeChainInterfaceAbc,
    HardhatChainInterface,
    SignedAuthorization,
    TxParams,
)
from .globals import (
    chain_interfaces_manager,
    get_config,
    get_coverage_handler,
    get_exception_handler,
)
from .internal import UnknownEvent, read_from_memory
from .json_rpc.communicator import JsonRpcError
from .primitive_types import (
    FixedSizeBytes,
    FixedSizeList,
    Integer,
    fixed_bytes_map,
    fixed_list_map,
    int_map,
    uint256,
    uint_map,
)

if TYPE_CHECKING:
    from .transactions import ChainTransactions, RevertError, TransactionAbc


# selector => (contract_fqn => pytypes_object)
errors: Dict[bytes, Dict[str, Any]] = {}
# selector => (contract_fqn => pytypes_object)
events: Dict[bytes, Dict[str, Any]] = {}
# contract_fqn => contract type
contracts_by_fqn: Dict[str, Any] = {}
# contract_metadata => contract_fqn
contracts_by_metadata: Dict[bytes, str] = {}
# contract_fqn => tuple of linearized base contract fqns
contracts_inheritance: Dict[str, Tuple[str, ...]] = {}
# list of pairs of (creation code segments, contract_fqn)
# where creation code segments is a tuple of (length, BLAKE2b hash)
creation_code_index: List[Tuple[Tuple[Tuple[int, bytes], ...], str]] = []
# user defined value type type identifier => underlying type type identifier
user_defined_value_types_index: Dict[str, str] = {}


def get_contracts_by_fqn() -> Dict[str, Any]:
    return contracts_by_fqn


def get_user_defined_value_types_index() -> Dict[str, str]:
    return user_defined_value_types_index


class RevertToSnapshotFailedError(Exception):
    pass


class NotConnectedError(Exception):
    pass


class AlreadyConnectedError(Exception):
    pass


class TransactionConfirmationFailedError(Exception):
    pass


class Struct:
    def encode_eip712_type(self) -> str:
        return encode_eip712_type(self)

    def encode_eip712_data(self) -> bytes:
        return encode_eip712_data(self)


class RequestType(StrEnum):
    ACCESS_LIST = "access_list"
    CALL = "call"
    ESTIMATE = "estimate"
    TX = "tx"


def fix_library_abi(args: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    ret = []
    for arg in args:
        arg = deepcopy(arg)
        if arg["type"] == "tuple":
            fix_library_abi(arg["components"])
        elif "internalType" in arg:
            # internalType was added in 0.5.11
            # versions before 0.5.11 are not supported by Wake anyway
            # but we may fetch ABIs generated by an older version of solc through Etherscan
            if arg["internalType"].startswith("contract "):
                # replace contract type with "address" but keep array suffix (if any)
                arg["type"] = arg["type"].replace(
                    arg["type"].split("[", 1)[0], "address"
                )
            elif arg["internalType"].startswith("enum "):
                # replace enum type with "uint8" but keep array suffix (if any)
                arg["type"] = arg["type"].replace(arg["type"].split("[", 1)[0], "uint8")
        ret.append(arg)
    return ret


class Wei(int):
    def to_ether(self) -> float:
        return self / 10**18

    def to_gwei(self) -> float:
        return self / 10**9

    @classmethod
    def from_ether(cls, value: Union[int, float]) -> Wei:
        return cls(int(value * 10**18))

    @classmethod
    def from_gwei(cls, value: Union[int, float]) -> Wei:
        return cls(int(value * 10**9))

    @classmethod
    def from_str(cls, value: str) -> Wei:
        count, unit = value.split()
        return cls(eth_utils.currency.to_wei(float(count), unit))


def detect_default_chain() -> Chain:
    if "wake.deployment" in sys.modules and "wake.testing" in sys.modules:
        import wake.deployment
        import wake.testing

        if wake.deployment.chain.connected and wake.testing.chain.connected:
            raise ValueError(
                "Both wake.testing.chain and wake.deployment.chain are connected. Please specify which chain to use."
            )

        if wake.deployment.chain.connected:
            return wake.deployment.chain
        elif wake.testing.chain.connected:
            return wake.testing.chain
        else:
            raise NotConnectedError("`chain` not connected")
    elif "wake.deployment" in sys.modules:
        import wake.deployment

        return wake.deployment.chain
    elif "wake.testing" in sys.modules:
        import wake.testing

        return wake.testing.chain
    else:
        raise NotConnectedError("`chain` not connected")


Eip712Domain = TypedDict(
    "Eip712Domain",
    {
        "name": str,
        "version": str,
        "chainId": int,
        "verifyingContract": Union[Account, Address, str],
        "salt": bytes,
    },
    total=False,
)


def check_connected(f):
    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        if not args[0].connected:
            raise NotConnectedError("Not connected to a chain")
        return f(*args, **kwargs)

    return wrapper


_test_accounts_generated_count: int = 0


class Chain(ABC):
    _connected: bool
    _chain_interface: ChainInterfaceAbc
    _accounts: List[Account]
    _accounts_set: Set[Account]  # for faster lookup
    _default_call_account: Optional[Account]
    _default_tx_account: Optional[Account]
    _default_estimate_account: Optional[Account]
    _default_access_list_account: Optional[Account]
    _default_tx_confirmations: int
    _deployed_libraries: DefaultDict[bytes, List[Library]]
    _single_source_errors: Set[bytes]
    _snapshots: Dict[str, Dict]
    _blocks: ChainBlocks
    _txs: ChainTransactions
    _chain_id: int
    _labels: Dict[Address, str]
    _require_signed_txs: bool
    _fork: Optional[str]
    _forked_chain_id: Optional[int]
    _debug_trace_call_supported: bool
    _client_version: str
    optimistic_pytypes_resolving: bool

    tx_callback: Optional[Callable[[TransactionAbc], None]]

    def __deepcopy__(self, memo):
        return self

    @abstractmethod
    def _connect_setup(
        self, min_gas_price: Optional[int], block_base_fee_per_gas: Optional[int]
    ) -> None:
        ...

    @abstractmethod
    def _connect_finalize(self) -> None:
        ...

    @abstractmethod
    def _new_private_key(self, extra_entropy: bytes = b"") -> bytes:
        ...

    @abstractmethod
    def snapshot(self) -> str:
        ...

    @abstractmethod
    def revert(self, snapshot_id: str) -> None:
        ...

    @abstractmethod
    def _build_transaction(
        self,
        request_type: RequestType,
        params: TxParams,
        arguments: Iterable,
        abi: Optional[Dict],
        block_identifier: Union[int, str],
    ) -> TxParams:
        ...

    @abstractmethod
    def _wait_for_transaction(
        self, tx: TransactionAbc, confirmations: Optional[int]
    ) -> None:
        ...

    @abstractmethod
    def _confirm_transaction(self, tx: TxParams) -> None:
        ...

    @property
    @abstractmethod
    def block_gas_limit(self) -> int:
        ...

    @block_gas_limit.setter
    @abstractmethod
    def block_gas_limit(self, value: int) -> None:
        ...

    @property
    @abstractmethod
    def gas_price(self) -> Wei:
        ...

    @gas_price.setter
    @abstractmethod
    def gas_price(self, value: int) -> None:
        ...

    @property
    @abstractmethod
    def max_priority_fee_per_gas(self) -> Wei:
        ...

    @max_priority_fee_per_gas.setter
    @abstractmethod
    def max_priority_fee_per_gas(self, value: int) -> None:
        ...

    @contextmanager  # pyright: ignore reportGeneralTypeIssues
    @abstractmethod
    def connect(
        self,
        uri: Optional[str] = None,
        *,
        accounts: Optional[int] = None,
        chain_id: Optional[int] = None,
        fork: Optional[str] = None,
        hardfork: Optional[str] = None,
        min_gas_price: Optional[Union[int, str]],
        block_base_fee_per_gas: Optional[Union[int, str]],
    ):
        ...

    def __init__(self):
        self._connected = False
        self._labels = {}
        self.optimistic_pytypes_resolving = False

    def _connect(
        self,
        uri: Optional[str] = None,
        *,
        accounts: Optional[int],
        chain_id: Optional[int],
        fork: Optional[str],
        hardfork: Optional[str],
        min_gas_price: Optional[Union[int, str]],
        block_base_fee_per_gas: Optional[Union[int, str]],
    ):
        global _test_accounts_generated_count

        if self._connected:
            raise AlreadyConnectedError("Already connected to a chain")

        if isinstance(min_gas_price, str):
            min_gas_price = Wei.from_str(min_gas_price)
        if isinstance(block_base_fee_per_gas, str):
            block_base_fee_per_gas = Wei.from_str(block_base_fee_per_gas)

        self._chain_interface = chain_interfaces_manager.get_or_create(
            uri, accounts=accounts, chain_id=chain_id, fork=fork, hardfork=hardfork
        )

        try:
            self._connected = True
            self._client_version = self._chain_interface.get_client_version()

            try:
                self._chain_interface.debug_trace_call(
                    {
                        "type": 0,
                    }
                )
                self._debug_trace_call_supported = True
            except (JsonRpcError, HTTPError):
                self._debug_trace_call_supported = False

            self._chain_id = self._chain_interface.get_chain_id()

            # determine the forked chain id (if any)
            # determine the chain hardfork to set the default tx type
            if isinstance(self._chain_interface, AnvilChainInterface):
                info = self._chain_interface.node_info()

                if (
                    "forkConfig" in info
                    and "forkUrl" in info["forkConfig"]
                    and info["forkConfig"]["forkUrl"] is not None
                ):
                    forked_chain_interface = ChainInterfaceAbc.connect(
                        get_config(), info["forkConfig"]["forkUrl"]
                    )
                    try:
                        self._forked_chain_id = forked_chain_interface.get_chain_id()
                    finally:
                        forked_chain_interface.close()
                else:
                    self._forked_chain_id = None
            elif isinstance(
                self._chain_interface,
                (GethLikeChainInterfaceAbc, HardhatChainInterface),
            ):
                if isinstance(self._chain_interface, GethLikeChainInterfaceAbc):
                    self._forked_chain_id = None
                else:
                    metadata = self._chain_interface.hardhat_metadata()
                    if (
                        "forkedNetwork" in metadata
                        and "chainId" in metadata["forkedNetwork"]
                    ):
                        self._forked_chain_id = metadata["forkedNetwork"]["chainId"]
                    else:
                        self._forked_chain_id = None
            else:
                raise NotImplementedError(
                    f"Unknown chain interface type: {type(self._chain_interface)}"
                )

            if block_base_fee_per_gas is not None:
                try:
                    self._chain_interface.set_next_block_base_fee_per_gas(
                        block_base_fee_per_gas
                    )
                except JsonRpcError:
                    pass

            from .transactions import ChainTransactions

            self._txs = ChainTransactions(self)

            self._accounts = [
                Account(acc, self) for acc in self._chain_interface.get_accounts()
            ]

            if len(self._accounts) > _test_accounts_generated_count:
                # generate private keys for accounts without private key
                for i in range(_test_accounts_generated_count, len(self._accounts)):
                    Address.from_mnemonic(
                        "test test test test test test test test test test test junk",
                        path=f"m/44'/60'/0'/0/{i}",
                    )
                _test_accounts_generated_count = len(self._accounts)

            self._accounts_set = set(self._accounts)
            self._snapshots = {}
            self._deployed_libraries = defaultdict(list)

            if len(self._accounts) > 0:
                self.set_default_accounts(self._accounts[0])
            else:
                self.set_default_accounts(None)
            self._default_tx_confirmations = 1
            self._blocks = ChainBlocks(self)
            self._fork = fork

            self._single_source_errors = {
                selector
                for selector, sources in errors.items()
                if len({source for fqn, source in sources.items()}) == 1
            }

            self.tx_callback = None

            self._connect_setup(min_gas_price, block_base_fee_per_gas)

            yield self
        except Exception as e:
            if not isinstance(e, BdbQuit):
                exception_handler = get_exception_handler()
                if exception_handler is not None:
                    exception_handler(*sys.exc_info())
                raise
        finally:
            self._connect_finalize()
            self._connected = False

    @property
    def connected(self) -> bool:
        return self._connected

    @property
    def client_version(self) -> str:
        return self._client_version

    @property
    @check_connected
    def chain_interface(self) -> ChainInterfaceAbc:
        return self._chain_interface

    @property
    @check_connected
    def chain_id(self) -> uint256:
        return uint256(self._chain_id)

    @property
    @check_connected
    def forked_chain_id(self) -> Optional[uint256]:
        return (
            uint256(self._forked_chain_id)
            if self._forked_chain_id is not None
            else None
        )

    @property
    @check_connected
    def accounts(self) -> Tuple[Account, ...]:
        return tuple(self._accounts)

    @property
    @check_connected
    def txs(self) -> ChainTransactions:
        return self._txs

    @property
    @check_connected
    def default_call_account(self) -> Optional[Account]:
        return self._default_call_account

    @default_call_account.setter
    @check_connected
    def default_call_account(self, account: Union[Account, Address, str]) -> None:
        if isinstance(account, Account):
            if account.chain != self:
                raise ValueError("Account is not from this chain")
            self._default_call_account = account
        else:
            self._default_call_account = Account(account, self)

    @property
    @check_connected
    def default_tx_account(self) -> Optional[Account]:
        return self._default_tx_account

    @default_tx_account.setter
    @check_connected
    def default_tx_account(self, account: Union[Account, Address, str]) -> None:
        if isinstance(account, Account):
            if account.chain != self:
                raise ValueError("Account is not from this chain")
            self._default_tx_account = account
        else:
            self._default_tx_account = Account(account, self)

    @property
    @check_connected
    def default_estimate_account(self) -> Optional[Account]:
        return self._default_estimate_account

    @default_estimate_account.setter
    @check_connected
    def default_estimate_account(self, account: Union[Account, Address, str]) -> None:
        if isinstance(account, Account):
            if account.chain != self:
                raise ValueError("Account is not from this chain")
            self._default_estimate_account = account
        else:
            self._default_estimate_account = Account(account, self)

    @property
    @check_connected
    def default_access_list_account(self) -> Optional[Account]:
        return self._default_access_list_account

    @default_access_list_account.setter
    @check_connected
    def default_access_list_account(
        self, account: Union[Account, Address, str]
    ) -> None:
        if isinstance(account, Account):
            if account.chain != self:
                raise ValueError("Account is not from this chain")
            self._default_access_list_account = account
        else:
            self._default_access_list_account = Account(account, self)

    @property
    @check_connected
    def coinbase(self) -> Account:
        return Account(self._chain_interface.get_coinbase(), self)

    @coinbase.setter
    @check_connected
    def coinbase(self, value: Union[Account, Address, str]) -> None:
        if isinstance(value, Account):
            if value.chain != self:
                raise ValueError("Account is not from this chain")
            self._chain_interface.set_coinbase(str(value.address))
        else:
            self._chain_interface.set_coinbase(str(value))

    @property
    @check_connected
    def blocks(self) -> ChainBlocks:
        return self._blocks

    @property
    @check_connected
    def require_signed_txs(self) -> bool:
        return self._require_signed_txs

    @require_signed_txs.setter
    @check_connected
    def require_signed_txs(self, value: bool) -> None:
        self._require_signed_txs = value

    @property
    @check_connected
    def default_tx_confirmations(self) -> int:
        return self._default_tx_confirmations

    @default_tx_confirmations.setter
    @check_connected
    def default_tx_confirmations(self, value: int) -> None:
        if value < 0:
            raise ValueError("Invalid transaction confirmations value")
        self._default_tx_confirmations = value

    @contextmanager
    def change_automine(self, automine: bool):
        if not self._connected:
            raise NotConnectedError("Not connected to a chain")
        automine_was = self._chain_interface.get_automine()
        self._chain_interface.set_automine(automine)
        try:
            yield
        except Exception as e:
            if not isinstance(e, BdbQuit):
                exception_handler = get_exception_handler()
                if exception_handler is not None:
                    exception_handler(*sys.exc_info())
                raise
        finally:
            self._chain_interface.set_automine(automine_was)

    @property
    @check_connected
    def automine(self) -> bool:
        return self._chain_interface.get_automine()

    @automine.setter
    @check_connected
    def automine(self, value: bool) -> None:
        self._chain_interface.set_automine(value)

    @check_connected
    def set_next_block_base_fee_per_gas(self, value: Union[int, str]) -> None:
        if isinstance(value, str):
            value = Wei.from_str(value)
        self._chain_interface.set_next_block_base_fee_per_gas(value)

    @check_connected
    def set_next_block_timestamp(self, timestamp: int) -> None:
        self._chain_interface.set_next_block_timestamp(timestamp)

    @check_connected
    def set_min_gas_price(self, value: Union[int, str]) -> None:
        if isinstance(value, str):
            value = Wei.from_str(value)
        self._chain_interface.set_min_gas_price(value)
        self.gas_price = value

    @check_connected
    def set_default_accounts(self, account: Union[Account, Address, str, None]) -> None:
        if isinstance(account, Account):
            if account.chain != self:
                raise ValueError("Account is not from this chain")
        elif account is not None:
            account = Account(account, self)

        self._default_call_account = account
        self._default_tx_account = account
        self._default_estimate_account = account
        self._default_access_list_account = account

    @check_connected
    def reset(self) -> None:
        self._chain_interface.reset()

    @check_connected
    def update_accounts(self):
        self._accounts = [
            Account(acc, self) for acc in self._chain_interface.get_accounts()
        ]
        self._accounts_set = set(self._accounts)

    @check_connected
    def mine(self, timestamp_change: Optional[Callable[[int], int]] = None) -> None:
        if timestamp_change is not None:
            block_info = self._chain_interface.get_block("latest")
            assert "timestamp" in block_info
            last_timestamp = int(block_info["timestamp"], 16)
            timestamp = timestamp_change(last_timestamp)
        else:
            timestamp = None

        self._chain_interface.mine(timestamp)

    @check_connected
    def mine_many(
        self, num_blocks: int, timestamp_change: Optional[int] = None
    ) -> None:
        self._chain_interface.mine_many(num_blocks, timestamp_change)

    @contextmanager
    def snapshot_and_revert(self):
        snapshot_id = self.snapshot()
        try:
            yield
        except Exception as e:
            if not isinstance(e, BdbQuit):
                exception_handler = get_exception_handler()
                if exception_handler is not None:
                    exception_handler(*sys.exc_info())
                raise
        finally:
            self.revert(snapshot_id)

    @overload
    def deploy(
        self,
        creation_code: bytes,
        *,
        request_type: Literal["call"],
        return_tx: Literal[False] = False,
        from_: Optional[Union[Account, Address, str]] = None,
        value: Union[int, str] = 0,
        gas_limit: Optional[Union[int, Literal["max", "auto"]]] = None,
        gas_price: Optional[Union[int, str]] = None,
        max_fee_per_gas: Optional[Union[int, str]] = None,
        max_priority_fee_per_gas: Optional[Union[int, str]] = None,
        access_list: Optional[
            Union[Dict[Union[Account, Address, str], List[int]], Literal["auto"]]
        ] = None,
        block: Optional[
            Union[int, Literal["latest", "pending", "earliest", "safe", "finalized"]]
        ] = None,
        confirmations: Optional[int] = None,
        revert_on_failure: bool = True,
    ) -> bytes:
        ...

    @overload
    def deploy(
        self,
        creation_code: bytes,
        *,
        request_type: Literal["tx"] = "tx",
        return_tx: Literal[False] = False,
        from_: Optional[Union[Account, Address, str]] = None,
        value: Union[int, str] = 0,
        gas_limit: Optional[Union[int, Literal["max", "auto"]]] = None,
        gas_price: Optional[Union[int, str]] = None,
        max_fee_per_gas: Optional[Union[int, str]] = None,
        max_priority_fee_per_gas: Optional[Union[int, str]] = None,
        access_list: Optional[
            Union[Dict[Union[Account, Address, str], List[int]], Literal["auto"]]
        ] = None,
        block: Optional[
            Union[int, Literal["latest", "pending", "earliest", "safe", "finalized"]]
        ] = None,
        confirmations: Optional[int] = None,
        revert_on_failure: bool = True,
    ) -> Contract:
        ...

    @overload
    def deploy(
        self,
        creation_code: bytes,
        *,
        request_type: Literal["estimate"],
        return_tx: Literal[False] = False,
        from_: Optional[Union[Account, Address, str]] = None,
        value: Union[int, str] = 0,
        gas_limit: Optional[Union[int, Literal["max", "auto"]]] = None,
        gas_price: Optional[Union[int, str]] = None,
        max_fee_per_gas: Optional[Union[int, str]] = None,
        max_priority_fee_per_gas: Optional[Union[int, str]] = None,
        access_list: Optional[
            Union[Dict[Union[Account, Address, str], List[int]], Literal["auto"]]
        ] = None,
        block: Optional[
            Union[int, Literal["latest", "pending", "earliest", "safe", "finalized"]]
        ] = None,
        confirmations: Optional[int] = None,
        revert_on_failure: bool = True,
    ) -> int:
        ...

    @overload
    def deploy(
        self,
        creation_code: bytes,
        *,
        request_type: Literal["access_list"],
        return_tx: Literal[False] = False,
        from_: Optional[Union[Account, Address, str]] = None,
        value: Union[int, str] = 0,
        gas_limit: Optional[Union[int, Literal["max", "auto"]]] = None,
        gas_price: Optional[Union[int, str]] = None,
        max_fee_per_gas: Optional[Union[int, str]] = None,
        max_priority_fee_per_gas: Optional[Union[int, str]] = None,
        access_list: Optional[
            Union[Dict[Union[Account, Address, str], List[int]], Literal["auto"]]
        ] = None,
        block: Optional[
            Union[int, Literal["latest", "pending", "earliest", "safe", "finalized"]]
        ] = None,
        confirmations: Optional[int] = None,
        revert_on_failure: bool = True,
    ) -> Tuple[Dict[Address, List[int]], int]:
        ...

    @overload
    def deploy(
        self,
        creation_code: bytes,
        *,
        request_type: Literal["tx"] = "tx",
        return_tx: Literal[True],
        from_: Optional[Union[Account, Address, str]] = None,
        value: Union[int, str] = 0,
        gas_limit: Optional[Union[int, Literal["max", "auto"]]] = None,
        gas_price: Optional[Union[int, str]] = None,
        max_fee_per_gas: Optional[Union[int, str]] = None,
        max_priority_fee_per_gas: Optional[Union[int, str]] = None,
        access_list: Optional[
            Union[Dict[Union[Account, Address, str], List[int]], Literal["auto"]]
        ] = None,
        block: Optional[
            Union[int, Literal["latest", "pending", "earliest", "safe", "finalized"]]
        ] = None,
        confirmations: Optional[int] = None,
        revert_on_failure: bool = True,
    ) -> TransactionAbc[Contract]:
        ...

    def deploy(
        self,
        creation_code: bytes,
        *,
        request_type: RequestType = "tx",
        return_tx: bool = False,
        from_: Optional[Union[Account, Address, str]] = None,
        value: Union[int, str] = 0,
        gas_limit: Optional[Union[int, Literal["max", "auto"]]] = None,
        gas_price: Optional[Union[int, str]] = None,
        max_fee_per_gas: Optional[Union[int, str]] = None,
        max_priority_fee_per_gas: Optional[Union[int, str]] = None,
        access_list: Optional[
            Union[Dict[Union[Account, Address, str], List[int]], Literal["auto"]]
        ] = None,
        block: Optional[
            Union[int, Literal["latest", "pending", "earliest", "safe", "finalized"]]
        ] = None,
        confirmations: Optional[int] = None,
        revert_on_failure: bool = True,
    ) -> Union[
        bytes,
        Contract,
        int,
        Tuple[Dict[Address, List[int]], int],
        TransactionAbc[Contract],
    ]:
        return Contract._execute(
            self,
            request_type,
            creation_code.hex(),
            [],
            return_tx,
            Contract,
            from_,
            None,
            value,
            gas_limit,
            gas_price,
            max_fee_per_gas,
            max_priority_fee_per_gas,
            access_list,
            type,
            block,
            confirmations,
            revert_on_failure,
        )

    def _convert_to_web3_type(self, value: Any) -> Any:
        if dataclasses.is_dataclass(value):
            return tuple(
                self._convert_to_web3_type(getattr(value, f.name))
                for f in dataclasses.fields(value)
            )
        elif isinstance(value, list):
            return [self._convert_to_web3_type(v) for v in value]
        elif isinstance(value, tuple):
            return tuple(self._convert_to_web3_type(v) for v in value)
        elif isinstance(value, Account):
            if value.chain != self:
                raise ValueError("Account must belong to this chain")
            return str(value.address)
        elif isinstance(value, Address):
            return str(value)
        elif hasattr(value, "selector") and isinstance(value.selector, bytes):
            instance = value.__self__
            return bytes.fromhex(str(instance.address)[2:]) + value.selector
        else:
            return value

    def _parse_console_log_data(self, data: bytes):
        selector = data[:4]

        if selector not in hardhat_console.abis:
            raise ValueError(f"Unknown selector: {selector.hex()}")
        abi = hardhat_console.abis[selector]

        output_types = [
            eth_utils.abi.collapse_if_tuple(cast(Dict[str, Any], arg))
            for arg in fix_library_abi(abi)
        ]
        decoded_data = list(Abi.decode(output_types, data[4:]))
        for i in range(len(decoded_data)):
            if abi[i]["type"] == "address":
                decoded_data[i] = Account(decoded_data[i], self)

        if len(decoded_data) == 1:
            decoded_data = decoded_data[0]

        return decoded_data

    def _convert_from_web3_type(
        self, tx: Optional[TransactionAbc], value: Any, expected_type: Type
    ) -> Any:
        origin = get_origin(expected_type)

        if isinstance(expected_type, type(None)):
            return None
        elif expected_type is Callable:
            assert isinstance(value, bytes)
            address = Address("0x" + value[:20].hex())
            fqn = get_fqn_from_address(
                address, tx.block.number - 1 if tx is not None else "latest", self
            )
            if fqn not in contracts_by_fqn:
                raise ValueError(f"Unknown contract: {fqn}")

            module_name, attrs = contracts_by_fqn[fqn]
            obj = getattr(importlib.import_module(module_name), attrs[0])
            for attr in attrs[1:]:
                obj = getattr(obj, attr)

            selector = value[20:24]

            for x in dir(obj):
                m = getattr(obj, x)
                if hasattr(m, "selector") and m.selector == selector:
                    return getattr(obj(address, self), x)

            raise ValueError(
                f"Unable to find function with selector {selector.hex()} in contract {fqn}"
            )
        elif isinstance(origin, type) and issubclass(origin, list):
            return origin(
                [
                    self._convert_from_web3_type(tx, v, get_args(expected_type)[0])
                    for v in value
                ]
            )
        elif isinstance(expected_type, type) and issubclass(expected_type, Integer):
            return expected_type(value)
        elif isinstance(expected_type, type) and issubclass(
            expected_type, FixedSizeBytes
        ):
            return expected_type(value)
        elif origin is tuple:
            return tuple(
                self._convert_from_web3_type(tx, v, t)
                for v, t in zip(value, get_args(expected_type))
            )
        elif dataclasses.is_dataclass(expected_type):
            assert isinstance(value, tuple)
            resolved_types = get_type_hints(
                expected_type  # pyright: ignore reportGeneralTypeIssues
            )
            field_types = [
                resolved_types[field.name]
                for field in dataclasses.fields(expected_type)
                if field.init
            ]
            assert len(value) == len(field_types)
            converted_values = [
                self._convert_from_web3_type(tx, v, t)
                for v, t in zip(value, field_types)
            ]
            return expected_type(*converted_values)
        elif isinstance(expected_type, type):
            if issubclass(expected_type, Contract):
                return expected_type(value, self)
            elif issubclass(expected_type, Account):
                return Account(value, self)
            elif issubclass(expected_type, IntEnum):
                return expected_type(value)
        return value

    def _process_revert_data(
        self,
        tx: Optional[TransactionAbc],
        revert_data: bytes,
    ) -> RevertError:
        from .transactions import UnknownRevertError

        selector = revert_data[0:4]
        if selector not in errors:
            e = UnknownRevertError(revert_data)
            e.tx = tx
            raise e from None

        if (
            selector not in self._single_source_errors
            and not self.optimistic_pytypes_resolving
        ):
            if tx is None:
                e = UnknownRevertError(revert_data)
                e.tx = tx
                raise e from None

            # ambiguous error, try to find the source contract
            tx._fetch_debug_trace_transaction()
            debug_trace = tx._debug_trace_transaction
            try:
                fqn_overrides: ChainMap[Address, Optional[str]] = ChainMap()
                for i in range(tx.tx_index):
                    prev_tx = tx.block.txs[i]
                    prev_tx._fetch_debug_trace_transaction()
                    process_debug_trace_for_fqn_overrides(
                        prev_tx,
                        prev_tx._debug_trace_transaction,  # pyright: ignore reportGeneralTypeIssues
                        fqn_overrides,
                    )
                fqn = process_debug_trace_for_revert(
                    tx,
                    debug_trace,  # pyright: ignore reportGeneralTypeIssues
                    fqn_overrides,
                )
            except ValueError:
                e = UnknownRevertError(revert_data)
                e.tx = tx
                raise e from None
        else:
            fqn = sorted(errors[selector].keys())[0]

        module_name, attrs = errors[selector][fqn]
        obj = getattr(importlib.import_module(module_name), attrs[0])
        for attr in attrs[1:]:
            obj = getattr(obj, attr)
        abi = obj._abi

        types = [
            eth_utils.abi.collapse_if_tuple(cast(Dict[str, Any], arg))
            for arg in fix_library_abi(abi["inputs"])
        ]
        decoded = Abi.decode(types, revert_data[4:])
        generated_error = self._convert_from_web3_type(tx, decoded, obj)
        generated_error.tx = tx
        return generated_error

    def _process_events(self, tx: TransactionAbc) -> list:
        fqn_overrides: ChainMap[Address, Optional[str]] = ChainMap()
        generated_events = []

        # process fqn_overrides for all txs before this one in the same block
        for i in range(tx.tx_index):
            tx_before = tx.block.txs[i]
            tx_before._fetch_debug_trace_transaction()
            process_debug_trace_for_fqn_overrides(
                tx_before,
                tx_before._debug_trace_transaction,  # pyright: ignore reportGeneralTypeIssues
                fqn_overrides,
            )
        assert len(fqn_overrides.maps) == 1

        logs = sorted(
            (
                l
                for l in tx.chain.chain_interface.get_logs(
                    from_block=tx.block.number, to_block=tx.block.number
                )
                if l["transactionHash"] == tx.tx_hash
            ),
            key=lambda l: int(l["logIndex"], 16),
        )
        for log in logs:
            topics = [
                bytes.fromhex(t[2:].zfill(64))
                if t.startswith("0x")
                else bytes.fromhex(t.zfill(64))
                for t in log["topics"]
            ]
            data = (
                bytes.fromhex(log["data"][2:])
                if log["data"].startswith("0x")
                else bytes.fromhex(log["data"])
            )
            address = Address(log["address"])
            unknown_event = UnknownEvent(topics, data)
            unknown_event.origin = Account(address, tx.chain)

            if len(topics) == 0:
                generated_events.append(unknown_event)
                continue

            selector = topics[0]

            if selector not in events:
                generated_events.append(unknown_event)
                continue

            if (
                len({source for source in events[selector].values()}) > 1
                and not self.optimistic_pytypes_resolving
            ):
                addresses = {address}

                if isinstance(tx.chain.chain_interface, AnvilChainInterface):
                    tx._fetch_trace_transaction()
                    trace = tx._trace_transaction
                    assert trace is not None

                    # `address` may not be the address of the syntatic contract that emitted the event
                    # it may be the address of a contract that delegatecalled into the syntatic contract
                    # find all delegatecalls from `address` recursively
                    finished = False
                    while not finished:
                        finished = True
                        for t in trace:
                            if (
                                "callType" in t["action"]
                                and t["action"]["callType"] == "delegatecall"
                                and Address(t["action"]["from"]) in addresses
                            ):
                                to = Address(t["action"]["to"])
                                if to not in addresses:
                                    addresses.add(to)
                                    finished = False

                candidates = []
                for a in addresses:
                    if a in fqn_overrides:
                        fqn = fqn_overrides[a]
                    else:
                        fqn = get_fqn_from_address(a, tx.block.number - 1, tx.chain)

                    if fqn is None:
                        continue

                    for base_fqn in contracts_inheritance[fqn]:
                        if base_fqn in events[selector]:
                            candidates.append(base_fqn)
                            break

                if len(candidates) != 1:
                    generated_events.append(unknown_event)
                    continue
                else:
                    fqn = candidates[0]
            else:
                fqn = sorted(events[selector].keys())[0]

            module_name, attrs = events[selector][fqn]
            obj = getattr(importlib.import_module(module_name), attrs[0])
            for attr in attrs[1:]:
                obj = getattr(obj, attr)
            abi = obj._abi

            topic_index = 1
            types = []

            decoded_indexed = []

            for input in fix_library_abi(abi["inputs"]):
                if input["indexed"]:
                    if input["type"] in {"string", "bytes", "tuple"} or input[
                        "type"
                    ].endswith("]"):
                        topic_type = "bytes32"
                    else:
                        topic_type = input["type"]
                    topic_data = log["topics"][topic_index]
                    if topic_data.startswith("0x"):
                        topic_data = topic_data[2:]
                    decoded_indexed.append(
                        Abi.decode([topic_type], bytes.fromhex(topic_data.zfill(64)))[0]
                    )
                    topic_index += 1
                else:
                    types.append(eth_utils.abi.collapse_if_tuple(input))
            decoded = list(
                Abi.decode(
                    types,
                    bytes.fromhex(log["data"][2:])
                    if log["data"].startswith("0x")
                    else bytes.fromhex(log["data"]),
                )
            )
            merged = []

            for input in abi["inputs"]:
                if input["indexed"]:
                    merged.append(decoded_indexed.pop(0))
                else:
                    merged.append(decoded.pop(0))

            merged = tuple(merged)
            generated_event = self._convert_from_web3_type(tx, merged, obj)
            generated_event.origin = Account(address, tx.chain)
            generated_events.append(generated_event)

        return generated_events

    def _process_return_data(
        self, tx: Optional[TransactionAbc], output: bytes, abi: Dict, return_type: Type
    ):
        output_types = [
            eth_utils.abi.collapse_if_tuple(cast(Dict[str, Any], arg))
            for arg in fix_library_abi(abi["outputs"])
        ]
        decoded_data = Abi.decode(output_types, output)
        if isinstance(decoded_data, (list, tuple)) and len(decoded_data) == 1:
            decoded_data = decoded_data[0]
        return self._convert_from_web3_type(tx, decoded_data, return_type)

    def _process_console_logs(self, trace_output: List[Dict[str, Any]]) -> List:
        hardhat_console_address = bytes.fromhex(
            "000000000000000000636F6e736F6c652e6c6f67"
        )
        console_logs = []
        for trace in trace_output:
            if "action" in trace and "to" in trace["action"]:
                to = trace["action"]["to"]
                if to.startswith("0x"):
                    to = to[2:]
                if bytes.fromhex(to) == hardhat_console_address:
                    input = trace["action"]["input"]
                    if input.startswith("0x"):
                        input = input[2:]
                    console_logs.append(
                        self._parse_console_log_data(bytes.fromhex(input))
                    )
        return console_logs

    def _process_console_logs_from_debug_trace(
        self, debug_trace: Dict[str, Any]
    ) -> List:
        hardhat_console_address = Address("0x000000000000000000636F6e736F6c652e6c6f67")
        console_logs = []
        for trace in debug_trace["structLogs"]:
            if trace["op"] == "STATICCALL":
                addr = Address(int(trace["stack"][-2], 16))
                if addr == hardhat_console_address:
                    args_offset = int(trace["stack"][-3], 16)
                    args_size = int(trace["stack"][-4], 16)
                    data = bytes(
                        read_from_memory(args_offset, args_size, trace["memory"])
                    )
                    console_logs.append(self._parse_console_log_data(data))

        return console_logs

    def _process_call_revert_data(self, e: JsonRpcError) -> bytes:
        try:
            # Hermez does not provide revert data for estimate
            if (
                isinstance(
                    self._chain_interface,
                    (AnvilChainInterface, GethLikeChainInterfaceAbc),
                )
                and e.data["code"] == 3
            ):
                revert_data = e.data["data"]
            elif (
                isinstance(self._chain_interface, HardhatChainInterface)
                and e.data["code"] == -32603
            ):
                revert_data = e.data["data"]["data"]
            else:
                raise e from None
        except Exception:
            raise e from None

        if revert_data.startswith("0x"):
            revert_data = revert_data[2:]

        return bytes.fromhex(revert_data)

    def _process_call_revert(self, e: JsonRpcError) -> RevertError:

        return self._process_revert_data(None, self._process_call_revert_data(e))

    def _send_transaction(
        self, tx_params: TxParams, from_: Optional[Union[Account, Address, str]]
    ) -> str:
        assert "from" in tx_params

        if self._chain_id in {56, 97}:
            # BSC doesn't support access lists and tx type
            tx_params.pop("type", None)
            tx_params.pop("accessList", None)

        if self.require_signed_txs:
            if isinstance(from_, (Account, Address)):
                key = from_.private_key
            elif from_ is None and self._default_tx_account is not None:
                key = self._default_tx_account.private_key
            else:
                key = None

            tx_params["nonce"] = self._chain_interface.get_transaction_count(
                str(tx_params["from"])
            )

            tx_params["from"] = eth_utils.address.to_checksum_address(tx_params["from"])

            if "to" in tx_params:
                tx_params["to"] = eth_utils.address.to_checksum_address(tx_params["to"])

            self._confirm_transaction(tx_params)

            if Account(tx_params["from"], self) in self._accounts_set:
                try:
                    tx_hash = self._chain_interface.send_transaction(tx_params)
                except (ValueError, JsonRpcError) as e:
                    try:
                        tx_hash = e.args[0]["data"]["txHash"]
                    except Exception:
                        raise e from None
            elif key is not None:
                signed_tx = Account(tx_params["from"], self).sign_transaction(tx_params)
                try:
                    tx_hash = self._chain_interface.send_raw_transaction(signed_tx)
                except (ValueError, JsonRpcError) as e:
                    try:
                        tx_hash = e.args[0]["data"]["txHash"]
                    except Exception:
                        raise e from None
            else:
                raise ValueError(
                    f"Private key for account {tx_params['from']} not known and is not owned by the connected client either."
                )
        else:
            if isinstance(self.chain_interface, AnvilChainInterface):
                try:
                    tx_hash = self.chain_interface.send_unsigned_transaction(tx_params)
                except (ValueError, JsonRpcError) as e:
                    try:
                        tx_hash = e.args[0]["data"]["txHash"]
                    except Exception:
                        raise e
            else:
                sender = Account(tx_params["from"], self)

                tx_params["nonce"] = self._chain_interface.get_transaction_count(
                    str(tx_params["from"])
                )

                with _signer_account(sender):
                    try:
                        tx_hash = self._chain_interface.send_transaction(tx_params)
                    except (ValueError, JsonRpcError) as e:
                        try:
                            tx_hash = e.args[0]["data"]["txHash"]
                        except Exception:
                            raise e

        self._txs.register_tx(tx_hash)

        return tx_hash

    @check_connected
    def _call(
        self,
        abi: Optional[Dict],
        arguments: Iterable,
        params: TxParams,
        return_type: Type,
        block: Union[int, str],
    ) -> Any:
        if isinstance(block, int) and block < 0:
            block = self._chain_interface.get_block_number() + 1 + block

        tx_params = self._build_transaction(
            RequestType.CALL, params, arguments, abi, block
        )
        try:
            coverage_handler = get_coverage_handler()
            if coverage_handler is not None and self._debug_trace_call_supported:
                ret = self._chain_interface.debug_trace_call(tx_params, block)
                coverage_handler.add_coverage(tx_params, self, ret)

                ret_value = ret["returnValue"]
                if ret_value.startswith("0x"):
                    ret_value = ret_value[2:]
                output = bytes.fromhex(ret_value)
                if ret["failed"]:
                    raise self._process_revert_data(None, output) from None
            else:
                output = self._chain_interface.call(tx_params, block)
        except JsonRpcError as e:
            raise self._process_call_revert(e) from None

        if abi is None:
            return output

        return self._process_return_data(None, output, abi, return_type)

    @check_connected
    def _estimate(
        self,
        abi: Optional[Dict],
        arguments: Iterable,
        params: TxParams,
        block: Union[int, str],
    ) -> int:
        if isinstance(block, int) and block < 0:
            block = self._chain_interface.get_block_number() + 1 + block

        tx_params = self._build_transaction(
            RequestType.ESTIMATE, params, arguments, abi, block
        )
        try:
            return self._chain_interface.estimate_gas(tx_params, block)
        except JsonRpcError as e:
            raise self._process_call_revert(e) from None

    @check_connected
    def _access_list(
        self,
        abi: Optional[Dict],
        arguments: Iterable,
        params: TxParams,
        block: Union[int, str],
    ):
        if isinstance(block, int) and block < 0:
            block = self._chain_interface.get_block_number() + 1 + block

        tx_params = self._build_transaction(
            RequestType.ACCESS_LIST, params, arguments, abi, block
        )
        try:
            response = self._chain_interface.create_access_list(tx_params, block)
            return {
                Address(e["address"]): [int(s, 16) for s in e["storageKeys"]]
                for e in response["accessList"]
            }, int(response["gasUsed"], 16)
        except JsonRpcError as e:
            raise self._process_call_revert(e) from None

    @check_connected
    def _transact(
        self,
        abi: Optional[Dict],
        arguments: Iterable,
        params: TxParams,
        return_tx: bool,
        return_type: Type,
        confirmations: Optional[int],
        from_: Optional[Union[Account, Address, str]],
    ) -> Any:
        tx_params = self._build_transaction(
            RequestType.TX, params, arguments, abi, "pending"
        )

        tx_hash = self._send_transaction(tx_params, from_)

        if "type" not in tx_params:
            from wake.development.transactions import LegacyTransaction

            tx_type = LegacyTransaction[return_type]
        elif tx_params["type"] == 1:
            from wake.development.transactions import Eip2930Transaction

            tx_type = Eip2930Transaction[return_type]
        elif tx_params["type"] == 2:
            from wake.development.transactions import Eip1559Transaction

            tx_type = Eip1559Transaction[return_type]
        elif tx_params["type"] == 4:
            from wake.development.transactions import Eip7702Transaction

            tx_type = Eip7702Transaction[return_type]
        else:
            raise ValueError(f"Unknown transaction type {tx_params['type']}")

        tx = tx_type(
            tx_hash,
            tx_params,
            abi,
            return_type,
            self,
        )

        if confirmations != 0:
            tx.wait(confirmations)

            coverage_handler = get_coverage_handler()
            if coverage_handler is not None:
                tx._fetch_debug_trace_transaction()
                coverage_handler.add_coverage(
                    tx_params,
                    self,
                    tx._debug_trace_transaction,  # pyright: ignore reportGeneralTypeIssues
                )

            if self.tx_callback is not None:
                self.tx_callback(tx)

            if tx.error is not None:
                raise tx.error

        if return_tx:
            return tx

        return tx.return_value


@contextmanager
def _signer_account(sender: Account):
    chain = sender.chain
    chain_interface = chain.chain_interface
    account_created = True
    if sender not in chain.accounts:
        account_created = False
        if isinstance(chain_interface, (AnvilChainInterface, HardhatChainInterface)):
            chain_interface.impersonate_account(str(sender))
        else:
            raise NotImplementedError()

    try:
        yield
    finally:
        if not account_created and isinstance(
            chain_interface, (AnvilChainInterface, HardhatChainInterface)
        ):
            chain_interface.stop_impersonating_account(str(sender))


def get_fqn_from_creation_code(creation_code: bytes) -> Tuple[str, int]:
    original_creation_code = creation_code

    for creation_code_segments, fqn in creation_code_index:
        creation_code = original_creation_code

        length, h = creation_code_segments[0]
        if length > len(creation_code):
            continue
        segment_h = BLAKE2b.new(data=creation_code[:length], digest_bits=256).digest()
        if segment_h != h:
            continue

        creation_code = creation_code[length:]
        found = True
        constructor_offset = length

        for length, h in creation_code_segments[1:]:
            if length + 20 > len(creation_code):
                found = False
                break
            creation_code = creation_code[20:]
            segment_h = BLAKE2b.new(
                data=creation_code[:length], digest_bits=256
            ).digest()
            if segment_h != h:
                found = False
                break
            creation_code = creation_code[length:]
            constructor_offset += length + 20

        if found:
            return fqn, constructor_offset

    raise ValueError("Could not find contract definition from creation code")


def get_fqn_from_address(
    addr: Address, block_number: Union[int, str], chain: Chain
) -> Optional[str]:
    code = chain.chain_interface.get_code(str(addr), block_number)
    metadata_length = int.from_bytes(code[-2:], "big")
    metadata = code[-metadata_length - 2 : -2]
    if metadata in contracts_by_metadata:
        return contracts_by_metadata[metadata]
    else:
        return None


def get_contract_from_fqn(fqn: str):
    return contracts_by_fqn[fqn]


def process_debug_trace_for_fqn_overrides(
    tx: TransactionAbc,
    debug_trace: Dict[str, Any],
    fqn_overrides: ChainMap[Address, Optional[str]],
) -> None:
    if tx.status == 0:
        return

    trace_is_create = [tx.to is None]
    addresses: List[Optional[Address]] = [tx.to.address if tx.to is not None else None]
    fqns: List[Optional[str]] = []

    fqn_overrides.maps.insert(0, {})

    if tx.to is None:
        fqns.append(None)  # contract is not deployed yet
    else:
        if tx.to.address in fqn_overrides:
            fqns.append(fqn_overrides[tx.to.address])
        else:
            fqns.append(
                get_fqn_from_address(tx.to.address, tx.block.number - 1, tx.chain)
            )

    for i, trace in enumerate(debug_trace["structLogs"]):
        if i > 0:
            prev_trace = debug_trace["structLogs"][i - 1]
            if (
                prev_trace["op"] in {"CALL", "CALLCODE", "DELEGATECALL", "STATICCALL"}
                and prev_trace["depth"] == trace["depth"]
            ):
                # precompiled contract was called in the previous trace
                fqn_overrides.maps[1].update(fqn_overrides.maps[0])
                fqn_overrides.maps.pop(0)
                trace_is_create.pop()
                addresses.pop()
                fqns.pop()

        if trace["op"] in {"CALL", "CALLCODE", "DELEGATECALL", "STATICCALL"}:
            trace_is_create.append(False)
            addr = Address(int(trace["stack"][-2], 16))
            addresses.append(addr)
            if addr in fqn_overrides:
                fqns.append(fqn_overrides[addr])
            else:
                fqns.append(get_fqn_from_address(addr, tx.block.number - 1, tx.chain))

            fqn_overrides.maps.insert(0, {})
        elif trace["op"] in {"CREATE", "CREATE2"}:
            offset = int(trace["stack"][-2], 16)
            length = int(trace["stack"][-3], 16)
            creation_code = read_from_memory(offset, length, trace["memory"])

            trace_is_create.append(True)
            addresses.append(None)
            fqns.append(get_fqn_from_creation_code(creation_code)[0])
            fqn_overrides.maps.insert(0, {})
        elif trace["op"] in {"INVALID", "RETURN", "REVERT", "STOP", "SELFDESTRUCT"}:
            if trace["op"] == "SELFDESTRUCT":
                if addresses[-1] is not None:
                    fqn_overrides.maps[0][addresses[-1]] = None

            if trace["op"] not in {"INVALID", "REVERT"} and len(fqn_overrides.maps) > 1:
                fqn_overrides.maps[1].update(fqn_overrides.maps[0])
            fqn_overrides.maps.pop(0)
            addresses.pop()

            if trace_is_create.pop():
                try:
                    addr = Address(
                        int(debug_trace["structLogs"][i + 1]["stack"][-1], 16)
                    )
                    if addr != Address(0):
                        fqn_overrides.maps[0][addr] = fqns[-1]
                except IndexError:
                    pass
            fqns.pop()


def process_debug_trace_for_revert(
    tx: TransactionAbc,
    debug_trace: Dict,
    fqn_overrides: ChainMap[Address, Optional[str]],
) -> str:
    if tx.to is None:
        origin = get_fqn_from_creation_code(tx.data)[0]
    elif tx.to.address in fqn_overrides:
        origin = fqn_overrides[tx.to.address]
    else:
        origin = get_fqn_from_address(tx.to.address, tx.block.number - 1, tx.chain)

    addresses: List[Optional[Address]] = [tx.to.address if tx.to is not None else None]
    fqns: List[Optional[str]] = [origin]
    trace_is_create: List[bool] = [tx.to is None]

    # select latest the most nested revert origin
    last_revert_origin = None
    last_revert_depth = 0

    for i, trace in enumerate(debug_trace["structLogs"]):
        if i > 0:
            prev_trace = debug_trace["structLogs"][i - 1]
            if (
                prev_trace["op"] in {"CALL", "CALLCODE", "DELEGATECALL", "STATICCALL"}
                and prev_trace["depth"] == trace["depth"]
            ):
                # precompiled contract was called in the previous trace
                fqn_overrides.maps[1].update(fqn_overrides.maps[0])
                fqn_overrides.maps.pop(0)
                addresses.pop()
                fqns.pop()
                trace_is_create.pop()

        if trace["op"] in {"CALL", "CALLCODE", "DELEGATECALL", "STATICCALL"}:
            trace_is_create.append(False)
            addr = Address(int(trace["stack"][-2], 16))
            addresses.append(addr)
            if addr in fqn_overrides:
                fqns.append(fqn_overrides[addr])
            else:
                fqns.append(get_fqn_from_address(addr, tx.block.number - 1, tx.chain))

            fqn_overrides.maps.insert(0, {})
        elif trace["op"] in {"CREATE", "CREATE2"}:
            offset = int(trace["stack"][-2], 16)
            length = int(trace["stack"][-3], 16)
            creation_code = read_from_memory(offset, length, trace["memory"])

            trace_is_create.append(True)
            addresses.append(None)
            fqns.append(get_fqn_from_creation_code(creation_code)[0])
            fqn_overrides.maps.insert(0, {})
        elif trace["op"] in {"INVALID", "REVERT"}:
            depth = len(fqns)
            fqn_overrides.maps.pop(0)
            fqn = fqns.pop()
            addresses.pop()

            if trace["op"] == "REVERT" and depth >= last_revert_depth:
                offset = int(trace["stack"][-1], 16)
                length = int(trace["stack"][-2], 16)
                data = read_from_memory(offset, length, trace["memory"])
                if data == tx.raw_error.data:
                    last_revert_origin = fqn
                    last_revert_depth = depth
        elif trace["op"] in {"RETURN", "STOP", "SELFDESTRUCT"}:
            if len(fqn_overrides.maps) > 1:
                fqn_overrides.maps[1].update(fqn_overrides.maps[0])
            fqn_overrides.maps.pop(0)
            addresses.pop()

            if trace_is_create.pop():
                try:
                    addr = Address(
                        int(debug_trace["structLogs"][i + 1]["stack"][-1], 16)
                    )
                    if addr != Address(0):
                        fqn_overrides.maps[0][addr] = fqns[-1]
                except IndexError:
                    pass
            fqns.pop()

    if last_revert_origin is None:
        raise ValueError("Could not find revert origin")
    return last_revert_origin


def process_debug_trace_for_events(
    tx: TransactionAbc,
    debug_trace: Dict,
    fqn_overrides: ChainMap[Address, Optional[str]],
) -> List[Tuple[bytes, Optional[str]]]:
    if tx.to is None:
        origin = get_fqn_from_creation_code(tx.data)[0]
    elif tx.to.address in fqn_overrides:
        origin = fqn_overrides[tx.to.address]
    else:
        origin = get_fqn_from_address(tx.to.address, tx.block.number - 1, tx.chain)

    addresses: List[Optional[Address]] = [tx.to.address if tx.to is not None else None]
    fqns: List[Optional[str]] = [origin]
    trace_is_create: List[bool] = [tx.to is None]
    event_fqns = []

    for i, trace in enumerate(debug_trace["structLogs"]):
        if i > 0:
            prev_trace = debug_trace["structLogs"][i - 1]
            if (
                prev_trace["op"] in {"CALL", "CALLCODE", "DELEGATECALL", "STATICCALL"}
                and prev_trace["depth"] == trace["depth"]
            ):
                # precompiled contract was called in the previous trace
                fqn_overrides.maps[1].update(fqn_overrides.maps[0])
                fqn_overrides.maps.pop(0)
                trace_is_create.pop()
                addresses.pop()
                fqns.pop()

        if trace["op"] in {"CALL", "CALLCODE", "DELEGATECALL", "STATICCALL"}:
            trace_is_create.append(False)
            addr = Address(int(trace["stack"][-2], 16))
            addresses.append(addr)
            if addr in fqn_overrides:
                fqns.append(fqn_overrides[addr])
            else:
                fqns.append(get_fqn_from_address(addr, tx.block.number - 1, tx.chain))

            fqn_overrides.maps.insert(0, {})
        elif trace["op"] in {"CREATE", "CREATE2"}:
            offset = int(trace["stack"][-2], 16)
            length = int(trace["stack"][-3], 16)
            creation_code = read_from_memory(offset, length, trace["memory"])

            trace_is_create.append(True)
            addresses.append(None)
            fqns.append(get_fqn_from_creation_code(creation_code)[0])
            fqn_overrides.maps.insert(0, {})
        elif trace["op"] in {"INVALID", "RETURN", "REVERT", "STOP", "SELFDESTRUCT"}:
            if trace["op"] not in {"INVALID", "REVERT"} and len(fqn_overrides.maps) > 1:
                fqn_overrides.maps[1].update(fqn_overrides.maps[0])
            fqn_overrides.maps.pop(0)
            addresses.pop()

            if trace_is_create.pop():
                try:
                    addr = Address(
                        int(debug_trace["structLogs"][i + 1]["stack"][-1], 16)
                    )
                    if addr != Address(0):
                        fqn_overrides.maps[0][addr] = fqns[-1]
                except IndexError:
                    pass
            fqns.pop()
        elif trace["op"] in {"LOG1", "LOG2", "LOG3", "LOG4"}:
            selector = trace["stack"][-3]
            if selector.startswith("0x"):
                selector = selector[2:]
            selector = bytes.fromhex(selector.zfill(64))
            event_fqns.append((selector, fqns[-1]))

    return event_fqns
