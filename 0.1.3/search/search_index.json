{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Woke # Woke is a Python-based development and testing framework for Solidity. Features # LSP server property-based fuzzer Installation # Woke requires Python 3.7 or higher. Using pip # pip3 install abch-woke The property-based fuzzer can be installed as an extra dependency. Due to the dependency on eth-brownie , it is recommended to install it into a virtual environment . pip3 install abch-woke [ fuzzer ]","title":"Installation"},{"location":"#woke","text":"Woke is a Python-based development and testing framework for Solidity.","title":"Woke"},{"location":"#features","text":"LSP server property-based fuzzer","title":"Features"},{"location":"#installation","text":"Woke requires Python 3.7 or higher.","title":"Installation"},{"location":"#using-pip","text":"pip3 install abch-woke The property-based fuzzer can be installed as an extra dependency. Due to the dependency on eth-brownie , it is recommended to install it into a virtual environment . pip3 install abch-woke [ fuzzer ]","title":"Using pip"},{"location":"configuration/","text":"Configuration # Woke can be configured using optional configuration files. The global configuration file is located in: $HOME/.config/Woke/config.toml on Linux/MacOS, %USERPROFILE%\\Woke\\config.toml on Windows. Additionally, the configuration file for each project can be located in {PROJECT_PATH}/woke.toml . Attention Configuration options loaded from TOML files affect only the behavior of the Woke command-line tool. LSP configuration options are loaded from LSP clients using the standard interface . Subconfigs # Any configuration file can include additional configuration files (subconfigs). These subconfigs are loaded after the original configuration file in the specified order. Subconfig configuration values override the values of the parent configuration file. Example woke.toml subconfigs = [ \"loaded_next.toml\" , \"../relative.toml\" , \"/tmp/absolute.toml\" , \"loaded_last.toml\" ] Configuration options # The resolution order for each configuration option is: default value, value in the global configuration file, value in the project configuration file. Example woke.toml subconfigs = [ \"./config1.toml\" , \"config2.toml\" ] [compiler.solc] evm_version = \"london\" include_paths = [ \"node_modules\" , \"lib\" ] remappings = [ \"@openzeppelin/=node_modules/@openzeppelin/\" ] target_version = \"0.8.10\" via_IR = true [compiler.solc.optimizer] enabled = true runs = 1000 compiler.solc namespace # {CWD} in the following table represents the current working directory (i.e. the directory from which the woke command is being executed). Option Description Default value allow_paths Allow paths passed to the solc executable [] evm_version EVM version as specified by Solidity docs \"\" (let the compiler decide) ignore_paths Files in these paths are not compiled unless imported from other non-ignored files [{CWD}/.woke-build, {CWD}/node_modules] include_paths Paths (along with {CWD} ) where files from non-relative imports are searched [{CWD}/node_modules] remappings Compiler remappings as specified by Solidity docs [] target_version Target solc version used to compile the project \"\" (use the latest version for each compilation unit) via_IR Compile the code via the Yul intermediate language (see Solidity docs ) \"\" (let the compiler decide) Info The include_paths option is the preferred way to handle imports of libraries. Remappings should be used only when include_paths cannot be used (e.g. when the import path differs from the system path of the imported file). compiler.solc.optimizer namespace # Option Description Default value enabled Compile the project with solc optimizations enabled. Leaving this unset disables most of the available optimizations. Setting this to false disables all optimizations for Solidity <0.8.6 and has the same behavior as leaving this unset for Solidity >=0.8.6. \"\" (unset) runs Configuration of the optimizer specifying how many times the code is intended to be run. Lower values optimize more for initial deployment cost, while higher values optimize more for high-frequency usage. 200 lsp.find_references namespace # Configuration options specific to the LSP Find references request. Option Description Default value include_declarations Also include declarations in Find references request results. false","title":"Configuration"},{"location":"configuration/#configuration","text":"Woke can be configured using optional configuration files. The global configuration file is located in: $HOME/.config/Woke/config.toml on Linux/MacOS, %USERPROFILE%\\Woke\\config.toml on Windows. Additionally, the configuration file for each project can be located in {PROJECT_PATH}/woke.toml . Attention Configuration options loaded from TOML files affect only the behavior of the Woke command-line tool. LSP configuration options are loaded from LSP clients using the standard interface .","title":"Configuration"},{"location":"configuration/#subconfigs","text":"Any configuration file can include additional configuration files (subconfigs). These subconfigs are loaded after the original configuration file in the specified order. Subconfig configuration values override the values of the parent configuration file. Example woke.toml subconfigs = [ \"loaded_next.toml\" , \"../relative.toml\" , \"/tmp/absolute.toml\" , \"loaded_last.toml\" ]","title":"Subconfigs"},{"location":"configuration/#configuration-options","text":"The resolution order for each configuration option is: default value, value in the global configuration file, value in the project configuration file. Example woke.toml subconfigs = [ \"./config1.toml\" , \"config2.toml\" ] [compiler.solc] evm_version = \"london\" include_paths = [ \"node_modules\" , \"lib\" ] remappings = [ \"@openzeppelin/=node_modules/@openzeppelin/\" ] target_version = \"0.8.10\" via_IR = true [compiler.solc.optimizer] enabled = true runs = 1000","title":"Configuration options"},{"location":"configuration/#compilersolc-namespace","text":"{CWD} in the following table represents the current working directory (i.e. the directory from which the woke command is being executed). Option Description Default value allow_paths Allow paths passed to the solc executable [] evm_version EVM version as specified by Solidity docs \"\" (let the compiler decide) ignore_paths Files in these paths are not compiled unless imported from other non-ignored files [{CWD}/.woke-build, {CWD}/node_modules] include_paths Paths (along with {CWD} ) where files from non-relative imports are searched [{CWD}/node_modules] remappings Compiler remappings as specified by Solidity docs [] target_version Target solc version used to compile the project \"\" (use the latest version for each compilation unit) via_IR Compile the code via the Yul intermediate language (see Solidity docs ) \"\" (let the compiler decide) Info The include_paths option is the preferred way to handle imports of libraries. Remappings should be used only when include_paths cannot be used (e.g. when the import path differs from the system path of the imported file).","title":"compiler.solc namespace"},{"location":"configuration/#compilersolcoptimizer-namespace","text":"Option Description Default value enabled Compile the project with solc optimizations enabled. Leaving this unset disables most of the available optimizations. Setting this to false disables all optimizations for Solidity <0.8.6 and has the same behavior as leaving this unset for Solidity >=0.8.6. \"\" (unset) runs Configuration of the optimizer specifying how many times the code is intended to be run. Lower values optimize more for initial deployment cost, while higher values optimize more for high-frequency usage. 200","title":"compiler.solc.optimizer namespace"},{"location":"configuration/#lspfind_references-namespace","text":"Configuration options specific to the LSP Find references request. Option Description Default value include_declarations Also include declarations in Find references request results. false","title":"lsp.find_references namespace"},{"location":"contributing/","text":"Contributing # Creating a virtual environment # Using virtualenvwrapper # mkvirtualenv woke Using venv # python3 -m venv env source env/bin/activate Installation # pip install -e \".[fuzzer,tests,dev]\" Pyright, our static type checker, is distributed through npm: npm i -g pyright Git hooks # For Unix-like platforms, we provide up git hooks to help with development. After cloning, execute. chmod +x ./setup-githooks.sh ./setup-githooks.sh Git hooks automatically run these commands when you commit: pytest tests -m \"not slow\" when the WOKE_HOOKS_RUN_ALL_TESTS environment variable is not set ( pytest tests is run otherwise) pyright on Python files being committed black on Python files being committed isort on Python files being committed mkdocs build --strict to make sure the documentation does not contain errors Any unstaged changes and untracked files are stashed before running the git pre-commit hook. After the commit is made, the stashed changes are popped from the stash. If this leads to a merge conflict, the stashed changes are left at the top of the stash.","title":"Contributing"},{"location":"contributing/#contributing","text":"","title":"Contributing"},{"location":"contributing/#creating-a-virtual-environment","text":"","title":"Creating a virtual environment"},{"location":"contributing/#using-virtualenvwrapper","text":"mkvirtualenv woke","title":"Using virtualenvwrapper"},{"location":"contributing/#using-venv","text":"python3 -m venv env source env/bin/activate","title":"Using venv"},{"location":"contributing/#installation","text":"pip install -e \".[fuzzer,tests,dev]\" Pyright, our static type checker, is distributed through npm: npm i -g pyright","title":"Installation"},{"location":"contributing/#git-hooks","text":"For Unix-like platforms, we provide up git hooks to help with development. After cloning, execute. chmod +x ./setup-githooks.sh ./setup-githooks.sh Git hooks automatically run these commands when you commit: pytest tests -m \"not slow\" when the WOKE_HOOKS_RUN_ALL_TESTS environment variable is not set ( pytest tests is run otherwise) pyright on Python files being committed black on Python files being committed isort on Python files being committed mkdocs build --strict to make sure the documentation does not contain errors Any unstaged changes and untracked files are stashed before running the git pre-commit hook. After the commit is made, the stashed changes are popped from the stash. If this leads to a merge conflict, the stashed changes are left at the top of the stash.","title":"Git hooks"},{"location":"fuzzer/","text":"Woke fuzzer # Woke fuzzer is a property-based fuzzer for Solidity smart contracts that allows testers to write their fuzz tests in Python. Installation # Warning Woke fuzzer uses eth-brownie package. For this reason, it is recommended to install Woke fuzzer into a virtual environment . It may be also needed to create a brownie-config.yaml configuration file so that Brownie can compile the project. Woke fuzzer is an optional feature of Woke and can be installed with pip: pip install abch-woke [ fuzzer ] Getting started # To get started, run the following command inside the project directory: woke init fuzz This command creates pytypes directory, generates smart contract's Python bindings and also copies an example file test_example.py into tests directory. Apart from having useful comments, this example file showcases basic structure of Woke fuzzer's fuzz tests which consists of: TestingSequence classes with methods decorated as Flows and Invariants that are used for fuzz testing and an __init__ method which is used for TestingSequence class setup and can also deploy contracts, test_* methods that run Woke fuzzer's Campaign with the TestingSequence class. Tip All of these can also be separated into multiple files, see more a verbose directory structure . TestingSequence and Campaign # TestingSequence is a tester defined class that specifies Flows and Invariants that will be later used for fuzz testing and it is also used to set up any prerequisites such as contract deployment or instance attributes later used in tests (contract owner, etc.) The Campaign class is a Woke fuzzer class that is responsible for the actual sequence generation and Flows and Invariants execution from TestingSequence . The number of generated sequences and Flows must be specified as arguments of the run function. The development chain network gets reverted between the sequences. In the example below, the contract is deployed and the Campaign is run with 1000 sequences consisting of 400 flows. import brownie from pytypes import VotingContractType from woke.fuzzer import Campaign from woke.fuzzer.random import random_account class TestingSequence : def __init ( self , contract : VotingContractType ): self . owner = random_account () self . contract = contract . deploy ({ \"from\" : self . owner }) self . subjects = {} # flows and invariants also go here def test_campaign ( voting_contract : VotingContractType ): for _ in range ( 1 ): brownie . accounts . add () campaign = Campaign ( lambda : TestingSequence ( VotingContractType )) campaign . run ( 1000 , 400 ) The number of execution times for a Flow per sequence can be tuned using decorators . Flows # A Flow is a test method with @flow decorator that uses the fuzzed smart contract and specifies where Woke fuzzer should insert randomly generated data. import brownie from woke.fuzzer.decorators import flow from woke.fuzzer.random import random_account , random_string ... @flow def flow_add_subject ( self ): brownie . accounts . add () subject_name = random_string ( 0 , 10 ) subject_account = random_account ( predicate = lambda a : a != self . owner and a not in self . subjects ) if len ( subject_name ) == 0 or subject_account in self . subjects : with brownie . reverts (): self . contract . addSubject ( subject_name , { \"from\" : subject_account }) else : self . contract . addSubject ( subject_name , { \"from\" : subject_account }) self . subjects [ subject_account ] = ( subject_name , 0 ) A sequence of these Flows is generated and executed by the Campaign class. brownie.reverts is used when a transaction is expected to revert. Should a contract fail to revert the transaction, it will be reported as a bug by the fuzzer. Invariants # Woke fuzzer is a property-based fuzzer and as such it allows testers to define Invariant methods with @invariant decorator. These Invariant methods check for correctness of certain properties in deployed fuzzed smart contracts after every Flow execution. from woke.fuzzer.decorators import invariant from woke.fuzzer.random import random_account ... @invariant def invariant_subjects ( self ): anyone = random_account () subjects = self . contract . getSubjects ({ \"from\" : anyone }) assert len ( subjects ) == len ( self . subjects ) for subject in subjects : anyone = random_account () subj = self . contract . getSubject ( subject , { \"from\" : anyone }) assert self . subjects [ subject ][ 0 ] == subj [ \"name\" ] assert self . subjects [ subject ][ 1 ] == subj [ \"votes\" ] Should any of the asserts in Invariant method fail, it will be reported as a bug by the fuzzer. Generating pseudo-random data # Woke fuzzer has several built-in methods for generating pseudo-random data: random_account chooses a random account from existing brownie accounts, random_int generates random integer but with custom (increased) probabilities for min , max and 0 , random_bool picks True/False randomly, random_string can construct a random string of given min and max length, random_bytes generates a sequence of random bytes with given min and max length. Some of the methods mentioned above also have other optional parameters such as predicates that can be used to further restrict which values will be generated, see source code for full specification. Running the fuzzer # After writing Flows and Invariants , Woke fuzzer can be run with all fuzz test files using: woke fuzz Or with specified fuzz test files: woke fuzz ./tests/test_token.py Info Woke fuzzer runs with multiple processes by default . Be sure to check out woke fuzz --help for optional CLI arguments . Checking out the progress # While fuzzing, the progress is reported in the console stating how many processes are still running. More verbose logs are stored in .woke-logs/fuzz directory, specifically the latest one for the last fuzzing campaign. Tip We recommend using less -r to view the log files because they are ANSI code coloured. What to do when Woke fuzzer finds a bug # When Woke fuzzer finds a bug it will print out a standard Python traceback and ask if a debugger should be attached. With the debugger not being attached, the current process is stopped but the rest of the processes continue fuzzing. The bug can be later checked out in execution logs the same way as when checking out the progress . With the debugger attached, IPython debugger instance is created which allows exploring the state of the fuzzing instance and development chain. Decorators # Apart from the @flow and @invariant that define type of the test method there are also decorators that can be used to tune Flow selection in a generated sequence: @weight(x) - specifies weight that will be used when generating a sequence with default weight being 100. Say flow1 has weight 100 and flow2 has weight 200, flow2 will have ~ \\(\\frac{2}{3}\\) of the executions and flow1 only ~ \\(\\frac{1}{3}\\) , @max_times(x) - specifies maximum times a Flow will be called in one generated sequence, @ignore - instructs Woke fuzzer to ignore the decorated Flow or Invariant , useful for testing and debugging. Optional CLI arguments # $ woke fuzz --help Usage: woke fuzz [OPTIONS] [PATHS]... Run Woke fuzzer. Options: -n, --process-count INTEGER Number of processes to create for fuzzing. -s, --seed TEXT Random seeds --passive Print one process output into console, run other in background. --network TEXT Choose brownie dev chain. Default is 'development' for ganache --help Show this message and exit. Fuzzing with multiple processes # By default, Woke fuzzer performs fuzzing with a number of processes equal to the number of CPU cores. -n can be used to specify the number of processes. Development chain # ganache-cli is used as a default command to spawn a local dev chain for each process. It's important to have ports 8545 to (8545 + # of processes) free and bindable. Woke fuzzer uses dev chain configuration from Brownie so other development chains such as anvil or hardhat can be selected with --network option, but make sure that Brownie actually fully supports the dev chain. Random seed selection # To make fuzzing reproducible, it's possible to specify a seed used when generating random data with -s . With multiple seeds specified, each seed is assigned to a different process and the remaining seeds are generated randomly. Passive mode # For debugging purposes, it's possible to run Woke fuzzer in passive mode using the --passive option. In this mode, Woke fuzzer will print out the output of the process #0 to the console. Python bindings # To make working with contracts a bit easier, Woke fuzzer generates Python bindings from smart contract's ABI into the pytypes directory of the project. Recommended directory structure # For bigger projects, we recommend splitting up contract setup, Flow definition and test_*.py files. project/ \u251c\u2500\u2500 contracts/ \u2502 \u251c\u2500\u2500 Token.sol \u2502 \u2514\u2500\u2500 Amm.sol \u2514\u2500\u2500 tests/ \u251c\u2500\u2500 token \u2502 \u251c\u2500\u2500 setup.py \u2502 \u2514\u2500\u2500 flows.py \u251c\u2500\u2500 amm \u2502 \u251c\u2500\u2500 setup.py \u2502 \u2514\u2500\u2500 flows.py \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 test_token.py \u2514\u2500\u2500 test_amm.py","title":"Fuzzer"},{"location":"fuzzer/#woke-fuzzer","text":"Woke fuzzer is a property-based fuzzer for Solidity smart contracts that allows testers to write their fuzz tests in Python.","title":"Woke fuzzer"},{"location":"fuzzer/#installation","text":"Warning Woke fuzzer uses eth-brownie package. For this reason, it is recommended to install Woke fuzzer into a virtual environment . It may be also needed to create a brownie-config.yaml configuration file so that Brownie can compile the project. Woke fuzzer is an optional feature of Woke and can be installed with pip: pip install abch-woke [ fuzzer ]","title":"Installation"},{"location":"fuzzer/#getting-started","text":"To get started, run the following command inside the project directory: woke init fuzz This command creates pytypes directory, generates smart contract's Python bindings and also copies an example file test_example.py into tests directory. Apart from having useful comments, this example file showcases basic structure of Woke fuzzer's fuzz tests which consists of: TestingSequence classes with methods decorated as Flows and Invariants that are used for fuzz testing and an __init__ method which is used for TestingSequence class setup and can also deploy contracts, test_* methods that run Woke fuzzer's Campaign with the TestingSequence class. Tip All of these can also be separated into multiple files, see more a verbose directory structure .","title":"Getting started"},{"location":"fuzzer/#testingsequence-and-campaign","text":"TestingSequence is a tester defined class that specifies Flows and Invariants that will be later used for fuzz testing and it is also used to set up any prerequisites such as contract deployment or instance attributes later used in tests (contract owner, etc.) The Campaign class is a Woke fuzzer class that is responsible for the actual sequence generation and Flows and Invariants execution from TestingSequence . The number of generated sequences and Flows must be specified as arguments of the run function. The development chain network gets reverted between the sequences. In the example below, the contract is deployed and the Campaign is run with 1000 sequences consisting of 400 flows. import brownie from pytypes import VotingContractType from woke.fuzzer import Campaign from woke.fuzzer.random import random_account class TestingSequence : def __init ( self , contract : VotingContractType ): self . owner = random_account () self . contract = contract . deploy ({ \"from\" : self . owner }) self . subjects = {} # flows and invariants also go here def test_campaign ( voting_contract : VotingContractType ): for _ in range ( 1 ): brownie . accounts . add () campaign = Campaign ( lambda : TestingSequence ( VotingContractType )) campaign . run ( 1000 , 400 ) The number of execution times for a Flow per sequence can be tuned using decorators .","title":"TestingSequence and Campaign"},{"location":"fuzzer/#flows","text":"A Flow is a test method with @flow decorator that uses the fuzzed smart contract and specifies where Woke fuzzer should insert randomly generated data. import brownie from woke.fuzzer.decorators import flow from woke.fuzzer.random import random_account , random_string ... @flow def flow_add_subject ( self ): brownie . accounts . add () subject_name = random_string ( 0 , 10 ) subject_account = random_account ( predicate = lambda a : a != self . owner and a not in self . subjects ) if len ( subject_name ) == 0 or subject_account in self . subjects : with brownie . reverts (): self . contract . addSubject ( subject_name , { \"from\" : subject_account }) else : self . contract . addSubject ( subject_name , { \"from\" : subject_account }) self . subjects [ subject_account ] = ( subject_name , 0 ) A sequence of these Flows is generated and executed by the Campaign class. brownie.reverts is used when a transaction is expected to revert. Should a contract fail to revert the transaction, it will be reported as a bug by the fuzzer.","title":"Flows"},{"location":"fuzzer/#invariants","text":"Woke fuzzer is a property-based fuzzer and as such it allows testers to define Invariant methods with @invariant decorator. These Invariant methods check for correctness of certain properties in deployed fuzzed smart contracts after every Flow execution. from woke.fuzzer.decorators import invariant from woke.fuzzer.random import random_account ... @invariant def invariant_subjects ( self ): anyone = random_account () subjects = self . contract . getSubjects ({ \"from\" : anyone }) assert len ( subjects ) == len ( self . subjects ) for subject in subjects : anyone = random_account () subj = self . contract . getSubject ( subject , { \"from\" : anyone }) assert self . subjects [ subject ][ 0 ] == subj [ \"name\" ] assert self . subjects [ subject ][ 1 ] == subj [ \"votes\" ] Should any of the asserts in Invariant method fail, it will be reported as a bug by the fuzzer.","title":"Invariants"},{"location":"fuzzer/#generating-pseudo-random-data","text":"Woke fuzzer has several built-in methods for generating pseudo-random data: random_account chooses a random account from existing brownie accounts, random_int generates random integer but with custom (increased) probabilities for min , max and 0 , random_bool picks True/False randomly, random_string can construct a random string of given min and max length, random_bytes generates a sequence of random bytes with given min and max length. Some of the methods mentioned above also have other optional parameters such as predicates that can be used to further restrict which values will be generated, see source code for full specification.","title":"Generating pseudo-random data"},{"location":"fuzzer/#running-the-fuzzer","text":"After writing Flows and Invariants , Woke fuzzer can be run with all fuzz test files using: woke fuzz Or with specified fuzz test files: woke fuzz ./tests/test_token.py Info Woke fuzzer runs with multiple processes by default . Be sure to check out woke fuzz --help for optional CLI arguments .","title":"Running the fuzzer"},{"location":"fuzzer/#checking-out-the-progress","text":"While fuzzing, the progress is reported in the console stating how many processes are still running. More verbose logs are stored in .woke-logs/fuzz directory, specifically the latest one for the last fuzzing campaign. Tip We recommend using less -r to view the log files because they are ANSI code coloured.","title":"Checking out the progress"},{"location":"fuzzer/#what-to-do-when-woke-fuzzer-finds-a-bug","text":"When Woke fuzzer finds a bug it will print out a standard Python traceback and ask if a debugger should be attached. With the debugger not being attached, the current process is stopped but the rest of the processes continue fuzzing. The bug can be later checked out in execution logs the same way as when checking out the progress . With the debugger attached, IPython debugger instance is created which allows exploring the state of the fuzzing instance and development chain.","title":"What to do when Woke fuzzer finds a bug"},{"location":"fuzzer/#decorators","text":"Apart from the @flow and @invariant that define type of the test method there are also decorators that can be used to tune Flow selection in a generated sequence: @weight(x) - specifies weight that will be used when generating a sequence with default weight being 100. Say flow1 has weight 100 and flow2 has weight 200, flow2 will have ~ \\(\\frac{2}{3}\\) of the executions and flow1 only ~ \\(\\frac{1}{3}\\) , @max_times(x) - specifies maximum times a Flow will be called in one generated sequence, @ignore - instructs Woke fuzzer to ignore the decorated Flow or Invariant , useful for testing and debugging.","title":"Decorators"},{"location":"fuzzer/#optional-cli-arguments","text":"$ woke fuzz --help Usage: woke fuzz [OPTIONS] [PATHS]... Run Woke fuzzer. Options: -n, --process-count INTEGER Number of processes to create for fuzzing. -s, --seed TEXT Random seeds --passive Print one process output into console, run other in background. --network TEXT Choose brownie dev chain. Default is 'development' for ganache --help Show this message and exit.","title":"Optional CLI arguments"},{"location":"fuzzer/#fuzzing-with-multiple-processes","text":"By default, Woke fuzzer performs fuzzing with a number of processes equal to the number of CPU cores. -n can be used to specify the number of processes.","title":"Fuzzing with multiple processes"},{"location":"fuzzer/#development-chain","text":"ganache-cli is used as a default command to spawn a local dev chain for each process. It's important to have ports 8545 to (8545 + # of processes) free and bindable. Woke fuzzer uses dev chain configuration from Brownie so other development chains such as anvil or hardhat can be selected with --network option, but make sure that Brownie actually fully supports the dev chain.","title":"Development chain"},{"location":"fuzzer/#random-seed-selection","text":"To make fuzzing reproducible, it's possible to specify a seed used when generating random data with -s . With multiple seeds specified, each seed is assigned to a different process and the remaining seeds are generated randomly.","title":"Random seed selection"},{"location":"fuzzer/#passive-mode","text":"For debugging purposes, it's possible to run Woke fuzzer in passive mode using the --passive option. In this mode, Woke fuzzer will print out the output of the process #0 to the console.","title":"Passive mode"},{"location":"fuzzer/#python-bindings","text":"To make working with contracts a bit easier, Woke fuzzer generates Python bindings from smart contract's ABI into the pytypes directory of the project.","title":"Python bindings"},{"location":"fuzzer/#recommended-directory-structure","text":"For bigger projects, we recommend splitting up contract setup, Flow definition and test_*.py files. project/ \u251c\u2500\u2500 contracts/ \u2502 \u251c\u2500\u2500 Token.sol \u2502 \u2514\u2500\u2500 Amm.sol \u2514\u2500\u2500 tests/ \u251c\u2500\u2500 token \u2502 \u251c\u2500\u2500 setup.py \u2502 \u2514\u2500\u2500 flows.py \u251c\u2500\u2500 amm \u2502 \u251c\u2500\u2500 setup.py \u2502 \u2514\u2500\u2500 flows.py \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 test_token.py \u2514\u2500\u2500 test_amm.py","title":"Recommended directory structure"},{"location":"language-server/","text":"Solidity LSP server # Woke implements a LSP server for Solidity. The only currently supported communication channel is TCP. Woke LSP server can be run using: woke lsp Or with an optional --port argument: woke lsp --port 1234 Info Multi-root workspaces are not currently supported. Projects using Woke server # VS Code Extension Configuration options # Server configuration options are loaded using the standard interface from LSP clients. The process of setting the configuration options is client specific. Configuration changes are handled by the server, and the project is recompiled if the compilation options change. The following configuration options are supported: woke.compiler.solc.allow_paths , woke.compiler.solc.evm_version , woke.compiler.solc.ignore_paths , woke.compiler.solc.include_paths , woke.compiler.solc.remappings , woke.compiler.solc.target_version , woke.compiler.solc.via_IR , woke.compiler.solc.optimizer.enabled , woke.compiler.solc.optimizer.runs , woke.lsp.find_references.include_declarations . The semantics of these configuration options are explained in the configuration section . Supported commands # Woke LSP server implements the command execution provider as specified by the LSP specification . The following commands are supported: Command Description woke.lsp.force_recompile Force recompile the opened project/files. Useful after modifying files outside the IDE (e.g. after installing npm packages). Features # Go to definition # Go to type definition # Go to implementation # Find implementations of an unimplemented function or modifier. Find references # Type hierarchy # Also works for virtual functions. Document links # Hover # Includes links to documentation for OpenZeppelin contracts. Code lens # Number of references is shown above each declaration. Document symbols # Diagnostics # Rename # Debugging # Woke LSP server can be debugged using: woke --debug lsp","title":"LSP server"},{"location":"language-server/#solidity-lsp-server","text":"Woke implements a LSP server for Solidity. The only currently supported communication channel is TCP. Woke LSP server can be run using: woke lsp Or with an optional --port argument: woke lsp --port 1234 Info Multi-root workspaces are not currently supported.","title":"Solidity LSP server"},{"location":"language-server/#projects-using-woke-server","text":"VS Code Extension","title":"Projects using Woke server"},{"location":"language-server/#configuration-options","text":"Server configuration options are loaded using the standard interface from LSP clients. The process of setting the configuration options is client specific. Configuration changes are handled by the server, and the project is recompiled if the compilation options change. The following configuration options are supported: woke.compiler.solc.allow_paths , woke.compiler.solc.evm_version , woke.compiler.solc.ignore_paths , woke.compiler.solc.include_paths , woke.compiler.solc.remappings , woke.compiler.solc.target_version , woke.compiler.solc.via_IR , woke.compiler.solc.optimizer.enabled , woke.compiler.solc.optimizer.runs , woke.lsp.find_references.include_declarations . The semantics of these configuration options are explained in the configuration section .","title":"Configuration options"},{"location":"language-server/#supported-commands","text":"Woke LSP server implements the command execution provider as specified by the LSP specification . The following commands are supported: Command Description woke.lsp.force_recompile Force recompile the opened project/files. Useful after modifying files outside the IDE (e.g. after installing npm packages).","title":"Supported commands"},{"location":"language-server/#features","text":"","title":"Features"},{"location":"language-server/#go-to-definition","text":"","title":"Go to definition"},{"location":"language-server/#go-to-type-definition","text":"","title":"Go to type definition"},{"location":"language-server/#go-to-implementation","text":"Find implementations of an unimplemented function or modifier.","title":"Go to implementation"},{"location":"language-server/#find-references","text":"","title":"Find references"},{"location":"language-server/#type-hierarchy","text":"Also works for virtual functions.","title":"Type hierarchy"},{"location":"language-server/#document-links","text":"","title":"Document links"},{"location":"language-server/#hover","text":"Includes links to documentation for OpenZeppelin contracts.","title":"Hover"},{"location":"language-server/#code-lens","text":"Number of references is shown above each declaration.","title":"Code lens"},{"location":"language-server/#document-symbols","text":"","title":"Document symbols"},{"location":"language-server/#diagnostics","text":"","title":"Diagnostics"},{"location":"language-server/#rename","text":"","title":"Rename"},{"location":"language-server/#debugging","text":"Woke LSP server can be debugged using: woke --debug lsp","title":"Debugging"},{"location":"solc-version-manager/","text":"Solc Version Manager (SVM) # Woke implements Solc Version Manager (SVM) to manage multiple installations of the solc compiler. Compiler versions are located in: $HOME/.config/Woke/compilers on Linux/MacOS, %USERPROFILE%\\Woke\\compilers on Windows. The chosen version of solc is available under the woke-solc executable which acts as a wrapper for the solc executable. Example $ woke-solc --version solc, the solidity compiler commandline interface Version: 0.8.15+commit.e14f2714.Linux.g++ Info solc binaries are downloaded from the Solidity repository which limits the minimum version of solc that can be installed. Commands # All the listed commands are available under the woke svm subcommand (e.g. woke svm list ). Command Description Options install Install the target version of solc . A version range may be provided which results into installation of the latest version matching the range (i.e. woke svm install 0.7 installs the version 0.7.6 ). --force reinstall the version even if already installed. list List installed versions of solc . --all list all available versions instead. remove Remove the target installed version of solc . --ignore-missing do not raise an exception if the target version is not installed. switch Change the selected version of solc to the target version. use Change the selected version of solc to the target version and install it if not already installed. A version range may be provided resulting into installation of the latest version matching the range. --force reinstall the version even if already installed.","title":"Solc Version Manager"},{"location":"solc-version-manager/#solc-version-manager-svm","text":"Woke implements Solc Version Manager (SVM) to manage multiple installations of the solc compiler. Compiler versions are located in: $HOME/.config/Woke/compilers on Linux/MacOS, %USERPROFILE%\\Woke\\compilers on Windows. The chosen version of solc is available under the woke-solc executable which acts as a wrapper for the solc executable. Example $ woke-solc --version solc, the solidity compiler commandline interface Version: 0.8.15+commit.e14f2714.Linux.g++ Info solc binaries are downloaded from the Solidity repository which limits the minimum version of solc that can be installed.","title":"Solc Version Manager (SVM)"},{"location":"solc-version-manager/#commands","text":"All the listed commands are available under the woke svm subcommand (e.g. woke svm list ). Command Description Options install Install the target version of solc . A version range may be provided which results into installation of the latest version matching the range (i.e. woke svm install 0.7 installs the version 0.7.6 ). --force reinstall the version even if already installed. list List installed versions of solc . --all list all available versions instead. remove Remove the target installed version of solc . --ignore-missing do not raise an exception if the target version is not installed. switch Change the selected version of solc to the target version. use Change the selected version of solc to the target version and install it if not already installed. A version range may be provided resulting into installation of the latest version matching the range. --force reinstall the version even if already installed.","title":"Commands"},{"location":"api-reference/","text":"API reference #","title":"API reference"},{"location":"api-reference/#api-reference","text":"","title":"API reference"},{"location":"api-reference/config/","text":"","title":"Config"},{"location":"api-reference/ir/declarations/contract-definition/","text":"Bases: DeclarationAbc Source code in woke/ast/ir/declaration/contract_definition.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 class ContractDefinition ( DeclarationAbc ): _ast_node : SolcContractDefinition _parent : SourceUnit __abstract : bool __base_contracts : List [ InheritanceSpecifier ] # ___dependencies __kind : ContractKind __fully_implemented : Optional [ bool ] __linearized_base_contracts : List [ AstNodeId ] # __scope __documentation : Optional [ Union [ StructuredDocumentation , str ]] # __used_errors __enums : List [ EnumDefinition ] __errors : List [ ErrorDefinition ] __events : List [ EventDefinition ] __functions : List [ FunctionDefinition ] __modifiers : List [ ModifierDefinition ] __structs : List [ StructDefinition ] __user_defined_value_types : List [ UserDefinedValueTypeDefinition ] __using_for_directives : List [ UsingForDirective ] __declared_variables : List [ VariableDeclaration ] __child_contracts : Set [ ContractDefinition ] def __init__ ( self , init : IrInitTuple , contract : SolcContractDefinition , parent : SourceUnit ): super () . __init__ ( init , contract , parent ) self . __abstract = contract . abstract self . __kind = contract . contract_kind self . __fully_implemented = contract . fully_implemented self . __linearized_base_contracts = list ( contract . linearized_base_contracts ) if contract . documentation is None : self . __documentation = None elif isinstance ( contract . documentation , SolcStructuredDocumentation ): self . __documentation = StructuredDocumentation ( init , contract . documentation , self ) elif isinstance ( contract . documentation , str ): self . __documentation = contract . documentation else : raise TypeError ( f \"Unknown type of documentation: { type ( contract . documentation ) } \" ) self . __base_contracts = [] for base_contract in contract . base_contracts : self . __base_contracts . append ( InheritanceSpecifier ( init , base_contract , self ) ) self . __child_contracts = set () self . __enums = [] self . __errors = [] self . __events = [] self . __functions = [] self . __modifiers = [] self . __structs = [] self . __user_defined_value_types = [] self . __using_for_directives = [] self . __declared_variables = [] for node in contract . nodes : if isinstance ( node , SolcEnumDefinition ): self . __enums . append ( EnumDefinition ( init , node , self )) elif isinstance ( node , SolcErrorDefinition ): self . __errors . append ( ErrorDefinition ( init , node , self )) elif isinstance ( node , SolcEventDefinition ): self . __events . append ( EventDefinition ( init , node , self )) elif isinstance ( node , SolcFunctionDefinition ): self . __functions . append ( FunctionDefinition ( init , node , self )) elif isinstance ( node , SolcModifierDefinition ): self . __modifiers . append ( ModifierDefinition ( init , node , self )) elif isinstance ( node , SolcStructDefinition ): self . __structs . append ( StructDefinition ( init , node , self )) elif isinstance ( node , SolcUserDefinedValueTypeDefinition ): self . __user_defined_value_types . append ( UserDefinedValueTypeDefinition ( init , node , self ) ) elif isinstance ( node , SolcUsingForDirective ): self . __using_for_directives . append ( UsingForDirective ( init , node , self )) elif isinstance ( node , SolcVariableDeclaration ): self . __declared_variables . append ( VariableDeclaration ( init , node , self )) init . reference_resolver . register_post_process_callback ( self . __post_process ) def __post_process ( self , callback_params : CallbackParams ): base_contracts = [] for base_contract in self . __base_contracts : contract = base_contract . base_name . referenced_declaration assert isinstance ( contract , ContractDefinition ) contract . __child_contracts . add ( self ) base_contracts . append ( contract ) self . _reference_resolver . register_destroy_callback ( self . file , partial ( self . __destroy , base_contracts ) ) def __destroy ( self , base_contracts : List [ ContractDefinition ]) -> None : for base_contract in base_contracts : base_contract . __child_contracts . remove ( self ) def _parse_name_location ( self ) -> Tuple [ int , int ]: IDENTIFIER = r \"[a-zA-Z$_][a-zA-Z0-9$_]*\" CONTRACT_RE = re . compile ( r \"^\\s*(abstract\\s)?\\s*contract\\s+(?P<name> {identifier} )\" . format ( identifier = IDENTIFIER ) . encode ( \"utf-8\" ) ) INTERFACE_RE = re . compile ( r \"^\\s*interface\\s+(?P<name> {identifier} )\" . format ( identifier = IDENTIFIER ) . encode ( \"utf-8\" ) ) LIBRARY_RE = re . compile ( r \"^\\s*library\\s+(?P<name> {identifier} )\" . format ( identifier = IDENTIFIER ) . encode ( \"utf-8\" ) ) if self . kind == ContractKind . CONTRACT : match = CONTRACT_RE . match ( self . _source ) elif self . kind == ContractKind . INTERFACE : match = INTERFACE_RE . match ( self . _source ) elif self . kind == ContractKind . LIBRARY : match = LIBRARY_RE . match ( self . _source ) else : raise ValueError ( f \"Unknown contract kind: { self . kind } \" ) assert match return self . byte_location [ 0 ] + match . start ( \"name\" ), self . byte_location [ 0 ] + match . end ( \"name\" ) @property def parent ( self ) -> SourceUnit : return self . _parent @property def canonical_name ( self ) -> str : return self . _name @property @lru_cache ( maxsize = None ) def declaration_string ( self ) -> str : ret = f \" { 'abstract ' if self . abstract else '' }{ self . kind } { self . name } \" ret += ( \" is \" + \", \" . join ( spec . source for spec in self . base_contracts ) if len ( self . base_contracts ) > 0 else \"\" ) if isinstance ( self . documentation , StructuredDocumentation ): return ( \"/// \" + \" \\n ///\" . join ( line for line in self . documentation . text . splitlines ()) + \" \\n \" + ret ) elif isinstance ( self . documentation , str ): return ( \"/// \" + \" \\n ///\" . join ( line for line in self . documentation . splitlines ()) + \" \\n \" + ret ) else : return ret @property def abstract ( self ) -> bool : return self . __abstract @property def base_contracts ( self ) -> Tuple [ InheritanceSpecifier ]: return tuple ( self . __base_contracts ) @property def child_contracts ( self ) -> FrozenSet [ ContractDefinition ]: return frozenset ( self . __child_contracts ) @property def kind ( self ) -> ContractKind : return self . __kind @property def fully_implemented ( self ) -> Optional [ bool ]: return self . __fully_implemented @property def linearized_base_contracts ( self ) -> Tuple [ ContractDefinition ]: base_contracts = [] for base_contract in self . __linearized_base_contracts : node = self . _reference_resolver . resolve_node ( base_contract , self . _cu_hash ) assert isinstance ( node , ContractDefinition ) base_contracts . append ( node ) return tuple ( base_contracts ) @property def documentation ( self ) -> Optional [ Union [ StructuredDocumentation , str ]]: return self . __documentation @property def enums ( self ) -> Tuple [ EnumDefinition ]: return tuple ( self . __enums ) @property def errors ( self ) -> Tuple [ ErrorDefinition ]: return tuple ( self . __errors ) @property def events ( self ) -> Tuple [ EventDefinition ]: return tuple ( self . __events ) @property def functions ( self ) -> Tuple [ FunctionDefinition ]: return tuple ( self . __functions ) @property def modifiers ( self ) -> Tuple [ ModifierDefinition ]: return tuple ( self . __modifiers ) @property def structs ( self ) -> Tuple [ StructDefinition ]: return tuple ( self . __structs ) @property def user_defined_value_types ( self ) -> Tuple [ UserDefinedValueTypeDefinition ]: return tuple ( self . __user_defined_value_types ) @property def using_for_directives ( self ) -> Tuple [ UsingForDirective ]: return tuple ( self . __using_for_directives ) @property def declared_variables ( self ) -> Tuple [ VariableDeclaration ]: return tuple ( self . __declared_variables ) @property def declarations ( self ) -> Iterator [ DeclarationAbc ]: yield from self . enums for enum in self . enums : yield from enum . values yield from self . errors yield from self . events yield from self . functions yield from self . modifiers yield from self . structs yield from self . user_defined_value_types yield from self . declared_variables","title":"Contract definition"},{"location":"api-reference/ir/declarations/event-definition/","text":"Bases: DeclarationAbc Source code in woke/ast/ir/declaration/event_definition.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 class EventDefinition ( DeclarationAbc ): _ast_node : SolcEventDefinition _parent : ContractDefinition __anonymous : bool __parameters : ParameterList __documentation : Optional [ Union [ StructuredDocumentation , str ]] def __init__ ( self , init : IrInitTuple , event : SolcEventDefinition , parent : IrAbc ): super () . __init__ ( init , event , parent ) self . __anonymous = event . anonymous self . __parameters = ParameterList ( init , event . parameters , self ) if event . documentation is None : self . __documentation = None elif isinstance ( event . documentation , SolcStructuredDocumentation ): self . __documentation = StructuredDocumentation ( init , event . documentation , self ) elif isinstance ( event . documentation , str ): self . __documentation = event . documentation else : raise TypeError ( f \"Unknown type of documentation: { type ( event . documentation ) } \" ) # TODO event selector? def _parse_name_location ( self ) -> Tuple [ int , int ]: IDENTIFIER = r \"[a-zA-Z$_][a-zA-Z0-9$_]*\" EVENT_RE = re . compile ( r \"^\\s*event\\s+(?P<name> {identifier} )\" . format ( identifier = IDENTIFIER ) . encode ( \"utf-8\" ) ) byte_start = self . _ast_node . src . byte_offset match = EVENT_RE . match ( self . _source ) assert match return byte_start + match . start ( \"name\" ), byte_start + match . end ( \"name\" ) @property def parent ( self ) -> ContractDefinition : return self . _parent @property def canonical_name ( self ) -> str : return f \" { self . _parent . canonical_name } . { self . _name } \" @property @lru_cache ( maxsize = None ) def declaration_string ( self ) -> str : ret = ( f \"event { self . _name } (\" + \", \" . join ( param . declaration_string for param in self . parameters . parameters ) + f \") { ' anonymous' if self . anonymous else '' } \" ) if isinstance ( self . documentation , StructuredDocumentation ): return ( \"/// \" + \" \\n ///\" . join ( line for line in self . documentation . text . splitlines ()) + \" \\n \" + ret ) elif isinstance ( self . documentation , str ): return ( \"/// \" + \" \\n ///\" . join ( line for line in self . documentation . splitlines ()) + \" \\n \" + ret ) else : return ret @property def anonymous ( self ) -> bool : return self . __anonymous @property def parameters ( self ) -> ParameterList : return self . __parameters @property def documentation ( self ) -> Optional [ Union [ StructuredDocumentation , str ]]: return self . __documentation","title":"Event definition"},{"location":"api-reference/ir/expressions/function-call/","text":"Bases: ExpressionAbc Source code in woke/ast/ir/expression/function_call.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class FunctionCall ( ExpressionAbc ): _ast_node : SolcFunctionCall _parent : IrAbc # TODO: make this more specific __arguments : List [ ExpressionAbc ] __expression : ExpressionAbc __kind : FunctionCallKind __names : List [ str ] __try_call : bool def __init__ ( self , init : IrInitTuple , function_call : SolcFunctionCall , parent : IrAbc ): super () . __init__ ( init , function_call , parent ) self . __kind = function_call . kind self . __names = list ( function_call . names ) self . __try_call = function_call . try_call self . __expression = ExpressionAbc . from_ast ( init , function_call . expression , self ) self . __arguments = [ ExpressionAbc . from_ast ( init , argument , self ) for argument in function_call . arguments ] @property def parent ( self ) -> IrAbc : return self . _parent @property def kind ( self ) -> FunctionCallKind : return self . __kind @property def names ( self ) -> Tuple [ str ]: return tuple ( self . __names ) @property def try_call ( self ) -> bool : return self . __try_call @property def expression ( self ) -> ExpressionAbc : return self . __expression @property def arguments ( self ) -> Tuple [ ExpressionAbc ]: return tuple ( self . __arguments )","title":"Function call"},{"location":"api_reference/","text":"API reference #","title":"API reference"},{"location":"api_reference/#api-reference","text":"","title":"API reference"},{"location":"api_reference/config/","text":"","title":"Config"}]}