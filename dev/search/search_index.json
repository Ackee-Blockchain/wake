{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Wake","text":"<p>Wake is a Python-based Solidity development and testing framework with built-in vulnerability detectors.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>testing framework based on pytest</li> <li>property-based fuzzer</li> <li>deployments &amp; mainnet interactions</li> <li>vulnerability and code quality detectors</li> <li>printers for extracting useful information from Solidity code</li> <li>static analysis framework for implementing custom detectors and printers</li> <li>Github actions for setting up Wake and running detectors</li> <li>language server (LSP)</li> <li>VS Code extension (Tools for Solidity)</li> <li>solc version manager</li> </ul>"},{"location":"#discovered-vulnerabilities","title":"Discovered vulnerabilities","text":"<p>Wake is used by the Ackee team to perform smart contract audits - and it helped to discover a bunch of high and critical vulnerabilities.</p> Vulnerability Severity Project Method Resources Profit &amp; loss accounted twice Critical IPOR Fuzz test Report, Wake tests Console permanent denial of service High Brahma Fuzz test Report Swap unwinding formula error High IPOR Fuzz test Report, Wake tests Swap unwinding fee accounted twice High IPOR Fuzz test Report, Wake tests Incorrect event data High Solady Integration test Report, Wake tests <code>INTEREST_FROM_STRATEGY_BELOW_ZERO</code> reverts DoS Medium IPOR Fuzz test Report, Wake tests Inaccurate hypothetical interest formula Medium IPOR Fuzz test Report, Wake tests Swap unwinding fee normalization error Medium IPOR Fuzz test Report, Wake tests Liquidation deposits accounted into LP balance Medium IPOR Fuzz test Report, Wake tests Missing receive function Medium Axelar Fuzz test Wake tests <code>SafeERC20</code> not used for <code>approve</code> Medium Lido Fuzz test Wake tests"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#4.10.1","title":"4.10.1 (Jun 11, 2024)","text":"<p>Fixes:</p> <ul> <li>fixed language server unicode decoding crash when trying to read from non-existent files [language server]</li> <li>fixed Yul definitions of <code>shl</code>, <code>shr</code> and <code>sar</code> instructions in <code>lsp-yul-definitions</code> printer [language server]</li> <li>fixed handling of language server subprocess crashes [language server]</li> </ul>"},{"location":"changelog/#4.10.0","title":"4.10.0 (Jun 11, 2024)","text":"<p>Features &amp; improvements:</p> <ul> <li>implemented abi encoding &amp; decoding of errors [testing framework]</li> <li>included standard Solidity interfaces, Create3 deployer and ERC-1967 factory into bundled-in contracts [testing framework]</li> <li>detectors &amp; printers now run in subprocesses in LSP [language server]</li> <li>implemented LSP workspace symbols feature [language server]</li> <li>added support for Solidity 0.8.26 [core]</li> <li>implemented <code>exclude</code> and <code>only</code> config options for printers [core]</li> </ul> <p>Changes:</p> <ul> <li>improved <code>random_int</code> documentation &amp; incorrect value checking [testing framework]</li> <li>changed <code>__str__</code> and <code>__repr__</code> of <code>Account</code> for easier debugging [testing framework]</li> <li>code lens LSP features re-implemented as LSP printers + created docs [language server]</li> <li>dropped support for Python 3.7 [core]</li> <li>upgraded pydantic to 2.x [core]</li> </ul> <p>Fixes:</p> <ul> <li>fixed pickling error when encoding dataclasses using new abi encoder [testing framework]</li> <li>fixed file descriptors leak in LSP [language server]</li> <li>fixed misbehavior of LSP configuration key removal [language server]</li> <li>fixed LSP connection crash due to incorrect content length with unicode characters [language server]</li> <li>fixed rare compilation pipeline crash with multiple solc versions [core]</li> <li>fixed <code>wake detect</code> &amp; <code>wake print</code> commands with latest <code>rich-click</code> [cli]</li> </ul>"},{"location":"changelog/#4.9.0","title":"4.9.0 (Apr 25, 2024)","text":"<p>Features &amp; improvements:</p> <ul> <li>new <code>deploy</code> method for contract deployment from creation code [testing framework]</li> <li>introduced alias <code>chain = default_chain</code> [testing framework]</li> <li><code>chain.txs</code> can now be indexed with numbers [testing framework]</li> <li><code>chain.chain_id</code> is now cast to <code>uint256</code> [testing framework]</li> </ul> <p>Fixes:</p> <ul> <li>fixed process count setting for collecting coverage [testing framework]</li> <li>fixed pytypes generator overloading + inheritance issue [testing framework]</li> <li>fixed LSP race conditions on files updated outside of IDE (VS Code) [language server]</li> <li>fixed <code>add_hover_from_offsets</code> LSP printers API function [language server]</li> <li>fixed <code>is_reachable</code> is control flow graph [static analysis]</li> <li>fixed recursion in <code>expression_is_only_owner</code> function [static analysis]</li> <li>fixed regex parsing from source code containing comments [core]</li> </ul>"},{"location":"changelog/#4.8.0","title":"4.8.0 (Apr 5, 2024)","text":"<p>Features &amp; improvements:</p> <ul> <li>implemented callback commands for LSP printers<ul> <li>go to locations, peek locations, open URI, copy to clipboard</li> </ul> </li> <li>Wake <code>console.log</code> is now tread as library (in respect to detectors)</li> <li>Wake <code>console.log</code> is now auto-completed in Solidity imports through LSP</li> <li>random seeds used in testing are now printed in pytest summary</li> <li>documented possible test reproducibility issues and their solutions</li> </ul> <p>Fixes:</p> <ul> <li>fixed empty array encoding in new abi coder</li> <li>Python warning messages are suppressed in shell completions</li> <li>fixed LSP config loading race conditions</li> <li>newly excluded Solidity files in LSP are now treated as deleted (fixes LSP crashes)</li> <li>primitive types (e.g. <code>bytes32</code>) are now returned from <code>keccak256</code> and <code>read_storage_variable</code></li> <li>fixed <code>get_variable_declarations_from_expression</code> recursion bug</li> </ul>"},{"location":"changelog/#4.7.0","title":"4.7.0 (Mar 16, 2024)","text":"<p>Features:</p> <ul> <li>added support for Solidity 0.8.25</li> </ul> <p>Fixes:</p> <ul> <li>fixed compilation crashes when using Solidity <code>log0</code> - <code>log4</code></li> <li>fixed compilation crashes when using <code>bytes.pop()</code></li> <li>fixed <code>random</code> affected by <code>logging</code> - created custom <code>Random</code> instance</li> <li>fixed compilation crashes in AST validation with Solidity &lt;= 0.7.2</li> </ul>"},{"location":"changelog/#4.6.0","title":"4.6.0 (Mar 13, 2024)","text":"<p>Features:</p> <ul> <li>added <code>visit_</code> functions for base classes to visitors</li> <li>added <code>on_revert</code> handler example to the default test template</li> <li>IR types (<code>wake.ir.types</code>) are now strictly comparable</li> <li>improved printing of structs and errors in call traces</li> <li>updated <code>axelar-proxy-contract-id</code> detector</li> <li><code>mint_erc20</code>, <code>burn_erc20</code> now works with constant total supply tokens (warning is printed that total supply cannot be updated)</li> </ul> <p>Fixes:</p> <ul> <li>fixed multiple issues in call traces printing</li> <li>fixed Python linter firing when using pytypes with new version of primitives types (<code>uint256</code>, etc.)</li> <li>fixed the type of <code>.min</code> <code>.max</code> members of primitive integer types</li> <li>fixed <code>is_reachable</code> helper function in <code>ControlFlowGraph</code></li> </ul>"},{"location":"changelog/#4.5.1","title":"4.5.1 (Feb 17, 2024)","text":"<p>Fixes:</p> <ul> <li><code>ValueError</code> is no longer raised for experimental <code>abi.encode_with_signature</code> and <code>abi.encode_call</code> with ambiguous integers</li> <li>fixed <code>mint_erc20</code>/<code>burn_erc20</code> for most tokens</li> </ul>"},{"location":"changelog/#4.5.0","title":"4.5.0 (Feb 12, 2024)","text":"<p>Features:</p> <ul> <li>Accounts / contracts can now be created without <code>default_chain</code> connected</li> <li>added new <code>unsafe-erc20-call</code> detector</li> <li>added support for named arguments in call traces</li> <li><code>reprlib</code> is used again in call traces, full call traces can be enabled with <code>-v</code> CLI option</li> <li>added alias <code>-h</code> for <code>--help</code> on command-line</li> <li>added <code>.min</code> and <code>.max</code> members to int/uint types</li> <li>added new experimental <code>abi</code> coder</li> </ul> <p>Fixes:</p> <ul> <li>fixed coverage collection with new Anvil</li> <li>fixed coverage collection on macOS/Windows</li> <li>fixed ambiguous errors resolving when reverting in contract constructor</li> <li>fixed ERC- slots detection using storage layout</li> <li>fixed debugger attachment when chain is not connected</li> </ul>"},{"location":"changelog/#4.4.1","title":"4.4.1 (Jan 30, 2024)","text":"<p>Fixes:</p> <ul> <li>changed detectors/printers preview interface causing <code>__init__</code> and click entry points being run even when not intended to be run on CLI / in LSP<ul> <li>fixes <code>OSError(30, 'Read-only file system')</code> error messages in LSP on macOS</li> </ul> </li> <li>fixed compiling projects from sources on Etherscan-like explorers in testing framework helper functions</li> </ul>"},{"location":"changelog/#4.4.0","title":"4.4.0 (Jan 27, 2024)","text":"<p>Features:</p> <ul> <li>Solidity 0.8.24 support</li> <li>LSP providers in detectors and printers (preview)</li> <li><code>ErrorDefinition</code> and <code>EventDefinition</code> are now supported in <code>pair_function_call_arguments</code> helper function</li> </ul> <p>Fixes:</p> <ul> <li>fixed <code>pair_function_call_arguments</code> - struct construction with (possibly nested) mapping in Solidity &lt; 0.7</li> <li>fixed LSP crash on file opened but not saved on disk</li> </ul>"},{"location":"changelog/#4.3.2","title":"4.3.2 (Jan 23, 2024)","text":"<p>Fixes:</p> <ul> <li>fixed issue when generating pytypes for cyclically imported Solidity files with inheritance</li> <li>fixed <code>wake test</code> multiprocessing mode on macOS and Windows</li> </ul>"},{"location":"changelog/#4.3.1","title":"4.3.1 (Jan 9, 2024)","text":"<p>Fixes:</p> <ul> <li>fixed <code>wake test</code> multiprocessing mode when running more than one test</li> <li>fixed global TOML config file not always loaded with local <code>wake.toml</code> in LSP</li> <li>fixed counter example README</li> </ul>"},{"location":"changelog/#4.3.0","title":"4.3.0 (Dec 24, 2023)","text":"<p>Features:</p> <ul> <li>print warnings when a detector set in config options is not discovered (both on the CLI and in LSP)</li> <li>added new <code>complex-struct-getter</code> and <code>struct-mapping-deletion</code> detectors</li> <li>added new <code>c3-linearization</code> printer</li> <li>re-run detectors after modifying a loaded detector</li> </ul> <p>Fixes:</p> <ul> <li>fixed Yul <code>return</code> ignored in the control flow graph</li> <li>fixed <code>AssertionError</code> in call traces when running out of gas</li> <li>fixed <code>abi-encode-with-signature</code> detector when processing signatures with nested brackets</li> <li>fixed detectors were not re-run after changing a detector-specific setting</li> <li>bumped <code>abch-tree-sitter</code> minimal version, fixing the language server crashes caused by <code>distutils</code> not being available in Python 3.12</li> </ul>"},{"location":"changelog/#4.2.0","title":"4.2.0 (Dec 11, 2023)","text":"<p>Features:</p> <ul> <li><code>wake open</code> command to open any Github or Etherscan-like project</li> <li><code>wake up</code> alias for <code>wake init</code></li> <li>new <code>unused-function</code> and <code>unused-modifier</code> detectors</li> <li>helper functions for working with storage variables now can handle whole arrays and structs</li> <li><code>wake detect</code> and <code>wake print</code> commands now accept <code>--theme</code> options</li> </ul> <p>Changes:</p> <ul> <li>changed <code>unused-import</code> detections impact from warning to info</li> </ul> <p>Fixes:</p> <ul> <li>fixed compiler crashes when using SMTChecker</li> </ul>"},{"location":"changelog/#4.1.2","title":"4.1.2 (Dec 3 , 2023)","text":"<p>Fixes:</p> <ul> <li><code>solc</code> binaries are automatically re-installed if corrupted</li> <li>added <code>--silent</code> mode to fix LSP server crashes on Windows because of unicode</li> </ul>"},{"location":"changelog/#4.1.1","title":"4.1.1 (Nov 28, 2023)","text":"<ul> <li>fixed script responsible for migration to XDG paths when the global config file already exists</li> <li>fixed assertion error in ownable pattern detection, manifested mainly by <code>reentrancy</code> detector crashes</li> </ul>"},{"location":"changelog/#4.1.0","title":"4.1.0 (Nov 28, 2023)","text":"<ul> <li>added new printers:<ul> <li><code>control-flow-graph</code></li> <li><code>imports-graph</code></li> <li><code>inheritance-graph</code></li> <li><code>inheritance-tree</code></li> <li><code>modifiers</code></li> <li><code>state-changes</code></li> </ul> </li> <li><code>lsp_range</code> and IR declaration <code>name_location</code> are now used in SARIF export</li> <li>implemented <code>SolidityName</code> Click parameter type for Solidity name shell completions</li> <li>improved <code>wake detect</code> and <code>wake print</code> help messages</li> <li>added a new <code>Command-line interface</code> docs page under the static analysis section</li> <li>state changes are now evaluated even for Yul blocks</li> <li>fixed crashes caused by <code>YulLiteral.value</code> being unset</li> </ul>"},{"location":"changelog/#4.0.1","title":"4.0.1 (Nov 22, 2023)","text":"<ul> <li>fixed SARIF export crashing in Github action</li> <li>fixed <code>wake detect</code> incorrect exit codes</li> <li>fixed exporting ignored detections in SARIF format</li> <li>minor changes to the documentation</li> </ul>"},{"location":"changelog/#4.0.0","title":"4.0.0 (Nov 20, 2023)","text":"<ul> <li> <p>reviewed, updated and documented IR model</p> <ul> <li>all IR nodes are now documented, generated docs available in API reference section</li> <li>added link to SourceUnit from all IR nodes</li> <li>added link to nearest StatementAbc from all expressions</li> <li>added link to declaration (FunctionDefinition/ModifierDefinition) from all statements</li> <li>added link to InlineAssembly from all Yul nodes</li> </ul> </li> <li> <p>updated control flow graph</p> <ul> <li>Yul is now fully supported; InlineAssembly blocks are now decomposed into Yul statemenets</li> <li>successful execution and reverting execution is now distinguished in control flow graph</li> <li>assert/require/revert function calls are now handled (including these calls in conditionals)</li> <li>fixed missing edge for in try/catch statement</li> </ul> </li> <li> <p>development &amp; testing framework</p> <ul> <li>all default accounts (<code>default_tx_account</code>, <code>default_call_account</code>, <code>default_estimate_account</code>, <code>default_access_list_account</code>) are now set by default</li> <li><code>may_revert</code> and <code>must_revert</code> context managers now re-raise original exception when it does not match one of arguments</li> <li>significantly improved performance when accessing <code>tx.events</code></li> <li>improved event resolving algorithm</li> <li>added <code>origin</code> field to all events, describing contract Account that emitted event</li> <li>improved forked chain ID detection</li> <li><code>fuzz</code> command was integrated into <code>test</code> command</li> <li>both single-process and multi-process tests now use pytest<ul> <li>running tests without pytest is still supported with <code>--no-pytest</code> flag</li> </ul> </li> </ul> </li> <li> <p>added support for Solidity 0.8.21, 0.8.22 and 0.8.23</p> </li> <li>added experimental support for Python 3.12</li> <li>rebranded from Woke to Wake<ul> <li>implemented automatic migration script for migrating project-specific and global files</li> </ul> </li> <li>all CLI commands now accept <code>--config</code> option for setting local config path</li> <li>implemented <code>svm install --all</code> to install all matching solc versions</li> <li>renamed <code>ignore_paths</code> config options to <code>exclude_paths</code><ul> <li>automatic migration script performs automatic renaming</li> </ul> </li> <li>all solc optimizer settings may now be configured</li> <li> <p>implemented new <code>wake init config</code> command for initializing only config file</p> </li> <li> <p>new detectors &amp; printers API</p> <ul> <li>printers are similar to detectors but allow printing (or exporting in other ways) any useful information</li> <li>users may create custom detectors &amp; printers using documented API</li> <li>may be project-specific, global and loaded from plugin packages</li> <li>project-specific detectors/printers must be first confirmed as verified to protect users downloading others (potentially malicious) projects</li> <li>both detectors and printers may accept any number of Click options and arguments that can be set in CLI, ENV variables and TOML files</li> <li>detector results and compiler warnings may be ignored using <code>// wake-disable-*</code> comments</li> <li>loading priorities may be specified for multiple detectors/printers with the same name loaded from multiple plugin packages</li> <li><code>wake.analysis</code>, <code>wake.ir</code> and <code>networkx</code> are now imported as lazy modules to improve auto-completions speed in CLI</li> <li>detectors cannot crash LSP server or prevent other detectors from executing, errors are reported to LSP clients</li> <li><code>logging</code> module logger attached to each detector/printer; logging messages are redirected to LSP client when running LSP server</li> <li>detectors are live-reloaded after modifications when running LSP server, no need to restart LSP server to trigger changes</li> <li>added helper CLI and LSP commands for creating new detector/printer from template</li> <li>added more export formats to detectors and printers</li> <li>both detectors and printers may be launched in <code>--watch</code> mode</li> <li>implemented export to SARIF format for detectors</li> <li>detectors may now assign dynamic impact &amp; confidence per-detection</li> </ul> </li> <li> <p>implemented ready-to-use printers</p> <ul> <li><code>abi</code> for exporting contract ABI</li> <li><code>storage-layout</code> for printing contract storage layout</li> <li><code>tokens</code> for finding all ERC-20/ERC-721/ERC-1155 tokens in project</li> </ul> </li> <li>improved existing detectors</li> <li>implemented new detectors<ul> <li><code>abi-encode-with-signature</code> for detecting invalid ABI signatures</li> <li><code>incorrect-interface</code> for detecting incorrectly implemented ERC-20/ERC-721/ERC-1155 interface</li> <li><code>unused-import</code> for finding unused imports</li> </ul> </li> </ul>"},{"location":"compilation/","title":"Compilation","text":"<p>Wake comes with default compilation settings that should work for many projects. However, in some cases, it may be necessary to customize the compilation settings.</p> <p>To run the compiler, use: <pre><code>wake compile\n</code></pre></p> <p>The <code>--help</code> flag can be used to display additional options.</p> <p>Tip</p> <p>Wake comes with <code>wake up</code> (to initialize a new or existing project) and <code>wake up config</code> (to prepare just the <code>wake.toml</code> config file) commands. The commands can automatically set remappings for Foundry projects and enable the solc optimizer if needed.</p>"},{"location":"compilation/#include-paths","title":"Include paths","text":"<p>Include paths define locations where to search for Solidity files imported using direct (non-relative) import strings. An example of a direct import string is: <pre><code>import \"openzeppelin/contracts/token/ERC20/ERC20.sol\";\n</code></pre></p> <p>The default settings for include paths are: wake.toml<pre><code>[compiler.solc]\ninclude_paths = [\"node_modules\"]\n</code></pre></p> <p>Info</p> <p>Include paths should only be used if path segments (directories in the import string) reflect directories in the file system.</p> <p>For example, if the import string is <code>import \"openzeppelin/contracts/token/ERC20/ERC20.sol\";</code>, but the file is located at <code>node_modules/openzeppelin/src/contracts/token/ERC20/ERC20.sol</code>, then include paths cannot be used because of the <code>src</code> directory in the path.</p>"},{"location":"compilation/#remappings","title":"Remappings","text":"<p>Remappings allow performing a substitution in import strings. More information about remappings can be found in the Solidity documentation.</p> <p>Note</p> <p>It is highly recommended to use include paths instead of remappings whenever possible.</p>"},{"location":"compilation/#foundry-projects","title":"Foundry projects","text":"<p>Include paths typically cannot be used in Foundry projects. The <code>forge remappings</code> command can generate remappings that can be copied into the <code>wake.toml</code> file: <pre><code>$ forge remappings\n@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\n@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\nds-test/=lib/forge-std/lib/ds-test/src/\nforge-std/=lib/forge-std/src/\n</code></pre></p> wake.toml<pre><code>[compiler.solc]\nremappings = [\n  \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\n  \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\n  \"ds-test/=lib/forge-std/lib/ds-test/src/\",\n  \"forge-std/=lib/forge-std/src/\"\n]\n</code></pre>"},{"location":"compilation/#exclude-paths","title":"Exclude paths","text":"<p>Exclude paths define locations of Solidity files that should not be compiled unless imported from another non-excluded file.</p> <p>The default settings for exclude paths are: wake.toml<pre><code>[compiler.solc]\nexclude_paths = [\"node_modules\", \"venv\", \".venv\", \"lib\", \"script\", \"test\"]\n</code></pre></p>"},{"location":"compilation/#via-ir","title":"Via IR","text":"<p>The compiler can can generate bytecode by converting the sources to Yul first (<code>Solidity -&gt; Yul -&gt; EVM bytecode</code>) instead of the traditional <code>Solidity -&gt; EVM bytecode</code> approach. See the Solidity documentation for more information.</p> <p>By default, the <code>via_IR</code> config option is left unset, which leaves the decision to the compiler. It can be enabled by setting the option to <code>true</code>: wake.toml<pre><code>[compiler.solc]\nvia_IR = true\n</code></pre></p> <p><code>Stack too deep</code> errors</p> <p>One way to avoid <code>Stack too deep</code> errors is to enable <code>via_IR</code> and the optimizer.</p>"},{"location":"compilation/#optimizer","title":"Optimizer","text":"<p>Wake allows setting all optimizer options supported by the Solidity compiler (see the Solidity documentation). By default, Wake leaves the <code>enabled</code> option unset, which leaves the decision to the compiler. It can be enabled by setting the option to <code>true</code>: wake.toml<pre><code>[compiler.solc.optimizer]\nenabled = true\nruns = 200\n</code></pre></p>"},{"location":"configuration/","title":"Configuration","text":"<p>Wake can be configured using configuration options loaded from multiple sources in the following order:</p> <ul> <li>default values,</li> <li>global configuration file,</li> <li>project configuration file,</li> <li>environment variables,</li> <li>command-line arguments.</li> </ul>"},{"location":"configuration/#default-values","title":"Default values","text":"Info <p>The following TOML snippet shows the default values of all configuration options. <pre><code>subconfigs = []\n\n[api_keys]\n# etherscan = \"\" (unset - no Etherscan API key)\n# \"goerli.etherscan\" = \"\" (unset - no Goerli Etherscan API key)\n# ...\n\n[compiler.solc]\nallow_paths = []\n# evm_version (unset - let the compiler decide)\nexclude_paths = [\"node_modules\", \"venv\", \".venv\", \"lib\", \"script\", \"test\"]\ninclude_paths = [\"node_modules\"]\nremappings = []\n# target_version (unset - use the latest version)\n# via_IR (unset - let the compiler decide)\n\n[compiler.solc.optimizer]\n# enabled (unset - let the compiler decide)\nruns = 200\n\n[compiler.solc.optimizer.details]\n# peephole (unset - let the compiler decide)\n# inliner (unset - let the compiler decide)\n# jumpdest_remover (unset - let the compiler decide)\n# order_literals (unset - let the compiler decide)\n# deduplicate (unset - let the compiler decide)\n# cse (unset - let the compiler decide)\n# constant_optimizer (unset - let the compiler decide)\n# simple_counter_for_loop_unchecked_increment (unset - let the compiler decide)\n\n[compiler.solc.optimizer.details.yul_details]\n# stack_allocation (unset - let the compiler decide)\n# optimizer_steps (unset - let the compiler decide)\n\n[deployment]\nconfirm_transactions = true\nsilent = false\n\n[detector]\n\n[detectors]\nexclude = []\n# only (unset - all detectors are enabled)\nignore_paths = [\"venv\", \".venv\", \"test\"]\nexclude_paths = [\"node_modules\", \"lib\", \"script\"]\n\n[printers]\nexclude = []\n# only (unset - all printers are enabled)\n\n[printer]\n\n[lsp]\ncompilation_delay = 0\n\n[lsp.code_lens]\nenable = true\nsort_tag_priority = [\n    \"lsp-references\", \"lsp-selectors\", \"lsp-inheritance-graph\",\n    \"lsp-linearized-inheritance-graph\"\n]\n\n[lsp.detectors]\nenable = true\n\n[lsp.find_references]\ninclude_declarations = false\n\n[lsp.inlay_hints]\nenable = true\nsort_tag_priority = []\n\n[general]\ncall_trace_options = [\n    \"contract_name\", \"function_name\", \"named_arguments\", \"status\",\n    \"call_type\", \"value\", \"return_value\", \"error\"\n]\njson_rpc_timeout = 15\nlink_format = \"vscode://file/{path}:{line}:{col}\"\n\n[testing]\ncmd = \"anvil\"\n\n[testing.anvil]\ncmd_args = \"--prune-history 100 --transaction-block-keeper 10 --steps-tracing --silent\"\n\n[testing.ganache]\ncmd_args = \"-k istanbul -q\"\n\n[testing.hardhat]\ncmd_args = \"\"\n</code></pre></p>"},{"location":"configuration/#global-configuration-file","title":"Global configuration file","text":"<p>The global configuration file is loaded from <code>$XDG_CONFIG_HOME/wake/config.toml</code>. If <code>$XDG_CONFIG_HOME</code> is not set, the global configuration file is loaded from:</p> <ul> <li><code>$HOME/.config/wake/config.toml</code> on Linux/MacOS,</li> <li><code>%LOCALAPPDATA%\\wake\\config.toml</code> on Windows.</li> </ul> <p>Additionally, there is a <code>plugins.toml</code> file in the same directory. It holds <code>verified_paths</code> with trusted paths to detectors and printers. The paths are updated automatically with command-line queries or when creating a new detector or printer.</p> <p>The <code>plugins.toml</code> file can be used to specify priorities when having multiple colliding detectors or printers of the same name installed.</p> <p>Example plugins.toml</p> <pre><code>[detector_loading_priorities]\nreentrancy = \"my_detectors\"  # prefer my_detectors module if present\nunused-import = [\"my_detectors\", \"wake_detectors\"]  # prefer my_detectors, then wake_detectors\n\"*\" = \"wake_detectors\"  # prefer wake_detectors for all other detectors\n\n[printer_loading_priorities]\n# follows the same structure\n</code></pre>"},{"location":"configuration/#project-configuration-file","title":"Project configuration file","text":"<p>The project configuration file is loaded from <code>./wake.toml</code>. This can be changed using the <code>wake --config path/to/wake.toml</code> command-line option.</p>"},{"location":"configuration/#subconfigs","title":"Subconfigs","text":"<p>The global <code>config.toml</code> and project configuration files can include additional TOML files (subconfigs). These subconfigs are loaded after the original configuration file in the specified order. Subconfig configuration values override the values of the parent configuration file.</p> <p>Example</p> <pre><code>subconfigs = [\"loaded_next.toml\", \"../relative.toml\", \"/tmp/absolute.toml\", \"loaded_last.toml\"]\n</code></pre>"},{"location":"configuration/#environment-variables","title":"Environment variables","text":"<p>Environment variables (if supported) are printed in the help message of each command on the command-line.</p>"},{"location":"configuration/#command-line-arguments","title":"Command-line arguments","text":"<p>Command-line arguments for each command can be displayed using the <code>--help</code> option.</p>"},{"location":"configuration/#configuration-options","title":"Configuration options","text":""},{"location":"configuration/#api_keys-namespace","title":"<code>api_keys</code> namespace","text":"<p>The <code>api_keys</code> namespace may contain API keys for Etherscan, BscScan, PolygonScan, etc. Blockchain explorer API keys are stored under the lowercase name of the explorer with a subdomain prefix if needed (e.g. <code>goerli.etherscan</code>).</p> <p>Additionally, detectors and printers may use this namespace to load needed API keys.</p> <p>Warning</p> <p>Keep your API keys secret. Store them in the global configuration file or in a separate file included as a subconfig and add this file to <code>.gitignore</code>.</p>"},{"location":"configuration/#compilersolc-namespace","title":"<code>compiler.solc</code> namespace","text":"Option Description <code>allow_paths</code> Allow paths passed to the <code>solc</code> executable <code>evm_version</code> EVM version as specified by the Solidity docs <code>exclude_paths</code> Files in these paths are not compiled unless imported from other non-excluded files <code>include_paths</code> Paths (along with the current working directory) where files from non-relative imports are searched <code>remappings</code> Compiler remappings as specified by the Solidity docs <code>target_version</code> Target <code>solc</code> version used to compile the project <code>via_IR</code> Compile the code via the Yul intermediate language (see the Solidity docs) <p>Info</p> <p>The <code>include_paths</code> option is the preferred way to handle imports of libraries. Remappings should be used only when <code>include_paths</code> cannot be used (e.g. when the import path differs from the system path of the imported file).</p>"},{"location":"configuration/#compilersolcoptimizer-namespace","title":"<code>compiler.solc.optimizer</code> namespace","text":"Option Description <code>enabled</code> Compile the project with solc optimizations enabled. Leaving this unset disables most of the available optimizations. Setting this to <code>false</code> disables all optimizations for Solidity &lt;0.8.6 and has the same behavior as leaving this unset for Solidity &gt;=0.8.6. <code>runs</code> Configuration of the optimizer specifying how many times the code is intended to be run. Lower values optimize more for initial deployment cost, while higher values optimize more for high-frequency usage."},{"location":"configuration/#compilersolcoptimizerdetails-namespace","title":"<code>compiler.solc.optimizer.details</code> namespace","text":"<p>For optimizer details, see the Solidity docs. Settings follow the same structure as in the Solidity docs with an exception of <code>optimizer.details.yul</code> not being supported.</p>"},{"location":"configuration/#detector-namespace","title":"<code>detector</code> namespace","text":"<p>This namespace contains detector-specific configuration options. See the documentation of each detector for more information. Each detector has its own namespace under the <code>detector</code> namespace, e.g. <code>detector.reentrancy</code>. Every detector supports at least the <code>min_confidence</code> and <code>min_impact</code> options:</p> <p>Example</p> <pre><code>[detector.\"unchecked-return-value\"]\nmin_confidence = \"medium\"\nmin_impact = \"high\"\n</code></pre>"},{"location":"configuration/#detectors-namespace","title":"<code>detectors</code> namespace","text":"Option Description <code>exclude</code> List of detectors that should not be enabled. <code>only</code> List of detectors that should only be enabled. <code>ignore_paths</code> Detections or subdetections in these paths are always ignored. Intended for files that will never be deployed (e.g. test files). <code>exclude_paths</code> Detections are excluded if a whole detection (including subdetections) is in these paths. Intended for dependencies."},{"location":"configuration/#general-namespace","title":"<code>general</code> namespace","text":"Option Description <code>call_trace_options</code> What information to display in call traces. Possible options: <code>contract_name</code>, <code>address</code>, <code>function_name</code>, <code>named_arguments</code>, <code>arguments</code>, <code>status</code>, <code>call_type</code>, <code>value</code>, <code>gas</code>, <code>sender</code>, <code>return_value</code>, <code>error</code>. <code>json_rpc_timeout</code> Timeout in seconds when communicating with a node via JSON-RPC. <code>link_format</code> Format of links to source code files used in detectors and printers. The link should contain <code>{path}</code>, <code>{line}</code> and <code>{col}</code> placeholders."},{"location":"configuration/#generatorcontrol_flow_graph-namespace","title":"<code>generator.control_flow_graph</code> namespace","text":"<p>Related to the <code>wake.generate.control_flow_graph</code> LSP command.</p> Option Description Default value <code>direction</code> Graph direction. Possible options: <code>TB</code>, <code>BT</code>, <code>LR</code>, <code>RL</code>. <code>TB</code> <code>vscode_urls</code> Attach VS Code URLs to the graph nodes <code>true</code>"},{"location":"configuration/#generatorimports_graph-namespace","title":"<code>generator.imports_graph</code> namespace","text":"<p>Related to the <code>wake.generate.imports_graph</code> LSP command.</p> Option Description Default value <code>direction</code> Graph direction. Possible options: <code>TB</code>, <code>BT</code>, <code>LR</code>, <code>RL</code>. <code>TB</code> <code>imports_direction</code> Direction of edges between imported files. Possible options: <code>imported-to-importing</code>, <code>importing-to-imported</code>. <code>imported-to-importing</code> <code>vscode_urls</code> Attach VS Code URLs to the graph nodes <code>true</code>"},{"location":"configuration/#generatorinheritance_graph-namespace","title":"<code>generator.inheritance_graph</code> namespace","text":"<p>Related to the <code>wake.generate.inheritance_graph</code> LSP command.</p> Option Description Default value <code>direction</code> Graph direction. Possible options: <code>TB</code>, <code>BT</code>, <code>LR</code>, <code>RL</code>. <code>BT</code> <code>vscode_urls</code> Attach VS Code URLs to the graph nodes <code>true</code>"},{"location":"configuration/#generatorinheritance_graph_full-namespace","title":"<code>generator.inheritance_graph_full</code> namespace","text":"<p>Related to the <code>wake.generate.inheritance_graph_full</code> LSP command.</p> Option Description Default value <code>direction</code> Graph direction. Possible options: <code>TB</code>, <code>BT</code>, <code>LR</code>, <code>RL</code>. <code>BT</code> <code>vscode_urls</code> Attach VS Code URLs to the graph nodes <code>true</code>"},{"location":"configuration/#generatorlinearized_inheritance_graph-namespace","title":"<code>generator.linearized_inheritance_graph</code> namespace","text":"<p>Related to the <code>wake.generate.linearized_inheritance_graph</code> LSP command.</p> Option Description Default value <code>direction</code> Graph direction. Possible options: <code>TB</code>, <code>BT</code>, <code>LR</code>, <code>RL</code>. <code>LR</code> <code>vscode_urls</code> Attach VS Code URLs to the graph nodes <code>true</code>"},{"location":"configuration/#lsp-namespace","title":"<code>lsp</code> namespace","text":"Option Description <code>compilation_delay</code> Delay in seconds before the project is compiled after a keystroke."},{"location":"configuration/#lspcode_lens-namespace","title":"<code>lsp.code_lens</code> namespace","text":"Option Description <code>enable</code> Enable LSP code lens language server feature. <code>sort_tag_priority</code> Order of code lens with the same start and end position based on sort tags used in detectors/printers. Sort tags default to the printer/detector name."},{"location":"configuration/#lspdetectors-namespace","title":"<code>lsp.detectors</code> namespace","text":"Option Description <code>enable</code> Enable vulnerability detectors in the LSP server."},{"location":"configuration/#lspfind_references-namespace","title":"<code>lsp.find_references</code> namespace","text":"<p>Configuration options specific to the LSP <code>Find references</code> request.</p> Option Description <code>include_declarations</code> Also include declarations in <code>Find references</code> request results."},{"location":"configuration/#lspinlay_hints-namespace","title":"<code>lsp.inlay_hints</code> namespace","text":"Option Description <code>enable</code> Enable inlay hints language server feature. <code>sort_tag_priority</code> Order of inlay hints with the same position based on sort tags used in detectors/printers. Sort tags default to the printer/detector name."},{"location":"configuration/#printer-namespace","title":"<code>printer</code> namespace","text":"<p>This namespace contains printer-specific configuration options. See the documentation of each printer for more information. Each printer has its own namespace under the <code>printer</code> namespace, e.g. <code>printer.\"lsp-references\"</code>.</p> <p>Example</p> <pre><code>[printer.\"lsp-references\"]\nlocal_variables = false\n</code></pre>"},{"location":"configuration/#printers-namespace","title":"<code>printers</code> namespace","text":"<p>The following settings mainly apply to LSP printers that are run automatically by the LSP server.</p> Option Description <code>exclude</code> List of printers that should not be enabled. <code>only</code> List of printers that should only be enabled."},{"location":"configuration/#testing-namespace","title":"<code>testing</code> namespace","text":"Option Description <code>cmd</code> Development chain implementation to use. May be <code>anvil</code>, <code>hardhat</code> or <code>ganache</code>."},{"location":"configuration/#testinganvil-namespace","title":"<code>testing.anvil</code> namespace","text":"Option Description <code>cmd_args</code> Command line arguments passed to the <code>anvil</code> executable when launching it."},{"location":"configuration/#testingganache-namespace","title":"<code>testing.ganache</code> namespace","text":"Option Description <code>cmd_args</code> Command line arguments passed to the <code>ganache</code> executable when launching it."},{"location":"configuration/#testinghardhat-namespace","title":"<code>testing.hardhat</code> namespace","text":"Option Description <code>cmd_args</code> Command line arguments passed to the <code>npx hardhat node</code> command when launching it."},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#creating-a-virtual-environment","title":"Creating a virtual environment","text":""},{"location":"contributing/#using-poetry","title":"Using Poetry","text":"<pre><code>poetry shell\n</code></pre>"},{"location":"contributing/#using-venv","title":"Using venv","text":"<pre><code>python3 -m venv env\nsource env/bin/activate\n</code></pre>"},{"location":"contributing/#using-virtualenvwrapper","title":"Using virtualenvwrapper","text":"<pre><code>mkvirtualenv wake\n</code></pre>"},{"location":"contributing/#installation","title":"Installation","text":""},{"location":"contributing/#using-poetry_1","title":"Using Poetry","text":"<pre><code>poetry install -E tests -E dev\n</code></pre>"},{"location":"contributing/#using-pip","title":"Using pip","text":"<pre><code>pip install -e \".[tests,dev]\"\n</code></pre>"},{"location":"contributing/#other-dependencies","title":"Other dependencies","text":"<p>Pyright, our static type checker, is distributed through npm:</p> <pre><code>npm i -g pyright\n</code></pre>"},{"location":"contributing/#git-hooks","title":"Git hooks","text":"<p>For Unix-like platforms, we provide git hooks to help with development.</p> <p>After cloning, execute:</p> <pre><code>chmod +x ./setup-githooks.sh\n./setup-githooks.sh\n</code></pre> <p>Git hooks automatically run these commands when you commit:</p> <ul> <li>gitmoji-fuzzy-hook git prepare-commit-msg hook to help you choose a gitmoji</li> <li><code>pytest tests -m \"not slow\"</code> when the <code>WAKE_HOOKS_RUN_ALL_TESTS</code> environment variable is not set (<code>pytest tests</code> is run otherwise)</li> <li><code>black</code> on Python files being committed</li> <li><code>isort</code> on Python files being committed</li> <li><code>pyright</code> on Python files being committed</li> <li><code>mkdocs build --strict</code> to make sure the documentation does not contain errors</li> </ul> <p>Any unstaged changes and untracked files are stashed before running the git pre-commit hook. After the commit is made, the stashed changes are popped from the stash. If this leads to a merge conflict, the stashed changes are left at the top of the stash.</p>"},{"location":"installation/","title":"Installation","text":"<p>Wake requires Python 3.8 or higher.</p> <p>Warning</p> <p>Python 3.12 is experimentally supported.</p>"},{"location":"installation/#using-pip","title":"Using pip","text":"<pre><code>pip3 install eth-wake\n</code></pre>"},{"location":"installation/#together-with-vs-code-extension","title":"Together with VS Code extension","text":"<p><code>eth-wake</code> is automatically installed with the Tools for Solidity extension.</p>"},{"location":"installation/#docker-image","title":"Docker image","text":"<p>Wake is also available as a Docker image:</p> <pre><code>docker pull ackeeblockchain/wake\ndocker run -it ackeeblockchain/wake wake --help\n</code></pre>"},{"location":"installation/#github-actions","title":"Github actions","text":"<p>Wake comes with 2 Github actions:</p> <ul> <li><code>Ackee-Blockchain/wake-setup-action</code> - sets up a CI pipeline with Wake and Anvil pre-installed</li> <li><code>Ackee-Blockchain/wake-detect-action</code> - runs detectors with optional SARIF output</li> </ul>"},{"location":"installation/#shell-completions","title":"Shell completions","text":"<p>It is possible to enable shell completions for the <code>wake</code> command (does not apply to <code>wake-solc</code>). The instructions depend on the shell you are using.</p> BashZshFish <p>Add the following to your <code>~/.bashrc</code> file:</p> <pre><code>eval \"$(_WAKE_COMPLETE=bash_source wake)\"\n</code></pre> <p>Add the following to your <code>~/.zshrc</code> file:</p> <pre><code>eval \"$(_WAKE_COMPLETE=zsh_source wake)\"\n</code></pre> <p>Add the following to your <code>~/.config/fish/completions/wake.fish</code> file:</p> <pre><code>eval (env _WAKE_COMPLETE=fish_source wake)\n</code></pre>"},{"location":"language-server/","title":"Solidity LSP server","text":"<p>Wake implements an LSP server for Solidity. The only currently supported communication channel is TCP.</p> <p>Wake LSP server can be run using: <pre><code>wake lsp\n</code></pre></p> <p>Or with an optional <code>--port</code> argument (default 65432): <pre><code>wake lsp --port 1234\n</code></pre></p> <p>Info</p> <p>Multi-root workspaces are not currently supported.</p>"},{"location":"language-server/#projects-using-wake-lsp-server","title":"Projects using Wake LSP server","text":"<ul> <li>VS Code Extension</li> </ul>"},{"location":"language-server/#configuration-options","title":"Configuration options","text":"<p>Server configuration options are loaded using the standard interface from LSP clients. The process of setting the configuration options is client specific. Configuration changes are handled by the server, and the project is recompiled if the compilation options change.</p> <p>The full list of supported configuration options can be found in the configuration section.</p> <p>Tip</p> <p>The LSP server automatically loads the configuration options from the <code>wake.toml</code> file located in the root of the project if <code>wake.use_toml_if_present</code> is set to <code>True</code>.</p> <p>The path to the configuration file can be changed using the <code>wake.toml_path</code> configuration option.</p>"},{"location":"language-server/#supported-commands","title":"Supported commands","text":"<p>Wake LSP server implements the command execution provider as specified by the LSP specification. The following commands are supported:</p> Command Arguments Description <code>wake.init.detector</code> <code>0</code>: name of the detector<code>1</code>: boolean indicating whether the detector should be global (True) or project-specific (False) Initialize a detector from a template in <code>$XDG_DATA_HOME/wake/global-detectors</code> or <code>./detectors</code> (if the detector is project-specific). <code>wake.init.printer</code> <code>0</code>: name of the printer<code>1</code>: boolean indicating whether the printer should be global (True) or project-specific (False) Initialize a printer from a template in <code>$XDG_DATA_HOME/wake/global-printers</code> or <code>./printers</code> (if the printer is project-specific). <code>wake.lsp.force_recompile</code> Force recompile the opened project/files. Useful after modifying files outside the IDE (e.g. after installing npm packages). <code>wake.lsp.force_rerun_detectors</code> Force rerun detectors on the opened project/files. <code>wake.generate.control_flow_graph</code> <code>0</code>: URI of the document containing the function<code>1</code>: canonical name of the function Generate a control flow graph for the given function or modifier. Returns the source code of the graph in Graphviz (DOT) format. <code>wake.generate.imports_graph</code> Generate an imports graph for the whole project. A workspace must be opened. Returns the source code of the graph in Graphviz (DOT) format. <code>wake.generate.inheritance_graph</code> <code>0</code>: URI of the document containing the contract<code>1</code>: name of the contract Generate an inheritance graph for the given contract. Returns the source code of the graph in Graphviz (DOT) format. <code>wake.generate.inheritance_graph_full</code> Generate an inheritance graph for the whole project. A workspace must be opened. Returns the source code of the graph in Graphviz (DOT) format. <code>wake.generate.linearized_inheritance_graph</code> <code>0</code>: URI of the document containing the contract<code>1</code>: name of the contract Generate a linearized inheritance graph for the given contract. Returns the source code of the graph in Graphviz (DOT) format."},{"location":"language-server/#features","title":"Features","text":""},{"location":"language-server/#go-to-definition","title":"Go to definition","text":""},{"location":"language-server/#go-to-type-definition","title":"Go to type definition","text":""},{"location":"language-server/#go-to-implementation","title":"Go to implementation","text":"<p>Finds implementations of an unimplemented function or modifier.</p> <p></p>"},{"location":"language-server/#find-references","title":"Find references","text":""},{"location":"language-server/#type-hierarchy","title":"Type hierarchy","text":"<p>Also works for virtual functions.</p> <p></p>"},{"location":"language-server/#document-links","title":"Document links","text":""},{"location":"language-server/#hover","title":"Hover","text":"<p>Includes links to documentation for OpenZeppelin contracts.</p> <p></p>"},{"location":"language-server/#code-lens","title":"Code lens","text":"<p>Number of references is shown above each declaration.</p> <p></p>"},{"location":"language-server/#document-symbols","title":"Document symbols","text":""},{"location":"language-server/#diagnostics","title":"Diagnostics","text":"<p>Together with compiler errors, diagnostics also include results from Wake vulnerability detectors.</p> <p></p> <p></p>"},{"location":"language-server/#rename","title":"Rename","text":""},{"location":"language-server/#debugging","title":"Debugging","text":"<p>Wake LSP server can be debugged using: <pre><code>wake --debug lsp\n</code></pre></p>"},{"location":"solc-version-manager/","title":"Solc Version Manager (SVM)","text":"<p>Wake implements Solc Version Manager (SVM) to manage multiple installations of the solc compiler. Compiler executables for different versions are located in <code>$XDG_DATA_HOME/wake/compilers</code>. The default value of <code>$XDG_DATA_HOME</code> is:</p> <ul> <li><code>$HOME/.local/share</code> on Linux/MacOS,</li> <li><code>%LOCALAPPDATA%</code> on Windows.</li> </ul> <p>The chosen version of solc is available under the <code>wake-solc</code> executable which acts as a wrapper for the solc executable.</p> <p>Example</p> <pre><code>$ wake-solc --version\nsolc, the solidity compiler commandline interface\nVersion: 0.8.15+commit.e14f2714.Linux.g++\n</code></pre> <p>Info</p> <p>solc binaries are downloaded from the Solidity repository which limits the minimum version of solc that can be installed.</p>"},{"location":"solc-version-manager/#commands","title":"Commands","text":"<p>All the listed commands are available under the <code>wake svm</code> subcommand (e.g. <code>wake svm list</code>).</p> Command Description Options <code>install</code> Install the target version of solc. A version range may be provided which results into installation of the latest version matching the range (i.e. <code>wake svm install 0.7</code> installs the version <code>0.7.6</code>). <code>--force</code> reinstall the version even if already installed.<code>--all</code> install all versions matching the target range. <code>list</code> List installed versions of solc. <code>--all</code> list all available versions instead. <code>remove</code> Remove the target installed version of solc. <code>--ignore-missing</code> do not raise an exception if the target  version is not installed. <code>switch</code> Change the selected version of solc to the target version. <code>use</code> Change the selected version of solc to the target version and install it if not already installed. A version range may be provided resulting into installation of the latest version matching the range. <code>--force</code> reinstall the version even if already installed."},{"location":"api-reference/analysis/cfg/","title":"cfg","text":""},{"location":"api-reference/analysis/cfg/#wake.analysis.cfg","title":"<code>wake.analysis.cfg</code>  <code>module</code>","text":""},{"location":"api-reference/analysis/cfg/#wake.analysis.cfg.TransitionConditionKind","title":"<code>TransitionConditionKind</code>  <code>class</code>","text":"<p>         Bases: <code>StrEnum</code></p> Source code in <code>wake/analysis/cfg.py</code> <pre><code>class TransitionConditionKind(StrEnum):\n    IS_TRUE = \"is true\"\n    \"\"\"\n    Associated expression evaluates to true.\n    \"\"\"\n    IS_FALSE = \"is false\"\n    \"\"\"\n    Associated expression evaluates to false.\n    \"\"\"\n    ALWAYS = \"always\"\n    \"\"\"\n    Transition is always taken.\n    \"\"\"\n    NEVER = \"never\"\n    \"\"\"\n    Transition is never taken.\n    \"\"\"\n    TRY_SUCCEEDED = \"try succeeded\"\n    \"\"\"\n    Try call succeeded.\n    \"\"\"\n    TRY_REVERTED = \"try reverted\"\n    \"\"\"\n    Try call reverted with a string reason.\n    \"\"\"\n    TRY_PANICKED = \"try panicked\"\n    \"\"\"\n    Try call panicked with an uint256 error code.\n    \"\"\"\n    TRY_FAILED = \"try failed\"\n    \"\"\"\n    Try call failed with a bytes memory reason.\n    \"\"\"\n    SWITCH_MATCHED = \"switch matched\"\n    \"\"\"\n    Yul switch case value matched the switch expression.\n    \"\"\"\n    SWITCH_DEFAULT = \"switch default\"\n    \"\"\"\n    None of the Yul switch case values matched the switch expression.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/analysis/cfg/#wake.analysis.cfg.TransitionConditionKind.IS_TRUE","title":"<code>IS_TRUE = 'is true'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Associated expression evaluates to true.</p>"},{"location":"api-reference/analysis/cfg/#wake.analysis.cfg.TransitionConditionKind.IS_FALSE","title":"<code>IS_FALSE = 'is false'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Associated expression evaluates to false.</p>"},{"location":"api-reference/analysis/cfg/#wake.analysis.cfg.TransitionConditionKind.ALWAYS","title":"<code>ALWAYS = 'always'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transition is always taken.</p>"},{"location":"api-reference/analysis/cfg/#wake.analysis.cfg.TransitionConditionKind.NEVER","title":"<code>NEVER = 'never'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transition is never taken.</p>"},{"location":"api-reference/analysis/cfg/#wake.analysis.cfg.TransitionConditionKind.TRY_SUCCEEDED","title":"<code>TRY_SUCCEEDED = 'try succeeded'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Try call succeeded.</p>"},{"location":"api-reference/analysis/cfg/#wake.analysis.cfg.TransitionConditionKind.TRY_REVERTED","title":"<code>TRY_REVERTED = 'try reverted'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Try call reverted with a string reason.</p>"},{"location":"api-reference/analysis/cfg/#wake.analysis.cfg.TransitionConditionKind.TRY_PANICKED","title":"<code>TRY_PANICKED = 'try panicked'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Try call panicked with an uint256 error code.</p>"},{"location":"api-reference/analysis/cfg/#wake.analysis.cfg.TransitionConditionKind.TRY_FAILED","title":"<code>TRY_FAILED = 'try failed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Try call failed with a bytes memory reason.</p>"},{"location":"api-reference/analysis/cfg/#wake.analysis.cfg.TransitionConditionKind.SWITCH_MATCHED","title":"<code>SWITCH_MATCHED = 'switch matched'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Yul switch case value matched the switch expression.</p>"},{"location":"api-reference/analysis/cfg/#wake.analysis.cfg.TransitionConditionKind.SWITCH_DEFAULT","title":"<code>SWITCH_DEFAULT = 'switch default'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>None of the Yul switch case values matched the switch expression.</p>"},{"location":"api-reference/analysis/cfg/#wake.analysis.cfg.ControlFlowGraph","title":"<code>ControlFlowGraph</code>  <code>class</code>","text":"<p>Control flow graph for a function or a modifier. Uses NetworkX DiGraph as the underlying data structure.</p> <p>Holds the following invariants:</p> <ul> <li>all nodes are of CfgNode type,</li> <li>start_node, success_end_node and revert_end_node are always present and empty (i.e. they contain no statements),</li> <li>all edges have a <code>condition</code> attribute holding a 2-item tuple:<ul> <li>the first item is a TransitionConditionKind enum value,</li> <li>the second item is an optional ExpressionAbc instance.</li> </ul> </li> </ul> <p>Tip</p> <p>The Tools for Solidity VS Code extension provides a visualizer for CFGs. The visualized CFGs are stripped of empty nodes, so they may slightly differ from the CFGs constructed by this class.</p> Source code in <code>wake/analysis/cfg.py</code> <pre><code>class ControlFlowGraph:\n    \"\"\"\n    Control flow graph for a function or a modifier. Uses NetworkX [DiGraph](https://networkx.org/documentation/stable/reference/classes/digraph.html) as the underlying data structure.\n\n    Holds the following invariants:\n\n    - all nodes are of [CfgNode][wake.analysis.cfg.CfgNode] type,\n    - [start_node][wake.analysis.cfg.ControlFlowGraph.start_node], [success_end_node][wake.analysis.cfg.ControlFlowGraph.success_end_node] and [revert_end_node][wake.analysis.cfg.ControlFlowGraph.revert_end_node] are always present and empty (i.e. they contain no statements),\n    - all edges have a `condition` attribute holding a 2-item tuple:\n        - the first item is a [TransitionConditionKind][wake.analysis.cfg.TransitionConditionKind] enum value,\n        - the second item is an optional [ExpressionAbc][wake.ir.expressions.abc.ExpressionAbc] instance.\n\n    !!! tip\n        The [Tools for Solidity](https://marketplace.visualstudio.com/items?itemName=AckeeBlockchain.tools-for-solidity) VS Code extension provides a visualizer for CFGs.\n        The visualized CFGs are stripped of empty nodes, so they may slightly differ from the CFGs constructed by this class.\n    \"\"\"\n\n    _graph: nx.DiGraph\n    _declaration: Union[FunctionDefinition, ModifierDefinition, YulFunctionDefinition]\n    _statements_lookup: Dict[Union[StatementAbc, YulStatementAbc], CfgNode]\n    _start_node: CfgNode\n    _success_end_node: CfgNode\n    _revert_end_node: CfgNode\n\n    def __init__(\n        self,\n        declaration: Union[\n            FunctionDefinition, ModifierDefinition, YulFunctionDefinition\n        ],\n    ):\n        if declaration.body is None:\n            raise ValueError(\"Function body is None.\")\n        self._declaration = declaration\n\n        self._graph = nx.DiGraph()\n        self._start_node = CfgNode()\n        self._graph.add_node(self._start_node)\n        next_node = CfgNode()\n        self._graph.add_node(next_node)\n        self._graph.add_edge(\n            self._start_node,\n            next_node,\n            condition=(TransitionConditionKind.ALWAYS, None),\n        )\n        self._success_end_node = CfgNode()\n        self._graph.add_node(self._success_end_node)\n        self._revert_end_node = CfgNode()\n        self._graph.add_node(self._revert_end_node)\n\n        tmp = CfgNode.from_statement(\n            self._graph,\n            next_node,\n            self._success_end_node,\n            self._revert_end_node,\n            None,\n            None,\n            declaration.body,\n        )\n        self._graph.add_edge(\n            tmp,\n            self._success_end_node,\n            condition=(TransitionConditionKind.ALWAYS, None),\n        )\n\n        while _normalize(\n            self._graph,\n            self._start_node,\n            self._success_end_node,\n            self._revert_end_node,\n        ):\n            pass\n\n        self._statements_lookup = {\n            stmt: node for node in self._graph.nodes for stmt in node.statements\n        }\n        for node in self._graph.nodes:\n            for stmt in node.statements:\n                self._statements_lookup[stmt] = node\n            if node.control_statement is not None:\n                self._statements_lookup[node.control_statement] = node\n\n    @property\n    def graph(self) -&gt; nx.DiGraph:\n        \"\"\"\n        Returns:\n            Read-only view of the underlying NetworkX DiGraph.\n        \"\"\"\n        return self._graph.copy(as_view=True)\n\n    @property\n    def declaration(\n        self,\n    ) -&gt; Union[FunctionDefinition, ModifierDefinition, YulFunctionDefinition]:\n        \"\"\"\n        Returns:\n            Function or modifier definition for which this CFG was constructed.\n        \"\"\"\n        return self._declaration\n\n    @property\n    def start_node(self) -&gt; CfgNode:\n        \"\"\"\n        Start node is guaranteed to be empty, i.e. it has no statements.\n\n        Returns:\n            Start node of this CFG, i.e. the node that is always executed first.\n        \"\"\"\n        return self._start_node\n\n    @property\n    def success_end_node(self) -&gt; CfgNode:\n        \"\"\"\n        Success end node is guaranteed to be empty, i.e. it has no statements.\n\n        Returns:\n            Success end node of this CFG, i.e. the node that is always executed last if the function or modifier does not revert.\n        \"\"\"\n        return self._success_end_node\n\n    @property\n    def revert_end_node(self) -&gt; CfgNode:\n        \"\"\"\n        Revert end node is guaranteed to be empty, i.e. it has no statements.\n\n        Returns:\n            Revert end node of this CFG, signaling that the function or modifier reverted under some condition.\n        \"\"\"\n        return self._revert_end_node\n\n    def get_cfg_node(self, statement: Union[StatementAbc, YulStatementAbc]) -&gt; CfgNode:\n        \"\"\"\n        Raises:\n            KeyError: If the given statement is not contained in this CFG or if the statement is of the\n                [Block][wake.ir.statements.block.Block], [UncheckedBlock][wake.ir.statements.unchecked_block.UncheckedBlock],\n                [YulBlock][wake.ir.yul.block.YulBlock] or [InlineAssembly][wake.ir.statements.inline_assembly.InlineAssembly] type.\n\n\n        [Block][wake.ir.statements.block.Block], [UncheckedBlock][wake.ir.statements.block.UncheckedBlock], [YulBlock][wake.ir.yul.block.YulBlock] and [InlineAssembly][wake.ir.statements.inline_assembly.InlineAssembly] statements\n        serve as containers for other statements and so may be contained in multiple CFG nodes. For this reason, a single [CfgNode][wake.analysis.cfg.CfgNode] cannot be returned for these statements.\n\n        Args:\n            statement: Statement for which to get the CFG node.\n\n        Returns:\n            CFG node that contains the given statement.\n        \"\"\"\n        return self._statements_lookup[statement]\n\n    def is_reachable(\n        self,\n        start: Union[StatementAbc, YulStatementAbc],\n        end: Union[StatementAbc, YulStatementAbc],\n    ) -&gt; bool:\n        \"\"\"\n        Returns False for `start == end` unless there is a loop in the CFG containing `start`.\n\n        Args:\n            start: Statement that is expected to be executed before `end`.\n            end: Statement that is expected to be executed after `start`.\n\n        Returns:\n            True if there is an execution path from `start` to `end` in this CFG, False otherwise.\n        \"\"\"\n        start_node = self._statements_lookup[start]\n        end_node = self._statements_lookup[end]\n        if start_node == end_node:\n            start_index = (\n                start_node.statements.index(start)\n                if start != start_node.control_statement\n                else len(start_node.statements)\n            )\n            end_index = (\n                end_node.statements.index(end)\n                if end != end_node.control_statement\n                else len(end_node.statements)\n            )\n            if start_index &lt; end_index:\n                return True\n\n            for _, to in nx.edge_dfs(self._graph, start_node):\n                if to == end_node:\n                    return True\n\n            return False\n        else:\n            return nx.has_path(self._graph, start_node, end_node)\n</code></pre>"},{"location":"api-reference/analysis/cfg/#wake.analysis.cfg.ControlFlowGraph.graph","title":"<code>graph: nx.DiGraph</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>DiGraph</code> <p>Read-only view of the underlying NetworkX DiGraph.</p>"},{"location":"api-reference/analysis/cfg/#wake.analysis.cfg.ControlFlowGraph.declaration","title":"<code>declaration: Union[FunctionDefinition, ModifierDefinition, YulFunctionDefinition]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[FunctionDefinition, ModifierDefinition, YulFunctionDefinition]</code> <p>Function or modifier definition for which this CFG was constructed.</p>"},{"location":"api-reference/analysis/cfg/#wake.analysis.cfg.ControlFlowGraph.start_node","title":"<code>start_node: CfgNode</code>  <code>property</code>","text":"<p>Start node is guaranteed to be empty, i.e. it has no statements.</p> <p>Returns:</p> Type Description <code>CfgNode</code> <p>Start node of this CFG, i.e. the node that is always executed first.</p>"},{"location":"api-reference/analysis/cfg/#wake.analysis.cfg.ControlFlowGraph.success_end_node","title":"<code>success_end_node: CfgNode</code>  <code>property</code>","text":"<p>Success end node is guaranteed to be empty, i.e. it has no statements.</p> <p>Returns:</p> Type Description <code>CfgNode</code> <p>Success end node of this CFG, i.e. the node that is always executed last if the function or modifier does not revert.</p>"},{"location":"api-reference/analysis/cfg/#wake.analysis.cfg.ControlFlowGraph.revert_end_node","title":"<code>revert_end_node: CfgNode</code>  <code>property</code>","text":"<p>Revert end node is guaranteed to be empty, i.e. it has no statements.</p> <p>Returns:</p> Type Description <code>CfgNode</code> <p>Revert end node of this CFG, signaling that the function or modifier reverted under some condition.</p>"},{"location":"api-reference/analysis/cfg/#wake.analysis.cfg.ControlFlowGraph.get_cfg_node","title":"<code>get_cfg_node(statement)</code>","text":"<p>Raises:</p> Type Description <code>KeyError</code> <p>If the given statement is not contained in this CFG or if the statement is of the Block, UncheckedBlock, YulBlock or InlineAssembly type.</p> <p>Block, UncheckedBlock, YulBlock and InlineAssembly statements serve as containers for other statements and so may be contained in multiple CFG nodes. For this reason, a single CfgNode cannot be returned for these statements.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Union[StatementAbc, YulStatementAbc]</code> <p>Statement for which to get the CFG node.</p> required <p>Returns:</p> Type Description <code>CfgNode</code> <p>CFG node that contains the given statement.</p> Source code in <code>wake/analysis/cfg.py</code> <pre><code>def get_cfg_node(self, statement: Union[StatementAbc, YulStatementAbc]) -&gt; CfgNode:\n    \"\"\"\n    Raises:\n        KeyError: If the given statement is not contained in this CFG or if the statement is of the\n            [Block][wake.ir.statements.block.Block], [UncheckedBlock][wake.ir.statements.unchecked_block.UncheckedBlock],\n            [YulBlock][wake.ir.yul.block.YulBlock] or [InlineAssembly][wake.ir.statements.inline_assembly.InlineAssembly] type.\n\n\n    [Block][wake.ir.statements.block.Block], [UncheckedBlock][wake.ir.statements.block.UncheckedBlock], [YulBlock][wake.ir.yul.block.YulBlock] and [InlineAssembly][wake.ir.statements.inline_assembly.InlineAssembly] statements\n    serve as containers for other statements and so may be contained in multiple CFG nodes. For this reason, a single [CfgNode][wake.analysis.cfg.CfgNode] cannot be returned for these statements.\n\n    Args:\n        statement: Statement for which to get the CFG node.\n\n    Returns:\n        CFG node that contains the given statement.\n    \"\"\"\n    return self._statements_lookup[statement]\n</code></pre>"},{"location":"api-reference/analysis/cfg/#wake.analysis.cfg.ControlFlowGraph.is_reachable","title":"<code>is_reachable(start, end)</code>","text":"<p>Returns False for <code>start == end</code> unless there is a loop in the CFG containing <code>start</code>.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Union[StatementAbc, YulStatementAbc]</code> <p>Statement that is expected to be executed before <code>end</code>.</p> required <code>end</code> <code>Union[StatementAbc, YulStatementAbc]</code> <p>Statement that is expected to be executed after <code>start</code>.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if there is an execution path from <code>start</code> to <code>end</code> in this CFG, False otherwise.</p> Source code in <code>wake/analysis/cfg.py</code> <pre><code>def is_reachable(\n    self,\n    start: Union[StatementAbc, YulStatementAbc],\n    end: Union[StatementAbc, YulStatementAbc],\n) -&gt; bool:\n    \"\"\"\n    Returns False for `start == end` unless there is a loop in the CFG containing `start`.\n\n    Args:\n        start: Statement that is expected to be executed before `end`.\n        end: Statement that is expected to be executed after `start`.\n\n    Returns:\n        True if there is an execution path from `start` to `end` in this CFG, False otherwise.\n    \"\"\"\n    start_node = self._statements_lookup[start]\n    end_node = self._statements_lookup[end]\n    if start_node == end_node:\n        start_index = (\n            start_node.statements.index(start)\n            if start != start_node.control_statement\n            else len(start_node.statements)\n        )\n        end_index = (\n            end_node.statements.index(end)\n            if end != end_node.control_statement\n            else len(end_node.statements)\n        )\n        if start_index &lt; end_index:\n            return True\n\n        for _, to in nx.edge_dfs(self._graph, start_node):\n            if to == end_node:\n                return True\n\n        return False\n    else:\n        return nx.has_path(self._graph, start_node, end_node)\n</code></pre>"},{"location":"api-reference/analysis/cfg/#wake.analysis.cfg.CfgNode","title":"<code>CfgNode</code>  <code>class</code>","text":"<p>Basic building block of a control flow graph. Holds a list of statements and an optional control statement that is always executed last (if set). Solidity and Yul statements may be mixed in the same CFG node.</p> Source code in <code>wake/analysis/cfg.py</code> <pre><code>class CfgNode:\n    \"\"\"\n    Basic building block of a control flow graph. Holds a list of statements and an optional control statement that is always\n    executed last (if set). Solidity and Yul statements may be mixed in the same CFG node.\n    \"\"\"\n\n    _id_counter: int = 0\n    _id: int\n    _statements: List[Union[StatementAbc, YulStatementAbc]]\n    # control statement is always the last statement\n    _control_statement: Optional[\n        Union[\n            DoWhileStatement,\n            ForStatement,\n            IfStatement,\n            TryStatement,\n            WhileStatement,\n            YulForLoop,\n            YulIf,\n            YulSwitch,\n        ]\n    ]\n\n    def __init__(self):\n        self._id = self.__class__._id_counter\n        self.__class__._id_counter += 1\n        self._statements = []\n        self._control_statement = None\n\n    def __str__(self):\n        return (\n            \"\\n\".join(statement.source for statement in self.statements)\n            if len(self.statements) &gt; 0\n            else \"\"\n        )\n\n    @property\n    def id(self) -&gt; int:\n        \"\"\"\n        The concrete value should not be relied upon, it is only guaranteed to be unique within a single CFG.\n\n        Returns:\n            Unique ID of this CFG node.\n        \"\"\"\n        return self._id\n\n    @property\n    def statements(self) -&gt; Tuple[Union[StatementAbc, YulStatementAbc], ...]:\n        \"\"\"\n        Returns:\n            Statements contained in this CFG node.\n        \"\"\"\n        return tuple(self._statements)\n\n    @property\n    def control_statement(\n        self,\n    ) -&gt; Optional[\n        Union[\n            DoWhileStatement,\n            ForStatement,\n            IfStatement,\n            TryStatement,\n            WhileStatement,\n            YulForLoop,\n            YulIf,\n            YulSwitch,\n        ]\n    ]:\n        \"\"\"\n        Control statements are handled specially in CFG construction, because they contain sub-statements that are not\n        part of the current CFG node. At the same time, control statements are always nearest parent statements for\n        some expressions and so must be indexed.\n\n        !!! example\n            For example, [IfStatement][wake.ir.statements.if_statement.IfStatement] is the nearest parent statement\n            of the [IfStatement.condition][wake.ir.statements.if_statement.IfStatement.condition] expression.\n\n        A control statement is always the last statement in a CFG node.\n\n        Returns:\n            Control statement of this CFG node, if any.\n        \"\"\"\n        return self._control_statement\n\n    @classmethod\n    def from_statement(\n        cls,\n        graph: nx.DiGraph,\n        prev: CfgNode,\n        success_end: CfgNode,\n        revert_end: CfgNode,\n        loop_body_post: Optional[CfgNode],\n        loop_body_next: Optional[CfgNode],\n        statement: Union[StatementAbc, YulStatementAbc],\n    ) -&gt; CfgNode:\n        if isinstance(statement, (Block, UncheckedBlock, YulBlock)):\n            for body_statement in statement.statements:\n                prev = cls.from_statement(\n                    graph,\n                    prev,\n                    success_end,\n                    revert_end,\n                    loop_body_post,\n                    loop_body_next,\n                    body_statement,\n                )\n            return prev\n        elif isinstance(statement, InlineAssembly):\n            return cls.from_statement(\n                graph,\n                prev,\n                success_end,\n                revert_end,\n                loop_body_post,\n                loop_body_next,\n                statement.yul_block,\n            )\n        elif (\n            isinstance(statement, YulExpressionStatement)\n            and isinstance(statement.expression, YulFunctionCall)\n            and statement.expression.function_name.name == \"revert\"\n        ):\n            prev._statements.append(statement)\n            next = CfgNode()\n            graph.add_node(next)\n            graph.add_edge(\n                prev, revert_end, condition=(TransitionConditionKind.ALWAYS, None)\n            )\n            graph.add_edge(prev, next, condition=(TransitionConditionKind.NEVER, None))\n            return next\n        elif (\n            isinstance(statement, YulExpressionStatement)\n            and isinstance(statement.expression, YulFunctionCall)\n            and statement.expression.function_name.name == \"return\"\n        ):\n            prev._statements.append(statement)\n            next = CfgNode()\n            graph.add_node(next)\n            graph.add_edge(\n                prev, success_end, condition=(TransitionConditionKind.ALWAYS, None)\n            )\n            graph.add_edge(prev, next, condition=(TransitionConditionKind.NEVER, None))\n            return next\n        elif isinstance(statement, (Break, YulBreak)):\n            prev._statements.append(statement)\n            next = CfgNode()\n            assert loop_body_next is not None\n            graph.add_node(next)\n            graph.add_edge(\n                prev, loop_body_next, condition=(TransitionConditionKind.ALWAYS, None)\n            )\n            graph.add_edge(prev, next, condition=(TransitionConditionKind.NEVER, None))\n            return next\n        elif isinstance(statement, (Continue, YulContinue)):\n            prev._statements.append(statement)\n            next = CfgNode()\n            assert loop_body_post is not None\n            graph.add_node(next)\n            graph.add_edge(\n                prev, loop_body_post, condition=(TransitionConditionKind.ALWAYS, None)\n            )\n            graph.add_edge(prev, next, condition=(TransitionConditionKind.NEVER, None))\n            return next\n        elif isinstance(statement, DoWhileStatement):\n            return cls.from_do_while_statement(\n                graph, prev, success_end, revert_end, statement\n            )\n        elif isinstance(statement, ForStatement):\n            return cls.from_for_statement(\n                graph, prev, success_end, revert_end, statement\n            )\n        elif isinstance(statement, IfStatement):\n            return cls.from_if_statement(\n                graph,\n                prev,\n                success_end,\n                revert_end,\n                loop_body_post,\n                loop_body_next,\n                statement,\n            )\n        elif isinstance(statement, (Return, YulLeave)):\n            prev._statements.append(statement)\n            next = CfgNode()\n            graph.add_node(next)\n            graph.add_edge(\n                prev, success_end, condition=(TransitionConditionKind.ALWAYS, None)\n            )\n            graph.add_edge(prev, next, condition=(TransitionConditionKind.NEVER, None))\n            return next\n        elif isinstance(statement, RevertStatement):\n            prev._statements.append(statement)\n            next = CfgNode()\n            graph.add_node(next)\n            graph.add_edge(\n                prev, revert_end, condition=(TransitionConditionKind.ALWAYS, None)\n            )\n            graph.add_edge(prev, next, condition=(TransitionConditionKind.NEVER, None))\n            return next\n        elif isinstance(statement, ExpressionStatement):\n\n            def process_expression(expression: ExpressionAbc, node: CfgNode) -&gt; bool:\n                if isinstance(expression, Conditional):\n                    true_node = CfgNode()\n                    graph.add_node(true_node)\n                    false_node = CfgNode()\n                    graph.add_node(false_node)\n\n                    graph.add_edge(\n                        node,\n                        true_node,\n                        condition=(\n                            TransitionConditionKind.IS_TRUE,\n                            expression.condition,\n                        ),\n                    )\n                    graph.add_edge(\n                        node,\n                        false_node,\n                        condition=(\n                            TransitionConditionKind.IS_FALSE,\n                            expression.condition,\n                        ),\n                    )\n\n                    true_is_control = process_expression(\n                        expression.true_expression, true_node\n                    )\n                    false_is_control = process_expression(\n                        expression.false_expression, false_node\n                    )\n\n                    if not true_is_control:\n                        graph.remove_node(true_node)\n                        if false_is_control:\n                            graph.add_edge(\n                                node,\n                                next,\n                                condition=(\n                                    TransitionConditionKind.IS_TRUE,\n                                    expression.condition,\n                                ),\n                            )\n\n                    if not false_is_control:\n                        graph.remove_node(false_node)\n                        if true_is_control:\n                            graph.add_edge(\n                                node,\n                                next,\n                                condition=(\n                                    TransitionConditionKind.IS_FALSE,\n                                    expression.condition,\n                                ),\n                            )\n\n                    return true_is_control or false_is_control\n                elif isinstance(expression, FunctionCall):\n                    func_called = expression.function_called\n                    if func_called == GlobalSymbol.REVERT:\n                        graph.add_edge(\n                            node,\n                            revert_end,\n                            condition=(TransitionConditionKind.ALWAYS, None),\n                        )\n                        graph.add_edge(\n                            node, next, condition=(TransitionConditionKind.NEVER, None)\n                        )\n                        return True\n                    elif func_called in {\n                        GlobalSymbol.REQUIRE,\n                        GlobalSymbol.ASSERT,\n                    }:\n                        graph.add_edge(\n                            node,\n                            next,\n                            condition=(\n                                TransitionConditionKind.IS_TRUE,\n                                expression.arguments[0],\n                            ),\n                        )\n                        graph.add_edge(\n                            node,\n                            revert_end,\n                            condition=(\n                                TransitionConditionKind.IS_FALSE,\n                                expression.arguments[0],\n                            ),\n                        )\n                        return True\n                    else:\n                        return False\n                else:\n                    return False\n\n            prev._statements.append(statement)\n            next = CfgNode()\n            graph.add_node(next)\n\n            if process_expression(\n                statement.expression,  # pyright: ignore reportArgumentType\n                prev,\n            ):\n                return next\n            else:\n                graph.remove_node(next)\n                return prev\n        elif isinstance(statement, TryStatement):\n            return cls.from_try_statement(\n                graph,\n                prev,\n                success_end,\n                revert_end,\n                loop_body_post,\n                loop_body_next,\n                statement,\n            )\n        elif isinstance(statement, WhileStatement):\n            return cls.from_while_statement(\n                graph, prev, success_end, revert_end, statement\n            )\n        elif isinstance(statement, YulCase):\n            raise NotImplementedError()  # should be handled by YulSwitch\n        elif isinstance(statement, YulForLoop):\n            return cls.from_yul_for_loop(\n                graph, prev, success_end, revert_end, statement\n            )\n        elif isinstance(statement, YulIf):\n            return cls.from_yul_if(\n                graph,\n                prev,\n                success_end,\n                revert_end,\n                loop_body_post,\n                loop_body_next,\n                statement,\n            )\n        elif isinstance(statement, YulSwitch):\n            return cls.from_yul_switch(graph, prev, success_end, revert_end, statement)\n        else:\n            prev._statements.append(statement)\n            return prev\n\n    @classmethod\n    def from_if_statement(\n        cls,\n        graph: nx.DiGraph,\n        prev: CfgNode,\n        success_end: CfgNode,\n        revert_end: CfgNode,\n        loop_body_post: Optional[CfgNode],\n        loop_body_next: Optional[CfgNode],\n        if_statement: IfStatement,\n    ) -&gt; CfgNode:\n        assert prev._control_statement is None\n        prev._control_statement = if_statement\n        true_node = CfgNode()\n        graph.add_node(true_node)\n        true_node_end = cls.from_statement(\n            graph,\n            true_node,\n            success_end,\n            revert_end,\n            loop_body_post,\n            loop_body_next,\n            if_statement.true_body,\n        )\n\n        false_node = CfgNode()\n        graph.add_node(false_node)\n\n        if if_statement.false_body is None:\n            false_node_end = false_node\n        else:\n            false_node_end = cls.from_statement(\n                graph,\n                false_node,\n                success_end,\n                revert_end,\n                loop_body_post,\n                loop_body_next,\n                if_statement.false_body,\n            )\n\n        next = CfgNode()\n        graph.add_node(next)\n        graph.add_edge(\n            prev,\n            true_node,\n            condition=(TransitionConditionKind.IS_TRUE, if_statement.condition),\n        )\n        graph.add_edge(\n            prev,\n            false_node,\n            condition=(TransitionConditionKind.IS_FALSE, if_statement.condition),\n        )\n        graph.add_edge(\n            true_node_end, next, condition=(TransitionConditionKind.ALWAYS, None)\n        )\n        graph.add_edge(\n            false_node_end, next, condition=(TransitionConditionKind.ALWAYS, None)\n        )\n        return next\n\n    @classmethod\n    def from_yul_if(\n        cls,\n        graph: nx.DiGraph,\n        prev: CfgNode,\n        success_end: CfgNode,\n        revert_end: CfgNode,\n        loop_body_post: Optional[CfgNode],\n        loop_body_next: Optional[CfgNode],\n        if_statement: YulIf,\n    ):\n        assert prev._control_statement is None\n        prev._control_statement = if_statement\n        true_node = CfgNode()\n        graph.add_node(true_node)\n        true_node_end = cls.from_statement(\n            graph,\n            true_node,\n            success_end,\n            revert_end,\n            loop_body_post,\n            loop_body_next,\n            if_statement.body,\n        )\n        next = CfgNode()\n        graph.add_node(next)\n        graph.add_edge(\n            prev,\n            true_node,\n            condition=(TransitionConditionKind.IS_TRUE, if_statement.condition),\n        )\n        graph.add_edge(\n            prev,\n            next,\n            condition=(TransitionConditionKind.IS_FALSE, if_statement.condition),\n        )\n        graph.add_edge(\n            true_node_end, next, condition=(TransitionConditionKind.ALWAYS, None)\n        )\n        return next\n\n    @classmethod\n    def from_do_while_statement(\n        cls,\n        graph: nx.DiGraph,\n        prev: CfgNode,\n        success_end: CfgNode,\n        revert_end: CfgNode,\n        do_while_statement: DoWhileStatement,\n    ) -&gt; CfgNode:\n        body = CfgNode()\n        graph.add_node(body)\n        next = CfgNode()\n        graph.add_node(next)\n        body_end = cls.from_statement(\n            graph, body, success_end, revert_end, body, next, do_while_statement.body\n        )\n        assert body_end._control_statement is None\n        body_end._control_statement = do_while_statement\n\n        graph.add_edge(prev, body, condition=(TransitionConditionKind.ALWAYS, None))\n        graph.add_edge(\n            body_end,\n            next,\n            condition=(TransitionConditionKind.IS_FALSE, do_while_statement.condition),\n        )\n        graph.add_edge(\n            body_end,\n            body,\n            condition=(TransitionConditionKind.IS_TRUE, do_while_statement.condition),\n        )\n        return next\n\n    @classmethod\n    def from_for_statement(\n        cls,\n        graph: nx.DiGraph,\n        prev: CfgNode,\n        success_end: CfgNode,\n        revert_end: CfgNode,\n        for_statement: ForStatement,\n    ) -&gt; CfgNode:\n        if for_statement.initialization_expression is not None:\n            prev = cls.from_statement(\n                graph,\n                prev,\n                success_end,\n                revert_end,\n                None,\n                None,\n                for_statement.initialization_expression,\n            )\n        assert prev._control_statement is None\n        prev._control_statement = for_statement\n\n        body = CfgNode()\n        graph.add_node(body)\n        next = CfgNode()\n        graph.add_node(next)\n        loop_post = CfgNode()\n        graph.add_node(loop_post)\n        if for_statement.loop_expression is not None:\n            loop_post_end = cls.from_statement(\n                graph,\n                loop_post,\n                success_end,\n                revert_end,\n                loop_post,\n                next,\n                for_statement.loop_expression,\n            )\n        else:\n            loop_post_end = loop_post\n        body_end = cls.from_statement(\n            graph, body, success_end, revert_end, loop_post, next, for_statement.body\n        )\n\n        graph.add_edge(\n            body_end, loop_post, condition=(TransitionConditionKind.ALWAYS, None)\n        )\n        graph.add_edge(\n            prev,\n            body,\n            condition=(TransitionConditionKind.IS_TRUE, for_statement.condition),\n        )\n        graph.add_edge(\n            prev,\n            next,\n            condition=(TransitionConditionKind.IS_FALSE, for_statement.condition),\n        )\n        graph.add_edge(\n            loop_post_end,\n            body,\n            condition=(TransitionConditionKind.IS_TRUE, for_statement.condition),\n        )\n        graph.add_edge(\n            loop_post_end,\n            next,\n            condition=(TransitionConditionKind.IS_FALSE, for_statement.condition),\n        )\n        return next\n\n    @classmethod\n    def from_yul_for_loop(\n        cls,\n        graph: nx.DiGraph,\n        prev: CfgNode,\n        success_end: CfgNode,\n        revert_end: CfgNode,\n        for_loop: YulForLoop,\n    ) -&gt; CfgNode:\n        assert prev._control_statement is None\n        prev = cls.from_statement(\n            graph, prev, success_end, revert_end, None, None, for_loop.pre\n        )\n        assert prev._control_statement is None\n        prev._control_statement = for_loop\n\n        body = CfgNode()\n        graph.add_node(body)\n        next = CfgNode()\n        graph.add_node(next)\n        loop_post = CfgNode()\n        graph.add_node(loop_post)\n        body_end = cls.from_statement(\n            graph, body, success_end, revert_end, loop_post, next, for_loop.body\n        )\n        loop_post_end = cls.from_statement(\n            graph, loop_post, success_end, revert_end, loop_post, next, for_loop.post\n        )\n\n        graph.add_edge(\n            body_end, loop_post, condition=(TransitionConditionKind.ALWAYS, None)\n        )\n        graph.add_edge(\n            prev, body, condition=(TransitionConditionKind.IS_TRUE, for_loop.condition)\n        )\n        graph.add_edge(\n            prev,\n            next,\n            condition=(TransitionConditionKind.IS_FALSE, for_loop.condition),\n        )\n        graph.add_edge(\n            loop_post_end,\n            body,\n            condition=(TransitionConditionKind.IS_TRUE, for_loop.condition),\n        )\n        graph.add_edge(\n            loop_post_end,\n            next,\n            condition=(TransitionConditionKind.IS_FALSE, for_loop.condition),\n        )\n        return next\n\n    @classmethod\n    def from_try_statement(\n        cls,\n        graph: nx.DiGraph,\n        prev: CfgNode,\n        success_end: CfgNode,\n        revert_end: CfgNode,\n        loop_body_post: Optional[CfgNode],\n        loop_body_next: Optional[CfgNode],\n        try_statement: TryStatement,\n    ) -&gt; CfgNode:\n        assert prev._control_statement is None\n        prev._control_statement = try_statement\n\n        success_node = CfgNode()\n        graph.add_node(success_node)\n        success_node_end = cls.from_statement(\n            graph,\n            success_node,\n            success_end,\n            revert_end,\n            loop_body_post,\n            loop_body_next,\n            try_statement.clauses[0].block,\n        )\n\n        revert_node = None\n        revert_node_end = None\n        panic_node = None\n        panic_node_end = None\n        fail_node = None\n        fail_node_end = None\n        for clause in try_statement.clauses[1:]:\n            if clause.error_name == \"Error\":\n                revert_node = CfgNode()\n                graph.add_node(revert_node)\n                revert_node_end = cls.from_statement(\n                    graph,\n                    revert_node,\n                    success_end,\n                    revert_end,\n                    loop_body_post,\n                    loop_body_next,\n                    clause.block,\n                )\n            elif clause.error_name == \"Panic\":\n                panic_node = CfgNode()\n                graph.add_node(panic_node)\n                panic_node_end = cls.from_statement(\n                    graph,\n                    panic_node,\n                    success_end,\n                    revert_end,\n                    loop_body_post,\n                    loop_body_next,\n                    clause.block,\n                )\n            elif clause.error_name == \"\":\n                fail_node = CfgNode()\n                graph.add_node(fail_node)\n                fail_node_end = cls.from_statement(\n                    graph,\n                    fail_node,\n                    success_end,\n                    revert_end,\n                    loop_body_post,\n                    loop_body_next,\n                    clause.block,\n                )\n            else:\n                raise NotImplementedError(f\"Unknown error name: {clause.error_name}\")\n\n        next = CfgNode()\n        graph.add_node(next)\n\n        graph.add_edge(\n            prev,\n            success_node,\n            condition=(\n                TransitionConditionKind.TRY_SUCCEEDED,\n                try_statement.external_call,\n            ),\n        )\n        graph.add_edge(\n            success_node_end, next, condition=(TransitionConditionKind.ALWAYS, None)\n        )\n        if revert_node is not None:\n            graph.add_edge(\n                prev,\n                revert_node,\n                condition=(\n                    TransitionConditionKind.TRY_REVERTED,\n                    try_statement.external_call,\n                ),\n            )\n            graph.add_edge(\n                revert_node_end, next, condition=(TransitionConditionKind.ALWAYS, None)\n            )\n        if panic_node is not None:\n            graph.add_edge(\n                prev,\n                panic_node,\n                condition=(\n                    TransitionConditionKind.TRY_PANICKED,\n                    try_statement.external_call,\n                ),\n            )\n            graph.add_edge(\n                panic_node_end, next, condition=(TransitionConditionKind.ALWAYS, None)\n            )\n        if fail_node is not None:\n            graph.add_edge(\n                prev,\n                fail_node,\n                condition=(\n                    TransitionConditionKind.TRY_FAILED,\n                    try_statement.external_call,\n                ),\n            )\n            graph.add_edge(\n                fail_node_end, next, condition=(TransitionConditionKind.ALWAYS, None)\n            )\n        else:\n            graph.add_edge(\n                prev,\n                revert_end,\n                condition=(\n                    TransitionConditionKind.TRY_FAILED,\n                    try_statement.external_call,\n                ),\n            )\n        return next\n\n    @classmethod\n    def from_yul_switch(\n        cls,\n        graph: nx.DiGraph,\n        prev: CfgNode,\n        success_end: CfgNode,\n        revert_end: CfgNode,\n        switch: YulSwitch,\n    ) -&gt; CfgNode:\n        assert prev._control_statement is None\n        prev._control_statement = switch\n\n        next = CfgNode()\n        graph.add_node(next)\n\n        for case_ in switch.cases:\n            case_node = CfgNode()\n            graph.add_node(case_node)\n            graph.add_edge(\n                prev,\n                case_node,\n                condition=(TransitionConditionKind.SWITCH_MATCHED, case_.value)\n                if case_.value != \"default\"\n                else (TransitionConditionKind.SWITCH_DEFAULT, None),\n            )\n            case_node_end = cls.from_statement(\n                graph,\n                case_node,\n                success_end,\n                revert_end,\n                case_node,\n                next,\n                case_.body,\n            )\n            graph.add_edge(\n                case_node_end, next, condition=(TransitionConditionKind.ALWAYS, None)\n            )\n\n        if not any(case.value == \"default\" for case in switch.cases):\n            graph.add_edge(\n                prev,\n                next,\n                condition=(TransitionConditionKind.SWITCH_DEFAULT, None),\n            )\n\n        return next\n\n    @classmethod\n    def from_while_statement(\n        cls,\n        graph: nx.DiGraph,\n        prev: CfgNode,\n        success_end: CfgNode,\n        revert_end: CfgNode,\n        while_statement: WhileStatement,\n    ) -&gt; CfgNode:\n        assert prev._control_statement is None\n        prev._control_statement = while_statement\n\n        body = CfgNode()\n        graph.add_node(body)\n        next = CfgNode()\n        graph.add_node(next)\n        body_end = cls.from_statement(\n            graph, body, success_end, revert_end, body, next, while_statement.body\n        )\n\n        graph.add_edge(\n            prev,\n            body,\n            condition=(TransitionConditionKind.IS_TRUE, while_statement.condition),\n        )\n        graph.add_edge(\n            prev,\n            next,\n            condition=(TransitionConditionKind.IS_FALSE, while_statement.condition),\n        )\n        graph.add_edge(\n            body_end,\n            body,\n            condition=(TransitionConditionKind.IS_TRUE, while_statement.condition),\n        )\n        graph.add_edge(\n            body_end,\n            next,\n            condition=(TransitionConditionKind.IS_FALSE, while_statement.condition),\n        )\n        return next\n</code></pre>"},{"location":"api-reference/analysis/cfg/#wake.analysis.cfg.CfgNode.id","title":"<code>id: int</code>  <code>property</code>","text":"<p>The concrete value should not be relied upon, it is only guaranteed to be unique within a single CFG.</p> <p>Returns:</p> Type Description <code>int</code> <p>Unique ID of this CFG node.</p>"},{"location":"api-reference/analysis/cfg/#wake.analysis.cfg.CfgNode.statements","title":"<code>statements: Tuple[Union[StatementAbc, YulStatementAbc], ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[Union[StatementAbc, YulStatementAbc], ...]</code> <p>Statements contained in this CFG node.</p>"},{"location":"api-reference/analysis/cfg/#wake.analysis.cfg.CfgNode.control_statement","title":"<code>control_statement: Optional[Union[DoWhileStatement, ForStatement, IfStatement, TryStatement, WhileStatement, YulForLoop, YulIf, YulSwitch]]</code>  <code>property</code>","text":"<p>Control statements are handled specially in CFG construction, because they contain sub-statements that are not part of the current CFG node. At the same time, control statements are always nearest parent statements for some expressions and so must be indexed.</p> <p>Example</p> <p>For example, IfStatement is the nearest parent statement of the IfStatement.condition expression.</p> <p>A control statement is always the last statement in a CFG node.</p> <p>Returns:</p> Type Description <code>Optional[Union[DoWhileStatement, ForStatement, IfStatement, TryStatement, WhileStatement, YulForLoop, YulIf, YulSwitch]]</code> <p>Control statement of this CFG node, if any.</p>"},{"location":"api-reference/analysis/utils/","title":"utils","text":""},{"location":"api-reference/analysis/utils/#wake.analysis.utils","title":"<code>wake.analysis.utils</code>  <code>module</code>","text":""},{"location":"api-reference/analysis/utils/#wake.analysis.utils.get_all_base_and_child_declarations","title":"<code>get_all_base_and_child_declarations(declaration, *, base=True, child=True)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>declaration</code> <code>Union[FunctionDefinition, ModifierDefinition, VariableDeclaration]</code> <p>Declaration to get base and child declarations of.</p> required <code>base</code> <code>bool</code> <p>Return base declarations of the given declaration.</p> <code>True</code> <code>child</code> <code>bool</code> <p>Return child declarations of the given declaration.</p> <code>True</code> <p>Returns:</p> Type Description <code>Union[Set[Union[FunctionDefinition, VariableDeclaration]], Set[ModifierDefinition]]</code> <p>Recursively all base and child declarations of the given declaration plus the given declaration itself.</p> <p>Set of ModifierDefinitions is returned for ModifierDefinition input, otherwise set of FunctionDefinitions and VariableDeclarations is returned.</p> Source code in <code>wake/analysis/utils.py</code> <pre><code>def get_all_base_and_child_declarations(\n    declaration: Union[FunctionDefinition, ModifierDefinition, VariableDeclaration],\n    *,\n    base: bool = True,\n    child: bool = True,\n) -&gt; Union[\n    Set[Union[FunctionDefinition, VariableDeclaration]], Set[ModifierDefinition]\n]:\n    \"\"\"\n    Args:\n        declaration: Declaration to get base and child declarations of.\n        base: Return base declarations of the given declaration.\n        child: Return child declarations of the given declaration.\n\n    Returns:\n        Recursively all base and child declarations of the given declaration plus the given declaration itself.\n\n            Set of [ModifierDefinitions][wake.ir.declarations.modifier_definition.ModifierDefinition] is returned for [ModifierDefinition][wake.ir.declarations.modifier_definition.ModifierDefinition] input,\n            otherwise set of [FunctionDefinitions][wake.ir.declarations.function_definition.FunctionDefinition] and [VariableDeclarations][wake.ir.declarations.variable_declaration.VariableDeclaration] is returned.\n    \"\"\"\n    ret = {declaration}\n    queue: Deque[\n        Union[FunctionDefinition, ModifierDefinition, VariableDeclaration]\n    ] = deque([declaration])\n\n    while len(queue) &gt; 0:\n        declaration = queue.popleft()\n\n        if isinstance(declaration, VariableDeclaration):\n            for base_func in declaration.base_functions:\n                if base and base_func not in ret:\n                    ret.add(base_func)\n                    queue.append(base_func)\n        elif isinstance(declaration, FunctionDefinition):\n            for base_func in declaration.base_functions:\n                if base and base_func not in ret:\n                    ret.add(base_func)\n                    queue.append(base_func)\n            for child_func in declaration.child_functions:\n                if child and child_func not in ret:\n                    ret.add(child_func)\n                    queue.append(child_func)\n        elif isinstance(declaration, ModifierDefinition):\n            for base_mod in declaration.base_modifiers:\n                if base and base_mod not in ret:\n                    ret.add(base_mod)\n                    queue.append(base_mod)\n            for child_mod in declaration.child_modifiers:\n                if child and child_mod not in ret:\n                    ret.add(child_mod)\n                    queue.append(child_mod)\n    return ret  # pyright: ignore reportGeneralTypeIssues\n</code></pre>"},{"location":"api-reference/analysis/utils/#wake.analysis.utils.get_function_implementations","title":"<code>get_function_implementations(function, *, variables=True)</code>","text":"<p>Also returns the given function if it is implemented.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>FunctionDefinition</code> <p>Function to get implementations of.</p> required <code>variables</code> <code>bool</code> <p>Include variable declarations in the returned set.</p> <code>True</code> <p>Returns:</p> Type Description <code>Set[Union[FunctionDefinition, VariableDeclaration]]</code> <p>All overridden implemented functions and variable declarations of the given function.</p> Source code in <code>wake/analysis/utils.py</code> <pre><code>def get_function_implementations(  # pyright: ignore reportGeneralTypeIssues\n    function: FunctionDefinition,\n    *,\n    variables: bool = True,\n) -&gt; Set[Union[FunctionDefinition, VariableDeclaration]]:\n    \"\"\"\n    Also returns the given function if it is implemented.\n\n    Args:\n        function: Function to get implementations of.\n        variables: Include variable declarations in the returned set.\n\n    Returns:\n        All overridden implemented functions and variable declarations of the given function.\n    \"\"\"\n    ret = set()\n\n    for child in get_all_base_and_child_declarations(function, base=False):\n        if isinstance(child, VariableDeclaration):\n            if variables:\n                ret.add(child)\n        else:\n            if child.implemented:\n                ret.add(child)\n\n    return ret  # pyright: ignore reportGeneralTypeIssues\n</code></pre>"},{"location":"api-reference/analysis/utils/#wake.analysis.utils.get_modifier_implementations","title":"<code>get_modifier_implementations(modifier)</code>","text":"<p>Also returns the given modifier if it is implemented.</p> <p>Parameters:</p> Name Type Description Default <code>modifier</code> <code>ModifierDefinition</code> <p>Modifier to get implementations of.</p> required <p>Returns:</p> Type Description <code>Set[ModifierDefinition]</code> <p>All overridden implemented modifiers of the given modifier.</p> Source code in <code>wake/analysis/utils.py</code> <pre><code>def get_modifier_implementations(\n    modifier: ModifierDefinition,\n) -&gt; Set[ModifierDefinition]:\n    \"\"\"\n    Also returns the given modifier if it is implemented.\n\n    Args:\n        modifier: Modifier to get implementations of.\n\n    Returns:\n        All overridden implemented modifiers of the given modifier.\n    \"\"\"\n    ret = set()\n\n    for child in get_all_base_and_child_declarations(modifier, base=False):\n        if child.implemented:\n            ret.add(child)\n\n    return ret\n</code></pre>"},{"location":"api-reference/analysis/utils/#wake.analysis.utils.pair_function_call_arguments","title":"<code>pair_function_call_arguments(definition, call)</code>","text":"<p>Pairs function call arguments with error/event/function/struct definition parameters. Returned pairs are in the same order as the definition parameters/members.</p> <p>Example</p> <p>The function also handles calls of bounded functions with the <code>using for</code> directive.</p> <pre><code>contract C {\n    using SafeERC20 for IERC20;\n\n    function withdraw(IERC20 token, uint256 amount) external {\n        token.safeTransfer(msg.sender, amount); // token is the first argument of safeTransfer\n    }\n}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>definition</code> <code>Union[ErrorDefinition, EventDefinition, FunctionDefinition, StructDefinition]</code> <p>Definition called.</p> required <code>call</code> <code>FunctionCall</code> <p>Function call or struct constructor call.</p> required <p>Returns:</p> Type Description <code>Tuple[Tuple[VariableDeclaration, ExpressionAbc], ...]</code> <p>Tuple of pairs of definition parameters/members and function call arguments.</p> Source code in <code>wake/analysis/utils.py</code> <pre><code>def pair_function_call_arguments(\n    definition: Union[\n        ErrorDefinition, EventDefinition, FunctionDefinition, StructDefinition\n    ],\n    call: FunctionCall,\n) -&gt; Tuple[Tuple[VariableDeclaration, ExpressionAbc], ...]:\n    \"\"\"\n    Pairs function call arguments with error/event/function/struct definition parameters.\n    Returned pairs are in the same order as the definition parameters/members.\n\n    !!! example\n        The function also handles calls of bounded functions with the `using for` directive.\n\n        ```solidity\n        contract C {\n            using SafeERC20 for IERC20;\n\n            function withdraw(IERC20 token, uint256 amount) external {\n                token.safeTransfer(msg.sender, amount); // token is the first argument of safeTransfer\n            }\n        }\n        ```\n\n    Args:\n        definition: Definition called.\n        call: Function call or struct constructor call.\n\n    Returns:\n        Tuple of pairs of definition parameters/members and function call arguments.\n    \"\"\"\n    assert len(call.names) == 0 or len(call.names) == len(\n        call.arguments\n    ), \"Call names must be empty or same length as arguments\"\n\n    vars = (\n        [v for v in definition.members if not isinstance(v.type_name, Mapping)]\n        if isinstance(definition, StructDefinition)\n        else definition.parameters.parameters\n    )\n\n    if len(vars) == len(call.arguments):\n        if len(call.names) == 0:\n            return tuple(zip(vars, call.arguments))\n        else:\n            return tuple((p, call.arguments[call.names.index(p.name)]) for p in vars)\n    elif len(vars) == len(call.arguments) + 1:\n        # using for\n        node = call.expression\n        if isinstance(node, FunctionCallOptions):\n            node = node.expression\n        if isinstance(node, MemberAccess):\n            node = node.expression\n\n        if len(call.names) == 0:\n            return ((vars[0], node),) + tuple(zip(vars[1:], call.arguments))\n        else:\n            return ((vars[0], node),) + tuple(\n                (p, call.arguments[call.names.index(p.name)]) for p in vars[1:]\n            )\n    else:\n        raise ValueError(\n            f\"{definition.name} has {len(vars)} parameters but called with {len(call.arguments)} arguments\"\n        )\n</code></pre>"},{"location":"api-reference/compiler/build-data-model/","title":"build_data_model","text":""},{"location":"api-reference/compiler/build-data-model/#wake.compiler.build_data_model","title":"<code>wake.compiler.build_data_model</code>  <code>module</code>","text":""},{"location":"api-reference/compiler/build-data-model/#wake.compiler.build_data_model.CompilationUnitBuildInfo","title":"<code>CompilationUnitBuildInfo</code>  <code>class</code>","text":"<p>         Bases: <code>BuildInfoModel</code></p> <p>Holds all compilation errors and warnings that occurred during compilation of a single compilation unit. Some errors and warnings may not be associated with any specific source code location. Because of incremental compilation, it is important to keep track of all errors and warnings that occurred during compilation of a compilation unit with a given hash.</p> <p>Attributes:</p> Name Type Description <code>errors</code> <code>List[SolcOutputError]</code> <p>List of compilation warnings and errors that occurred during compilation of the compilation unit.</p> Source code in <code>wake/compiler/build_data_model.py</code> <pre><code>class CompilationUnitBuildInfo(BuildInfoModel):\n    \"\"\"\n    Holds all compilation errors and warnings that occurred during compilation of a single compilation unit.\n    Some errors and warnings may not be associated with any specific source code location.\n    Because of incremental compilation, it is important to keep track of all errors and warnings that occurred during compilation of a compilation unit with a given hash.\n\n    Attributes:\n        errors: List of compilation warnings and errors that occurred during compilation of the compilation unit.\n    \"\"\"\n\n    errors: List[SolcOutputError]\n</code></pre>"},{"location":"api-reference/compiler/build-data-model/#wake.compiler.build_data_model.ProjectBuild","title":"<code>ProjectBuild</code>  <code>class</code>","text":"<p>Class holding a single project build.</p> Source code in <code>wake/compiler/build_data_model.py</code> <pre><code>class ProjectBuild:\n    \"\"\"\n    Class holding a single project build.\n    \"\"\"\n\n    _interval_trees: Dict[Path, IntervalTree]\n    _reference_resolver: ReferenceResolver\n    _source_units: Dict[Path, SourceUnit]\n\n    def __init__(\n        self,\n        interval_trees: Dict[Path, IntervalTree],\n        reference_resolver: ReferenceResolver,\n        source_units: Dict[Path, SourceUnit],\n    ):\n        self._interval_trees = interval_trees\n        self._reference_resolver = reference_resolver\n        self._source_units = source_units\n\n    @property\n    def interval_trees(self) -&gt; Dict[Path, IntervalTree]:\n        \"\"\"\n        Returns:\n            Mapping of source file paths to [interval trees](https://github.com/chaimleib/intervaltree) that can be used to query IR nodes by byte offsets in the source code.\n        \"\"\"\n        return MappingProxyType(\n            self._interval_trees\n        )  # pyright: ignore reportGeneralTypeIssues\n\n    @property\n    def reference_resolver(self) -&gt; ReferenceResolver:\n        \"\"\"\n        Returns:\n            Reference resolver responsible for resolving AST node IDs to IR nodes. Useful especially for resolving references across different compilation units.\n        \"\"\"\n        return self._reference_resolver\n\n    @property\n    def source_units(self) -&gt; Dict[Path, SourceUnit]:\n        \"\"\"\n        Returns:\n            Mapping of source file paths to top-level [SourceUnit][wake.ir.meta.source_unit.SourceUnit] IR nodes.\n        \"\"\"\n        return MappingProxyType(\n            self._source_units\n        )  # pyright: ignore reportGeneralTypeIssues\n</code></pre>"},{"location":"api-reference/compiler/build-data-model/#wake.compiler.build_data_model.ProjectBuild.interval_trees","title":"<code>interval_trees: Dict[Path, IntervalTree]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Dict[Path, IntervalTree]</code> <p>Mapping of source file paths to interval trees that can be used to query IR nodes by byte offsets in the source code.</p>"},{"location":"api-reference/compiler/build-data-model/#wake.compiler.build_data_model.ProjectBuild.reference_resolver","title":"<code>reference_resolver: ReferenceResolver</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>ReferenceResolver</code> <p>Reference resolver responsible for resolving AST node IDs to IR nodes. Useful especially for resolving references across different compilation units.</p>"},{"location":"api-reference/compiler/build-data-model/#wake.compiler.build_data_model.ProjectBuild.source_units","title":"<code>source_units: Dict[Path, SourceUnit]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Dict[Path, SourceUnit]</code> <p>Mapping of source file paths to top-level SourceUnit IR nodes.</p>"},{"location":"api-reference/compiler/build-data-model/#wake.compiler.build_data_model.ProjectBuildInfo","title":"<code>ProjectBuildInfo</code>  <code>class</code>","text":"<p>         Bases: <code>BuildInfoModel</code></p> <p>Attributes:</p> Name Type Description <code>compilation_units</code> <code>Dict[str, CompilationUnitBuildInfo]</code> <p>Mapping of compilation unit hex-encoded hashes to compilation unit build info.</p> <code>source_units_info</code> <code>Dict[str, SourceUnitInfo]</code> <p>Mapping of source unit names to source unit info.</p> <code>allow_paths</code> <code>FrozenSet[Path]</code> <p>Compilation allow_paths used during compilation.</p> <code>exclude_paths</code> <code>FrozenSet[Path]</code> <p>Compilation exclude_paths used during compilation.</p> <code>include_paths</code> <code>FrozenSet[Path]</code> <p>Compilation include_paths used during compilation.</p> <code>settings</code> <code>SolcInputSettings</code> <p>solc input settings used during compilation.</p> <code>target_solidity_version</code> <code>Optional[SolidityVersion]</code> <p>Solidity target_version used during compilation, if any.</p> <code>wake_version</code> <code>str</code> <p><code>eth-wake</code> version used during compilation.</p> <code>incremental</code> <code>bool</code> <p>Whether the compilation was performed in incremental mode.</p> Source code in <code>wake/compiler/build_data_model.py</code> <pre><code>class ProjectBuildInfo(BuildInfoModel):\n    \"\"\"\n    Attributes:\n        compilation_units: Mapping of compilation unit hex-encoded hashes to compilation unit build info.\n        source_units_info: Mapping of source unit names to source unit info.\n        allow_paths: Compilation [allow_paths][wake.config.data_model.SolcConfig.allow_paths] used during compilation.\n        exclude_paths: Compilation [exclude_paths][wake.config.data_model.SolcConfig.exclude_paths] used during compilation.\n        include_paths: Compilation [include_paths][wake.config.data_model.SolcConfig.include_paths] used during compilation.\n        settings: solc input settings used during compilation.\n        target_solidity_version: Solidity [target_version][wake.config.data_model.SolcConfig.target_version] used during compilation, if any.\n        wake_version: `eth-wake` version used during compilation.\n        incremental: Whether the compilation was performed in incremental mode.\n    \"\"\"\n\n    compilation_units: Dict[str, CompilationUnitBuildInfo]\n    source_units_info: Dict[str, SourceUnitInfo]\n    allow_paths: FrozenSet[Path]\n    exclude_paths: FrozenSet[Path]\n    include_paths: FrozenSet[Path]\n    settings: SolcInputSettings\n    target_solidity_version: Optional[SolidityVersion]\n    wake_version: str\n    incremental: bool\n\n    @field_serializer(\"target_solidity_version\", when_used=\"json\")\n    def serialize_target_version(self, version: Optional[SolidityVersion], info):\n        return str(version) if version is not None else None\n</code></pre>"},{"location":"api-reference/compiler/build-data-model/#wake.compiler.build_data_model.SourceUnitInfo","title":"<code>SourceUnitInfo</code>  <code>class</code>","text":"<p>         Bases: <code>BuildInfoModel</code></p> <p>Attributes:</p> Name Type Description <code>fs_path</code> <code>Path</code> <p>Path to the source unit.</p> <code>blake2b_hash</code> <code>HexBytes</code> <p>256-bit blake2b hash of the source unit contents.</p> Source code in <code>wake/compiler/build_data_model.py</code> <pre><code>class SourceUnitInfo(BuildInfoModel):\n    \"\"\"\n    Attributes:\n        fs_path: Path to the source unit.\n        blake2b_hash: 256-bit blake2b hash of the source unit contents.\n    \"\"\"\n\n    fs_path: Path\n    blake2b_hash: HexBytes\n</code></pre>"},{"location":"api-reference/config/data-model/","title":"data_model","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model","title":"<code>wake.config.data_model</code>  <code>module</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.AnvilConfig","title":"<code>AnvilConfig</code>  <code>class</code>","text":"<p>         Bases: <code>WakeConfigModel</code></p> Source code in <code>wake/config/data_model.py</code> <pre><code>class AnvilConfig(WakeConfigModel):\n    cmd_args: str = (\n        \"--prune-history 100 --transaction-block-keeper 10 --steps-tracing --silent\"\n    )\n    \"\"\"\n    Command line arguments to pass to `anvil`.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/config/data-model/#wake.config.data_model.AnvilConfig.cmd_args","title":"<code>cmd_args: str = '--prune-history 100 --transaction-block-keeper 10 --steps-tracing --silent'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Command line arguments to pass to <code>anvil</code>.</p>"},{"location":"api-reference/config/data-model/#wake.config.data_model.CodeLensConfig","title":"<code>CodeLensConfig</code>  <code>class</code>","text":"<p>         Bases: <code>WakeConfigModel</code></p> Source code in <code>wake/config/data_model.py</code> <pre><code>class CodeLensConfig(WakeConfigModel):\n    enable: bool = True\n    \"\"\"\n    Show code lenses.\n    \"\"\"\n    sort_tag_priority: List[str] = [\n        \"lsp-references\",\n        \"lsp-selectors\",\n        \"lsp-inheritance-graph\",\n        \"lsp-linearized-inheritance-graph\",\n    ]\n    \"\"\"\n    Order of code lens with the same start and end position based on sort tags used in detectors/printers. Sort tags default to the printer/detector name.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/config/data-model/#wake.config.data_model.CodeLensConfig.enable","title":"<code>enable: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Show code lenses.</p>"},{"location":"api-reference/config/data-model/#wake.config.data_model.CodeLensConfig.sort_tag_priority","title":"<code>sort_tag_priority: List[str] = ['lsp-references', 'lsp-selectors', 'lsp-inheritance-graph', 'lsp-linearized-inheritance-graph']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Order of code lens with the same start and end position based on sort tags used in detectors/printers. Sort tags default to the printer/detector name.</p>"},{"location":"api-reference/config/data-model/#wake.config.data_model.CompilerConfig","title":"<code>CompilerConfig</code>  <code>class</code>","text":"<p>         Bases: <code>WakeConfigModel</code></p> Source code in <code>wake/config/data_model.py</code> <pre><code>class CompilerConfig(WakeConfigModel):\n    solc: SolcConfig = Field(default_factory=SolcConfig)\n</code></pre>"},{"location":"api-reference/config/data-model/#wake.config.data_model.CompilerConfig.solc","title":"<code>solc: SolcConfig = Field(default_factory=SolcConfig)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.ControlFlowGraphConfig","title":"<code>ControlFlowGraphConfig</code>  <code>class</code>","text":"<p>         Bases: <code>WakeConfigModel</code></p> <p>Unstable, may change in the future.</p> Source code in <code>wake/config/data_model.py</code> <pre><code>class ControlFlowGraphConfig(WakeConfigModel):\n    \"\"\"\n    Unstable, may change in the future.\n    \"\"\"\n\n    direction: GraphsDirection = GraphsDirection.TopBottom\n    vscode_urls: bool = True\n</code></pre>"},{"location":"api-reference/config/data-model/#wake.config.data_model.ControlFlowGraphConfig.direction","title":"<code>direction: GraphsDirection = GraphsDirection.TopBottom</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.ControlFlowGraphConfig.vscode_urls","title":"<code>vscode_urls: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.DeploymentConfig","title":"<code>DeploymentConfig</code>  <code>class</code>","text":"<p>         Bases: <code>WakeConfigModel</code></p> Source code in <code>wake/config/data_model.py</code> <pre><code>class DeploymentConfig(WakeConfigModel):\n    confirm_transactions: bool = True\n    \"\"\"\n    Require confirmation for each transaction.\n    \"\"\"\n    silent: bool = False\n    \"\"\"\n    Do not require confirmation for each transaction and do not print transaction status.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/config/data-model/#wake.config.data_model.DeploymentConfig.confirm_transactions","title":"<code>confirm_transactions: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Require confirmation for each transaction.</p>"},{"location":"api-reference/config/data-model/#wake.config.data_model.DeploymentConfig.silent","title":"<code>silent: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Do not require confirmation for each transaction and do not print transaction status.</p>"},{"location":"api-reference/config/data-model/#wake.config.data_model.DetectorConfig","title":"<code>DetectorConfig</code>  <code>class</code>","text":"<p>         Bases: <code>WakeConfigModel</code></p> <p>Namespace for detector-specific config options. Each attribute should be named after the detector name and hold a dictionary with string keys matching the Click option names.</p> Source code in <code>wake/config/data_model.py</code> <pre><code>class DetectorConfig(WakeConfigModel, extra=\"allow\"):\n    \"\"\"\n    Namespace for detector-specific config options.\n    Each attribute should be named after the detector name and hold a dictionary with string keys matching the Click option names.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/config/data-model/#wake.config.data_model.DetectorsConfig","title":"<code>DetectorsConfig</code>  <code>class</code>","text":"<p>         Bases: <code>WakeConfigModel</code></p> Source code in <code>wake/config/data_model.py</code> <pre><code>class DetectorsConfig(WakeConfigModel):\n    exclude: FrozenSet[str] = frozenset()\n    \"\"\"\n    Names of detectors that should not be loaded.\n    \"\"\"\n    only: Optional[FrozenSet[str]] = None\n    \"\"\"\n    Names of detectors that should only be loaded.\n    \"\"\"\n    ignore_paths: FrozenSet[\n        Annotated[Path, BeforeValidator(lambda p: Path(p).resolve())]\n    ] = Field(\n        default_factory=lambda: frozenset(\n            [\n                Path.cwd() / \"venv\",\n                Path.cwd() / \".venv\",\n                Path.cwd() / \"test\",\n            ]\n        )\n    )\n    \"\"\"\n    Detections in these paths must be ignored under all circumstances.\n    Useful for ignoring detections in Solidity test files.\n    \"\"\"\n    exclude_paths: FrozenSet[\n        Annotated[Path, BeforeValidator(lambda p: Path(p).resolve())]\n    ] = Field(\n        default_factory=lambda: frozenset(\n            [\n                Path.cwd() / \"node_modules\",\n                Path.cwd() / \"lib\",\n                Path.cwd() / \"script\",\n            ]\n        )\n    )\n    \"\"\"\n    Detections in these paths are ignored unless linked to a (sub)detection in a non-excluded path.\n    Useful for ignoring detections in dependencies.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/config/data-model/#wake.config.data_model.DetectorsConfig.exclude","title":"<code>exclude: FrozenSet[str] = frozenset()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Names of detectors that should not be loaded.</p>"},{"location":"api-reference/config/data-model/#wake.config.data_model.DetectorsConfig.exclude_paths","title":"<code>exclude_paths: FrozenSet[Annotated[Path, BeforeValidator(lambda p: Path(p).resolve())]] = Field(default_factory=lambda: frozenset([Path.cwd() / 'node_modules', Path.cwd() / 'lib', Path.cwd() / 'script']))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Detections in these paths are ignored unless linked to a (sub)detection in a non-excluded path. Useful for ignoring detections in dependencies.</p>"},{"location":"api-reference/config/data-model/#wake.config.data_model.DetectorsConfig.ignore_paths","title":"<code>ignore_paths: FrozenSet[Annotated[Path, BeforeValidator(lambda p: Path(p).resolve())]] = Field(default_factory=lambda: frozenset([Path.cwd() / 'venv', Path.cwd() / '.venv', Path.cwd() / 'test']))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Detections in these paths must be ignored under all circumstances. Useful for ignoring detections in Solidity test files.</p>"},{"location":"api-reference/config/data-model/#wake.config.data_model.DetectorsConfig.only","title":"<code>only: Optional[FrozenSet[str]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Names of detectors that should only be loaded.</p>"},{"location":"api-reference/config/data-model/#wake.config.data_model.DetectorsLspConfig","title":"<code>DetectorsLspConfig</code>  <code>class</code>","text":"<p>         Bases: <code>WakeConfigModel</code></p> Source code in <code>wake/config/data_model.py</code> <pre><code>class DetectorsLspConfig(WakeConfigModel):\n    enable: bool = True\n    \"\"\"\n    Run detectors in LSP.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/config/data-model/#wake.config.data_model.DetectorsLspConfig.enable","title":"<code>enable: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Run detectors in LSP.</p>"},{"location":"api-reference/config/data-model/#wake.config.data_model.FindReferencesConfig","title":"<code>FindReferencesConfig</code>  <code>class</code>","text":"<p>         Bases: <code>WakeConfigModel</code></p> Source code in <code>wake/config/data_model.py</code> <pre><code>class FindReferencesConfig(WakeConfigModel):\n    include_declarations: bool = False\n    \"\"\"\n    Include declarations in the results.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/config/data-model/#wake.config.data_model.FindReferencesConfig.include_declarations","title":"<code>include_declarations: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Include declarations in the results.</p>"},{"location":"api-reference/config/data-model/#wake.config.data_model.GanacheConfig","title":"<code>GanacheConfig</code>  <code>class</code>","text":"<p>         Bases: <code>WakeConfigModel</code></p> Source code in <code>wake/config/data_model.py</code> <pre><code>class GanacheConfig(WakeConfigModel):\n    cmd_args: str = \"-k istanbul -q\"\n    \"\"\"\n    Command line arguments to pass to `ganache`.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/config/data-model/#wake.config.data_model.GanacheConfig.cmd_args","title":"<code>cmd_args: str = '-k istanbul -q'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Command line arguments to pass to <code>ganache</code>.</p>"},{"location":"api-reference/config/data-model/#wake.config.data_model.GeneralConfig","title":"<code>GeneralConfig</code>  <code>class</code>","text":"<p>         Bases: <code>WakeConfigModel</code></p> Source code in <code>wake/config/data_model.py</code> <pre><code>class GeneralConfig(WakeConfigModel):\n    call_trace_options: FrozenSet[str] = frozenset(\n        [\n            \"contract_name\",\n            \"function_name\",\n            \"named_arguments\",\n            \"status\",\n            \"call_type\",\n            \"value\",\n            \"return_value\",\n            \"error\",\n        ]\n    )\n    \"\"\"\n    Options to include in call traces.\n    \"\"\"\n    json_rpc_timeout: float = 15\n    \"\"\"\n    Timeout applied to JSON-RPC requests.\n    \"\"\"\n    link_format: str = \"vscode://file/{path}:{line}:{col}\"\n    \"\"\"\n    Format of links used in detectors and printers.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/config/data-model/#wake.config.data_model.GeneralConfig.call_trace_options","title":"<code>call_trace_options: FrozenSet[str] = frozenset(['contract_name', 'function_name', 'named_arguments', 'status', 'call_type', 'value', 'return_value', 'error'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Options to include in call traces.</p>"},{"location":"api-reference/config/data-model/#wake.config.data_model.GeneralConfig.json_rpc_timeout","title":"<code>json_rpc_timeout: float = 15</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Timeout applied to JSON-RPC requests.</p>"},{"location":"api-reference/config/data-model/#wake.config.data_model.GeneralConfig.link_format","title":"<code>link_format: str = 'vscode://file/{path}:{line}:{col}'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Format of links used in detectors and printers.</p>"},{"location":"api-reference/config/data-model/#wake.config.data_model.GeneratorConfig","title":"<code>GeneratorConfig</code>  <code>class</code>","text":"<p>         Bases: <code>WakeConfigModel</code></p> <p>Unstable, may change in the future.</p> Source code in <code>wake/config/data_model.py</code> <pre><code>class GeneratorConfig(WakeConfigModel):\n    \"\"\"\n    Unstable, may change in the future.\n    \"\"\"\n\n    control_flow_graph: ControlFlowGraphConfig = Field(\n        default_factory=ControlFlowGraphConfig\n    )\n    imports_graph: ImportsGraphConfig = Field(default_factory=ImportsGraphConfig)\n    inheritance_graph: InheritanceGraphConfig = Field(\n        default_factory=InheritanceGraphConfig\n    )\n    inheritance_graph_full: InheritanceGraphConfig = Field(\n        default_factory=InheritanceGraphConfig\n    )\n    linearized_inheritance_graph: LinearizedInheritanceGraphConfig = Field(\n        default_factory=LinearizedInheritanceGraphConfig\n    )\n</code></pre>"},{"location":"api-reference/config/data-model/#wake.config.data_model.GeneratorConfig.control_flow_graph","title":"<code>control_flow_graph: ControlFlowGraphConfig = Field(default_factory=ControlFlowGraphConfig)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.GeneratorConfig.imports_graph","title":"<code>imports_graph: ImportsGraphConfig = Field(default_factory=ImportsGraphConfig)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.GeneratorConfig.inheritance_graph","title":"<code>inheritance_graph: InheritanceGraphConfig = Field(default_factory=InheritanceGraphConfig)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.GeneratorConfig.inheritance_graph_full","title":"<code>inheritance_graph_full: InheritanceGraphConfig = Field(default_factory=InheritanceGraphConfig)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.GeneratorConfig.linearized_inheritance_graph","title":"<code>linearized_inheritance_graph: LinearizedInheritanceGraphConfig = Field(default_factory=LinearizedInheritanceGraphConfig)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.GraphsDirection","title":"<code>GraphsDirection</code>  <code>class</code>","text":"<p>         Bases: <code>StrEnum</code></p> Source code in <code>wake/config/data_model.py</code> <pre><code>class GraphsDirection(StrEnum):\n    TopBottom = \"TB\"\n    BottomTop = \"BT\"\n    LeftRight = \"LR\"\n    RightLeft = \"RL\"\n</code></pre>"},{"location":"api-reference/config/data-model/#wake.config.data_model.GraphsDirection.BottomTop","title":"<code>BottomTop = 'BT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.GraphsDirection.LeftRight","title":"<code>LeftRight = 'LR'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.GraphsDirection.RightLeft","title":"<code>RightLeft = 'RL'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.GraphsDirection.TopBottom","title":"<code>TopBottom = 'TB'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.HardhatConfig","title":"<code>HardhatConfig</code>  <code>class</code>","text":"<p>         Bases: <code>WakeConfigModel</code></p> Source code in <code>wake/config/data_model.py</code> <pre><code>class HardhatConfig(WakeConfigModel):\n    cmd_args: str = \"\"\n    \"\"\"\n    Command line arguments to pass to `npx hardhat node`.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/config/data-model/#wake.config.data_model.HardhatConfig.cmd_args","title":"<code>cmd_args: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Command line arguments to pass to <code>npx hardhat node</code>.</p>"},{"location":"api-reference/config/data-model/#wake.config.data_model.ImportsDirection","title":"<code>ImportsDirection</code>  <code>class</code>","text":"<p>         Bases: <code>StrEnum</code></p> Source code in <code>wake/config/data_model.py</code> <pre><code>class ImportsDirection(StrEnum):\n    ImportedToImporting = \"imported-to-importing\"\n    ImportingToImported = \"importing-to-imported\"\n</code></pre>"},{"location":"api-reference/config/data-model/#wake.config.data_model.ImportsDirection.ImportedToImporting","title":"<code>ImportedToImporting = 'imported-to-importing'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.ImportsDirection.ImportingToImported","title":"<code>ImportingToImported = 'importing-to-imported'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.ImportsGraphConfig","title":"<code>ImportsGraphConfig</code>  <code>class</code>","text":"<p>         Bases: <code>WakeConfigModel</code></p> <p>Unstable, may change in the future.</p> Source code in <code>wake/config/data_model.py</code> <pre><code>class ImportsGraphConfig(WakeConfigModel):\n    \"\"\"\n    Unstable, may change in the future.\n    \"\"\"\n\n    direction: GraphsDirection = GraphsDirection.TopBottom\n    imports_direction: ImportsDirection = ImportsDirection.ImportedToImporting\n    vscode_urls: bool = True\n</code></pre>"},{"location":"api-reference/config/data-model/#wake.config.data_model.ImportsGraphConfig.direction","title":"<code>direction: GraphsDirection = GraphsDirection.TopBottom</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.ImportsGraphConfig.imports_direction","title":"<code>imports_direction: ImportsDirection = ImportsDirection.ImportedToImporting</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.ImportsGraphConfig.vscode_urls","title":"<code>vscode_urls: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.InheritanceGraphConfig","title":"<code>InheritanceGraphConfig</code>  <code>class</code>","text":"<p>         Bases: <code>WakeConfigModel</code></p> <p>Unstable, may change in the future.</p> Source code in <code>wake/config/data_model.py</code> <pre><code>class InheritanceGraphConfig(WakeConfigModel):\n    \"\"\"\n    Unstable, may change in the future.\n    \"\"\"\n\n    direction: GraphsDirection = GraphsDirection.BottomTop\n    vscode_urls: bool = True\n</code></pre>"},{"location":"api-reference/config/data-model/#wake.config.data_model.InheritanceGraphConfig.direction","title":"<code>direction: GraphsDirection = GraphsDirection.BottomTop</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.InheritanceGraphConfig.vscode_urls","title":"<code>vscode_urls: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.InlayHintsConfig","title":"<code>InlayHintsConfig</code>  <code>class</code>","text":"<p>         Bases: <code>WakeConfigModel</code></p> Source code in <code>wake/config/data_model.py</code> <pre><code>class InlayHintsConfig(WakeConfigModel):\n    enable: bool = True\n    \"\"\"\n    Show inlay hints.\n    \"\"\"\n    sort_tag_priority: List[str] = []\n    \"\"\"\n    Order of inlay hints with the same position based on sort tags used in detectors/printers. Sort tags default to the printer/detector name.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/config/data-model/#wake.config.data_model.InlayHintsConfig.enable","title":"<code>enable: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Show inlay hints.</p>"},{"location":"api-reference/config/data-model/#wake.config.data_model.InlayHintsConfig.sort_tag_priority","title":"<code>sort_tag_priority: List[str] = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Order of inlay hints with the same position based on sort tags used in detectors/printers. Sort tags default to the printer/detector name.</p>"},{"location":"api-reference/config/data-model/#wake.config.data_model.LinearizedInheritanceGraphConfig","title":"<code>LinearizedInheritanceGraphConfig</code>  <code>class</code>","text":"<p>         Bases: <code>WakeConfigModel</code></p> <p>Unstable, may change in the future.</p> Source code in <code>wake/config/data_model.py</code> <pre><code>class LinearizedInheritanceGraphConfig(WakeConfigModel):\n    \"\"\"\n    Unstable, may change in the future.\n    \"\"\"\n\n    direction: GraphsDirection = GraphsDirection.LeftRight\n    vscode_urls: bool = True\n</code></pre>"},{"location":"api-reference/config/data-model/#wake.config.data_model.LinearizedInheritanceGraphConfig.direction","title":"<code>direction: GraphsDirection = GraphsDirection.LeftRight</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.LinearizedInheritanceGraphConfig.vscode_urls","title":"<code>vscode_urls: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.LspConfig","title":"<code>LspConfig</code>  <code>class</code>","text":"<p>         Bases: <code>WakeConfigModel</code></p> Source code in <code>wake/config/data_model.py</code> <pre><code>class LspConfig(WakeConfigModel):\n    compilation_delay: float = 0\n    \"\"\"\n    Delay to wait after a file content change before recompiling.\n    \"\"\"\n    code_lens: CodeLensConfig = Field(default_factory=CodeLensConfig)\n    \"\"\"\n    Code lens config options.\n    \"\"\"\n    detectors: DetectorsLspConfig = Field(default_factory=DetectorsLspConfig)\n    \"\"\"\n    Detectors config options specific to LSP.\n    \"\"\"\n    find_references: FindReferencesConfig = Field(default_factory=FindReferencesConfig)\n    \"\"\"\n    Find references config options.\n    \"\"\"\n    inlay_hints: InlayHintsConfig = Field(default_factory=InlayHintsConfig)\n    \"\"\"\n    Inlay hints config options.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/config/data-model/#wake.config.data_model.LspConfig.code_lens","title":"<code>code_lens: CodeLensConfig = Field(default_factory=CodeLensConfig)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Code lens config options.</p>"},{"location":"api-reference/config/data-model/#wake.config.data_model.LspConfig.compilation_delay","title":"<code>compilation_delay: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Delay to wait after a file content change before recompiling.</p>"},{"location":"api-reference/config/data-model/#wake.config.data_model.LspConfig.detectors","title":"<code>detectors: DetectorsLspConfig = Field(default_factory=DetectorsLspConfig)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Detectors config options specific to LSP.</p>"},{"location":"api-reference/config/data-model/#wake.config.data_model.LspConfig.find_references","title":"<code>find_references: FindReferencesConfig = Field(default_factory=FindReferencesConfig)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Find references config options.</p>"},{"location":"api-reference/config/data-model/#wake.config.data_model.LspConfig.inlay_hints","title":"<code>inlay_hints: InlayHintsConfig = Field(default_factory=InlayHintsConfig)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Inlay hints config options.</p>"},{"location":"api-reference/config/data-model/#wake.config.data_model.PrinterConfig","title":"<code>PrinterConfig</code>  <code>class</code>","text":"<p>         Bases: <code>WakeConfigModel</code></p> <p>Namespace for printer-specific config options. Each attribute should be named after the printer name and hold a dictionary with string keys matching the Click option names.</p> Source code in <code>wake/config/data_model.py</code> <pre><code>class PrinterConfig(WakeConfigModel, extra=\"allow\"):\n    \"\"\"\n    Namespace for printer-specific config options.\n    Each attribute should be named after the printer name and hold a dictionary with string keys matching the Click option names.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/config/data-model/#wake.config.data_model.PrintersConfig","title":"<code>PrintersConfig</code>  <code>class</code>","text":"<p>         Bases: <code>WakeConfigModel</code></p> <p>Holds general printer config options for all printers.</p> Source code in <code>wake/config/data_model.py</code> <pre><code>class PrintersConfig(WakeConfigModel):\n    \"\"\"\n    Holds general printer config options for all printers.\n    \"\"\"\n\n    exclude: FrozenSet[str] = frozenset()\n    \"\"\"\n    Names of printers that should not be loaded.\n    \"\"\"\n    only: Optional[FrozenSet[str]] = None\n    \"\"\"\n    Names of printers that should only be loaded.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/config/data-model/#wake.config.data_model.PrintersConfig.exclude","title":"<code>exclude: FrozenSet[str] = frozenset()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Names of printers that should not be loaded.</p>"},{"location":"api-reference/config/data-model/#wake.config.data_model.PrintersConfig.only","title":"<code>only: Optional[FrozenSet[str]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Names of printers that should only be loaded.</p>"},{"location":"api-reference/config/data-model/#wake.config.data_model.SolcConfig","title":"<code>SolcConfig</code>  <code>class</code>","text":"<p>         Bases: <code>WakeConfigModel</code></p> Source code in <code>wake/config/data_model.py</code> <pre><code>class SolcConfig(WakeConfigModel):\n    allow_paths: FrozenSet[\n        Annotated[Path, BeforeValidator(lambda p: Path(p).resolve())]\n    ] = frozenset()\n    \"\"\"Wake should set solc `--allow-paths` automatically. This option allows to specify additional allowed paths.\"\"\"\n    evm_version: Optional[EvmVersionEnum] = None\n    \"\"\"Version of the EVM to compile for. Leave unset to let the solc decide.\"\"\"\n    exclude_paths: FrozenSet[\n        Annotated[Path, BeforeValidator(lambda p: Path(p).resolve())]\n    ] = Field(\n        default_factory=lambda: frozenset(\n            [\n                Path.cwd() / \"node_modules\",\n                Path.cwd() / \"venv\",\n                Path.cwd() / \".venv\",\n                Path.cwd() / \"lib\",\n                Path.cwd() / \"script\",\n                Path.cwd() / \"test\",\n            ]\n        )\n    )\n    \"\"\"\n    Solidity files in these paths are excluded from compilation unless imported from a non-excluded file.\n    \"\"\"\n    include_paths: FrozenSet[\n        Annotated[Path, BeforeValidator(lambda p: Path(p).resolve())]\n    ] = Field(default_factory=lambda: frozenset([Path.cwd() / \"node_modules\"]))\n    \"\"\"\n    Paths where to search for Solidity files imported using direct (non-relative) import paths.\n    \"\"\"\n    optimizer: SolcOptimizerConfig = Field(default_factory=SolcOptimizerConfig)\n    \"\"\"\n    Optimizer config options.\n    \"\"\"\n    remappings: List[\n        Annotated[\n            SolcRemapping,\n            BeforeValidator(convert_remapping),\n            PlainSerializer(lambda r: str(r), when_used=\"json\"),\n        ]\n    ] = []\n    \"\"\"\n    Remappings to apply during compilation.\n    \"\"\"\n    target_version: Optional[SolidityVersion] = None\n    \"\"\"\n    Target Solidity version to use for all files during compilation.\n    \"\"\"\n    via_IR: Optional[bool] = None\n    \"\"\"\n    Use new IR-based compiler pipeline.\n    \"\"\"\n\n    @field_serializer(\"target_version\", when_used=\"json\")\n    def serialize_target_version(self, version: Optional[SolidityVersion], info):\n        return str(version) if version is not None else None\n</code></pre>"},{"location":"api-reference/config/data-model/#wake.config.data_model.SolcConfig.allow_paths","title":"<code>allow_paths: FrozenSet[Annotated[Path, BeforeValidator(lambda p: Path(p).resolve())]] = frozenset()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Wake should set solc <code>--allow-paths</code> automatically. This option allows to specify additional allowed paths.</p>"},{"location":"api-reference/config/data-model/#wake.config.data_model.SolcConfig.evm_version","title":"<code>evm_version: Optional[EvmVersionEnum] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Version of the EVM to compile for. Leave unset to let the solc decide.</p>"},{"location":"api-reference/config/data-model/#wake.config.data_model.SolcConfig.exclude_paths","title":"<code>exclude_paths: FrozenSet[Annotated[Path, BeforeValidator(lambda p: Path(p).resolve())]] = Field(default_factory=lambda: frozenset([Path.cwd() / 'node_modules', Path.cwd() / 'venv', Path.cwd() / '.venv', Path.cwd() / 'lib', Path.cwd() / 'script', Path.cwd() / 'test']))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Solidity files in these paths are excluded from compilation unless imported from a non-excluded file.</p>"},{"location":"api-reference/config/data-model/#wake.config.data_model.SolcConfig.include_paths","title":"<code>include_paths: FrozenSet[Annotated[Path, BeforeValidator(lambda p: Path(p).resolve())]] = Field(default_factory=lambda: frozenset([Path.cwd() / 'node_modules']))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Paths where to search for Solidity files imported using direct (non-relative) import paths.</p>"},{"location":"api-reference/config/data-model/#wake.config.data_model.SolcConfig.optimizer","title":"<code>optimizer: SolcOptimizerConfig = Field(default_factory=SolcOptimizerConfig)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optimizer config options.</p>"},{"location":"api-reference/config/data-model/#wake.config.data_model.SolcConfig.remappings","title":"<code>remappings: List[Annotated[SolcRemapping, BeforeValidator(convert_remapping), PlainSerializer(lambda r: str(r), when_used=json)]] = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Remappings to apply during compilation.</p>"},{"location":"api-reference/config/data-model/#wake.config.data_model.SolcConfig.target_version","title":"<code>target_version: Optional[SolidityVersion] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Target Solidity version to use for all files during compilation.</p>"},{"location":"api-reference/config/data-model/#wake.config.data_model.SolcConfig.via_IR","title":"<code>via_IR: Optional[bool] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use new IR-based compiler pipeline.</p>"},{"location":"api-reference/config/data-model/#wake.config.data_model.SolcConfig.serialize_target_version","title":"<code>serialize_target_version(version, info)</code>","text":"Source code in <code>wake/config/data_model.py</code> <pre><code>@field_serializer(\"target_version\", when_used=\"json\")\ndef serialize_target_version(self, version: Optional[SolidityVersion], info):\n    return str(version) if version is not None else None\n</code></pre>"},{"location":"api-reference/config/data-model/#wake.config.data_model.SolcOptimizerConfig","title":"<code>SolcOptimizerConfig</code>  <code>class</code>","text":"<p>         Bases: <code>WakeConfigModel</code></p> Source code in <code>wake/config/data_model.py</code> <pre><code>class SolcOptimizerConfig(WakeConfigModel):\n    enabled: Optional[bool] = None\n    runs: int = 200\n    details: SolcOptimizerDetailsConfig = Field(\n        default_factory=SolcOptimizerDetailsConfig\n    )\n</code></pre>"},{"location":"api-reference/config/data-model/#wake.config.data_model.SolcOptimizerConfig.details","title":"<code>details: SolcOptimizerDetailsConfig = Field(default_factory=SolcOptimizerDetailsConfig)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.SolcOptimizerConfig.enabled","title":"<code>enabled: Optional[bool] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.SolcOptimizerConfig.runs","title":"<code>runs: int = 200</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.SolcOptimizerDetailsConfig","title":"<code>SolcOptimizerDetailsConfig</code>  <code>class</code>","text":"<p>         Bases: <code>WakeConfigModel</code></p> Source code in <code>wake/config/data_model.py</code> <pre><code>class SolcOptimizerDetailsConfig(WakeConfigModel):\n    peephole: Optional[bool] = None\n    inliner: Optional[bool] = None\n    jumpdest_remover: Optional[bool] = None\n    order_literals: Optional[bool] = None\n    deduplicate: Optional[bool] = None\n    cse: Optional[bool] = None\n    constant_optimizer: Optional[bool] = None\n    simple_counter_for_loop_unchecked_increment: Optional[bool] = None\n    # no need to add yul option here, since it applies only to solc &lt; 0.6.0\n    yul_details: SolcOptimizerYulDetailsConfig = Field(\n        default_factory=SolcOptimizerYulDetailsConfig\n    )\n</code></pre>"},{"location":"api-reference/config/data-model/#wake.config.data_model.SolcOptimizerDetailsConfig.constant_optimizer","title":"<code>constant_optimizer: Optional[bool] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.SolcOptimizerDetailsConfig.cse","title":"<code>cse: Optional[bool] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.SolcOptimizerDetailsConfig.deduplicate","title":"<code>deduplicate: Optional[bool] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.SolcOptimizerDetailsConfig.inliner","title":"<code>inliner: Optional[bool] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.SolcOptimizerDetailsConfig.jumpdest_remover","title":"<code>jumpdest_remover: Optional[bool] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.SolcOptimizerDetailsConfig.order_literals","title":"<code>order_literals: Optional[bool] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.SolcOptimizerDetailsConfig.peephole","title":"<code>peephole: Optional[bool] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.SolcOptimizerDetailsConfig.simple_counter_for_loop_unchecked_increment","title":"<code>simple_counter_for_loop_unchecked_increment: Optional[bool] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.SolcOptimizerDetailsConfig.yul_details","title":"<code>yul_details: SolcOptimizerYulDetailsConfig = Field(default_factory=SolcOptimizerYulDetailsConfig)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.SolcOptimizerYulDetailsConfig","title":"<code>SolcOptimizerYulDetailsConfig</code>  <code>class</code>","text":"<p>         Bases: <code>WakeConfigModel</code></p> Source code in <code>wake/config/data_model.py</code> <pre><code>class SolcOptimizerYulDetailsConfig(WakeConfigModel):\n    stack_allocation: Optional[bool] = None\n    optimizer_steps: Optional[str] = None\n</code></pre>"},{"location":"api-reference/config/data-model/#wake.config.data_model.SolcOptimizerYulDetailsConfig.optimizer_steps","title":"<code>optimizer_steps: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.SolcOptimizerYulDetailsConfig.stack_allocation","title":"<code>stack_allocation: Optional[bool] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.SolcRemapping","title":"<code>SolcRemapping</code>  <code>class</code>","text":"Source code in <code>wake/config/data_model.py</code> <pre><code>@dataclass\nclass SolcRemapping:\n    context: Optional[str]\n    prefix: str\n    target: Optional[str]\n\n    def __iter__(self):\n        return iter(astuple(self))\n\n    def __str__(self):\n        if self.context is None:\n            return f\"{self.prefix}={self.target or ''}\"\n        else:\n            return f\"{self.context}:{self.prefix}={self.target or ''}\"\n</code></pre>"},{"location":"api-reference/config/data-model/#wake.config.data_model.SolcRemapping.context","title":"<code>context: Optional[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.SolcRemapping.prefix","title":"<code>prefix: str</code>  <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.SolcRemapping.target","title":"<code>target: Optional[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.SolcRemapping.__iter__","title":"<code>__iter__()</code>","text":"Source code in <code>wake/config/data_model.py</code> <pre><code>def __iter__(self):\n    return iter(astuple(self))\n</code></pre>"},{"location":"api-reference/config/data-model/#wake.config.data_model.TestingConfig","title":"<code>TestingConfig</code>  <code>class</code>","text":"<p>         Bases: <code>WakeConfigModel</code></p> Source code in <code>wake/config/data_model.py</code> <pre><code>class TestingConfig(WakeConfigModel):\n    cmd: str = \"anvil\"\n    \"\"\"\n    Which development chain to use for testing. Should be one of `anvil`, `ganache` or `hardhat`.\n    \"\"\"\n    anvil: AnvilConfig = Field(default_factory=AnvilConfig)\n    \"\"\"\n    Anvil-specific config options.\n    \"\"\"\n    ganache: GanacheConfig = Field(default_factory=GanacheConfig)\n    \"\"\"\n    Ganache-specific config options.\n    \"\"\"\n    hardhat: HardhatConfig = Field(default_factory=HardhatConfig)\n    \"\"\"\n    Hardhat-specific config options.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/config/data-model/#wake.config.data_model.TestingConfig.anvil","title":"<code>anvil: AnvilConfig = Field(default_factory=AnvilConfig)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Anvil-specific config options.</p>"},{"location":"api-reference/config/data-model/#wake.config.data_model.TestingConfig.cmd","title":"<code>cmd: str = 'anvil'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Which development chain to use for testing. Should be one of <code>anvil</code>, <code>ganache</code> or <code>hardhat</code>.</p>"},{"location":"api-reference/config/data-model/#wake.config.data_model.TestingConfig.ganache","title":"<code>ganache: GanacheConfig = Field(default_factory=GanacheConfig)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Ganache-specific config options.</p>"},{"location":"api-reference/config/data-model/#wake.config.data_model.TestingConfig.hardhat","title":"<code>hardhat: HardhatConfig = Field(default_factory=HardhatConfig)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Hardhat-specific config options.</p>"},{"location":"api-reference/config/data-model/#wake.config.data_model.TopLevelConfig","title":"<code>TopLevelConfig</code>  <code>class</code>","text":"<p>         Bases: <code>WakeConfigModel</code></p> Source code in <code>wake/config/data_model.py</code> <pre><code>class TopLevelConfig(WakeConfigModel):\n    subconfigs: List[Annotated[Path, BeforeValidator(lambda p: Path(p).resolve())]] = []\n    api_keys: Dict[str, str] = {}\n    compiler: CompilerConfig = Field(default_factory=CompilerConfig)\n    detectors: DetectorsConfig = Field(default_factory=DetectorsConfig)\n    detector: DetectorConfig = Field(default_factory=DetectorConfig)\n    generator: GeneratorConfig = Field(default_factory=GeneratorConfig)\n    lsp: LspConfig = Field(default_factory=LspConfig)\n    testing: TestingConfig = Field(default_factory=TestingConfig)\n    deployment: DeploymentConfig = Field(default_factory=DeploymentConfig)\n    printers: PrintersConfig = Field(default_factory=PrintersConfig)\n    printer: PrinterConfig = Field(default_factory=PrinterConfig)\n    general: GeneralConfig = Field(default_factory=GeneralConfig)\n</code></pre>"},{"location":"api-reference/config/data-model/#wake.config.data_model.TopLevelConfig.api_keys","title":"<code>api_keys: Dict[str, str] = {}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.TopLevelConfig.compiler","title":"<code>compiler: CompilerConfig = Field(default_factory=CompilerConfig)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.TopLevelConfig.deployment","title":"<code>deployment: DeploymentConfig = Field(default_factory=DeploymentConfig)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.TopLevelConfig.detector","title":"<code>detector: DetectorConfig = Field(default_factory=DetectorConfig)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.TopLevelConfig.detectors","title":"<code>detectors: DetectorsConfig = Field(default_factory=DetectorsConfig)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.TopLevelConfig.general","title":"<code>general: GeneralConfig = Field(default_factory=GeneralConfig)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.TopLevelConfig.generator","title":"<code>generator: GeneratorConfig = Field(default_factory=GeneratorConfig)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.TopLevelConfig.lsp","title":"<code>lsp: LspConfig = Field(default_factory=LspConfig)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.TopLevelConfig.printer","title":"<code>printer: PrinterConfig = Field(default_factory=PrinterConfig)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.TopLevelConfig.printers","title":"<code>printers: PrintersConfig = Field(default_factory=PrintersConfig)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.TopLevelConfig.subconfigs","title":"<code>subconfigs: List[Annotated[Path, BeforeValidator(lambda p: Path(p).resolve())]] = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.TopLevelConfig.testing","title":"<code>testing: TestingConfig = Field(default_factory=TestingConfig)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.WakeConfigModel","title":"<code>WakeConfigModel</code>  <code>class</code>","text":"<p>         Bases: <code>BaseModel</code></p> Source code in <code>wake/config/data_model.py</code> <pre><code>class WakeConfigModel(BaseModel):\n    model_config = ConfigDict(\n        extra=\"forbid\",\n        frozen=True,\n    )\n</code></pre>"},{"location":"api-reference/config/data-model/#wake.config.data_model.WakeConfigModel.model_config","title":"<code>model_config = ConfigDict(extra='forbid', frozen=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/config/data-model/#wake.config.data_model.convert_remapping","title":"<code>convert_remapping(v)</code>","text":"Source code in <code>wake/config/data_model.py</code> <pre><code>def convert_remapping(v):\n    if isinstance(v, SolcRemapping):\n        return v\n    elif isinstance(v, dict):\n        return SolcRemapping(**v)\n\n    remapping_re = re.compile(\n        r\"(?:(?P&lt;context&gt;[^:\\s]+)?:)?(?P&lt;prefix&gt;[^\\s=]+)=(?P&lt;target&gt;[^\\s]+)?\"\n    )\n    match = remapping_re.match(v)\n    assert match, f\"`{v}` is not a valid solc remapping.\"\n\n    groupdict = match.groupdict()\n    context = groupdict[\"context\"]\n    prefix = groupdict[\"prefix\"]\n    target = groupdict[\"target\"]\n    return SolcRemapping(context=context, prefix=prefix, target=target)\n</code></pre>"},{"location":"api-reference/config/wake-config/","title":"wake_config","text":""},{"location":"api-reference/config/wake-config/#wake.config.wake_config","title":"<code>wake.config.wake_config</code>  <code>module</code>","text":""},{"location":"api-reference/config/wake-config/#wake.config.wake_config.UnsupportedPlatformError","title":"<code>UnsupportedPlatformError</code>  <code>class</code>","text":"<p>         Bases: <code>Exception</code></p> <p>The current platform is not supported. Supported platforms are: Linux, macOS, Windows.</p> Source code in <code>wake/config/wake_config.py</code> <pre><code>class UnsupportedPlatformError(Exception):\n    \"\"\"\n    The current platform is not supported. Supported platforms are: Linux, macOS, Windows.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/config/wake-config/#wake.config.wake_config.WakeConfig","title":"<code>WakeConfig</code>  <code>class</code>","text":"<p>Wake configuration class. This class is responsible for loading, storing and merging all Wake config options.</p> Source code in <code>wake/config/wake_config.py</code> <pre><code>class WakeConfig:\n    \"\"\"\n    Wake configuration class. This class is responsible for loading, storing and merging all Wake config options.\n    \"\"\"\n\n    __local_config_path: Path\n    __project_root_path: Path\n    __global_config_path: Path\n    __global_data_path: Path\n    __global_cache_path: Path\n    __loaded_files: Set[Path]\n    __config_raw: Dict[str, Any]\n    __config: TopLevelConfig\n\n    def __init__(\n        self,\n        *_,\n        local_config_path: Optional[Union[str, Path]] = None,\n        project_root_path: Optional[Union[str, Path]] = None,\n    ):\n        \"\"\"\n        Initialize the `WakeConfig` class. If `project_root_path` is not provided, the current working directory is used.\n        If `local_config_path` is not provided, the `wake.toml` file in the project root directory is used.\n        \"\"\"\n        system = platform.system()\n\n        try:\n            self.__global_config_path = (\n                Path(os.environ[\"XDG_CONFIG_HOME\"]) / \"wake\" / \"config.toml\"\n            )\n        except KeyError:\n            if system in {\"Linux\", \"Darwin\"}:\n                self.__global_config_path = (\n                    Path.home() / \".config\" / \"wake\" / \"config.toml\"\n                )\n            elif system == \"Windows\":\n                self.__global_config_path = (\n                    Path(os.environ[\"LOCALAPPDATA\"]) / \"wake\" / \"config.toml\"\n                )\n            else:\n                raise UnsupportedPlatformError(f\"Platform `{system}` is not supported.\")\n\n        try:\n            self.__global_data_path = Path(os.environ[\"XDG_DATA_HOME\"]) / \"wake\"\n        except KeyError:\n            if system in {\"Linux\", \"Darwin\"}:\n                self.__global_data_path = Path.home() / \".local\" / \"share\" / \"wake\"\n            elif system == \"Windows\":\n                self.__global_data_path = Path(os.environ[\"LOCALAPPDATA\"]) / \"wake\"\n            else:\n                raise UnsupportedPlatformError(f\"Platform `{system}` is not supported.\")\n\n        try:\n            self.__global_cache_path = Path(os.environ[\"XDG_CACHE_HOME\"]) / \"wake\"\n        except KeyError:\n            if system in {\"Linux\", \"Darwin\"}:\n                self.__global_cache_path = Path.home() / \".cache\" / \"wake\"\n            elif system == \"Windows\":\n                self.__global_cache_path = Path(os.environ[\"TEMP\"]) / \"wake\"\n            else:\n                raise UnsupportedPlatformError(f\"Platform `{system}` is not supported.\")\n\n        self.__global_config_path.parent.mkdir(parents=True, exist_ok=True)\n        self.__global_data_path.mkdir(parents=True, exist_ok=True)\n\n        if project_root_path is None:\n            self.__project_root_path = Path.cwd().resolve()\n        else:\n            self.__project_root_path = Path(project_root_path).resolve()\n\n        if local_config_path is None:\n            self.__local_config_path = self.__project_root_path / \"wake.toml\"\n        else:\n            self.__local_config_path = Path(local_config_path).resolve()\n\n        if not self.__project_root_path.is_dir():\n            raise ValueError(\n                f\"Project root path '{self.__project_root_path}' is not a directory.\"\n            )\n\n        self.__loaded_files = set()\n        with change_cwd(self.__project_root_path):\n            self.__config = TopLevelConfig()\n        self.__config_raw = self.__config.model_dump(by_alias=True)\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Returns:\n            JSON representation of the config.\n        \"\"\"\n        return self.__config.model_dump_json(by_alias=True, exclude_unset=True)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Returns:\n            String representation of the config.\n        \"\"\"\n        config_dict = reprlib.repr(self.__config_raw)\n        return f\"{self.__class__.__name__}.fromdict({config_dict}, config_path={repr(self.__local_config_path)}, project_root_path={repr(self.__project_root_path)})\"\n\n    def __merge_dicts(self, old: Dict[str, Any], new: Dict[str, Any]) -&gt; None:\n        for k, v in new.items():\n            if k not in old.keys():\n                old[k] = v\n            else:\n                if isinstance(v, dict):\n                    self.__merge_dicts(old[k], new[k])\n                else:\n                    old[k] = v\n\n    def __modified_keys(self, old: Dict, new: Dict, result: Dict) -&gt; None:\n        for k, v in new.items():\n            if k not in old.keys():\n                result[k] = v\n            else:\n                if isinstance(v, dict):\n                    result[k] = {}\n                    self.__modified_keys(old[k], new[k], result[k])\n                    if not result[k]:\n                        del result[k]\n                else:\n                    if old[k] != v:\n                        result[k] = v\n        for k, v in old.items():\n            if k not in new.keys():\n                result[k] = None\n\n    def __load_file(\n        self,\n        parent: Optional[Path],\n        path: Path,\n        new_config: Dict[str, Any],\n        graph: nx.DiGraph,\n    ) -&gt; None:\n        if not path.is_file():\n            if parent is None:\n                logger.info(f\"Config file '{path}' does not exist.\")\n            else:\n                logger.warning(\n                    f\"Config file '{path}' loaded from '{parent}' does not exist.\"\n                )\n        else:\n            # change the current working dir so that we can resolve relative paths\n            with change_cwd(path.parent):\n                with path.open(\"rb\") as f:\n                    loaded_config = tomli.load(f)\n\n                graph.add_node(path, config=loaded_config)\n                if parent is not None:\n                    graph.add_edge(parent, path)\n\n                # detect cyclic subconfigs\n                if not nx.is_directed_acyclic_graph(graph):\n                    cycles = list(nx.simple_cycles(graph))\n                    error = f\"Found cyclic config subconfigs:\"\n                    for no, cycle in enumerate(cycles):\n                        error += f\"\\nCycle {no}:\\n\"\n                        for path in cycle:\n                            error += f\"{path}\\n\"\n                    raise ValueError(error)\n\n                # validate the loaded config\n                parsed_config = TopLevelConfig.model_validate(loaded_config)\n\n                # rebuild the loaded config from the pydantic model\n                # this ensures that all stored paths are absolute\n                loaded_config = parsed_config.model_dump(\n                    by_alias=True, exclude_unset=True\n                )\n\n                # merge the original config and the newly loaded config\n                self.__merge_dicts(new_config, loaded_config)\n\n                for subconfig_path in parsed_config.subconfigs:\n                    self.__load_file(path, subconfig_path, new_config, graph)\n\n    @classmethod\n    def fromdict(\n        cls,\n        config_dict: Dict[str, Any],\n        *,\n        project_root_path: Optional[Union[str, Path]] = None,\n    ) -&gt; \"WakeConfig\":\n        \"\"\"\n        Args:\n            config_dict: Dictionary containing the config options.\n            project_root_path: Path to the project root directory.\n\n        Returns:\n            Instance of the `WakeConfig` class with the provided config options.\n        \"\"\"\n        instance = cls(project_root_path=project_root_path)\n        with change_cwd(instance.project_root_path):\n            parsed_config = TopLevelConfig.model_validate(config_dict)\n        instance.__config_raw = parsed_config.model_dump(\n            by_alias=True, exclude_unset=True\n        )\n        instance.__config = parsed_config\n        return instance\n\n    def todict(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Returns:\n            Dictionary containing the config options.\n        \"\"\"\n        return self.__config_raw\n\n    def set(\n        self,\n        config_dict: Dict[str, Any],\n        deleted_options: Iterable[Tuple[Union[int, str], ...]],\n    ) -&gt; Dict:\n        \"\"\"\n        Set the config to a new dictionary.\n\n        Args:\n            config_dict: Dictionary containing the new config options.\n            deleted_options: Iterable of config option paths (in the form of tuples of string keys and integer indices) that should be deleted from the config (reset to their default values).\n\n        Returns:\n            Dictionary containing the modified config options.\n        \"\"\"\n        with change_cwd(self.project_root_path):\n            parsed_config = TopLevelConfig.model_validate(config_dict)\n        parsed_config_raw = parsed_config.model_dump(by_alias=True, exclude_unset=True)\n\n        original_config = deepcopy(self.__config_raw)\n        self.__config_raw = parsed_config_raw\n\n        for deleted_option in deleted_options:\n            conf = self.__config_raw\n            skip = False\n            for segment in deleted_option[:-1]:\n                if segment in conf:\n                    conf = conf[segment]  # type: ignore\n                else:\n                    skip = True\n                    break\n\n            if skip:\n                continue\n            if isinstance(conf, dict):\n                conf.pop(deleted_option[-1], None)  # type: ignore\n            elif isinstance(conf, list):\n                try:\n                    conf.remove(deleted_option[-1])\n                except ValueError:\n                    pass\n\n        self.__config = TopLevelConfig.model_validate(self.__config_raw)\n        modified_keys = {}\n        self.__modified_keys(\n            original_config,\n            self.__config.model_dump(by_alias=True, exclude_unset=True),\n            modified_keys,\n        )\n        return modified_keys\n\n    def update(\n        self,\n        config_dict: Dict[str, Any],\n        deleted_options: Iterable[Tuple[Union[int, str], ...]],\n    ) -&gt; Dict:\n        \"\"\"\n        Update the config with a new dictionary.\n\n        Args:\n            config_dict: Dictionary containing the new config options.\n            deleted_options: Iterable of config option paths (in the form of tuples of string keys and integer indices) that should be deleted from the config (reset to their default values).\n\n        Returns:\n            Dictionary containing the modified config options.\n        \"\"\"\n        with change_cwd(self.project_root_path):\n            parsed_config = TopLevelConfig.model_validate(config_dict)\n        parsed_config_raw = parsed_config.model_dump(by_alias=True, exclude_unset=True)\n\n        original_config = deepcopy(self.__config_raw)\n        self.__merge_dicts(self.__config_raw, parsed_config_raw)\n\n        for deleted_option in deleted_options:\n            conf = self.__config_raw\n            skip = False\n            for segment in deleted_option[:-1]:\n                if segment in conf:\n                    conf = conf[segment]  # type: ignore\n                else:\n                    skip = True\n                    break\n\n            if skip:\n                continue\n            if isinstance(conf, dict):\n                conf.pop(deleted_option[-1], None)  # type: ignore\n            elif isinstance(conf, list):\n                try:\n                    conf.remove(deleted_option[-1])\n                except ValueError:\n                    pass\n\n        self.__config = TopLevelConfig.model_validate(self.__config_raw)\n        modified_keys = {}\n        self.__modified_keys(\n            original_config,\n            self.__config.model_dump(by_alias=True, exclude_unset=True),\n            modified_keys,\n        )\n        return modified_keys\n\n    def load_configs(self) -&gt; None:\n        \"\"\"\n        Clear any previous config options and load both the global config file `config.toml`\n        located in the Wake root directory and the project specific local config file.\n        Typically, this is expected to be called right after `WakeConfig` instantiation.\n        \"\"\"\n        self.__loaded_files = set()\n        with change_cwd(self.__project_root_path):\n            self.__config = TopLevelConfig()\n        self.__config_raw = self.__config.model_dump(by_alias=True)\n\n        self.load(self.global_config_path)\n        self.load(self.local_config_path)\n\n    def load(self, path: Path) -&gt; None:\n        \"\"\"\n        Load config from the provided file path. Any already loaded config options are overridden by the options loaded\n        from this file.\n\n        Args:\n            path: System path to the config file.\n        \"\"\"\n        subconfigs_graph = nx.DiGraph()\n        config_raw_copy = deepcopy(self.__config_raw)\n\n        self.__load_file(None, path.resolve(), config_raw_copy, subconfigs_graph)\n\n        config = TopLevelConfig.model_validate(config_raw_copy)\n        self.__config_raw = config_raw_copy\n        self.__config = config\n        self.__loaded_files.update(\n            subconfigs_graph.nodes  # pyright: ignore reportGeneralTypeIssues\n        )\n\n    @property\n    def loaded_files(self) -&gt; FrozenSet[Path]:\n        \"\"\"\n        Returns:\n            All loaded config files, including files that were loaded using the `subconfigs` config key.\n        \"\"\"\n        return frozenset(self.__loaded_files)\n\n    @property\n    def local_config_path(self) -&gt; Path:\n        \"\"\"\n        Returns:\n            System path to the local config file.\n        \"\"\"\n        return self.__local_config_path\n\n    @local_config_path.setter\n    def local_config_path(self, path: Path) -&gt; None:\n        \"\"\"\n        Args:\n            path: New system path to the local config file.\n        \"\"\"\n        self.__local_config_path = path\n\n    @property\n    def global_config_path(self) -&gt; Path:\n        \"\"\"\n        Returns:\n            System path to the global config file.\n        \"\"\"\n        return self.__global_config_path\n\n    @property\n    def global_data_path(self) -&gt; Path:\n        \"\"\"\n        Returns:\n            System path to the global data directory.\n        \"\"\"\n        return self.__global_data_path\n\n    @property\n    def global_cache_path(self) -&gt; Path:\n        \"\"\"\n        Returns:\n            System path to the global cache directory.\n        \"\"\"\n        return self.__global_cache_path\n\n    @property\n    def project_root_path(self) -&gt; Path:\n        \"\"\"\n        Returns:\n            System path to the project root directory.\n        \"\"\"\n        return self.__project_root_path\n\n    @property\n    def min_solidity_version(self) -&gt; SolidityVersion:\n        \"\"\"\n        Returns:\n            Minimum supported Solidity version.\n        \"\"\"\n        return SolidityVersion.fromstring(\"0.6.2\")\n\n    @property\n    def max_solidity_version(self) -&gt; SolidityVersion:\n        \"\"\"\n        Returns:\n            Maximum supported Solidity version.\n        \"\"\"\n        return SolidityVersion.fromstring(\"0.8.26\")\n\n    @property\n    def detectors(self) -&gt; DetectorsConfig:\n        \"\"\"\n        Returns:\n            General config options for all detectors.\n        \"\"\"\n        return self.__config.detectors\n\n    @property\n    def detector(self) -&gt; DetectorConfig:\n        \"\"\"\n        Returns:\n            Per-detector config options.\n        \"\"\"\n        return self.__config.detector\n\n    @property\n    def api_keys(self) -&gt; Dict[str, str]:\n        \"\"\"\n        Returns:\n            API keys for various services.\n        \"\"\"\n        return self.__config.api_keys\n\n    @property\n    def compiler(self) -&gt; CompilerConfig:\n        \"\"\"\n        Returns:\n            Compiler config options.\n        \"\"\"\n        return self.__config.compiler\n\n    @property\n    def generator(self) -&gt; GeneratorConfig:\n        \"\"\"\n        Returns:\n            Config options for specific to assets generated by Wake.\n        \"\"\"\n        return self.__config.generator\n\n    @property\n    def lsp(self) -&gt; LspConfig:\n        \"\"\"\n        Returns:\n            LSP config options.\n        \"\"\"\n        return self.__config.lsp\n\n    @property\n    def testing(self) -&gt; TestingConfig:\n        \"\"\"\n        Returns:\n            Testing config options.\n        \"\"\"\n        return self.__config.testing\n\n    @property\n    def deployment(self) -&gt; DeploymentConfig:\n        \"\"\"\n        Returns:\n            Deployment config options.\n        \"\"\"\n        return self.__config.deployment\n\n    @property\n    def general(self) -&gt; GeneralConfig:\n        \"\"\"\n        Returns:\n            General config options.\n        \"\"\"\n        return self.__config.general\n\n    @property\n    def printers(self) -&gt; PrintersConfig:\n        \"\"\"\n        Returns:\n            General config options for all printers.\n        \"\"\"\n        return self.__config.printers\n\n    @property\n    def printer(self) -&gt; PrinterConfig:\n        \"\"\"\n        Returns:\n            Per-printer config options.\n        \"\"\"\n        return self.__config.printer\n</code></pre>"},{"location":"api-reference/config/wake-config/#wake.config.wake_config.WakeConfig.api_keys","title":"<code>api_keys: Dict[str, str]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>API keys for various services.</p>"},{"location":"api-reference/config/wake-config/#wake.config.wake_config.WakeConfig.compiler","title":"<code>compiler: CompilerConfig</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>CompilerConfig</code> <p>Compiler config options.</p>"},{"location":"api-reference/config/wake-config/#wake.config.wake_config.WakeConfig.deployment","title":"<code>deployment: DeploymentConfig</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>DeploymentConfig</code> <p>Deployment config options.</p>"},{"location":"api-reference/config/wake-config/#wake.config.wake_config.WakeConfig.detector","title":"<code>detector: DetectorConfig</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>DetectorConfig</code> <p>Per-detector config options.</p>"},{"location":"api-reference/config/wake-config/#wake.config.wake_config.WakeConfig.detectors","title":"<code>detectors: DetectorsConfig</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>DetectorsConfig</code> <p>General config options for all detectors.</p>"},{"location":"api-reference/config/wake-config/#wake.config.wake_config.WakeConfig.general","title":"<code>general: GeneralConfig</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>GeneralConfig</code> <p>General config options.</p>"},{"location":"api-reference/config/wake-config/#wake.config.wake_config.WakeConfig.generator","title":"<code>generator: GeneratorConfig</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>GeneratorConfig</code> <p>Config options for specific to assets generated by Wake.</p>"},{"location":"api-reference/config/wake-config/#wake.config.wake_config.WakeConfig.global_cache_path","title":"<code>global_cache_path: Path</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Path</code> <p>System path to the global cache directory.</p>"},{"location":"api-reference/config/wake-config/#wake.config.wake_config.WakeConfig.global_config_path","title":"<code>global_config_path: Path</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Path</code> <p>System path to the global config file.</p>"},{"location":"api-reference/config/wake-config/#wake.config.wake_config.WakeConfig.global_data_path","title":"<code>global_data_path: Path</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Path</code> <p>System path to the global data directory.</p>"},{"location":"api-reference/config/wake-config/#wake.config.wake_config.WakeConfig.loaded_files","title":"<code>loaded_files: FrozenSet[Path]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>FrozenSet[Path]</code> <p>All loaded config files, including files that were loaded using the <code>subconfigs</code> config key.</p>"},{"location":"api-reference/config/wake-config/#wake.config.wake_config.WakeConfig.local_config_path","title":"<code>local_config_path: Path</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>Path</code> <p>System path to the local config file.</p>"},{"location":"api-reference/config/wake-config/#wake.config.wake_config.WakeConfig.lsp","title":"<code>lsp: LspConfig</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>LspConfig</code> <p>LSP config options.</p>"},{"location":"api-reference/config/wake-config/#wake.config.wake_config.WakeConfig.max_solidity_version","title":"<code>max_solidity_version: SolidityVersion</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>SolidityVersion</code> <p>Maximum supported Solidity version.</p>"},{"location":"api-reference/config/wake-config/#wake.config.wake_config.WakeConfig.min_solidity_version","title":"<code>min_solidity_version: SolidityVersion</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>SolidityVersion</code> <p>Minimum supported Solidity version.</p>"},{"location":"api-reference/config/wake-config/#wake.config.wake_config.WakeConfig.printer","title":"<code>printer: PrinterConfig</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>PrinterConfig</code> <p>Per-printer config options.</p>"},{"location":"api-reference/config/wake-config/#wake.config.wake_config.WakeConfig.printers","title":"<code>printers: PrintersConfig</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>PrintersConfig</code> <p>General config options for all printers.</p>"},{"location":"api-reference/config/wake-config/#wake.config.wake_config.WakeConfig.project_root_path","title":"<code>project_root_path: Path</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Path</code> <p>System path to the project root directory.</p>"},{"location":"api-reference/config/wake-config/#wake.config.wake_config.WakeConfig.testing","title":"<code>testing: TestingConfig</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>TestingConfig</code> <p>Testing config options.</p>"},{"location":"api-reference/config/wake-config/#wake.config.wake_config.WakeConfig.__init__","title":"<code>__init__(*_, local_config_path=None, project_root_path=None)</code>","text":"<p>Initialize the <code>WakeConfig</code> class. If <code>project_root_path</code> is not provided, the current working directory is used. If <code>local_config_path</code> is not provided, the <code>wake.toml</code> file in the project root directory is used.</p> Source code in <code>wake/config/wake_config.py</code> <pre><code>def __init__(\n    self,\n    *_,\n    local_config_path: Optional[Union[str, Path]] = None,\n    project_root_path: Optional[Union[str, Path]] = None,\n):\n    \"\"\"\n    Initialize the `WakeConfig` class. If `project_root_path` is not provided, the current working directory is used.\n    If `local_config_path` is not provided, the `wake.toml` file in the project root directory is used.\n    \"\"\"\n    system = platform.system()\n\n    try:\n        self.__global_config_path = (\n            Path(os.environ[\"XDG_CONFIG_HOME\"]) / \"wake\" / \"config.toml\"\n        )\n    except KeyError:\n        if system in {\"Linux\", \"Darwin\"}:\n            self.__global_config_path = (\n                Path.home() / \".config\" / \"wake\" / \"config.toml\"\n            )\n        elif system == \"Windows\":\n            self.__global_config_path = (\n                Path(os.environ[\"LOCALAPPDATA\"]) / \"wake\" / \"config.toml\"\n            )\n        else:\n            raise UnsupportedPlatformError(f\"Platform `{system}` is not supported.\")\n\n    try:\n        self.__global_data_path = Path(os.environ[\"XDG_DATA_HOME\"]) / \"wake\"\n    except KeyError:\n        if system in {\"Linux\", \"Darwin\"}:\n            self.__global_data_path = Path.home() / \".local\" / \"share\" / \"wake\"\n        elif system == \"Windows\":\n            self.__global_data_path = Path(os.environ[\"LOCALAPPDATA\"]) / \"wake\"\n        else:\n            raise UnsupportedPlatformError(f\"Platform `{system}` is not supported.\")\n\n    try:\n        self.__global_cache_path = Path(os.environ[\"XDG_CACHE_HOME\"]) / \"wake\"\n    except KeyError:\n        if system in {\"Linux\", \"Darwin\"}:\n            self.__global_cache_path = Path.home() / \".cache\" / \"wake\"\n        elif system == \"Windows\":\n            self.__global_cache_path = Path(os.environ[\"TEMP\"]) / \"wake\"\n        else:\n            raise UnsupportedPlatformError(f\"Platform `{system}` is not supported.\")\n\n    self.__global_config_path.parent.mkdir(parents=True, exist_ok=True)\n    self.__global_data_path.mkdir(parents=True, exist_ok=True)\n\n    if project_root_path is None:\n        self.__project_root_path = Path.cwd().resolve()\n    else:\n        self.__project_root_path = Path(project_root_path).resolve()\n\n    if local_config_path is None:\n        self.__local_config_path = self.__project_root_path / \"wake.toml\"\n    else:\n        self.__local_config_path = Path(local_config_path).resolve()\n\n    if not self.__project_root_path.is_dir():\n        raise ValueError(\n            f\"Project root path '{self.__project_root_path}' is not a directory.\"\n        )\n\n    self.__loaded_files = set()\n    with change_cwd(self.__project_root_path):\n        self.__config = TopLevelConfig()\n    self.__config_raw = self.__config.model_dump(by_alias=True)\n</code></pre>"},{"location":"api-reference/config/wake-config/#wake.config.wake_config.WakeConfig.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>String representation of the config.</p> Source code in <code>wake/config/wake_config.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Returns:\n        String representation of the config.\n    \"\"\"\n    config_dict = reprlib.repr(self.__config_raw)\n    return f\"{self.__class__.__name__}.fromdict({config_dict}, config_path={repr(self.__local_config_path)}, project_root_path={repr(self.__project_root_path)})\"\n</code></pre>"},{"location":"api-reference/config/wake-config/#wake.config.wake_config.WakeConfig.__str__","title":"<code>__str__()</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>JSON representation of the config.</p> Source code in <code>wake/config/wake_config.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Returns:\n        JSON representation of the config.\n    \"\"\"\n    return self.__config.model_dump_json(by_alias=True, exclude_unset=True)\n</code></pre>"},{"location":"api-reference/config/wake-config/#wake.config.wake_config.WakeConfig.fromdict","title":"<code>fromdict(config_dict, *, project_root_path=None)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>config_dict</code> <code>Dict[str, Any]</code> <p>Dictionary containing the config options.</p> required <code>project_root_path</code> <code>Optional[Union[str, Path]]</code> <p>Path to the project root directory.</p> <code>None</code> <p>Returns:</p> Type Description <code>WakeConfig</code> <p>Instance of the <code>WakeConfig</code> class with the provided config options.</p> Source code in <code>wake/config/wake_config.py</code> <pre><code>@classmethod\ndef fromdict(\n    cls,\n    config_dict: Dict[str, Any],\n    *,\n    project_root_path: Optional[Union[str, Path]] = None,\n) -&gt; \"WakeConfig\":\n    \"\"\"\n    Args:\n        config_dict: Dictionary containing the config options.\n        project_root_path: Path to the project root directory.\n\n    Returns:\n        Instance of the `WakeConfig` class with the provided config options.\n    \"\"\"\n    instance = cls(project_root_path=project_root_path)\n    with change_cwd(instance.project_root_path):\n        parsed_config = TopLevelConfig.model_validate(config_dict)\n    instance.__config_raw = parsed_config.model_dump(\n        by_alias=True, exclude_unset=True\n    )\n    instance.__config = parsed_config\n    return instance\n</code></pre>"},{"location":"api-reference/config/wake-config/#wake.config.wake_config.WakeConfig.load","title":"<code>load(path)</code>","text":"<p>Load config from the provided file path. Any already loaded config options are overridden by the options loaded from this file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>System path to the config file.</p> required Source code in <code>wake/config/wake_config.py</code> <pre><code>def load(self, path: Path) -&gt; None:\n    \"\"\"\n    Load config from the provided file path. Any already loaded config options are overridden by the options loaded\n    from this file.\n\n    Args:\n        path: System path to the config file.\n    \"\"\"\n    subconfigs_graph = nx.DiGraph()\n    config_raw_copy = deepcopy(self.__config_raw)\n\n    self.__load_file(None, path.resolve(), config_raw_copy, subconfigs_graph)\n\n    config = TopLevelConfig.model_validate(config_raw_copy)\n    self.__config_raw = config_raw_copy\n    self.__config = config\n    self.__loaded_files.update(\n        subconfigs_graph.nodes  # pyright: ignore reportGeneralTypeIssues\n    )\n</code></pre>"},{"location":"api-reference/config/wake-config/#wake.config.wake_config.WakeConfig.load_configs","title":"<code>load_configs()</code>","text":"<p>Clear any previous config options and load both the global config file <code>config.toml</code> located in the Wake root directory and the project specific local config file. Typically, this is expected to be called right after <code>WakeConfig</code> instantiation.</p> Source code in <code>wake/config/wake_config.py</code> <pre><code>def load_configs(self) -&gt; None:\n    \"\"\"\n    Clear any previous config options and load both the global config file `config.toml`\n    located in the Wake root directory and the project specific local config file.\n    Typically, this is expected to be called right after `WakeConfig` instantiation.\n    \"\"\"\n    self.__loaded_files = set()\n    with change_cwd(self.__project_root_path):\n        self.__config = TopLevelConfig()\n    self.__config_raw = self.__config.model_dump(by_alias=True)\n\n    self.load(self.global_config_path)\n    self.load(self.local_config_path)\n</code></pre>"},{"location":"api-reference/config/wake-config/#wake.config.wake_config.WakeConfig.set","title":"<code>set(config_dict, deleted_options)</code>","text":"<p>Set the config to a new dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>config_dict</code> <code>Dict[str, Any]</code> <p>Dictionary containing the new config options.</p> required <code>deleted_options</code> <code>Iterable[Tuple[Union[int, str], ...]]</code> <p>Iterable of config option paths (in the form of tuples of string keys and integer indices) that should be deleted from the config (reset to their default values).</p> required <p>Returns:</p> Type Description <code>Dict</code> <p>Dictionary containing the modified config options.</p> Source code in <code>wake/config/wake_config.py</code> <pre><code>def set(\n    self,\n    config_dict: Dict[str, Any],\n    deleted_options: Iterable[Tuple[Union[int, str], ...]],\n) -&gt; Dict:\n    \"\"\"\n    Set the config to a new dictionary.\n\n    Args:\n        config_dict: Dictionary containing the new config options.\n        deleted_options: Iterable of config option paths (in the form of tuples of string keys and integer indices) that should be deleted from the config (reset to their default values).\n\n    Returns:\n        Dictionary containing the modified config options.\n    \"\"\"\n    with change_cwd(self.project_root_path):\n        parsed_config = TopLevelConfig.model_validate(config_dict)\n    parsed_config_raw = parsed_config.model_dump(by_alias=True, exclude_unset=True)\n\n    original_config = deepcopy(self.__config_raw)\n    self.__config_raw = parsed_config_raw\n\n    for deleted_option in deleted_options:\n        conf = self.__config_raw\n        skip = False\n        for segment in deleted_option[:-1]:\n            if segment in conf:\n                conf = conf[segment]  # type: ignore\n            else:\n                skip = True\n                break\n\n        if skip:\n            continue\n        if isinstance(conf, dict):\n            conf.pop(deleted_option[-1], None)  # type: ignore\n        elif isinstance(conf, list):\n            try:\n                conf.remove(deleted_option[-1])\n            except ValueError:\n                pass\n\n    self.__config = TopLevelConfig.model_validate(self.__config_raw)\n    modified_keys = {}\n    self.__modified_keys(\n        original_config,\n        self.__config.model_dump(by_alias=True, exclude_unset=True),\n        modified_keys,\n    )\n    return modified_keys\n</code></pre>"},{"location":"api-reference/config/wake-config/#wake.config.wake_config.WakeConfig.todict","title":"<code>todict()</code>","text":"<p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary containing the config options.</p> Source code in <code>wake/config/wake_config.py</code> <pre><code>def todict(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Returns:\n        Dictionary containing the config options.\n    \"\"\"\n    return self.__config_raw\n</code></pre>"},{"location":"api-reference/config/wake-config/#wake.config.wake_config.WakeConfig.update","title":"<code>update(config_dict, deleted_options)</code>","text":"<p>Update the config with a new dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>config_dict</code> <code>Dict[str, Any]</code> <p>Dictionary containing the new config options.</p> required <code>deleted_options</code> <code>Iterable[Tuple[Union[int, str], ...]]</code> <p>Iterable of config option paths (in the form of tuples of string keys and integer indices) that should be deleted from the config (reset to their default values).</p> required <p>Returns:</p> Type Description <code>Dict</code> <p>Dictionary containing the modified config options.</p> Source code in <code>wake/config/wake_config.py</code> <pre><code>def update(\n    self,\n    config_dict: Dict[str, Any],\n    deleted_options: Iterable[Tuple[Union[int, str], ...]],\n) -&gt; Dict:\n    \"\"\"\n    Update the config with a new dictionary.\n\n    Args:\n        config_dict: Dictionary containing the new config options.\n        deleted_options: Iterable of config option paths (in the form of tuples of string keys and integer indices) that should be deleted from the config (reset to their default values).\n\n    Returns:\n        Dictionary containing the modified config options.\n    \"\"\"\n    with change_cwd(self.project_root_path):\n        parsed_config = TopLevelConfig.model_validate(config_dict)\n    parsed_config_raw = parsed_config.model_dump(by_alias=True, exclude_unset=True)\n\n    original_config = deepcopy(self.__config_raw)\n    self.__merge_dicts(self.__config_raw, parsed_config_raw)\n\n    for deleted_option in deleted_options:\n        conf = self.__config_raw\n        skip = False\n        for segment in deleted_option[:-1]:\n            if segment in conf:\n                conf = conf[segment]  # type: ignore\n            else:\n                skip = True\n                break\n\n        if skip:\n            continue\n        if isinstance(conf, dict):\n            conf.pop(deleted_option[-1], None)  # type: ignore\n        elif isinstance(conf, list):\n            try:\n                conf.remove(deleted_option[-1])\n            except ValueError:\n                pass\n\n    self.__config = TopLevelConfig.model_validate(self.__config_raw)\n    modified_keys = {}\n    self.__modified_keys(\n        original_config,\n        self.__config.model_dump(by_alias=True, exclude_unset=True),\n        modified_keys,\n    )\n    return modified_keys\n</code></pre>"},{"location":"api-reference/core/solidity-version/","title":"solidity_version","text":""},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version","title":"<code>wake.core.solidity_version</code>  <code>module</code>","text":""},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SemanticVersion","title":"<code>SemanticVersion</code>  <code>class</code>","text":"<p>         Bases: <code>VersionAbc</code></p> <p>A class representing a single Solidity version (not a range of versions). Prerelease and build tags are parsed but ignored (even in comparison). As of <code>solc</code> version 0.8.11 there is no use for them.</p> Source code in <code>wake/core/solidity_version.py</code> <pre><code>class SemanticVersion(VersionAbc):\n    \"\"\"\n    A class representing a single Solidity version (not a range of versions).\n    Prerelease and build tags are parsed but ignored (even in comparison). As of `solc` version 0.8.11 there is no use for them.\n    \"\"\"\n\n    NUMBER = r\"0|[1-9][0-9]*\"\n    PRERELEASE_OR_BUILD_PART = r\"[-0-9A-Za-z]+\"\n    PRERELEASE_OR_BUILD = r\"{part}(?:\\.{part})*\".format(part=PRERELEASE_OR_BUILD_PART)\n    RE = re.compile(\n        r\"^(?P&lt;major&gt;{number})\\.(?P&lt;minor&gt;{number})\\.(?P&lt;patch&gt;{number})(?:-(?P&lt;prerelease&gt;{prerelease}))?(?:\\+(?P&lt;build&gt;{build}))?$\".format(\n            number=NUMBER, prerelease=PRERELEASE_OR_BUILD, build=PRERELEASE_OR_BUILD\n        )\n    )\n    __major: int\n    __minor: int\n    __patch: int\n    __prerelease: Optional[str]\n    __build: Optional[str]\n\n    def __init__(\n        self,\n        major: int,\n        minor: int,\n        patch: int,\n        prerelease: Optional[str] = None,\n        build: Optional[str] = None,\n    ):\n        \"\"\"\n        Create a new instance of `SemanticVersion`.\n\n        Args:\n            major: The major version number.\n            minor: The minor version number.\n            patch: The patch version number.\n            prerelease: The prerelease tag.\n            build: The build tag.\n        \"\"\"\n        self.__major = major\n        self.__minor = minor\n        self.__patch = patch\n        self.__prerelease = prerelease\n        self.__build = build\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Return a user-friendly string representation of the version.\n        \"\"\"\n        s = f\"{self.major}.{self.minor}.{self.patch}\"\n        if self.prerelease is not None:\n            s += f\"-{self.prerelease}\"\n        if self.build is not None:\n            s += f\"+{self.build}\"\n        return s\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Return a string representation of the version.\n        \"\"\"\n        prerelease = (\n            '\"' + self.prerelease + '\"' if self.prerelease is not None else None\n        )\n        build = '\"' + self.build + '\"' if self.build is not None else None\n        return f\"{self.__class__.__name__}({self.major}, {self.minor}, {self.patch}, {prerelease}, {build})\"\n\n    def __hash__(self) -&gt; int:\n        \"\"\"\n        Return a hash of the version. Prerelease and build tags are ignored.\n        \"\"\"\n        return hash((self.major, self.minor, self.patch))\n\n    def __eq__(self, other) -&gt; bool:\n        \"\"\"\n        Return `True` if the given version is equal to this version, `False` otherwise.\n        Prerelease and build tags are ignored.\n        \"\"\"\n        cls = self.__class__\n\n        if isinstance(other, str):\n            other = cls.fromstring(other)\n        elif not isinstance(other, cls):\n            return NotImplemented\n        return (\n            self.major == other.major\n            and self.minor == other.minor\n            and self.patch == other.patch\n        )\n\n    def __lt__(self, other) -&gt; bool:\n        \"\"\"\n        Return `True` if the given version is less than this version, `False` otherwise.\n        Prerelease and build tags are ignored.\n        \"\"\"\n        cls = self.__class__\n\n        if isinstance(other, str):\n            other = cls.fromstring(other)\n        elif not isinstance(other, self.__class__):\n            return NotImplemented\n        return (self.major, self.minor, self.patch) &lt; (\n            other.major,\n            other.minor,\n            other.patch,\n        )\n\n    def __le__(self, other) -&gt; bool:\n        \"\"\"\n        Return `True` if the given version is less than or equal to this version, `False` otherwise.\n        Prerelease and build tags are ignored.\n        \"\"\"\n        return self &lt; other or self == other\n\n    def __gt__(self, other):\n        \"\"\"\n        Return `True` if the given version is greater than this version, `False` otherwise.\n        Prerelease and build tags are ignored.\n        \"\"\"\n        lt = self &lt; other\n        if lt is NotImplemented:\n            return NotImplemented\n        return not lt and self != other\n\n    def __ge__(self, other):\n        \"\"\"\n        Return `True` if the given version is greater than or equal to this version, `False` otherwise.\n        Prerelease and build tags are ignored.\n        \"\"\"\n        lt = self &lt; other\n        if lt is NotImplemented:\n            return NotImplemented\n        return not lt\n\n    @classmethod\n    def fromstring(cls: Type[T], version_str: str) -&gt; T:\n        \"\"\"\n        Create a new instance of `SemanticVersion` from a string.\n\n        Args:\n            version_str: The string to parse.\n        \"\"\"\n        match = cls.RE.match(version_str)\n        if not match:\n            raise ValueError(f\"Invalid Solidity version: `{version_str}`\")\n        groups = match.groupdict()\n        major = int(groups[\"major\"])\n        minor = int(groups[\"minor\"])\n        patch = int(groups[\"patch\"])\n        prerelease = groups[\"prerelease\"]\n        build = groups[\"build\"]\n        return cls(major, minor, patch, prerelease, build)\n\n    @property\n    def major(self) -&gt; int:\n        \"\"\"\n        Return the major version number.\n        \"\"\"\n        return self.__major\n\n    @property\n    def minor(self) -&gt; int:\n        \"\"\"\n        Return the minor version number.\n        \"\"\"\n        return self.__minor\n\n    @property\n    def patch(self) -&gt; int:\n        \"\"\"\n        Return the patch version number.\n        \"\"\"\n        return self.__patch\n\n    @property\n    def prerelease(self) -&gt; Optional[str]:\n        \"\"\"\n        Return the prerelease tag.\n        \"\"\"\n        return self.__prerelease\n\n    @property\n    def build(self) -&gt; Optional[str]:\n        \"\"\"\n        Return the build tag.\n        \"\"\"\n        return self.__build\n</code></pre>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SemanticVersion.build","title":"<code>build: Optional[str]</code>  <code>property</code>","text":"<p>Return the build tag.</p>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SemanticVersion.major","title":"<code>major: int</code>  <code>property</code>","text":"<p>Return the major version number.</p>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SemanticVersion.minor","title":"<code>minor: int</code>  <code>property</code>","text":"<p>Return the minor version number.</p>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SemanticVersion.patch","title":"<code>patch: int</code>  <code>property</code>","text":"<p>Return the patch version number.</p>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SemanticVersion.prerelease","title":"<code>prerelease: Optional[str]</code>  <code>property</code>","text":"<p>Return the prerelease tag.</p>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SemanticVersion.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Return <code>True</code> if the given version is equal to this version, <code>False</code> otherwise. Prerelease and build tags are ignored.</p> Source code in <code>wake/core/solidity_version.py</code> <pre><code>def __eq__(self, other) -&gt; bool:\n    \"\"\"\n    Return `True` if the given version is equal to this version, `False` otherwise.\n    Prerelease and build tags are ignored.\n    \"\"\"\n    cls = self.__class__\n\n    if isinstance(other, str):\n        other = cls.fromstring(other)\n    elif not isinstance(other, cls):\n        return NotImplemented\n    return (\n        self.major == other.major\n        and self.minor == other.minor\n        and self.patch == other.patch\n    )\n</code></pre>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SemanticVersion.__ge__","title":"<code>__ge__(other)</code>","text":"<p>Return <code>True</code> if the given version is greater than or equal to this version, <code>False</code> otherwise. Prerelease and build tags are ignored.</p> Source code in <code>wake/core/solidity_version.py</code> <pre><code>def __ge__(self, other):\n    \"\"\"\n    Return `True` if the given version is greater than or equal to this version, `False` otherwise.\n    Prerelease and build tags are ignored.\n    \"\"\"\n    lt = self &lt; other\n    if lt is NotImplemented:\n        return NotImplemented\n    return not lt\n</code></pre>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SemanticVersion.__gt__","title":"<code>__gt__(other)</code>","text":"<p>Return <code>True</code> if the given version is greater than this version, <code>False</code> otherwise. Prerelease and build tags are ignored.</p> Source code in <code>wake/core/solidity_version.py</code> <pre><code>def __gt__(self, other):\n    \"\"\"\n    Return `True` if the given version is greater than this version, `False` otherwise.\n    Prerelease and build tags are ignored.\n    \"\"\"\n    lt = self &lt; other\n    if lt is NotImplemented:\n        return NotImplemented\n    return not lt and self != other\n</code></pre>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SemanticVersion.__hash__","title":"<code>__hash__()</code>","text":"<p>Return a hash of the version. Prerelease and build tags are ignored.</p> Source code in <code>wake/core/solidity_version.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"\n    Return a hash of the version. Prerelease and build tags are ignored.\n    \"\"\"\n    return hash((self.major, self.minor, self.patch))\n</code></pre>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SemanticVersion.__init__","title":"<code>__init__(major, minor, patch, prerelease=None, build=None)</code>","text":"<p>Create a new instance of <code>SemanticVersion</code>.</p> <p>Parameters:</p> Name Type Description Default <code>major</code> <code>int</code> <p>The major version number.</p> required <code>minor</code> <code>int</code> <p>The minor version number.</p> required <code>patch</code> <code>int</code> <p>The patch version number.</p> required <code>prerelease</code> <code>Optional[str]</code> <p>The prerelease tag.</p> <code>None</code> <code>build</code> <code>Optional[str]</code> <p>The build tag.</p> <code>None</code> Source code in <code>wake/core/solidity_version.py</code> <pre><code>def __init__(\n    self,\n    major: int,\n    minor: int,\n    patch: int,\n    prerelease: Optional[str] = None,\n    build: Optional[str] = None,\n):\n    \"\"\"\n    Create a new instance of `SemanticVersion`.\n\n    Args:\n        major: The major version number.\n        minor: The minor version number.\n        patch: The patch version number.\n        prerelease: The prerelease tag.\n        build: The build tag.\n    \"\"\"\n    self.__major = major\n    self.__minor = minor\n    self.__patch = patch\n    self.__prerelease = prerelease\n    self.__build = build\n</code></pre>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SemanticVersion.__le__","title":"<code>__le__(other)</code>","text":"<p>Return <code>True</code> if the given version is less than or equal to this version, <code>False</code> otherwise. Prerelease and build tags are ignored.</p> Source code in <code>wake/core/solidity_version.py</code> <pre><code>def __le__(self, other) -&gt; bool:\n    \"\"\"\n    Return `True` if the given version is less than or equal to this version, `False` otherwise.\n    Prerelease and build tags are ignored.\n    \"\"\"\n    return self &lt; other or self == other\n</code></pre>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SemanticVersion.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Return <code>True</code> if the given version is less than this version, <code>False</code> otherwise. Prerelease and build tags are ignored.</p> Source code in <code>wake/core/solidity_version.py</code> <pre><code>def __lt__(self, other) -&gt; bool:\n    \"\"\"\n    Return `True` if the given version is less than this version, `False` otherwise.\n    Prerelease and build tags are ignored.\n    \"\"\"\n    cls = self.__class__\n\n    if isinstance(other, str):\n        other = cls.fromstring(other)\n    elif not isinstance(other, self.__class__):\n        return NotImplemented\n    return (self.major, self.minor, self.patch) &lt; (\n        other.major,\n        other.minor,\n        other.patch,\n    )\n</code></pre>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SemanticVersion.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the version.</p> Source code in <code>wake/core/solidity_version.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Return a string representation of the version.\n    \"\"\"\n    prerelease = (\n        '\"' + self.prerelease + '\"' if self.prerelease is not None else None\n    )\n    build = '\"' + self.build + '\"' if self.build is not None else None\n    return f\"{self.__class__.__name__}({self.major}, {self.minor}, {self.patch}, {prerelease}, {build})\"\n</code></pre>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SemanticVersion.__str__","title":"<code>__str__()</code>","text":"<p>Return a user-friendly string representation of the version.</p> Source code in <code>wake/core/solidity_version.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Return a user-friendly string representation of the version.\n    \"\"\"\n    s = f\"{self.major}.{self.minor}.{self.patch}\"\n    if self.prerelease is not None:\n        s += f\"-{self.prerelease}\"\n    if self.build is not None:\n        s += f\"+{self.build}\"\n    return s\n</code></pre>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SemanticVersion.fromstring","title":"<code>fromstring(version_str)</code>  <code>classmethod</code>","text":"<p>Create a new instance of <code>SemanticVersion</code> from a string.</p> <p>Parameters:</p> Name Type Description Default <code>version_str</code> <code>str</code> <p>The string to parse.</p> required Source code in <code>wake/core/solidity_version.py</code> <pre><code>@classmethod\ndef fromstring(cls: Type[T], version_str: str) -&gt; T:\n    \"\"\"\n    Create a new instance of `SemanticVersion` from a string.\n\n    Args:\n        version_str: The string to parse.\n    \"\"\"\n    match = cls.RE.match(version_str)\n    if not match:\n        raise ValueError(f\"Invalid Solidity version: `{version_str}`\")\n    groups = match.groupdict()\n    major = int(groups[\"major\"])\n    minor = int(groups[\"minor\"])\n    patch = int(groups[\"patch\"])\n    prerelease = groups[\"prerelease\"]\n    build = groups[\"build\"]\n    return cls(major, minor, patch, prerelease, build)\n</code></pre>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SolidityVersion","title":"<code>SolidityVersion</code>  <code>class</code>","text":"<p>         Bases: <code>SemanticVersion</code></p> <p>A class representing a single Solidity version. Just an alias for SemanticVersion.</p> Source code in <code>wake/core/solidity_version.py</code> <pre><code>class SolidityVersion(SemanticVersion):\n    \"\"\"\n    A class representing a single Solidity version. Just an alias for [SemanticVersion](#semanticversion).\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SolidityVersionExpr","title":"<code>SolidityVersionExpr</code>  <code>class</code>","text":"<p>A class representing a Solidity version expression. It keeps the original expression string and a <code>SolidityVersionRanges</code> instance that represents the expression.</p> Source code in <code>wake/core/solidity_version.py</code> <pre><code>class SolidityVersionExpr:\n    \"\"\"\n    A class representing a Solidity version expression.\n    It keeps the original expression string and a `SolidityVersionRanges` instance that represents the expression.\n    \"\"\"\n\n    ERROR_MSG = r\"Invalid Solidity version expression: `{value}`\"\n    NUMBER = r\"x|X|\\*|0|[1-9][0-9]*\"\n    PARTIAL = r\"(?P&lt;major&gt;{number})\\s*(?:\\.\\s*(?P&lt;minor&gt;{number}))?\\s*(?:\\.\\s*(?P&lt;patch&gt;{number}))?\".format(\n        number=NUMBER\n    )\n    PARTIAL_RE = re.compile(r\"^\\s*{partial}\\s*$\".format(partial=PARTIAL))\n    PART = r\"(?P&lt;operator&gt;\\^|~|&lt;|&lt;=|&gt;|&gt;=|=)?\\s*{partial}\".format(partial=PARTIAL)\n    RANGE_RE = re.compile(r\"\\s*{part}\\s*\".format(part=PART))\n    RANGES_RE = re.compile(r\"^(\\s*{part}\\s*)+$\".format(part=PART))\n\n    __expression: str\n    __ranges: SolidityVersionRanges\n\n    def __init__(self, expr: str):\n        \"\"\"\n        Create a new instance of `SolidityVersionExpr`.\n\n        Args:\n            expr: The Solidity version expression to parse.\n        \"\"\"\n        cls = self.__class__\n        self.__expression = expr\n        evaluated_ranges = []\n\n        ranges = expr.split(\"||\")\n        for r in ranges:\n            if \"-\" in r:\n                evaluated_ranges.append(cls.__parse_hyphen_range(r))\n            else:\n                evaluated_ranges.append(cls.__parse_range(r))\n        self.__ranges = SolidityVersionRanges(evaluated_ranges)\n\n    @classmethod\n    def __parse_range(cls, range_str: str) -&gt; SolidityVersionRange:\n        check = cls.RANGES_RE.match(range_str)\n        if not check:\n            raise ValueError(cls.ERROR_MSG.format(value=range_str))\n\n        matches = cls.RANGE_RE.finditer(range_str)\n        ret = SolidityVersionRange(None, None, None, None)\n        for match in matches:\n            ret &amp;= cls.__parse_simple(match.groupdict(), match.string.strip())\n        return ret\n\n    @classmethod\n    def __parse_hyphen_range(cls, hyphen_range: str) -&gt; SolidityVersionRange:\n        partials = hyphen_range.split(\"-\")\n        if len(partials) != 2:\n            raise ValueError(cls.ERROR_MSG.format(value=hyphen_range))\n        match_left = cls.PARTIAL_RE.match(partials[0])\n        match_right = cls.PARTIAL_RE.match(partials[1])\n        if not match_left or not match_right:\n            raise ValueError(cls.ERROR_MSG.format(value=hyphen_range))\n\n        partial_left = cls.__parse_partial(\n            match_left.groupdict(), match_left.string.strip()\n        )\n        left = cls.__evaluate_ge(*partial_left)\n        partial_right = cls.__parse_partial(\n            match_right.groupdict(), match_right.string.strip()\n        )\n        right = cls.__evaluate_le(*partial_right, match_right.string.strip())\n        return left &amp; right\n\n    @classmethod\n    def __parse_partial(\n        cls, match_dict: Dict[str, Any], match_str: str\n    ) -&gt; Tuple[Optional[int], Optional[int], Optional[int]]:\n        major = match_dict[\"major\"]\n        minor = match_dict[\"minor\"]\n        patch = match_dict[\"patch\"]\n        if major in {None, \"x\", \"X\", \"*\"}:\n            major = None\n        else:\n            major = int(major)\n        if minor in {None, \"x\", \"X\", \"*\"}:\n            minor = None\n        else:\n            minor = int(minor)\n        if patch in {None, \"x\", \"X\", \"*\"}:\n            patch = None\n        else:\n            patch = int(patch)\n\n        # partials should be in ascending order, i.e.: 1.0.x, 1.x.x, x.x.x, not x.0.1 or 1.x.5\n        if (major is None and not all(x is None for x in (minor, patch))) or (\n            minor is None and patch is not None\n        ):\n            raise ValueError(cls.ERROR_MSG.format(value=match_str))\n\n        return major, minor, patch\n\n    @classmethod\n    def __evaluate_caret(\n        cls,\n        major: Optional[int],\n        minor: Optional[int],\n        patch: Optional[int],\n        match_str: str,\n    ) -&gt; SolidityVersionRange:\n        if major is None:\n            raise ValueError(cls.ERROR_MSG.format(value=match_str))\n        elif minor is None:\n            # ^1.x.x := &gt;=1.0.0 &lt; 2.0.0\n            v1 = SolidityVersion(major, 0, 0)\n            v2 = SolidityVersion(major + 1, 0, 0)\n            return SolidityVersionRange(v1, True, v2, False)\n        elif patch is None:\n            if major != 0:\n                # ^1.2.x := &gt;=1.2.0 &lt; 2.0.0\n                v1 = SolidityVersion(major, minor, 0)\n                v2 = SolidityVersion(major + 1, 0, 0)\n                return SolidityVersionRange(v1, True, v2, False)\n            else:\n                # ^0.2.x := &gt;=0.2.0 &lt;0.3.0\n                # ^0.0.x := &gt;=0.0.0 &lt;0.1.0\n                v1 = SolidityVersion(major, minor, 0)\n                v2 = SolidityVersion(major, minor + 1, 0)\n                return SolidityVersionRange(v1, True, v2, False)\n        elif major != 0:\n            # ^1.2.3 := &gt;=1.2.3 &lt;2.0.0\n            v1 = SolidityVersion(major, minor, patch)\n            v2 = SolidityVersion(major + 1, 0, 0)\n            return SolidityVersionRange(v1, True, v2, False)\n        elif minor != 0:\n            # ^0.2.3 := &gt;=0.2.3 &lt;0.3.0\n            v1 = SolidityVersion(major, minor, patch)\n            v2 = SolidityVersion(major, minor + 1, 0)\n            return SolidityVersionRange(v1, True, v2, False)\n        elif patch != 0:\n            # ^0.0.3 := &gt;=0.0.3 &lt;0.0.4\n            v1 = SolidityVersion(major, minor, patch)\n            v2 = SolidityVersion(major, minor, patch + 1)\n            return SolidityVersionRange(v1, True, v2, False)\n        else:\n            raise ValueError(cls.ERROR_MSG.format(value=match_str))\n\n    @classmethod\n    def __evaluate_tilde(\n        cls,\n        major: Optional[int],\n        minor: Optional[int],\n        patch: Optional[int],\n        match_str: str,\n    ) -&gt; SolidityVersionRange:\n        if major is None:\n            raise ValueError(cls.ERROR_MSG.format(value=match_str))\n        elif minor is None:\n            # ~1.x.x := &gt;=1.0.0 &lt;2.0.0\n            v1 = SolidityVersion(major, 0, 0)\n            v2 = SolidityVersion(major + 1, 0, 0)\n            return SolidityVersionRange(v1, True, v2, False)\n        elif patch is None:\n            # ~1.2.x := &gt;=1.2.0 &lt;1.3.0\n            v1 = SolidityVersion(major, minor, 0)\n            v2 = SolidityVersion(major, minor + 1, 0)\n            return SolidityVersionRange(v1, True, v2, False)\n        else:\n            # ~1.2.3 := &gt;=1.2.3 &lt;1.3.0\n            v1 = SolidityVersion(major, minor, patch)\n            v2 = SolidityVersion(major, minor + 1, 0)\n            return SolidityVersionRange(v1, True, v2, False)\n\n    @classmethod\n    def __evaluate_lt(\n        cls,\n        major: Optional[int],\n        minor: Optional[int],\n        patch: Optional[int],\n        match_str: str,\n    ) -&gt; SolidityVersionRange:\n        if major is None:\n            raise ValueError(cls.ERROR_MSG.format(value=match_str))\n        # &lt;1.x.x := &lt;1.0.0\n        # &lt;1.2.x := &lt;1.2.0\n        # &lt;1.2.3 := &lt;1.2.3\n        v2 = SolidityVersion(major, minor or 0, patch or 0)\n        return SolidityVersionRange(None, None, v2, False)\n\n    @classmethod\n    def __evaluate_le(\n        cls,\n        major: Optional[int],\n        minor: Optional[int],\n        patch: Optional[int],\n        match_str: str,\n    ) -&gt; SolidityVersionRange:\n        if major is None:\n            raise ValueError(cls.ERROR_MSG.format(value=match_str))\n        elif minor is None:\n            # &lt;=1.x.x := &lt;2.0.0\n            v2 = SolidityVersion(major + 1, 0, 0)\n            return SolidityVersionRange(None, None, v2, False)\n        elif patch is None:\n            # &lt;=1.2.x := &lt;1.3.0\n            v2 = SolidityVersion(major, minor + 1, 0)\n            return SolidityVersionRange(None, None, v2, False)\n        else:\n            # &lt;=1.2.3 := &lt;=1.2.3\n            v2 = SolidityVersion(major, minor, patch)\n            return SolidityVersionRange(None, None, v2, True)\n\n    @classmethod\n    def __evaluate_gt(\n        cls,\n        major: Optional[int],\n        minor: Optional[int],\n        patch: Optional[int],\n        match_str: str,\n    ) -&gt; SolidityVersionRange:\n        if major is None:\n            raise ValueError(cls.ERROR_MSG.format(value=match_str))\n        elif minor is None:\n            # &gt;1.x.x := &gt;=2.0.0\n            v1 = SolidityVersion(major + 1, 0, 0)\n            return SolidityVersionRange(v1, True, None, None)\n        elif patch is None:\n            # &gt;1.2.x := &gt;=1.3.0\n            v1 = SolidityVersion(major, minor + 1, 0)\n            return SolidityVersionRange(v1, True, None, None)\n        else:\n            # &gt;1.2.3 := &gt;1.2.3\n            v1 = SolidityVersion(major, minor, patch)\n            return SolidityVersionRange(v1, False, None, None)\n\n    @classmethod\n    def __evaluate_ge(\n        cls, major: Optional[int], minor: Optional[int], patch: Optional[int]\n    ) -&gt; SolidityVersionRange:\n        # &gt;=x.x.x := &gt;=0.0.0\n        # &gt;=1.x.x := &gt;=1.0.0\n        # &gt;=1.2.x := &gt;=1.2.0\n        # &gt;=1.2.3 := &gt;=1.2.3\n        v1 = SolidityVersion(major or 0, minor or 0, patch or 0)\n        return SolidityVersionRange(v1, True, None, None)\n\n    @classmethod\n    def __evaluate_eq(\n        cls, major: Optional[int], minor: Optional[int], patch: Optional[int]\n    ) -&gt; SolidityVersionRange:\n        # x.x.x := &gt;=0.0.0\n        if major is None:\n            return SolidityVersionRange(\"0.0.0\", True, None, None)\n        # 1.x.x := &gt;=1.0.0 &lt;2.0.0\n        elif minor is None:\n            v1 = SolidityVersion(major, 0, 0)\n            v2 = SolidityVersion(major + 1, 0, 0)\n            return SolidityVersionRange(v1, True, v2, False)\n        # 1.2.x := &gt;=1.2.0 &lt;1.3.0\n        elif patch is None:\n            v1 = SolidityVersion(major, minor, 0)\n            v2 = SolidityVersion(major, minor + 1, 0)\n            return SolidityVersionRange(v1, True, v2, False)\n        # 1.2.3 := &gt;=1.2.3 &lt;=1.2.3\n        else:\n            v = SolidityVersion(major, minor, patch)\n            return SolidityVersionRange(v, True, v, True)\n\n    @classmethod\n    def __parse_simple(cls, match_dict: dict, match_str: str) -&gt; SolidityVersionRange:\n        operator: Optional[str] = match_dict[\"operator\"]\n        major, minor, patch = cls.__parse_partial(match_dict, match_str)\n\n        if operator == \"^\":\n            return cls.__evaluate_caret(major, minor, patch, match_str)\n        elif operator == \"~\":\n            return cls.__evaluate_tilde(major, minor, patch, match_str)\n        elif operator == \"&lt;\":\n            return cls.__evaluate_lt(major, minor, patch, match_str)\n        elif operator == \"&lt;=\":\n            return cls.__evaluate_le(major, minor, patch, match_str)\n        elif operator == \"&gt;\":\n            return cls.__evaluate_gt(major, minor, patch, match_str)\n        elif operator == \"&gt;=\":\n            return cls.__evaluate_ge(major, minor, patch)\n        elif operator == \"=\" or operator is None:\n            return cls.__evaluate_eq(major, minor, patch)\n        else:\n            raise ValueError(cls.ERROR_MSG.format(value=match_str))\n\n    def __contains__(self, item: Any) -&gt; bool:\n        \"\"\"\n        Return `True` if the given Solidity version is contained in this range, `False` otherwise.\n\n        Args:\n            item: The Solidity version to check for containment. Can be either a `SolidityVersion` instance or a string.\n        \"\"\"\n        if isinstance(item, str):\n            item = SolidityVersion.fromstring(item)\n        if not isinstance(item, SolidityVersion):\n            return NotImplemented\n        for r in self.__ranges:\n            if item in r:\n                return True\n        return False\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Return a user-friendly string representation of the range.\n        \"\"\"\n        return self.__expression\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Return a string representation of the range.\n        \"\"\"\n        return f'{self.__class__.__name__}(\"{str(self)}\")'\n\n    @property\n    def version_ranges(self) -&gt; SolidityVersionRanges:\n        \"\"\"\n        Return the parsed Solidity version ranges.\n        \"\"\"\n        return self.__ranges\n</code></pre>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SolidityVersionExpr.version_ranges","title":"<code>version_ranges: SolidityVersionRanges</code>  <code>property</code>","text":"<p>Return the parsed Solidity version ranges.</p>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SolidityVersionExpr.__contains__","title":"<code>__contains__(item)</code>","text":"<p>Return <code>True</code> if the given Solidity version is contained in this range, <code>False</code> otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>The Solidity version to check for containment. Can be either a <code>SolidityVersion</code> instance or a string.</p> required Source code in <code>wake/core/solidity_version.py</code> <pre><code>def __contains__(self, item: Any) -&gt; bool:\n    \"\"\"\n    Return `True` if the given Solidity version is contained in this range, `False` otherwise.\n\n    Args:\n        item: The Solidity version to check for containment. Can be either a `SolidityVersion` instance or a string.\n    \"\"\"\n    if isinstance(item, str):\n        item = SolidityVersion.fromstring(item)\n    if not isinstance(item, SolidityVersion):\n        return NotImplemented\n    for r in self.__ranges:\n        if item in r:\n            return True\n    return False\n</code></pre>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SolidityVersionExpr.__init__","title":"<code>__init__(expr)</code>","text":"<p>Create a new instance of <code>SolidityVersionExpr</code>.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>str</code> <p>The Solidity version expression to parse.</p> required Source code in <code>wake/core/solidity_version.py</code> <pre><code>def __init__(self, expr: str):\n    \"\"\"\n    Create a new instance of `SolidityVersionExpr`.\n\n    Args:\n        expr: The Solidity version expression to parse.\n    \"\"\"\n    cls = self.__class__\n    self.__expression = expr\n    evaluated_ranges = []\n\n    ranges = expr.split(\"||\")\n    for r in ranges:\n        if \"-\" in r:\n            evaluated_ranges.append(cls.__parse_hyphen_range(r))\n        else:\n            evaluated_ranges.append(cls.__parse_range(r))\n    self.__ranges = SolidityVersionRanges(evaluated_ranges)\n</code></pre>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SolidityVersionExpr.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the range.</p> Source code in <code>wake/core/solidity_version.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Return a string representation of the range.\n    \"\"\"\n    return f'{self.__class__.__name__}(\"{str(self)}\")'\n</code></pre>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SolidityVersionExpr.__str__","title":"<code>__str__()</code>","text":"<p>Return a user-friendly string representation of the range.</p> Source code in <code>wake/core/solidity_version.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Return a user-friendly string representation of the range.\n    \"\"\"\n    return self.__expression\n</code></pre>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SolidityVersionRange","title":"<code>SolidityVersionRange</code>  <code>class</code>","text":"<p>A class representing a range of Solidity versions by keeping the lower and the higher bound. Both bounds can be inclusive or non-inclusive. In case the lower bound is unspecified, the default value 0.0.0 (inclusive) is used. If the lower bound is semantically greater than the higher bound, create an empty range.</p> Source code in <code>wake/core/solidity_version.py</code> <pre><code>class SolidityVersionRange:\n    \"\"\"\n    A class representing a range of Solidity versions by keeping the lower and the higher bound.\n    Both bounds can be inclusive or non-inclusive.\n    In case the lower bound is unspecified, the default value 0.0.0 (inclusive) is used.\n    If the lower bound is semantically greater than the higher bound, create an empty range.\n    \"\"\"\n\n    __lower: SolidityVersion\n    __lower_inclusive: bool\n    __higher: Optional[SolidityVersion]\n    __higher_inclusive: Optional[bool]\n\n    def __init__(\n        self,\n        lower_bound: Optional[Union[SolidityVersion, str]],\n        lower_inclusive: Optional[bool],\n        higher_bound: Optional[Union[SolidityVersion, str]],\n        higher_inclusive: Optional[bool],\n    ):\n        \"\"\"\n        Create a new instance of `SolidityVersionRange`.\n\n        Args:\n            lower_bound: The lower bound of the range. If `None`, the default value 0.0.0 is used.\n            lower_inclusive: If `True`, the lower bound is inclusive, otherwise it is non-inclusive.\n                May only be `None` if `lower_bound` is `None`.\n            higher_bound: The higher bound of the range. If `None`, the range is unbounded.\n            higher_inclusive: If `True`, the higher bound is inclusive, otherwise it is non-inclusive.\n                May only be `None` if `higher_bound` is `None`.\n        \"\"\"\n        if (lower_bound is None) != (lower_inclusive is None):\n            raise ValueError(\n                \"Both arguments lower_bound and lower_inclusive must be either set or unset.\"\n            )\n        if (higher_bound is None) != (higher_inclusive is None):\n            raise ValueError(\n                \"Both arguments higher_bound and higher_inclusive must be either set or unset.\"\n            )\n\n        self.__lower_inclusive = True if lower_inclusive is None else lower_inclusive\n        if lower_bound is None:\n            self.__lower = SolidityVersion(0, 0, 0)\n        else:\n            self.__lower = SolidityVersion.fromstring(str(lower_bound))\n\n        self.__higher_inclusive = higher_inclusive\n        if higher_bound is None:\n            self.__higher = None\n        else:\n            self.__higher = SolidityVersion.fromstring(str(higher_bound))\n\n            if (\n                self.lower &gt; self.higher\n                or self.lower == self.higher\n                and (not lower_inclusive or not higher_inclusive)\n            ):\n                # create an empty range\n                self.__lower = SolidityVersion(0, 0, 0)\n                self.__lower_inclusive = False\n                self.__higher = self.lower\n                self.__higher_inclusive = False\n\n    def __contains__(self, item: Any) -&gt; bool:\n        \"\"\"\n        Return `True` if the given Solidity version is contained in this range, `False` otherwise.\n\n        Args:\n            item: The Solidity version to check for containment. Can be either a `SolidityVersion` instance or a string.\n        \"\"\"\n        if isinstance(item, str):\n            item = SolidityVersion.fromstring(item)\n        if not isinstance(item, SolidityVersion):\n            return NotImplemented\n        if self.isempty():\n            return False\n\n        lower_check = item &gt;= self.lower if self.lower_inclusive else item &gt; self.lower\n        if not lower_check or self.higher is None:\n            return lower_check\n        higher_check = (\n            item &lt;= self.higher if self.higher_inclusive else item &lt; self.higher\n        )\n        return lower_check and higher_check\n\n    def __hash__(self) -&gt; int:\n        \"\"\"\n        Return a hash of the range.\n        \"\"\"\n        return hash(\n            (\n                self.lower,\n                self.lower_inclusive,\n                self.higher,\n                self.higher_inclusive,\n            )\n        )\n\n    def __eq__(self, other) -&gt; bool:\n        \"\"\"\n        Return `True` if the given range is equal to this range, `False` otherwise.\n        \"\"\"\n        if not isinstance(other, SolidityVersionRange):\n            return NotImplemented\n        self_attr = (\n            self.lower,\n            self.lower_inclusive,\n            self.higher,\n            self.higher_inclusive,\n        )\n        other_attr = (\n            other.lower,\n            other.lower_inclusive,\n            other.higher,\n            other.higher_inclusive,\n        )\n        return self_attr == other_attr\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Return a user-friendly string representation of the range.\n        \"\"\"\n        s = f\"{'&gt;=' if self.lower_inclusive else '&gt;'}{self.lower}\"\n        if self.higher is not None:\n            s = s + f\" {'&lt;=' if self.higher_inclusive else '&lt;'}{self.higher}\"\n        return s\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Return a string representation of the range.\n        \"\"\"\n        lower = '\"' + str(self.lower) + '\"'\n        higher = '\"' + str(self.higher) + '\"' if self.higher is not None else None\n        return f\"{self.__class__.__name__}({lower}, {self.lower_inclusive}, {higher}, {self.higher_inclusive})\"\n\n    def __and__(self, other: \"SolidityVersionRange\") -&gt; \"SolidityVersionRange\":\n        \"\"\"\n        Perform an intersection of two Solidity version ranges and return a new instance of `SolidityVersionRange`.\n        \"\"\"\n        if self.lower &lt; other.lower:\n            lower_bound = other.lower\n            lower_inclusive = other.lower_inclusive\n        elif self.lower &gt; other.lower:\n            lower_bound = self.lower\n            lower_inclusive = self.lower_inclusive\n        else:\n            lower_bound = self.lower\n            if not self.lower_inclusive:\n                lower_inclusive = self.lower_inclusive\n            else:\n                lower_inclusive = other.lower_inclusive\n\n        if self.higher is None:\n            higher_bound = other.higher\n            higher_inclusive = other.higher_inclusive\n        elif other.higher is None:\n            higher_bound = self.higher\n            higher_inclusive = self.higher_inclusive\n        else:\n            if self.higher &lt; other.higher:\n                higher_bound = self.higher\n                higher_inclusive = self.higher_inclusive\n            elif self.higher &gt; other.higher:\n                higher_bound = other.higher\n                higher_inclusive = other.higher_inclusive\n            else:\n                higher_bound = self.higher\n                if not self.higher_inclusive:\n                    higher_inclusive = self.higher_inclusive\n                else:\n                    higher_inclusive = other.higher_inclusive\n\n        return SolidityVersionRange(\n            lower_bound, lower_inclusive, higher_bound, higher_inclusive\n        )\n\n    @classmethod\n    def intersection(cls, *args: \"SolidityVersionRange\") -&gt; \"SolidityVersionRange\":\n        \"\"\"\n        Perform an intersection of all `SolidityVersionRange` arguments and return a new instance of `SolidityVersionRange`.\n        \"\"\"\n        ret = cls(None, None, None, None)\n        for r in args:\n            ret &amp;= r\n        return ret\n\n    def isempty(self) -&gt; bool:\n        \"\"\"\n        Return `True` if the range is empty (no Solidity version can be contained in this range), `False` otherwise.\n        \"\"\"\n        return (\n            self.lower == SolidityVersion(0, 0, 0)\n            and not self.lower_inclusive\n            and self.higher == SolidityVersion(0, 0, 0)\n            and not self.higher_inclusive\n        )\n\n    @property\n    def lower(self) -&gt; SolidityVersion:\n        \"\"\"\n        Return the lower bound of the range.\n        \"\"\"\n        return self.__lower\n\n    @property\n    def lower_inclusive(self) -&gt; bool:\n        \"\"\"\n        Return `True` if the lower bound is inclusive, `False` otherwise.\n        \"\"\"\n        return self.__lower_inclusive\n\n    @property\n    def higher(self) -&gt; Optional[SolidityVersion]:\n        \"\"\"\n        Return the higher bound of the range, if any.\n        \"\"\"\n        return self.__higher\n\n    @property\n    def higher_inclusive(self) -&gt; Optional[bool]:\n        \"\"\"\n        Return `True` if the higher bound is inclusive, `False` if it is non-inclusive or `None` if the range is unbounded.\n        \"\"\"\n        return self.__higher_inclusive\n</code></pre>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SolidityVersionRange.higher","title":"<code>higher: Optional[SolidityVersion]</code>  <code>property</code>","text":"<p>Return the higher bound of the range, if any.</p>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SolidityVersionRange.higher_inclusive","title":"<code>higher_inclusive: Optional[bool]</code>  <code>property</code>","text":"<p>Return <code>True</code> if the higher bound is inclusive, <code>False</code> if it is non-inclusive or <code>None</code> if the range is unbounded.</p>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SolidityVersionRange.lower","title":"<code>lower: SolidityVersion</code>  <code>property</code>","text":"<p>Return the lower bound of the range.</p>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SolidityVersionRange.lower_inclusive","title":"<code>lower_inclusive: bool</code>  <code>property</code>","text":"<p>Return <code>True</code> if the lower bound is inclusive, <code>False</code> otherwise.</p>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SolidityVersionRange.__and__","title":"<code>__and__(other)</code>","text":"<p>Perform an intersection of two Solidity version ranges and return a new instance of <code>SolidityVersionRange</code>.</p> Source code in <code>wake/core/solidity_version.py</code> <pre><code>def __and__(self, other: \"SolidityVersionRange\") -&gt; \"SolidityVersionRange\":\n    \"\"\"\n    Perform an intersection of two Solidity version ranges and return a new instance of `SolidityVersionRange`.\n    \"\"\"\n    if self.lower &lt; other.lower:\n        lower_bound = other.lower\n        lower_inclusive = other.lower_inclusive\n    elif self.lower &gt; other.lower:\n        lower_bound = self.lower\n        lower_inclusive = self.lower_inclusive\n    else:\n        lower_bound = self.lower\n        if not self.lower_inclusive:\n            lower_inclusive = self.lower_inclusive\n        else:\n            lower_inclusive = other.lower_inclusive\n\n    if self.higher is None:\n        higher_bound = other.higher\n        higher_inclusive = other.higher_inclusive\n    elif other.higher is None:\n        higher_bound = self.higher\n        higher_inclusive = self.higher_inclusive\n    else:\n        if self.higher &lt; other.higher:\n            higher_bound = self.higher\n            higher_inclusive = self.higher_inclusive\n        elif self.higher &gt; other.higher:\n            higher_bound = other.higher\n            higher_inclusive = other.higher_inclusive\n        else:\n            higher_bound = self.higher\n            if not self.higher_inclusive:\n                higher_inclusive = self.higher_inclusive\n            else:\n                higher_inclusive = other.higher_inclusive\n\n    return SolidityVersionRange(\n        lower_bound, lower_inclusive, higher_bound, higher_inclusive\n    )\n</code></pre>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SolidityVersionRange.__contains__","title":"<code>__contains__(item)</code>","text":"<p>Return <code>True</code> if the given Solidity version is contained in this range, <code>False</code> otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>The Solidity version to check for containment. Can be either a <code>SolidityVersion</code> instance or a string.</p> required Source code in <code>wake/core/solidity_version.py</code> <pre><code>def __contains__(self, item: Any) -&gt; bool:\n    \"\"\"\n    Return `True` if the given Solidity version is contained in this range, `False` otherwise.\n\n    Args:\n        item: The Solidity version to check for containment. Can be either a `SolidityVersion` instance or a string.\n    \"\"\"\n    if isinstance(item, str):\n        item = SolidityVersion.fromstring(item)\n    if not isinstance(item, SolidityVersion):\n        return NotImplemented\n    if self.isempty():\n        return False\n\n    lower_check = item &gt;= self.lower if self.lower_inclusive else item &gt; self.lower\n    if not lower_check or self.higher is None:\n        return lower_check\n    higher_check = (\n        item &lt;= self.higher if self.higher_inclusive else item &lt; self.higher\n    )\n    return lower_check and higher_check\n</code></pre>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SolidityVersionRange.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Return <code>True</code> if the given range is equal to this range, <code>False</code> otherwise.</p> Source code in <code>wake/core/solidity_version.py</code> <pre><code>def __eq__(self, other) -&gt; bool:\n    \"\"\"\n    Return `True` if the given range is equal to this range, `False` otherwise.\n    \"\"\"\n    if not isinstance(other, SolidityVersionRange):\n        return NotImplemented\n    self_attr = (\n        self.lower,\n        self.lower_inclusive,\n        self.higher,\n        self.higher_inclusive,\n    )\n    other_attr = (\n        other.lower,\n        other.lower_inclusive,\n        other.higher,\n        other.higher_inclusive,\n    )\n    return self_attr == other_attr\n</code></pre>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SolidityVersionRange.__hash__","title":"<code>__hash__()</code>","text":"<p>Return a hash of the range.</p> Source code in <code>wake/core/solidity_version.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"\n    Return a hash of the range.\n    \"\"\"\n    return hash(\n        (\n            self.lower,\n            self.lower_inclusive,\n            self.higher,\n            self.higher_inclusive,\n        )\n    )\n</code></pre>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SolidityVersionRange.__init__","title":"<code>__init__(lower_bound, lower_inclusive, higher_bound, higher_inclusive)</code>","text":"<p>Create a new instance of <code>SolidityVersionRange</code>.</p> <p>Parameters:</p> Name Type Description Default <code>lower_bound</code> <code>Optional[Union[SolidityVersion, str]]</code> <p>The lower bound of the range. If <code>None</code>, the default value 0.0.0 is used.</p> required <code>lower_inclusive</code> <code>Optional[bool]</code> <p>If <code>True</code>, the lower bound is inclusive, otherwise it is non-inclusive. May only be <code>None</code> if <code>lower_bound</code> is <code>None</code>.</p> required <code>higher_bound</code> <code>Optional[Union[SolidityVersion, str]]</code> <p>The higher bound of the range. If <code>None</code>, the range is unbounded.</p> required <code>higher_inclusive</code> <code>Optional[bool]</code> <p>If <code>True</code>, the higher bound is inclusive, otherwise it is non-inclusive. May only be <code>None</code> if <code>higher_bound</code> is <code>None</code>.</p> required Source code in <code>wake/core/solidity_version.py</code> <pre><code>def __init__(\n    self,\n    lower_bound: Optional[Union[SolidityVersion, str]],\n    lower_inclusive: Optional[bool],\n    higher_bound: Optional[Union[SolidityVersion, str]],\n    higher_inclusive: Optional[bool],\n):\n    \"\"\"\n    Create a new instance of `SolidityVersionRange`.\n\n    Args:\n        lower_bound: The lower bound of the range. If `None`, the default value 0.0.0 is used.\n        lower_inclusive: If `True`, the lower bound is inclusive, otherwise it is non-inclusive.\n            May only be `None` if `lower_bound` is `None`.\n        higher_bound: The higher bound of the range. If `None`, the range is unbounded.\n        higher_inclusive: If `True`, the higher bound is inclusive, otherwise it is non-inclusive.\n            May only be `None` if `higher_bound` is `None`.\n    \"\"\"\n    if (lower_bound is None) != (lower_inclusive is None):\n        raise ValueError(\n            \"Both arguments lower_bound and lower_inclusive must be either set or unset.\"\n        )\n    if (higher_bound is None) != (higher_inclusive is None):\n        raise ValueError(\n            \"Both arguments higher_bound and higher_inclusive must be either set or unset.\"\n        )\n\n    self.__lower_inclusive = True if lower_inclusive is None else lower_inclusive\n    if lower_bound is None:\n        self.__lower = SolidityVersion(0, 0, 0)\n    else:\n        self.__lower = SolidityVersion.fromstring(str(lower_bound))\n\n    self.__higher_inclusive = higher_inclusive\n    if higher_bound is None:\n        self.__higher = None\n    else:\n        self.__higher = SolidityVersion.fromstring(str(higher_bound))\n\n        if (\n            self.lower &gt; self.higher\n            or self.lower == self.higher\n            and (not lower_inclusive or not higher_inclusive)\n        ):\n            # create an empty range\n            self.__lower = SolidityVersion(0, 0, 0)\n            self.__lower_inclusive = False\n            self.__higher = self.lower\n            self.__higher_inclusive = False\n</code></pre>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SolidityVersionRange.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the range.</p> Source code in <code>wake/core/solidity_version.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Return a string representation of the range.\n    \"\"\"\n    lower = '\"' + str(self.lower) + '\"'\n    higher = '\"' + str(self.higher) + '\"' if self.higher is not None else None\n    return f\"{self.__class__.__name__}({lower}, {self.lower_inclusive}, {higher}, {self.higher_inclusive})\"\n</code></pre>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SolidityVersionRange.__str__","title":"<code>__str__()</code>","text":"<p>Return a user-friendly string representation of the range.</p> Source code in <code>wake/core/solidity_version.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Return a user-friendly string representation of the range.\n    \"\"\"\n    s = f\"{'&gt;=' if self.lower_inclusive else '&gt;'}{self.lower}\"\n    if self.higher is not None:\n        s = s + f\" {'&lt;=' if self.higher_inclusive else '&lt;'}{self.higher}\"\n    return s\n</code></pre>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SolidityVersionRange.intersection","title":"<code>intersection(*args)</code>  <code>classmethod</code>","text":"<p>Perform an intersection of all <code>SolidityVersionRange</code> arguments and return a new instance of <code>SolidityVersionRange</code>.</p> Source code in <code>wake/core/solidity_version.py</code> <pre><code>@classmethod\ndef intersection(cls, *args: \"SolidityVersionRange\") -&gt; \"SolidityVersionRange\":\n    \"\"\"\n    Perform an intersection of all `SolidityVersionRange` arguments and return a new instance of `SolidityVersionRange`.\n    \"\"\"\n    ret = cls(None, None, None, None)\n    for r in args:\n        ret &amp;= r\n    return ret\n</code></pre>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SolidityVersionRange.isempty","title":"<code>isempty()</code>","text":"<p>Return <code>True</code> if the range is empty (no Solidity version can be contained in this range), <code>False</code> otherwise.</p> Source code in <code>wake/core/solidity_version.py</code> <pre><code>def isempty(self) -&gt; bool:\n    \"\"\"\n    Return `True` if the range is empty (no Solidity version can be contained in this range), `False` otherwise.\n    \"\"\"\n    return (\n        self.lower == SolidityVersion(0, 0, 0)\n        and not self.lower_inclusive\n        and self.higher == SolidityVersion(0, 0, 0)\n        and not self.higher_inclusive\n    )\n</code></pre>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SolidityVersionRanges","title":"<code>SolidityVersionRanges</code>  <code>class</code>","text":"<p>Helper class implementing intersection on List[SolidityVersionRange]. No normalization is performed, i.e. the ranges are taken as is without merging.</p> Source code in <code>wake/core/solidity_version.py</code> <pre><code>class SolidityVersionRanges:\n    \"\"\"\n    Helper class implementing intersection on List[SolidityVersionRange].\n    No normalization is performed, i.e. the ranges are taken as is without merging.\n    \"\"\"\n\n    __version_ranges: Tuple[SolidityVersionRange, ...]\n\n    def __init__(self, version_ranges: Iterable[SolidityVersionRange]):\n        \"\"\"\n        Create a new instance of `SolidityVersionRanges`.\n\n        Args:\n            version_ranges: The Solidity version ranges that this instance should represent.\n        \"\"\"\n        self.__version_ranges = tuple(version_ranges)\n\n    def __and__(self, other: Any):\n        \"\"\"\n        Perform an intersection of two `SolidityVersionRanges` and return a new instance of `SolidityVersionRanges`.\n\n        Args:\n            other: The other `SolidityVersionRanges` instance to intersect with.\n        \"\"\"\n        if not isinstance(other, SolidityVersionRanges):\n            return NotImplemented\n        ret = []\n        for r1, r2 in itertools.product(self.version_ranges, other.version_ranges):\n            new_range = r1 &amp; r2\n            if not new_range.isempty():\n                ret.append(new_range)\n        return SolidityVersionRanges(ret)\n\n    def __iter__(self):\n        for version_range in self.__version_ranges:\n            yield version_range\n\n    def __len__(self):\n        return len(self.__version_ranges)\n\n    def __str__(self):\n        return \" || \".join(\n            str(version_range) for version_range in self.__version_ranges\n        )\n\n    def __contains__(self, item):\n        if isinstance(item, str):\n            item = SolidityVersion.fromstring(item)\n        if not isinstance(item, SolidityVersion):\n            return NotImplemented\n        return any(item in version_range for version_range in self.__version_ranges)\n\n    @property\n    def version_ranges(self) -&gt; Tuple[SolidityVersionRange, ...]:\n        \"\"\"\n        Return the Solidity version ranges that this instance represents.\n        \"\"\"\n        return self.__version_ranges\n</code></pre>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SolidityVersionRanges.version_ranges","title":"<code>version_ranges: Tuple[SolidityVersionRange, ...]</code>  <code>property</code>","text":"<p>Return the Solidity version ranges that this instance represents.</p>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SolidityVersionRanges.__and__","title":"<code>__and__(other)</code>","text":"<p>Perform an intersection of two <code>SolidityVersionRanges</code> and return a new instance of <code>SolidityVersionRanges</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The other <code>SolidityVersionRanges</code> instance to intersect with.</p> required Source code in <code>wake/core/solidity_version.py</code> <pre><code>def __and__(self, other: Any):\n    \"\"\"\n    Perform an intersection of two `SolidityVersionRanges` and return a new instance of `SolidityVersionRanges`.\n\n    Args:\n        other: The other `SolidityVersionRanges` instance to intersect with.\n    \"\"\"\n    if not isinstance(other, SolidityVersionRanges):\n        return NotImplemented\n    ret = []\n    for r1, r2 in itertools.product(self.version_ranges, other.version_ranges):\n        new_range = r1 &amp; r2\n        if not new_range.isempty():\n            ret.append(new_range)\n    return SolidityVersionRanges(ret)\n</code></pre>"},{"location":"api-reference/core/solidity-version/#wake.core.solidity_version.SolidityVersionRanges.__init__","title":"<code>__init__(version_ranges)</code>","text":"<p>Create a new instance of <code>SolidityVersionRanges</code>.</p> <p>Parameters:</p> Name Type Description Default <code>version_ranges</code> <code>Iterable[SolidityVersionRange]</code> <p>The Solidity version ranges that this instance should represent.</p> required Source code in <code>wake/core/solidity_version.py</code> <pre><code>def __init__(self, version_ranges: Iterable[SolidityVersionRange]):\n    \"\"\"\n    Create a new instance of `SolidityVersionRanges`.\n\n    Args:\n        version_ranges: The Solidity version ranges that this instance should represent.\n    \"\"\"\n    self.__version_ranges = tuple(version_ranges)\n</code></pre>"},{"location":"api-reference/core/visitor/","title":"visitor","text":""},{"location":"api-reference/core/visitor/#wake.core.visitor","title":"<code>wake.core.visitor</code>  <code>module</code>","text":""},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor","title":"<code>Visitor</code>  <code>class</code>","text":"<p>Base class for detectors and printers. <code>visit_</code> methods are called automatically by the execution engine.</p> <p>Attributes:</p> Name Type Description <code>build</code> <code>ProjectBuild</code> <p>The latest compilation build of the project.</p> <code>build_info</code> <code>ProjectBuildInfo</code> <p>Information about the latest compilation build of the project.</p> <code>config</code> <code>WakeConfig</code> <p>The loaded Wake configuration.</p> <code>imports_graph</code> <code>DiGraph</code> <p>A directed graph representing the import dependencies of the project. Nodes are represented by string source unit names. Edges are directed from the imported source unit to the importing source unit.</p> <p>Nodes hold the following data attributes:</p> <ul> <li><code>path</code>: Path to the source unit file.</li> <li><code>versions</code>: SolidityVersionRanges describing allowed Solidity versions by pragma directives.</li> <li><code>hash</code>: bytes 256-bit BLAKE2b hash of the source unit file contents.</li> <li><code>content</code>: bytes source unit file contents.</li> </ul> <p>Warning</p> <p>Imports graph may contain source units that are not present in the build. This can happen for example because of a failed compilation.</p> <code>logger</code> <code>Logger</code> <p>A logger instance that can be used to log messages to the console. The log messages are redirected to a VS Code output window in the case of detectors running in the VS Code extension.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>class Visitor:\n    \"\"\"\n    Base class for detectors and printers. `visit_` methods are called automatically by the execution engine.\n\n    Attributes:\n        build: The latest compilation build of the project.\n        build_info: Information about the latest compilation build of the project.\n        config: The loaded Wake configuration.\n        imports_graph: A directed graph representing the import dependencies of the project.\n            Nodes are represented by string [source unit names](https://docs.soliditylang.org/en/latest/path-resolution.html).\n            Edges are directed from the imported source unit to the importing source unit.\n\n            Nodes hold the following data attributes:\n\n            - `path`: [Path][pathlib.Path] to the source unit file.\n            - `versions`: [SolidityVersionRanges][wake.core.solidity_version.SolidityVersionRanges] describing allowed Solidity versions by pragma directives.\n            - `hash`: [bytes][bytes] 256-bit BLAKE2b hash of the source unit file contents.\n            - `content`: [bytes][bytes] source unit file contents.\n\n            !!! warning\n                Imports graph may contain source units that are not present in the build. This can happen for example because of a failed compilation.\n\n        logger: A logger instance that can be used to log messages to the console. The log messages are redirected to a VS Code output window in the case of detectors running in the VS Code extension.\n    \"\"\"\n\n    build: ProjectBuild\n    build_info: ProjectBuildInfo\n    config: WakeConfig\n    imports_graph: nx.DiGraph\n    logger: logging.Logger\n\n    def visit_ir_abc(self, node: ir.IrAbc):\n        \"\"\"\n        Visit any [IrAbc][wake.ir.abc.IrAbc] node.\n        \"\"\"\n\n    def visit_solidity_abc(self, node: ir.SolidityAbc):\n        \"\"\"\n        Visit any [SolidityAbc][wake.ir.abc.SolidityAbc] node.\n        \"\"\"\n\n    def visit_yul_abc(self, node: ir.YulAbc):\n        \"\"\"\n        Visit any [YulAbc][wake.ir.yul.abc.YulAbc] node.\n        \"\"\"\n\n    def visit_yul_statement_abc(self, node: ir.YulStatementAbc):\n        \"\"\"\n        Visit any [YulStatementAbc][wake.ir.yul.abc.YulStatementAbc] node.\n        \"\"\"\n\n    # declarations\n    def visit_declaration_abc(self, node: ir.DeclarationAbc):\n        \"\"\"\n        Visit any [DeclarationAbc][wake.ir.declarations.abc.DeclarationAbc] node.\n        \"\"\"\n\n    def visit_contract_definition(self, node: ir.ContractDefinition):\n        \"\"\"\n        Visit [ContractDefinition][wake.ir.declarations.contract_definition.ContractDefinition] node.\n        \"\"\"\n\n    def visit_enum_definition(self, node: ir.EnumDefinition):\n        \"\"\"\n        Visit [EnumDefinition][wake.ir.declarations.enum_definition.EnumDefinition] node.\n        \"\"\"\n\n    def visit_enum_value(self, node: ir.EnumValue):\n        \"\"\"\n        Visit [EnumValue][wake.ir.declarations.enum_value.EnumValue] node.\n        \"\"\"\n\n    def visit_error_definition(self, node: ir.ErrorDefinition):\n        \"\"\"\n        Visit [ErrorDefinition][wake.ir.declarations.error_definition.ErrorDefinition] node.\n        \"\"\"\n\n    def visit_event_definition(self, node: ir.EventDefinition):\n        \"\"\"\n        Visit [EventDefinition][wake.ir.declarations.event_definition.EventDefinition] node.\n        \"\"\"\n\n    def visit_function_definition(self, node: ir.FunctionDefinition):\n        \"\"\"\n        Visit [FunctionDefinition][wake.ir.declarations.function_definition.FunctionDefinition] node.\n        \"\"\"\n\n    def visit_modifier_definition(self, node: ir.ModifierDefinition):\n        \"\"\"\n        Visit [ModifierDefinition][wake.ir.declarations.modifier_definition.ModifierDefinition] node.\n        \"\"\"\n\n    def visit_struct_definition(self, node: ir.StructDefinition):\n        \"\"\"\n        Visit [StructDefinition][wake.ir.declarations.struct_definition.StructDefinition] node.\n        \"\"\"\n\n    def visit_user_defined_value_type_definition(\n        self, node: ir.UserDefinedValueTypeDefinition\n    ):\n        \"\"\"\n        Visit [UserDefinedValueTypeDefinition][wake.ir.declarations.user_defined_value_type_definition.UserDefinedValueTypeDefinition] node.\n        \"\"\"\n\n    def visit_variable_declaration(self, node: ir.VariableDeclaration):\n        \"\"\"\n        Visit [VariableDeclaration][wake.ir.declarations.variable_declaration.VariableDeclaration] node.\n        \"\"\"\n\n    # expressions\n    def visit_expression_abc(self, node: ir.ExpressionAbc):\n        \"\"\"\n        Visit any [ExpressionAbc][wake.ir.expressions.abc.ExpressionAbc] node.\n        \"\"\"\n\n    def visit_assignment(self, node: ir.Assignment):\n        \"\"\"\n        Visit [Assignment][wake.ir.expressions.assignment.Assignment] node.\n        \"\"\"\n\n    def visit_binary_operation(self, node: ir.BinaryOperation):\n        \"\"\"\n        Visit [BinaryOperation][wake.ir.expressions.binary_operation.BinaryOperation] node.\n        \"\"\"\n\n    def visit_conditional(self, node: ir.Conditional):\n        \"\"\"\n        Visit [Conditional][wake.ir.expressions.conditional.Conditional] node.\n        \"\"\"\n\n    def visit_elementary_type_name_expression(\n        self, node: ir.ElementaryTypeNameExpression\n    ):\n        \"\"\"\n        Visit [ElementaryTypeNameExpression][wake.ir.expressions.elementary_type_name_expression.ElementaryTypeNameExpression] node.\n        \"\"\"\n\n    def visit_function_call(self, node: ir.FunctionCall):\n        \"\"\"\n        Visit [FunctionCall][wake.ir.expressions.function_call.FunctionCall] node.\n        \"\"\"\n\n    def visit_function_call_options(self, node: ir.FunctionCallOptions):\n        \"\"\"\n        Visit [FunctionCallOptions][wake.ir.expressions.function_call_options.FunctionCallOptions] node.\n        \"\"\"\n\n    def visit_identifier(self, node: ir.Identifier):\n        \"\"\"\n        Visit [Identifier][wake.ir.expressions.identifier.Identifier] node.\n        \"\"\"\n\n    def visit_index_access(self, node: ir.IndexAccess):\n        \"\"\"\n        Visit [IndexAccess][wake.ir.expressions.index_access.IndexAccess] node.\n        \"\"\"\n\n    def visit_index_range_access(self, node: ir.IndexRangeAccess):\n        \"\"\"\n        Visit [IndexRangeAccess][wake.ir.expressions.index_range_access.IndexRangeAccess] node.\n        \"\"\"\n\n    def visit_literal(self, node: ir.Literal):\n        \"\"\"\n        Visit [Literal][wake.ir.expressions.literal.Literal] node.\n        \"\"\"\n\n    def visit_member_access(self, node: ir.MemberAccess):\n        \"\"\"\n        Visit [MemberAccess][wake.ir.expressions.member_access.MemberAccess] node.\n        \"\"\"\n\n    def visit_new_expression(self, node: ir.NewExpression):\n        \"\"\"\n        Visit [NewExpression][wake.ir.expressions.new_expression.NewExpression] node.\n        \"\"\"\n\n    def visit_tuple_expression(self, node: ir.TupleExpression):\n        \"\"\"\n        Visit [TupleExpression][wake.ir.expressions.tuple_expression.TupleExpression] node.\n        \"\"\"\n\n    def visit_unary_operation(self, node: ir.UnaryOperation):\n        \"\"\"\n        Visit [UnaryOperation][wake.ir.expressions.unary_operation.UnaryOperation] node.\n        \"\"\"\n\n    # meta\n    def visit_identifier_path(self, node: ir.IdentifierPath):\n        \"\"\"\n        Visit [IdentifierPath][wake.ir.meta.identifier_path.IdentifierPath] node.\n        \"\"\"\n\n    def visit_import_directive(self, node: ir.ImportDirective):\n        \"\"\"\n        Visit [ImportDirective][wake.ir.meta.import_directive.ImportDirective] node.\n        \"\"\"\n\n    def visit_inheritance_specifier(self, node: ir.InheritanceSpecifier):\n        \"\"\"\n        Visit [InheritanceSpecifier][wake.ir.meta.inheritance_specifier.InheritanceSpecifier] node.\n        \"\"\"\n\n    def visit_modifier_invocation(self, node: ir.ModifierInvocation):\n        \"\"\"\n        Visit [ModifierInvocation][wake.ir.meta.modifier_invocation.ModifierInvocation] node.\n        \"\"\"\n\n    def visit_override_specifier(self, node: ir.OverrideSpecifier):\n        \"\"\"\n        Visit [OverrideSpecifier][wake.ir.meta.override_specifier.OverrideSpecifier] node.\n        \"\"\"\n\n    def visit_parameter_list(self, node: ir.ParameterList):\n        \"\"\"\n        Visit [ParameterList][wake.ir.meta.parameter_list.ParameterList] node.\n        \"\"\"\n\n    def visit_pragma_directive(self, node: ir.PragmaDirective):\n        \"\"\"\n        Visit [PragmaDirective][wake.ir.meta.pragma_directive.PragmaDirective] node.\n        \"\"\"\n\n    def visit_source_unit(self, node: ir.SourceUnit):\n        \"\"\"\n        Visit [SourceUnit][wake.ir.meta.source_unit.SourceUnit] node.\n        \"\"\"\n\n    def visit_structured_documentation(self, node: ir.StructuredDocumentation):\n        \"\"\"\n        Visit [StructuredDocumentation][wake.ir.meta.structured_documentation.StructuredDocumentation] node.\n        \"\"\"\n\n    def visit_try_catch_clause(self, node: ir.TryCatchClause):\n        \"\"\"\n        Visit [TryCatchClause][wake.ir.meta.try_catch_clause.TryCatchClause] node.\n        \"\"\"\n\n    def visit_using_for_directive(self, node: ir.UsingForDirective):\n        \"\"\"\n        Visit [UsingForDirective][wake.ir.meta.using_for_directive.UsingForDirective] node.\n        \"\"\"\n\n    # statements\n    def visit_statement_abc(self, node: ir.StatementAbc):\n        \"\"\"\n        Visit any [StatementAbc][wake.ir.statements.abc.StatementAbc] node.\n        \"\"\"\n\n    def visit_block(self, node: ir.Block):\n        \"\"\"\n        Visit [Block][wake.ir.statements.block.Block] node.\n        \"\"\"\n\n    def visit_break(self, node: ir.Break):\n        \"\"\"\n        Visit [Break][wake.ir.statements.break_statement.Break] node.\n        \"\"\"\n\n    def visit_continue(self, node: ir.Continue):\n        \"\"\"\n        Visit [Continue][wake.ir.statements.continue_statement.Continue] node.\n        \"\"\"\n\n    def visit_do_while_statement(self, node: ir.DoWhileStatement):\n        \"\"\"\n        Visit [DoWhileStatement][wake.ir.statements.do_while_statement.DoWhileStatement] node.\n        \"\"\"\n\n    def visit_emit_statement(self, node: ir.EmitStatement):\n        \"\"\"\n        Visit [EmitStatement][wake.ir.statements.emit_statement.EmitStatement] node.\n        \"\"\"\n\n    def visit_expression_statement(self, node: ir.ExpressionStatement):\n        \"\"\"\n        Visit [ExpressionStatement][wake.ir.statements.expression_statement.ExpressionStatement] node.\n        \"\"\"\n\n    def visit_for_statement(self, node: ir.ForStatement):\n        \"\"\"\n        Visit [ForStatement][wake.ir.statements.for_statement.ForStatement] node.\n        \"\"\"\n\n    def visit_if_statement(self, node: ir.IfStatement):\n        \"\"\"\n        Visit [IfStatement][wake.ir.statements.if_statement.IfStatement] node.\n        \"\"\"\n\n    def visit_inline_assembly(self, node: ir.InlineAssembly):\n        \"\"\"\n        Visit [InlineAssembly][wake.ir.statements.inline_assembly.InlineAssembly] node.\n        \"\"\"\n\n    def visit_placeholder_statement(self, node: ir.PlaceholderStatement):\n        \"\"\"\n        Visit [PlaceholderStatement][wake.ir.statements.placeholder_statement.PlaceholderStatement] node.\n        \"\"\"\n\n    def visit_return(self, node: ir.Return):\n        \"\"\"\n        Visit [Return][wake.ir.statements.return_statement.Return] node.\n        \"\"\"\n\n    def visit_revert_statement(self, node: ir.RevertStatement):\n        \"\"\"\n        Visit [RevertStatement][wake.ir.statements.revert_statement.RevertStatement] node.\n        \"\"\"\n\n    def visit_try_statement(self, node: ir.TryStatement):\n        \"\"\"\n        Visit [TryStatement][wake.ir.statements.try_statement.TryStatement] node.\n        \"\"\"\n\n    def visit_unchecked_block(self, node: ir.UncheckedBlock):\n        \"\"\"\n        Visit [UncheckedBlock][wake.ir.statements.unchecked_block.UncheckedBlock] node.\n        \"\"\"\n\n    def visit_variable_declaration_statement(\n        self, node: ir.VariableDeclarationStatement\n    ):\n        \"\"\"\n        Visit [VariableDeclarationStatement][wake.ir.statements.variable_declaration_statement.VariableDeclarationStatement] node.\n        \"\"\"\n\n    def visit_while_statement(self, node: ir.WhileStatement):\n        \"\"\"\n        Visit [WhileStatement][wake.ir.statements.while_statement.WhileStatement] node.\n        \"\"\"\n\n    # type names\n    def visit_type_name_abc(self, node: ir.TypeNameAbc):\n        \"\"\"\n        Visit any [TypeNameAbc][wake.ir.type_names.abc.TypeNameAbc] node.\n        \"\"\"\n\n    def visit_array_type_name(self, node: ir.ArrayTypeName):\n        \"\"\"\n        Visit [ArrayTypeName][wake.ir.type_names.array_type_name.ArrayTypeName] node.\n        \"\"\"\n\n    def visit_elementary_type_name(self, node: ir.ElementaryTypeName):\n        \"\"\"\n        Visit [ElementaryTypeName][wake.ir.type_names.elementary_type_name.ElementaryTypeName] node.\n        \"\"\"\n\n    def visit_function_type_name(self, node: ir.FunctionTypeName):\n        \"\"\"\n        Visit [FunctionTypeName][wake.ir.type_names.function_type_name.FunctionTypeName] node.\n        \"\"\"\n\n    def visit_mapping(self, node: ir.Mapping):\n        \"\"\"\n        Visit [Mapping][wake.ir.type_names.mapping.Mapping] node.\n        \"\"\"\n\n    def visit_user_defined_type_name(self, node: ir.UserDefinedTypeName):\n        \"\"\"\n        Visit [UserDefinedTypeName][wake.ir.type_names.user_defined_type_name.UserDefinedTypeName] node.\n        \"\"\"\n\n    # yul\n    def visit_yul_assignment(self, node: ir.YulAssignment):\n        \"\"\"\n        Visit [YulAssignment][wake.ir.yul.assignment.YulAssignment] node.\n        \"\"\"\n\n    def visit_yul_block(self, node: ir.YulBlock):\n        \"\"\"\n        Visit [YulBlock][wake.ir.yul.block.YulBlock] node.\n        \"\"\"\n\n    def visit_yul_break(self, node: ir.YulBreak):\n        \"\"\"\n        Visit [YulBreak][wake.ir.yul.break_statement.YulBreak] node.\n        \"\"\"\n\n    def visit_yul_case(self, node: ir.YulCase):\n        \"\"\"\n        Visit [YulCase][wake.ir.yul.case_.YulCase] node.\n        \"\"\"\n\n    def visit_yul_continue(self, node: ir.YulContinue):\n        \"\"\"\n        Visit [YulContinue][wake.ir.yul.continue_statement.YulContinue] node.\n        \"\"\"\n\n    def visit_yul_expression_statement(self, node: ir.YulExpressionStatement):\n        \"\"\"\n        Visit [YulExpressionStatement][wake.ir.yul.expression_statement.YulExpressionStatement] node.\n        \"\"\"\n\n    def visit_yul_for_loop(self, node: ir.YulForLoop):\n        \"\"\"\n        Visit [YulForLoop][wake.ir.yul.for_loop.YulForLoop] node.\n        \"\"\"\n\n    def visit_yul_function_call(self, node: ir.YulFunctionCall):\n        \"\"\"\n        Visit [YulFunctionCall][wake.ir.yul.function_call.YulFunctionCall] node.\n        \"\"\"\n\n    def visit_yul_function_definition(self, node: ir.YulFunctionDefinition):\n        \"\"\"\n        Visit [YulFunctionDefinition][wake.ir.yul.function_definition.YulFunctionDefinition] node.\n        \"\"\"\n\n    def visit_yul_identifier(self, node: ir.YulIdentifier):\n        \"\"\"\n        Visit [YulIdentifier][wake.ir.yul.identifier.YulIdentifier] node.\n        \"\"\"\n\n    def visit_yul_if(self, node: ir.YulIf):\n        \"\"\"\n        Visit [YulIf][wake.ir.yul.if_statement.YulIf] node.\n        \"\"\"\n\n    def visit_yul_leave(self, node: ir.YulLeave):\n        \"\"\"\n        Visit [YulLeave][wake.ir.yul.leave.YulLeave] node.\n        \"\"\"\n\n    def visit_yul_literal(self, node: ir.YulLiteral):\n        \"\"\"\n        Visit [YulLiteral][wake.ir.yul.literal.YulLiteral] node.\n        \"\"\"\n\n    def visit_yul_switch(self, node: ir.YulSwitch):\n        \"\"\"\n        Visit [YulSwitch][wake.ir.yul.switch.YulSwitch] node.\n        \"\"\"\n\n    def visit_yul_typed_name(self, node: ir.YulTypedName):\n        \"\"\"\n        Visit [YulTypedName][wake.ir.yul.typed_name.YulTypedName] node.\n        \"\"\"\n\n    def visit_yul_variable_declaration(self, node: ir.YulVariableDeclaration):\n        \"\"\"\n        Visit [YulVariableDeclaration][wake.ir.yul.variable_declaration.YulVariableDeclaration] node.\n        \"\"\"\n\n    def generate_link_from_line_col(\n        self, path: Union[str, Path], line: int, col: int\n    ) -&gt; str:\n        \"\"\"\n        Generate a link to the given source unit file location.\n\n        Args:\n            path: Path to the source unit file.\n            line: Line number.\n            col: Column number.\n\n        Returns:\n            A link formatted according to the [link_format][wake.config.data_model.GeneralConfig.link_format] configuration option.\n        \"\"\"\n        if isinstance(path, Path):\n            path = str(path.resolve())\n        return self.config.general.link_format.format(path=path, line=line, col=col)\n\n    def generate_link(self, node: ir.IrAbc) -&gt; str:\n        \"\"\"\n        Generate a link to the start of the given node based on [name_location][wake.ir.declarations.abc.DeclarationAbc.name_location] or [byte_location][wake.ir.abc.IrAbc.byte_location].\n\n        Args:\n            node: Node to generate a link to.\n\n        Returns:\n            A link formatted according to the [link_format][wake.config.data_model.GeneralConfig.link_format] configuration option.\n        \"\"\"\n        if isinstance(node, ir.DeclarationAbc):\n            line, col = node.source_unit.get_line_col_from_byte_offset(\n                node.name_location[0]\n            )\n        else:\n            line, col = node.source_unit.get_line_col_from_byte_offset(\n                node.byte_location[0]\n            )\n        return self.generate_link_from_line_col(node.source_unit.file, line, col)\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.generate_link","title":"<code>generate_link(node)</code>","text":"<p>Generate a link to the start of the given node based on name_location or byte_location.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>IrAbc</code> <p>Node to generate a link to.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A link formatted according to the link_format configuration option.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def generate_link(self, node: ir.IrAbc) -&gt; str:\n    \"\"\"\n    Generate a link to the start of the given node based on [name_location][wake.ir.declarations.abc.DeclarationAbc.name_location] or [byte_location][wake.ir.abc.IrAbc.byte_location].\n\n    Args:\n        node: Node to generate a link to.\n\n    Returns:\n        A link formatted according to the [link_format][wake.config.data_model.GeneralConfig.link_format] configuration option.\n    \"\"\"\n    if isinstance(node, ir.DeclarationAbc):\n        line, col = node.source_unit.get_line_col_from_byte_offset(\n            node.name_location[0]\n        )\n    else:\n        line, col = node.source_unit.get_line_col_from_byte_offset(\n            node.byte_location[0]\n        )\n    return self.generate_link_from_line_col(node.source_unit.file, line, col)\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.generate_link_from_line_col","title":"<code>generate_link_from_line_col(path, line, col)</code>","text":"<p>Generate a link to the given source unit file location.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the source unit file.</p> required <code>line</code> <code>int</code> <p>Line number.</p> required <code>col</code> <code>int</code> <p>Column number.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A link formatted according to the link_format configuration option.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def generate_link_from_line_col(\n    self, path: Union[str, Path], line: int, col: int\n) -&gt; str:\n    \"\"\"\n    Generate a link to the given source unit file location.\n\n    Args:\n        path: Path to the source unit file.\n        line: Line number.\n        col: Column number.\n\n    Returns:\n        A link formatted according to the [link_format][wake.config.data_model.GeneralConfig.link_format] configuration option.\n    \"\"\"\n    if isinstance(path, Path):\n        path = str(path.resolve())\n    return self.config.general.link_format.format(path=path, line=line, col=col)\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_array_type_name","title":"<code>visit_array_type_name(node)</code>","text":"<p>Visit ArrayTypeName node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_array_type_name(self, node: ir.ArrayTypeName):\n    \"\"\"\n    Visit [ArrayTypeName][wake.ir.type_names.array_type_name.ArrayTypeName] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_assignment","title":"<code>visit_assignment(node)</code>","text":"<p>Visit Assignment node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_assignment(self, node: ir.Assignment):\n    \"\"\"\n    Visit [Assignment][wake.ir.expressions.assignment.Assignment] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_binary_operation","title":"<code>visit_binary_operation(node)</code>","text":"<p>Visit BinaryOperation node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_binary_operation(self, node: ir.BinaryOperation):\n    \"\"\"\n    Visit [BinaryOperation][wake.ir.expressions.binary_operation.BinaryOperation] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_block","title":"<code>visit_block(node)</code>","text":"<p>Visit Block node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_block(self, node: ir.Block):\n    \"\"\"\n    Visit [Block][wake.ir.statements.block.Block] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_break","title":"<code>visit_break(node)</code>","text":"<p>Visit Break node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_break(self, node: ir.Break):\n    \"\"\"\n    Visit [Break][wake.ir.statements.break_statement.Break] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_conditional","title":"<code>visit_conditional(node)</code>","text":"<p>Visit Conditional node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_conditional(self, node: ir.Conditional):\n    \"\"\"\n    Visit [Conditional][wake.ir.expressions.conditional.Conditional] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_continue","title":"<code>visit_continue(node)</code>","text":"<p>Visit Continue node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_continue(self, node: ir.Continue):\n    \"\"\"\n    Visit [Continue][wake.ir.statements.continue_statement.Continue] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_contract_definition","title":"<code>visit_contract_definition(node)</code>","text":"<p>Visit ContractDefinition node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_contract_definition(self, node: ir.ContractDefinition):\n    \"\"\"\n    Visit [ContractDefinition][wake.ir.declarations.contract_definition.ContractDefinition] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_declaration_abc","title":"<code>visit_declaration_abc(node)</code>","text":"<p>Visit any DeclarationAbc node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_declaration_abc(self, node: ir.DeclarationAbc):\n    \"\"\"\n    Visit any [DeclarationAbc][wake.ir.declarations.abc.DeclarationAbc] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_do_while_statement","title":"<code>visit_do_while_statement(node)</code>","text":"<p>Visit DoWhileStatement node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_do_while_statement(self, node: ir.DoWhileStatement):\n    \"\"\"\n    Visit [DoWhileStatement][wake.ir.statements.do_while_statement.DoWhileStatement] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_elementary_type_name","title":"<code>visit_elementary_type_name(node)</code>","text":"<p>Visit ElementaryTypeName node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_elementary_type_name(self, node: ir.ElementaryTypeName):\n    \"\"\"\n    Visit [ElementaryTypeName][wake.ir.type_names.elementary_type_name.ElementaryTypeName] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_elementary_type_name_expression","title":"<code>visit_elementary_type_name_expression(node)</code>","text":"<p>Visit ElementaryTypeNameExpression node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_elementary_type_name_expression(\n    self, node: ir.ElementaryTypeNameExpression\n):\n    \"\"\"\n    Visit [ElementaryTypeNameExpression][wake.ir.expressions.elementary_type_name_expression.ElementaryTypeNameExpression] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_emit_statement","title":"<code>visit_emit_statement(node)</code>","text":"<p>Visit EmitStatement node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_emit_statement(self, node: ir.EmitStatement):\n    \"\"\"\n    Visit [EmitStatement][wake.ir.statements.emit_statement.EmitStatement] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_enum_definition","title":"<code>visit_enum_definition(node)</code>","text":"<p>Visit EnumDefinition node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_enum_definition(self, node: ir.EnumDefinition):\n    \"\"\"\n    Visit [EnumDefinition][wake.ir.declarations.enum_definition.EnumDefinition] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_enum_value","title":"<code>visit_enum_value(node)</code>","text":"<p>Visit EnumValue node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_enum_value(self, node: ir.EnumValue):\n    \"\"\"\n    Visit [EnumValue][wake.ir.declarations.enum_value.EnumValue] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_error_definition","title":"<code>visit_error_definition(node)</code>","text":"<p>Visit ErrorDefinition node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_error_definition(self, node: ir.ErrorDefinition):\n    \"\"\"\n    Visit [ErrorDefinition][wake.ir.declarations.error_definition.ErrorDefinition] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_event_definition","title":"<code>visit_event_definition(node)</code>","text":"<p>Visit EventDefinition node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_event_definition(self, node: ir.EventDefinition):\n    \"\"\"\n    Visit [EventDefinition][wake.ir.declarations.event_definition.EventDefinition] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_expression_abc","title":"<code>visit_expression_abc(node)</code>","text":"<p>Visit any ExpressionAbc node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_expression_abc(self, node: ir.ExpressionAbc):\n    \"\"\"\n    Visit any [ExpressionAbc][wake.ir.expressions.abc.ExpressionAbc] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_expression_statement","title":"<code>visit_expression_statement(node)</code>","text":"<p>Visit ExpressionStatement node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_expression_statement(self, node: ir.ExpressionStatement):\n    \"\"\"\n    Visit [ExpressionStatement][wake.ir.statements.expression_statement.ExpressionStatement] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_for_statement","title":"<code>visit_for_statement(node)</code>","text":"<p>Visit ForStatement node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_for_statement(self, node: ir.ForStatement):\n    \"\"\"\n    Visit [ForStatement][wake.ir.statements.for_statement.ForStatement] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_function_call","title":"<code>visit_function_call(node)</code>","text":"<p>Visit FunctionCall node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_function_call(self, node: ir.FunctionCall):\n    \"\"\"\n    Visit [FunctionCall][wake.ir.expressions.function_call.FunctionCall] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_function_call_options","title":"<code>visit_function_call_options(node)</code>","text":"<p>Visit FunctionCallOptions node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_function_call_options(self, node: ir.FunctionCallOptions):\n    \"\"\"\n    Visit [FunctionCallOptions][wake.ir.expressions.function_call_options.FunctionCallOptions] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_function_definition","title":"<code>visit_function_definition(node)</code>","text":"<p>Visit FunctionDefinition node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_function_definition(self, node: ir.FunctionDefinition):\n    \"\"\"\n    Visit [FunctionDefinition][wake.ir.declarations.function_definition.FunctionDefinition] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_function_type_name","title":"<code>visit_function_type_name(node)</code>","text":"<p>Visit FunctionTypeName node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_function_type_name(self, node: ir.FunctionTypeName):\n    \"\"\"\n    Visit [FunctionTypeName][wake.ir.type_names.function_type_name.FunctionTypeName] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_identifier","title":"<code>visit_identifier(node)</code>","text":"<p>Visit Identifier node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_identifier(self, node: ir.Identifier):\n    \"\"\"\n    Visit [Identifier][wake.ir.expressions.identifier.Identifier] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_identifier_path","title":"<code>visit_identifier_path(node)</code>","text":"<p>Visit IdentifierPath node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_identifier_path(self, node: ir.IdentifierPath):\n    \"\"\"\n    Visit [IdentifierPath][wake.ir.meta.identifier_path.IdentifierPath] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_if_statement","title":"<code>visit_if_statement(node)</code>","text":"<p>Visit IfStatement node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_if_statement(self, node: ir.IfStatement):\n    \"\"\"\n    Visit [IfStatement][wake.ir.statements.if_statement.IfStatement] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_import_directive","title":"<code>visit_import_directive(node)</code>","text":"<p>Visit ImportDirective node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_import_directive(self, node: ir.ImportDirective):\n    \"\"\"\n    Visit [ImportDirective][wake.ir.meta.import_directive.ImportDirective] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_index_access","title":"<code>visit_index_access(node)</code>","text":"<p>Visit IndexAccess node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_index_access(self, node: ir.IndexAccess):\n    \"\"\"\n    Visit [IndexAccess][wake.ir.expressions.index_access.IndexAccess] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_index_range_access","title":"<code>visit_index_range_access(node)</code>","text":"<p>Visit IndexRangeAccess node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_index_range_access(self, node: ir.IndexRangeAccess):\n    \"\"\"\n    Visit [IndexRangeAccess][wake.ir.expressions.index_range_access.IndexRangeAccess] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_inheritance_specifier","title":"<code>visit_inheritance_specifier(node)</code>","text":"<p>Visit InheritanceSpecifier node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_inheritance_specifier(self, node: ir.InheritanceSpecifier):\n    \"\"\"\n    Visit [InheritanceSpecifier][wake.ir.meta.inheritance_specifier.InheritanceSpecifier] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_inline_assembly","title":"<code>visit_inline_assembly(node)</code>","text":"<p>Visit InlineAssembly node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_inline_assembly(self, node: ir.InlineAssembly):\n    \"\"\"\n    Visit [InlineAssembly][wake.ir.statements.inline_assembly.InlineAssembly] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_ir_abc","title":"<code>visit_ir_abc(node)</code>","text":"<p>Visit any IrAbc node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_ir_abc(self, node: ir.IrAbc):\n    \"\"\"\n    Visit any [IrAbc][wake.ir.abc.IrAbc] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_literal","title":"<code>visit_literal(node)</code>","text":"<p>Visit Literal node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_literal(self, node: ir.Literal):\n    \"\"\"\n    Visit [Literal][wake.ir.expressions.literal.Literal] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_mapping","title":"<code>visit_mapping(node)</code>","text":"<p>Visit Mapping node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_mapping(self, node: ir.Mapping):\n    \"\"\"\n    Visit [Mapping][wake.ir.type_names.mapping.Mapping] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_member_access","title":"<code>visit_member_access(node)</code>","text":"<p>Visit MemberAccess node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_member_access(self, node: ir.MemberAccess):\n    \"\"\"\n    Visit [MemberAccess][wake.ir.expressions.member_access.MemberAccess] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_modifier_definition","title":"<code>visit_modifier_definition(node)</code>","text":"<p>Visit ModifierDefinition node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_modifier_definition(self, node: ir.ModifierDefinition):\n    \"\"\"\n    Visit [ModifierDefinition][wake.ir.declarations.modifier_definition.ModifierDefinition] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_modifier_invocation","title":"<code>visit_modifier_invocation(node)</code>","text":"<p>Visit ModifierInvocation node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_modifier_invocation(self, node: ir.ModifierInvocation):\n    \"\"\"\n    Visit [ModifierInvocation][wake.ir.meta.modifier_invocation.ModifierInvocation] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_new_expression","title":"<code>visit_new_expression(node)</code>","text":"<p>Visit NewExpression node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_new_expression(self, node: ir.NewExpression):\n    \"\"\"\n    Visit [NewExpression][wake.ir.expressions.new_expression.NewExpression] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_override_specifier","title":"<code>visit_override_specifier(node)</code>","text":"<p>Visit OverrideSpecifier node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_override_specifier(self, node: ir.OverrideSpecifier):\n    \"\"\"\n    Visit [OverrideSpecifier][wake.ir.meta.override_specifier.OverrideSpecifier] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_parameter_list","title":"<code>visit_parameter_list(node)</code>","text":"<p>Visit ParameterList node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_parameter_list(self, node: ir.ParameterList):\n    \"\"\"\n    Visit [ParameterList][wake.ir.meta.parameter_list.ParameterList] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_placeholder_statement","title":"<code>visit_placeholder_statement(node)</code>","text":"<p>Visit PlaceholderStatement node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_placeholder_statement(self, node: ir.PlaceholderStatement):\n    \"\"\"\n    Visit [PlaceholderStatement][wake.ir.statements.placeholder_statement.PlaceholderStatement] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_pragma_directive","title":"<code>visit_pragma_directive(node)</code>","text":"<p>Visit PragmaDirective node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_pragma_directive(self, node: ir.PragmaDirective):\n    \"\"\"\n    Visit [PragmaDirective][wake.ir.meta.pragma_directive.PragmaDirective] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_return","title":"<code>visit_return(node)</code>","text":"<p>Visit Return node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_return(self, node: ir.Return):\n    \"\"\"\n    Visit [Return][wake.ir.statements.return_statement.Return] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_revert_statement","title":"<code>visit_revert_statement(node)</code>","text":"<p>Visit RevertStatement node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_revert_statement(self, node: ir.RevertStatement):\n    \"\"\"\n    Visit [RevertStatement][wake.ir.statements.revert_statement.RevertStatement] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_solidity_abc","title":"<code>visit_solidity_abc(node)</code>","text":"<p>Visit any SolidityAbc node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_solidity_abc(self, node: ir.SolidityAbc):\n    \"\"\"\n    Visit any [SolidityAbc][wake.ir.abc.SolidityAbc] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_source_unit","title":"<code>visit_source_unit(node)</code>","text":"<p>Visit SourceUnit node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_source_unit(self, node: ir.SourceUnit):\n    \"\"\"\n    Visit [SourceUnit][wake.ir.meta.source_unit.SourceUnit] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_statement_abc","title":"<code>visit_statement_abc(node)</code>","text":"<p>Visit any StatementAbc node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_statement_abc(self, node: ir.StatementAbc):\n    \"\"\"\n    Visit any [StatementAbc][wake.ir.statements.abc.StatementAbc] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_struct_definition","title":"<code>visit_struct_definition(node)</code>","text":"<p>Visit StructDefinition node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_struct_definition(self, node: ir.StructDefinition):\n    \"\"\"\n    Visit [StructDefinition][wake.ir.declarations.struct_definition.StructDefinition] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_structured_documentation","title":"<code>visit_structured_documentation(node)</code>","text":"<p>Visit StructuredDocumentation node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_structured_documentation(self, node: ir.StructuredDocumentation):\n    \"\"\"\n    Visit [StructuredDocumentation][wake.ir.meta.structured_documentation.StructuredDocumentation] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_try_catch_clause","title":"<code>visit_try_catch_clause(node)</code>","text":"<p>Visit TryCatchClause node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_try_catch_clause(self, node: ir.TryCatchClause):\n    \"\"\"\n    Visit [TryCatchClause][wake.ir.meta.try_catch_clause.TryCatchClause] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_try_statement","title":"<code>visit_try_statement(node)</code>","text":"<p>Visit TryStatement node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_try_statement(self, node: ir.TryStatement):\n    \"\"\"\n    Visit [TryStatement][wake.ir.statements.try_statement.TryStatement] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_tuple_expression","title":"<code>visit_tuple_expression(node)</code>","text":"<p>Visit TupleExpression node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_tuple_expression(self, node: ir.TupleExpression):\n    \"\"\"\n    Visit [TupleExpression][wake.ir.expressions.tuple_expression.TupleExpression] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_type_name_abc","title":"<code>visit_type_name_abc(node)</code>","text":"<p>Visit any TypeNameAbc node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_type_name_abc(self, node: ir.TypeNameAbc):\n    \"\"\"\n    Visit any [TypeNameAbc][wake.ir.type_names.abc.TypeNameAbc] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_unary_operation","title":"<code>visit_unary_operation(node)</code>","text":"<p>Visit UnaryOperation node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_unary_operation(self, node: ir.UnaryOperation):\n    \"\"\"\n    Visit [UnaryOperation][wake.ir.expressions.unary_operation.UnaryOperation] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_unchecked_block","title":"<code>visit_unchecked_block(node)</code>","text":"<p>Visit UncheckedBlock node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_unchecked_block(self, node: ir.UncheckedBlock):\n    \"\"\"\n    Visit [UncheckedBlock][wake.ir.statements.unchecked_block.UncheckedBlock] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_user_defined_type_name","title":"<code>visit_user_defined_type_name(node)</code>","text":"<p>Visit UserDefinedTypeName node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_user_defined_type_name(self, node: ir.UserDefinedTypeName):\n    \"\"\"\n    Visit [UserDefinedTypeName][wake.ir.type_names.user_defined_type_name.UserDefinedTypeName] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_user_defined_value_type_definition","title":"<code>visit_user_defined_value_type_definition(node)</code>","text":"<p>Visit UserDefinedValueTypeDefinition node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_user_defined_value_type_definition(\n    self, node: ir.UserDefinedValueTypeDefinition\n):\n    \"\"\"\n    Visit [UserDefinedValueTypeDefinition][wake.ir.declarations.user_defined_value_type_definition.UserDefinedValueTypeDefinition] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_using_for_directive","title":"<code>visit_using_for_directive(node)</code>","text":"<p>Visit UsingForDirective node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_using_for_directive(self, node: ir.UsingForDirective):\n    \"\"\"\n    Visit [UsingForDirective][wake.ir.meta.using_for_directive.UsingForDirective] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_variable_declaration","title":"<code>visit_variable_declaration(node)</code>","text":"<p>Visit VariableDeclaration node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_variable_declaration(self, node: ir.VariableDeclaration):\n    \"\"\"\n    Visit [VariableDeclaration][wake.ir.declarations.variable_declaration.VariableDeclaration] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_variable_declaration_statement","title":"<code>visit_variable_declaration_statement(node)</code>","text":"<p>Visit VariableDeclarationStatement node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_variable_declaration_statement(\n    self, node: ir.VariableDeclarationStatement\n):\n    \"\"\"\n    Visit [VariableDeclarationStatement][wake.ir.statements.variable_declaration_statement.VariableDeclarationStatement] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_while_statement","title":"<code>visit_while_statement(node)</code>","text":"<p>Visit WhileStatement node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_while_statement(self, node: ir.WhileStatement):\n    \"\"\"\n    Visit [WhileStatement][wake.ir.statements.while_statement.WhileStatement] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_yul_abc","title":"<code>visit_yul_abc(node)</code>","text":"<p>Visit any YulAbc node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_yul_abc(self, node: ir.YulAbc):\n    \"\"\"\n    Visit any [YulAbc][wake.ir.yul.abc.YulAbc] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_yul_assignment","title":"<code>visit_yul_assignment(node)</code>","text":"<p>Visit YulAssignment node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_yul_assignment(self, node: ir.YulAssignment):\n    \"\"\"\n    Visit [YulAssignment][wake.ir.yul.assignment.YulAssignment] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_yul_block","title":"<code>visit_yul_block(node)</code>","text":"<p>Visit YulBlock node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_yul_block(self, node: ir.YulBlock):\n    \"\"\"\n    Visit [YulBlock][wake.ir.yul.block.YulBlock] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_yul_break","title":"<code>visit_yul_break(node)</code>","text":"<p>Visit YulBreak node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_yul_break(self, node: ir.YulBreak):\n    \"\"\"\n    Visit [YulBreak][wake.ir.yul.break_statement.YulBreak] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_yul_case","title":"<code>visit_yul_case(node)</code>","text":"<p>Visit YulCase node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_yul_case(self, node: ir.YulCase):\n    \"\"\"\n    Visit [YulCase][wake.ir.yul.case_.YulCase] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_yul_continue","title":"<code>visit_yul_continue(node)</code>","text":"<p>Visit YulContinue node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_yul_continue(self, node: ir.YulContinue):\n    \"\"\"\n    Visit [YulContinue][wake.ir.yul.continue_statement.YulContinue] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_yul_expression_statement","title":"<code>visit_yul_expression_statement(node)</code>","text":"<p>Visit YulExpressionStatement node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_yul_expression_statement(self, node: ir.YulExpressionStatement):\n    \"\"\"\n    Visit [YulExpressionStatement][wake.ir.yul.expression_statement.YulExpressionStatement] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_yul_for_loop","title":"<code>visit_yul_for_loop(node)</code>","text":"<p>Visit YulForLoop node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_yul_for_loop(self, node: ir.YulForLoop):\n    \"\"\"\n    Visit [YulForLoop][wake.ir.yul.for_loop.YulForLoop] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_yul_function_call","title":"<code>visit_yul_function_call(node)</code>","text":"<p>Visit YulFunctionCall node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_yul_function_call(self, node: ir.YulFunctionCall):\n    \"\"\"\n    Visit [YulFunctionCall][wake.ir.yul.function_call.YulFunctionCall] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_yul_function_definition","title":"<code>visit_yul_function_definition(node)</code>","text":"<p>Visit YulFunctionDefinition node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_yul_function_definition(self, node: ir.YulFunctionDefinition):\n    \"\"\"\n    Visit [YulFunctionDefinition][wake.ir.yul.function_definition.YulFunctionDefinition] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_yul_identifier","title":"<code>visit_yul_identifier(node)</code>","text":"<p>Visit YulIdentifier node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_yul_identifier(self, node: ir.YulIdentifier):\n    \"\"\"\n    Visit [YulIdentifier][wake.ir.yul.identifier.YulIdentifier] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_yul_if","title":"<code>visit_yul_if(node)</code>","text":"<p>Visit YulIf node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_yul_if(self, node: ir.YulIf):\n    \"\"\"\n    Visit [YulIf][wake.ir.yul.if_statement.YulIf] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_yul_leave","title":"<code>visit_yul_leave(node)</code>","text":"<p>Visit YulLeave node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_yul_leave(self, node: ir.YulLeave):\n    \"\"\"\n    Visit [YulLeave][wake.ir.yul.leave.YulLeave] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_yul_literal","title":"<code>visit_yul_literal(node)</code>","text":"<p>Visit YulLiteral node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_yul_literal(self, node: ir.YulLiteral):\n    \"\"\"\n    Visit [YulLiteral][wake.ir.yul.literal.YulLiteral] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_yul_statement_abc","title":"<code>visit_yul_statement_abc(node)</code>","text":"<p>Visit any YulStatementAbc node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_yul_statement_abc(self, node: ir.YulStatementAbc):\n    \"\"\"\n    Visit any [YulStatementAbc][wake.ir.yul.abc.YulStatementAbc] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_yul_switch","title":"<code>visit_yul_switch(node)</code>","text":"<p>Visit YulSwitch node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_yul_switch(self, node: ir.YulSwitch):\n    \"\"\"\n    Visit [YulSwitch][wake.ir.yul.switch.YulSwitch] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_yul_typed_name","title":"<code>visit_yul_typed_name(node)</code>","text":"<p>Visit YulTypedName node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_yul_typed_name(self, node: ir.YulTypedName):\n    \"\"\"\n    Visit [YulTypedName][wake.ir.yul.typed_name.YulTypedName] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/core/visitor/#wake.core.visitor.Visitor.visit_yul_variable_declaration","title":"<code>visit_yul_variable_declaration(node)</code>","text":"<p>Visit YulVariableDeclaration node.</p> Source code in <code>wake/core/visitor.py</code> <pre><code>def visit_yul_variable_declaration(self, node: ir.YulVariableDeclaration):\n    \"\"\"\n    Visit [YulVariableDeclaration][wake.ir.yul.variable_declaration.YulVariableDeclaration] node.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/detectors/api/","title":"api","text":""},{"location":"api-reference/detectors/api/#wake.detectors.api","title":"<code>wake.detectors.api</code>  <code>module</code>","text":""},{"location":"api-reference/detectors/api/#wake.detectors.api.DetectorConfidence","title":"<code>DetectorConfidence</code>  <code>class</code>","text":"<p>         Bases: <code>StrEnum</code></p> <p>The confidence of a DetectorResult.</p> Source code in <code>wake/detectors/api.py</code> <pre><code>@total_ordering\nclass DetectorConfidence(StrEnum):\n    \"\"\"\n    The confidence of a [DetectorResult][wake.detectors.api.DetectorResult].\n    \"\"\"\n\n    LOW = \"low\"\n    MEDIUM = \"medium\"\n    HIGH = \"high\"\n\n    def __lt__(self, other: Any) -&gt; bool:\n        if not isinstance(other, DetectorConfidence):\n            return NotImplemented\n        prio = [\"low\", \"medium\", \"high\"]\n        return prio.index(self.value) &lt; prio.index(other.value)\n</code></pre>"},{"location":"api-reference/detectors/api/#wake.detectors.api.DetectorConfidence.LOW","title":"<code>LOW = 'low'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/detectors/api/#wake.detectors.api.DetectorConfidence.MEDIUM","title":"<code>MEDIUM = 'medium'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/detectors/api/#wake.detectors.api.DetectorConfidence.HIGH","title":"<code>HIGH = 'high'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/detectors/api/#wake.detectors.api.DetectorImpact","title":"<code>DetectorImpact</code>  <code>class</code>","text":"<p>         Bases: <code>StrEnum</code></p> <p>The impact of a DetectorResult.</p> Source code in <code>wake/detectors/api.py</code> <pre><code>@total_ordering\nclass DetectorImpact(StrEnum):\n    \"\"\"\n    The impact of a [DetectorResult][wake.detectors.api.DetectorResult].\n    \"\"\"\n\n    INFO = \"info\"\n    WARNING = \"warning\"\n    LOW = \"low\"\n    MEDIUM = \"medium\"\n    HIGH = \"high\"\n\n    def __lt__(self, other: Any) -&gt; bool:\n        if not isinstance(other, DetectorImpact):\n            return NotImplemented\n        prio = [\"info\", \"warning\", \"low\", \"medium\", \"high\"]\n        return prio.index(self.value) &lt; prio.index(other.value)\n</code></pre>"},{"location":"api-reference/detectors/api/#wake.detectors.api.DetectorImpact.INFO","title":"<code>INFO = 'info'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/detectors/api/#wake.detectors.api.DetectorImpact.WARNING","title":"<code>WARNING = 'warning'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/detectors/api/#wake.detectors.api.DetectorImpact.LOW","title":"<code>LOW = 'low'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/detectors/api/#wake.detectors.api.DetectorImpact.MEDIUM","title":"<code>MEDIUM = 'medium'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/detectors/api/#wake.detectors.api.DetectorImpact.HIGH","title":"<code>HIGH = 'high'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/detectors/api/#wake.detectors.api.Detection","title":"<code>Detection</code>  <code>class</code>","text":"<p>A single detection bound to a location in the source code through an IR node. May contain any number of subdetections.</p> <p>Attributes:</p> Name Type Description <code>ir_node</code> <code>IrAbc</code> <p>IR node representing the detection.</p> <code>message</code> <code>str</code> <p>User-friendly message describing the detection.</p> <code>subdetections</code> <code>Tuple[Detection, ...]</code> <p>Subdetections of this detection.</p> <code>lsp_range</code> <code>Optional[Tuple[int, int]]</code> <p>Byte offsets (start, end) of the detection used for highlighting in LSP diagnostics and in SARIF export.</p> <code>subdetections_mandatory</code> <code>bool</code> <p>Whether the detection requires at least one subdetection to be valid, or if the subdetections are not mandatory for the existence of the detection. This attribute determines whether the detection should be filtered out if all subdetections are filtered out based on the detectors ignore_paths configuration.</p> Source code in <code>wake/detectors/api.py</code> <pre><code>@dataclass(eq=True, frozen=True)\nclass Detection:\n    \"\"\"\n    A single detection bound to a location in the source code through an IR node. May contain any number of subdetections.\n\n    Attributes:\n        ir_node: IR node representing the detection.\n        message: User-friendly message describing the detection.\n        subdetections: Subdetections of this detection.\n        lsp_range: Byte offsets (start, end) of the detection used for highlighting in LSP diagnostics and in SARIF export.\n        subdetections_mandatory: Whether the detection requires at least one subdetection to be valid,\n            or if the subdetections are not mandatory for the existence of the detection.\n            This attribute determines whether the detection should be filtered out if all subdetections are filtered out based on the detectors [ignore_paths][wake.config.data_model.DetectorsConfig.ignore_paths] configuration.\n    \"\"\"\n\n    ir_node: IrAbc\n    message: str\n    subdetections: Tuple[Detection, ...] = field(default_factory=tuple)\n    lsp_range: Optional[Tuple[int, int]] = field(default=None)\n    subdetections_mandatory: bool = field(default=True)\n</code></pre>"},{"location":"api-reference/detectors/api/#wake.detectors.api.DetectorResult","title":"<code>DetectorResult</code>  <code>class</code>","text":"<p>A single result reported by a Detector.</p> <p>Attributes:</p> Name Type Description <code>detection</code> <code>Detection</code> <p>Detection describing the location in the source code and the message.</p> <code>impact</code> <code>DetectorImpact</code> <p>Impact of the detection.</p> <code>confidence</code> <code>DetectorConfidence</code> <p>Confidence of the detection.</p> <code>uri</code> <code>Optional[str]</code> <p>Optional URI to a page describing the detection.</p> Source code in <code>wake/detectors/api.py</code> <pre><code>@dataclass(eq=True, frozen=True)\nclass DetectorResult:\n    \"\"\"\n    A single result reported by a [Detector][wake.detectors.api.Detector].\n\n    Attributes:\n        detection: Detection describing the location in the source code and the message.\n        impact: Impact of the detection.\n        confidence: Confidence of the detection.\n        uri: Optional URI to a page describing the detection.\n    \"\"\"\n\n    detection: Detection\n    impact: DetectorImpact\n    confidence: DetectorConfidence\n    uri: Optional[str] = field(default=None)\n\n    def __post_init__(self):\n        if self.impact not in DetectorImpact.__members__.values():\n            raise ValueError(f\"Invalid impact: {self.impact}\")\n        if self.confidence not in DetectorConfidence.__members__.values():\n            raise ValueError(f\"Invalid confidence: {self.confidence}\")\n</code></pre>"},{"location":"api-reference/detectors/api/#wake.detectors.api.Detector","title":"<code>Detector</code>  <code>class</code>","text":"<p>         Bases: <code>Visitor</code></p> <p>Base class for detectors.</p> <p>Attributes:</p> Name Type Description <code>paths</code> <code>List[Path]</code> <p>Paths the detector should operate on. May be empty if a user did not specify any paths, e.g. when running <code>wake detect all</code>. In this case, the detector should operate on all paths. May be ignored unless visit_mode is <code>all</code>.</p> <code>extra</code> <code>Dict[Any, Any]</code> <p>Extra data shared between all detectors in a single run. May contain additional data set by the execution engine.</p> Source code in <code>wake/detectors/api.py</code> <pre><code>class Detector(Visitor, metaclass=ABCMeta):\n    \"\"\"\n    Base class for detectors.\n\n    Attributes:\n        paths: Paths the detector should operate on. May be empty if a user did not specify any paths, e.g. when running `wake detect all`.\n            In this case, the detector should operate on all paths. May be ignored unless [visit_mode][wake.detectors.api.Detector.visit_mode] is `all`.\n        extra: Extra data shared between all detectors in a single run. May contain additional data set by the execution engine.\n    \"\"\"\n\n    paths: List[Path]\n    extra: Dict[Any, Any]\n    lsp_provider: Optional[LspProvider]\n    execution_mode: Literal[\"cli\", \"lsp\", \"both\"] = \"both\"  # TODO is this needed?\n\n    @property\n    def visit_mode(self) -&gt; Literal[\"paths\", \"all\"]:\n        \"\"\"\n        Configurable visit mode of the detector. If set to `paths`, the detector `visit_` methods will be called only for the paths specified by the user.\n        If set to `all`, the detector `visit_` methods will be called for all paths, leaving the filtering of detections to the detector implementation.\n        In this case, the detector should use the `paths` attribute to determine which paths to operate on.\n\n        Returns:\n            Visit mode of the detector.\n        \"\"\"\n        return \"paths\"\n\n    @abstractmethod\n    def detect(self) -&gt; List[DetectorResult]:\n        \"\"\"\n        Abstract method that must be implemented in a detector to return the discovered detections.\n\n        Returns:\n            List of detector results.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api-reference/detectors/api/#wake.detectors.api.Detector.visit_mode","title":"<code>visit_mode: Literal['paths', 'all']</code>  <code>property</code>","text":"<p>Configurable visit mode of the detector. If set to <code>paths</code>, the detector <code>visit_</code> methods will be called only for the paths specified by the user. If set to <code>all</code>, the detector <code>visit_</code> methods will be called for all paths, leaving the filtering of detections to the detector implementation. In this case, the detector should use the <code>paths</code> attribute to determine which paths to operate on.</p> <p>Returns:</p> Type Description <code>Literal['paths', 'all']</code> <p>Visit mode of the detector.</p>"},{"location":"api-reference/detectors/api/#wake.detectors.api.Detector.detect","title":"<code>detect()</code>  <code>abstractmethod</code>","text":"<p>Abstract method that must be implemented in a detector to return the discovered detections.</p> <p>Returns:</p> Type Description <code>List[DetectorResult]</code> <p>List of detector results.</p> Source code in <code>wake/detectors/api.py</code> <pre><code>@abstractmethod\ndef detect(self) -&gt; List[DetectorResult]:\n    \"\"\"\n    Abstract method that must be implemented in a detector to return the discovered detections.\n\n    Returns:\n        List of detector results.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api-reference/ir/abc/","title":"abc","text":""},{"location":"api-reference/ir/abc/#wake.ir.abc","title":"<code>wake.ir.abc</code>  <code>module</code>","text":""},{"location":"api-reference/ir/abc/#wake.ir.abc.IrAbc","title":"<code>IrAbc</code>  <code>class</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Base class for all IR nodes. Defines attributes and methods that are common to all Solidity and Yul IR nodes.</p> <p>IR model is built on top of the AST (Abstract Syntax Tree) output of the solc compiler.</p> <p>Each IR node is associated with a source code location in a source file. This means that each IR node has a corresponding (typically non-empty) Solidity or Yul source code.</p> <p>Info</p> <p>Yul IR nodes can have empty source code. In the case of Solidity IR nodes, this should not happen.</p> Source code in <code>wake/ir/abc.py</code> <pre><code>class IrAbc(ABC):\n    \"\"\"\n    Base class for all IR nodes. Defines attributes and methods that are common to all Solidity and Yul IR nodes.\n\n    IR model is built on top of the AST (Abstract Syntax Tree) output of the [solc compiler](https://docs.soliditylang.org/en/latest/using-the-compiler.html).\n\n    Each IR node is associated with a [source code location][wake.ir.abc.IrAbc.byte_location] in a [source file][wake.ir.meta.source_unit.SourceUnit.file].\n    This means that each IR node has a corresponding (typically non-empty) Solidity or Yul [source code][wake.ir.abc.IrAbc.source].\n\n    !!! info\n        Yul IR nodes can have empty source code. In the case of Solidity IR nodes, this should not happen.\n\n    \"\"\"\n\n    _source: bytes\n    _ast_node: SolcNode\n    _parent: Optional[IrAbc]\n    _depth: int\n    _source_unit: SourceUnit\n    _reference_resolver: ReferenceResolver\n\n    def __init__(self, init: IrInitTuple, solc_node: SolcNode, parent: Optional[IrAbc]):\n        self._ast_node = solc_node\n        self._parent = parent\n        if self._parent is not None:\n            self._depth = self._parent.ast_tree_depth + 1\n        else:\n            self._depth = 0\n\n        assert init.source_unit is not None\n        self._source_unit = init.source_unit\n        self._reference_resolver = init.reference_resolver\n\n        source_start = solc_node.src.byte_offset\n        source_end = source_start + solc_node.src.byte_length\n        self._source = init.source[source_start:source_end]\n        if source_start != source_end:\n            init.interval_tree[source_start:source_end] = self\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        \"\"\"\n        Yields:\n            Self and (recursively) all child IR nodes.\n        \"\"\"\n        yield self\n\n    @property\n    @abstractmethod\n    def parent(self) -&gt; Optional[IrAbc]:\n        \"\"\"\n        The parent node of this node. Can only be `None` for the root ([Source unit][wake.ir.meta.source_unit.SourceUnit]) node.\n\n        Returns:\n            Parent node of this node.\n        \"\"\"\n        ...\n\n    @property\n    @abstractmethod\n    def ast_node(self) -&gt; SolcNode:\n        ...\n\n    @property\n    def ast_tree_depth(self) -&gt; int:\n        \"\"\"\n        The depth of this node in the AST tree. The root node ([Source unit][wake.ir.meta.source_unit.SourceUnit]) of each file has depth 0. Direct child nodes of a `node` have depth `{node}.ast_tree_depth + 1`.\n\n        !!! tip\n            Wake uses [interval trees](https://github.com/chaimleib/intervaltree) to get a list of all IR nodes at a given byte offset in a given file. This property can be used to sort these nodes by their depth in the AST tree and (for example) to choose the most nested one.\n\n        Returns:\n            Depth of this node in the AST tree, starting from 0.\n\n        \"\"\"\n        return self._depth\n\n    @property\n    def byte_location(self) -&gt; Tuple[int, int]:\n        \"\"\"\n        The byte location of a child node is typically a subrange of the byte location of its parent node.\n\n        !!! info\n            This is not true for [Structured documentation][wake.ir.meta.structured_documentation.StructuredDocumentation], where documentation strings must be located before a declaration.\n\n        Returns:\n            Tuple of the start and end byte offsets of this node in the source file.\n        \"\"\"\n        return (\n            self._ast_node.src.byte_offset,\n            self._ast_node.src.byte_offset + self._ast_node.src.byte_length,\n        )\n\n    @property\n    def source(self) -&gt; str:\n        \"\"\"\n        UTF-8 decoded source code from the [source file][wake.ir.meta.source_unit.SourceUnit.file] at the [byte offset][wake.ir.abc.IrAbc.byte_location] of this node.\n\n        Returns:\n            Solidity or Yul source code corresponding to this node.\n        \"\"\"\n        return self._source.decode(\"utf-8\")\n\n    @property\n    def source_unit(self) -&gt; SourceUnit:\n        \"\"\"\n        Returns:\n            Source unit that contains this node.\n        \"\"\"\n        return self._source_unit\n</code></pre>"},{"location":"api-reference/ir/abc/#wake.ir.abc.IrAbc.ast_tree_depth","title":"<code>ast_tree_depth: int</code>  <code>property</code>","text":"<p>The depth of this node in the AST tree. The root node (Source unit) of each file has depth 0. Direct child nodes of a <code>node</code> have depth <code>{node}.ast_tree_depth + 1</code>.</p> <p>Tip</p> <p>Wake uses interval trees to get a list of all IR nodes at a given byte offset in a given file. This property can be used to sort these nodes by their depth in the AST tree and (for example) to choose the most nested one.</p> <p>Returns:</p> Type Description <code>int</code> <p>Depth of this node in the AST tree, starting from 0.</p>"},{"location":"api-reference/ir/abc/#wake.ir.abc.IrAbc.byte_location","title":"<code>byte_location: Tuple[int, int]</code>  <code>property</code>","text":"<p>The byte location of a child node is typically a subrange of the byte location of its parent node.</p> <p>Info</p> <p>This is not true for Structured documentation, where documentation strings must be located before a declaration.</p> <p>Returns:</p> Type Description <code>Tuple[int, int]</code> <p>Tuple of the start and end byte offsets of this node in the source file.</p>"},{"location":"api-reference/ir/abc/#wake.ir.abc.IrAbc.parent","title":"<code>parent: Optional[IrAbc]</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>The parent node of this node. Can only be <code>None</code> for the root (Source unit) node.</p> <p>Returns:</p> Type Description <code>Optional[IrAbc]</code> <p>Parent node of this node.</p>"},{"location":"api-reference/ir/abc/#wake.ir.abc.IrAbc.source","title":"<code>source: str</code>  <code>property</code>","text":"<p>UTF-8 decoded source code from the source file at the byte offset of this node.</p> <p>Returns:</p> Type Description <code>str</code> <p>Solidity or Yul source code corresponding to this node.</p>"},{"location":"api-reference/ir/abc/#wake.ir.abc.IrAbc.source_unit","title":"<code>source_unit: SourceUnit</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>SourceUnit</code> <p>Source unit that contains this node.</p>"},{"location":"api-reference/ir/abc/#wake.ir.abc.IrAbc.__iter__","title":"<code>__iter__()</code>","text":"<p>Yields:</p> Type Description <code>IrAbc</code> <p>Self and (recursively) all child IR nodes.</p> Source code in <code>wake/ir/abc.py</code> <pre><code>def __iter__(self) -&gt; Iterator[IrAbc]:\n    \"\"\"\n    Yields:\n        Self and (recursively) all child IR nodes.\n    \"\"\"\n    yield self\n</code></pre>"},{"location":"api-reference/ir/abc/#wake.ir.abc.SolidityAbc","title":"<code>SolidityAbc</code>  <code>class</code>","text":"<p>         Bases: <code>IrAbc</code>, <code>ABC</code></p> <p>Abstract base class for all Solidity IR nodes.</p> Source code in <code>wake/ir/abc.py</code> <pre><code>class SolidityAbc(IrAbc, ABC):\n    \"\"\"\n    Abstract base class for all Solidity IR nodes.\n    \"\"\"\n\n    _ast_node: SolidityNode\n\n    def __init__(\n        self, init: IrInitTuple, solc_node: SolidityNode, parent: Optional[SolidityAbc]\n    ):\n        super().__init__(init, solc_node, parent)\n        self._reference_resolver.register_node(\n            self, solc_node.id, self.source_unit.cu_hash\n        )\n\n    @property\n    def ast_node(self) -&gt; SolidityNode:\n        return self._ast_node\n\n    @property\n    def ast_node_id(self) -&gt; int:\n        return self._ast_node.id\n</code></pre>"},{"location":"api-reference/ir/enums/","title":"enums","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums","title":"<code>wake.ir.enums</code>  <code>module</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.AssignmentOperator","title":"<code>AssignmentOperator</code>  <code>class</code>","text":"<p>         Bases: <code>StrEnum</code></p> <p>Assignment operator used in an Assignment expression.</p> Source code in <code>wake/ir/enums.py</code> <pre><code>class AssignmentOperator(StrEnum):\n    \"\"\"\n    Assignment operator used in an [Assignment][wake.ir.expressions.assignment.Assignment] expression.\n    \"\"\"\n\n    EQUALS = r\"=\"\n    PLUS_EQUALS = r\"+=\"\n    MINUS_EQUALS = r\"-=\"\n    TIMES_EQUALS = r\"*=\"\n    DIVIDE_EQUALS = r\"/=\"\n    MODULO_EQUALS = r\"%=\"\n    OR_EQUALS = r\"|=\"\n    AND_EQUALS = r\"&amp;=\"\n    XOR_EQUALS = r\"^=\"\n    RIGHT_SHIFT_EQUALS = r\"&gt;&gt;=\"\n    LEFT_SHIFT_EQUALS = r\"&lt;&lt;=\"\n</code></pre>"},{"location":"api-reference/ir/enums/#wake.ir.enums.AssignmentOperator.AND_EQUALS","title":"<code>AND_EQUALS = '&amp;='</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.AssignmentOperator.DIVIDE_EQUALS","title":"<code>DIVIDE_EQUALS = '/='</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.AssignmentOperator.EQUALS","title":"<code>EQUALS = '='</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.AssignmentOperator.LEFT_SHIFT_EQUALS","title":"<code>LEFT_SHIFT_EQUALS = '&lt;&lt;='</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.AssignmentOperator.MINUS_EQUALS","title":"<code>MINUS_EQUALS = '-='</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.AssignmentOperator.MODULO_EQUALS","title":"<code>MODULO_EQUALS = '%='</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.AssignmentOperator.OR_EQUALS","title":"<code>OR_EQUALS = '|='</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.AssignmentOperator.PLUS_EQUALS","title":"<code>PLUS_EQUALS = '+='</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.AssignmentOperator.RIGHT_SHIFT_EQUALS","title":"<code>RIGHT_SHIFT_EQUALS = '&gt;&gt;='</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.AssignmentOperator.TIMES_EQUALS","title":"<code>TIMES_EQUALS = '*='</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.AssignmentOperator.XOR_EQUALS","title":"<code>XOR_EQUALS = '^='</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.BinaryOpOperator","title":"<code>BinaryOpOperator</code>  <code>class</code>","text":"<p>         Bases: <code>StrEnum</code></p> <p>Binary operation operator used in a BinaryOperation expression.</p> Source code in <code>wake/ir/enums.py</code> <pre><code>class BinaryOpOperator(StrEnum):\n    \"\"\"\n    Binary operation operator used in a [BinaryOperation][wake.ir.expressions.binary_operation.BinaryOperation] expression.\n    \"\"\"\n\n    PLUS = r\"+\"\n    MINUS = r\"-\"\n    TIMES = r\"*\"\n    DIVIDE = r\"/\"\n    MODULO = r\"%\"\n    EXP = r\"**\"\n    BOOLEAN_AND = r\"&amp;&amp;\"\n    BOOLEAN_OR = r\"||\"\n    NEQ = r\"!=\"\n    EQ = r\"==\"\n    LT = r\"&lt;\"\n    LTE = r\"&lt;=\"\n    GT = r\"&gt;\"\n    GTE = r\"&gt;=\"\n    XOR = r\"^\"\n    BITWISE_AND = r\"&amp;\"\n    BITWISE_OR = r\"|\"\n    LEFT_SHIFT = r\"&lt;&lt;\"\n    RIGHT_SHIFT = r\"&gt;&gt;\"\n</code></pre>"},{"location":"api-reference/ir/enums/#wake.ir.enums.BinaryOpOperator.BITWISE_AND","title":"<code>BITWISE_AND = '&amp;'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.BinaryOpOperator.BITWISE_OR","title":"<code>BITWISE_OR = '|'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.BinaryOpOperator.BOOLEAN_AND","title":"<code>BOOLEAN_AND = '&amp;&amp;'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.BinaryOpOperator.BOOLEAN_OR","title":"<code>BOOLEAN_OR = '||'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.BinaryOpOperator.DIVIDE","title":"<code>DIVIDE = '/'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.BinaryOpOperator.EQ","title":"<code>EQ = '=='</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.BinaryOpOperator.EXP","title":"<code>EXP = '**'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.BinaryOpOperator.GT","title":"<code>GT = '&gt;'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.BinaryOpOperator.GTE","title":"<code>GTE = '&gt;='</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.BinaryOpOperator.LEFT_SHIFT","title":"<code>LEFT_SHIFT = '&lt;&lt;'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.BinaryOpOperator.LT","title":"<code>LT = '&lt;'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.BinaryOpOperator.LTE","title":"<code>LTE = '&lt;='</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.BinaryOpOperator.MINUS","title":"<code>MINUS = '-'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.BinaryOpOperator.MODULO","title":"<code>MODULO = '%'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.BinaryOpOperator.NEQ","title":"<code>NEQ = '!='</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.BinaryOpOperator.PLUS","title":"<code>PLUS = '+'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.BinaryOpOperator.RIGHT_SHIFT","title":"<code>RIGHT_SHIFT = '&gt;&gt;'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.BinaryOpOperator.TIMES","title":"<code>TIMES = '*'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.BinaryOpOperator.XOR","title":"<code>XOR = '^'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.ContractKind","title":"<code>ContractKind</code>  <code>class</code>","text":"<p>         Bases: <code>StrEnum</code></p> <p>Kind of a ContractDefinition declaration node.</p> Source code in <code>wake/ir/enums.py</code> <pre><code>class ContractKind(StrEnum):\n    \"\"\"\n    Kind of a [ContractDefinition][wake.ir.declarations.contract_definition.ContractDefinition] declaration node.\n    \"\"\"\n\n    CONTRACT = \"contract\"\n    INTERFACE = \"interface\"\n    LIBRARY = \"library\"\n</code></pre>"},{"location":"api-reference/ir/enums/#wake.ir.enums.ContractKind.CONTRACT","title":"<code>CONTRACT = 'contract'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.ContractKind.INTERFACE","title":"<code>INTERFACE = 'interface'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.ContractKind.LIBRARY","title":"<code>LIBRARY = 'library'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.DataLocation","title":"<code>DataLocation</code>  <code>class</code>","text":"<p>         Bases: <code>StrEnum</code></p> <p>Data location of a VariableDeclaration node. It also specifies the data location of the following types:</p> <ul> <li>Array,</li> <li>Bytes,</li> <li>String,</li> <li>Struct.</li> </ul> Source code in <code>wake/ir/enums.py</code> <pre><code>class DataLocation(StrEnum):\n    \"\"\"\n    Data location of a [VariableDeclaration][wake.ir.declarations.variable_declaration.VariableDeclaration] node.\n    It also specifies the data location of the following types:\n\n    - [Array][wake.ir.types.Array],\n    - [Bytes][wake.ir.types.Bytes],\n    - [String][wake.ir.types.String],\n    - [Struct][wake.ir.types.Struct].\n    \"\"\"\n\n    CALLDATA = \"calldata\"\n    DEFAULT = \"default\"\n    \"\"\"\n    Set only in [VariableDeclaration][wake.ir.declarations.variable_declaration.VariableDeclaration] nodes when the data location is not specified (and the compiler even does not allow it).\n    \"\"\"\n    MEMORY = \"memory\"\n    STORAGE = \"storage\"\n</code></pre>"},{"location":"api-reference/ir/enums/#wake.ir.enums.DataLocation.CALLDATA","title":"<code>CALLDATA = 'calldata'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.DataLocation.DEFAULT","title":"<code>DEFAULT = 'default'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Set only in VariableDeclaration nodes when the data location is not specified (and the compiler even does not allow it).</p>"},{"location":"api-reference/ir/enums/#wake.ir.enums.DataLocation.MEMORY","title":"<code>MEMORY = 'memory'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.DataLocation.STORAGE","title":"<code>STORAGE = 'storage'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionCallKind","title":"<code>FunctionCallKind</code>  <code>class</code>","text":"<p>         Bases: <code>StrEnum</code></p> <p>Kind of a FunctionCall expression node.</p> Source code in <code>wake/ir/enums.py</code> <pre><code>class FunctionCallKind(StrEnum):\n    \"\"\"\n    Kind of a [FunctionCall][wake.ir.expressions.function_call.FunctionCall] expression node.\n    \"\"\"\n\n    FUNCTION_CALL = \"functionCall\"\n    \"\"\"\n    Represents also an error call, event call and [NewExpression][wake.ir.expressions.new_expression.NewExpression] call.\n    \"\"\"\n    TYPE_CONVERSION = \"typeConversion\"\n    STRUCT_CONSTRUCTOR_CALL = \"structConstructorCall\"\n</code></pre>"},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionCallKind.FUNCTION_CALL","title":"<code>FUNCTION_CALL = 'functionCall'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Represents also an error call, event call and NewExpression call.</p>"},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionCallKind.STRUCT_CONSTRUCTOR_CALL","title":"<code>STRUCT_CONSTRUCTOR_CALL = 'structConstructorCall'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionCallKind.TYPE_CONVERSION","title":"<code>TYPE_CONVERSION = 'typeConversion'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionKind","title":"<code>FunctionKind</code>  <code>class</code>","text":"<p>         Bases: <code>StrEnum</code></p> <p>Kind of a FunctionDefinition declaration node.</p> Source code in <code>wake/ir/enums.py</code> <pre><code>class FunctionKind(StrEnum):\n    \"\"\"\n    Kind of a [FunctionDefinition][wake.ir.declarations.function_definition.FunctionDefinition] declaration node.\n    \"\"\"\n\n    FUNCTION = \"function\"\n    RECEIVE = \"receive\"\n    CONSTRUCTOR = \"constructor\"\n    FALLBACK = \"fallback\"\n    FREE_FUNCTION = \"freeFunction\"\n    \"\"\"\n    Function defined outside of a contract.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionKind.CONSTRUCTOR","title":"<code>CONSTRUCTOR = 'constructor'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionKind.FALLBACK","title":"<code>FALLBACK = 'fallback'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionKind.FREE_FUNCTION","title":"<code>FREE_FUNCTION = 'freeFunction'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Function defined outside of a contract.</p>"},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionKind.FUNCTION","title":"<code>FUNCTION = 'function'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionKind.RECEIVE","title":"<code>RECEIVE = 'receive'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind","title":"<code>FunctionTypeKind</code>  <code>class</code>","text":"<p>         Bases: <code>StrEnum</code></p> <p>Kind of a Function type.</p> Source code in <code>wake/ir/enums.py</code> <pre><code>class FunctionTypeKind(StrEnum):\n    \"\"\"\n    Kind of a [Function][wake.ir.types.Function] type.\n    \"\"\"\n\n    DECLARATION = \"declaration\"\n    INTERNAL = \"internal\"\n    EXTERNAL = \"external\"\n    DELEGATE_CALL = \"delegatecall\"\n    BARE_CALL = \"barecall\"\n    BARE_CALL_CODE = \"barecallcode\"\n    BARE_DELEGATE_CALL = \"baredelegatecall\"\n    BARE_STATIC_CALL = \"barestaticcall\"\n    CREATION = \"creation\"\n    SEND = \"send\"\n    TRANSFER = \"transfer\"\n    KECCAK256 = \"keccak256\"\n    SELFDESTRUCT = \"selfdestruct\"\n    REVERT = \"revert\"\n    EC_RECOVER = \"ecrecover\"\n    SHA256 = \"sha256\"\n    RIPEMD160 = \"ripemd160\"\n    LOG0 = \"log0\"\n    LOG1 = \"log1\"\n    LOG2 = \"log2\"\n    LOG3 = \"log3\"\n    LOG4 = \"log4\"\n    GAS_LEFT = \"gasleft\"\n    EVENT = \"event\"\n    ERROR = \"error\"\n    WRAP = \"wrap\"\n    UNWRAP = \"unwrap\"\n    SET_GAS = \"setgas\"\n    SET_VALUE = \"setvalue\"\n    BLOCK_HASH = \"blockhash\"\n    BLOBHASH = \"blobhash\"\n    ADD_MOD = \"addmod\"\n    MUL_MOD = \"mulmod\"\n    ARRAY_PUSH = \"arraypush\"\n    ARRAY_POP = \"arraypop\"  # TODO also used for byte array pop, distinguish?\n    BYTE_ARRAY_PUSH = \"bytearraypush\"\n    BYTES_CONCAT = \"bytesconcat\"\n    STRING_CONCAT = \"stringconcat\"\n    OBJECT_CREATION = \"objectcreation\"\n    ASSERT = \"assert\"\n    REQUIRE = \"require\"\n    ABI_ENCODE = \"abiencode\"\n    ABI_ENCODE_PACKED = \"abiencodepacked\"\n    ABI_ENCODE_WITH_SELECTOR = \"abiencodewithselector\"\n    ABI_ENCODE_CALL = \"abiencodecall\"\n    ABI_ENCODE_WITH_SIGNATURE = \"abiencodewithsignature\"\n    ABI_DECODE = \"abidecode\"\n    META_TYPE = \"metatype\"\n</code></pre>"},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.ABI_DECODE","title":"<code>ABI_DECODE = 'abidecode'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.ABI_ENCODE","title":"<code>ABI_ENCODE = 'abiencode'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.ABI_ENCODE_CALL","title":"<code>ABI_ENCODE_CALL = 'abiencodecall'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.ABI_ENCODE_PACKED","title":"<code>ABI_ENCODE_PACKED = 'abiencodepacked'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.ABI_ENCODE_WITH_SELECTOR","title":"<code>ABI_ENCODE_WITH_SELECTOR = 'abiencodewithselector'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.ABI_ENCODE_WITH_SIGNATURE","title":"<code>ABI_ENCODE_WITH_SIGNATURE = 'abiencodewithsignature'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.ADD_MOD","title":"<code>ADD_MOD = 'addmod'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.ARRAY_POP","title":"<code>ARRAY_POP = 'arraypop'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.ARRAY_PUSH","title":"<code>ARRAY_PUSH = 'arraypush'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.ASSERT","title":"<code>ASSERT = 'assert'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.BARE_CALL","title":"<code>BARE_CALL = 'barecall'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.BARE_CALL_CODE","title":"<code>BARE_CALL_CODE = 'barecallcode'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.BARE_DELEGATE_CALL","title":"<code>BARE_DELEGATE_CALL = 'baredelegatecall'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.BARE_STATIC_CALL","title":"<code>BARE_STATIC_CALL = 'barestaticcall'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.BLOBHASH","title":"<code>BLOBHASH = 'blobhash'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.BLOCK_HASH","title":"<code>BLOCK_HASH = 'blockhash'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.BYTES_CONCAT","title":"<code>BYTES_CONCAT = 'bytesconcat'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.BYTE_ARRAY_PUSH","title":"<code>BYTE_ARRAY_PUSH = 'bytearraypush'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.CREATION","title":"<code>CREATION = 'creation'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.DECLARATION","title":"<code>DECLARATION = 'declaration'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.DELEGATE_CALL","title":"<code>DELEGATE_CALL = 'delegatecall'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.EC_RECOVER","title":"<code>EC_RECOVER = 'ecrecover'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.ERROR","title":"<code>ERROR = 'error'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.EVENT","title":"<code>EVENT = 'event'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.EXTERNAL","title":"<code>EXTERNAL = 'external'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.GAS_LEFT","title":"<code>GAS_LEFT = 'gasleft'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.INTERNAL","title":"<code>INTERNAL = 'internal'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.KECCAK256","title":"<code>KECCAK256 = 'keccak256'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.LOG0","title":"<code>LOG0 = 'log0'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.LOG1","title":"<code>LOG1 = 'log1'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.LOG2","title":"<code>LOG2 = 'log2'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.LOG3","title":"<code>LOG3 = 'log3'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.LOG4","title":"<code>LOG4 = 'log4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.META_TYPE","title":"<code>META_TYPE = 'metatype'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.MUL_MOD","title":"<code>MUL_MOD = 'mulmod'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.OBJECT_CREATION","title":"<code>OBJECT_CREATION = 'objectcreation'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.REQUIRE","title":"<code>REQUIRE = 'require'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.REVERT","title":"<code>REVERT = 'revert'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.RIPEMD160","title":"<code>RIPEMD160 = 'ripemd160'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.SELFDESTRUCT","title":"<code>SELFDESTRUCT = 'selfdestruct'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.SEND","title":"<code>SEND = 'send'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.SET_GAS","title":"<code>SET_GAS = 'setgas'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.SET_VALUE","title":"<code>SET_VALUE = 'setvalue'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.SHA256","title":"<code>SHA256 = 'sha256'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.STRING_CONCAT","title":"<code>STRING_CONCAT = 'stringconcat'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.TRANSFER","title":"<code>TRANSFER = 'transfer'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.UNWRAP","title":"<code>UNWRAP = 'unwrap'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.FunctionTypeKind.WRAP","title":"<code>WRAP = 'wrap'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol","title":"<code>GlobalSymbol</code>  <code>class</code>","text":"<p>         Bases: <code>IntEnum</code></p> <p>Global symbols of the Solidity language. Symbols with identifiers from <code>-1</code> to <code>-99</code> are codified by the compiler and can only be referenced by Identifier nodes. Other symbols are not officially codified by the compiler, but Wake also defines identifiers for them. These symbols can only be referenced by MemberAccess nodes. See the Solidity docs for (an incomplete) list of global symbols and their descriptions.</p> Source code in <code>wake/ir/enums.py</code> <pre><code>class GlobalSymbol(IntEnum):\n    \"\"\"\n    Global symbols of the Solidity language. Symbols with identifiers from `-1` to `-99` are codified by the compiler and can only be referenced by [Identifier][wake.ir.expressions.identifier.Identifier] nodes.\n    Other symbols are not officially codified by the compiler, but Wake also defines identifiers for them. These symbols can only be referenced by [MemberAccess][wake.ir.expressions.member_access.MemberAccess] nodes.\n    See the [Solidity docs](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#special-variables-and-functions) for (an incomplete) list of global symbols and their descriptions.\n    \"\"\"\n\n    ABI = -1\n    ADDMOD = -2\n    ASSERT = -3\n    BLOCK = -4\n    BLOCKHASH = -5\n    ECRECOVER = -6\n    GASLEFT = -7\n    KECCAK256 = -8\n    LOG0 = -10  # removed in Solidity 0.8.0\n    LOG1 = -11  # removed in Solidity 0.8.0\n    LOG2 = -12  # removed in Solidity 0.8.0\n    LOG3 = -13  # removed in Solidity 0.8.0\n    LOG4 = -14  # removed in Solidity 0.8.0\n    MSG = -15\n    MULMOD = -16\n    NOW = -17\n    REQUIRE = -18\n    REVERT = -19\n    RIPEMD160 = -20\n    SELFDESTRUCT = -21\n    SHA256 = -22\n    SHA3 = -23\n    SUICIDE = -24\n    SUPER = -25\n    TX = -26\n    TYPE = -27\n    THIS = -28\n    BLOBHASH = -29\n\n    BLOCK_BASEFEE = -100\n    BLOCK_CHAINID = -101\n    BLOCK_COINBASE = -102\n    BLOCK_DIFFICULTY = -103\n    BLOCK_GASLIMIT = -104\n    BLOCK_NUMBER = -105\n    BLOCK_TIMESTAMP = -106\n    BLOCK_PREVRANDAO = -107\n    BLOCK_BLOBBASEFEE = -108\n\n    MSG_DATA = -200\n    MSG_SENDER = -201\n    MSG_SIG = -202\n    MSG_VALUE = -203\n\n    TX_GASPRICE = -300\n    TX_ORIGIN = -301\n\n    ABI_DECODE = -400\n    ABI_ENCODE = -401\n    ABI_ENCODE_PACKED = -402\n    ABI_ENCODE_WITH_SELECTOR = -403\n    ABI_ENCODE_WITH_SIGNATURE = -404\n    ABI_ENCODE_CALL = -405\n\n    BYTES_CONCAT = -500\n    BYTES_LENGTH = -501\n    BYTES_PUSH = -502\n    BYTES_POP = -503\n\n    STRING_CONCAT = -600\n\n    ADDRESS_BALANCE = -700\n    ADDRESS_CODE = -701\n    ADDRESS_CODEHASH = -702\n    ADDRESS_TRANSFER = -703\n    ADDRESS_SEND = -704\n    ADDRESS_CALL = -705\n    ADDRESS_DELEGATECALL = -706\n    ADDRESS_STATICCALL = -707\n\n    # available for contracts and interfaces\n    TYPE_NAME = -800\n    TYPE_CREATION_CODE = -801\n    TYPE_RUNTIME_CODE = -802\n    # available for interfaces only\n    TYPE_INTERFACE_ID = -803\n    # available for integers\n    TYPE_MIN = -804\n    TYPE_MAX = -805\n\n    ARRAY_LENGTH = -900\n    ARRAY_PUSH = -901\n    ARRAY_POP = -902\n\n    FUNCTION_SELECTOR = -1000\n    FUNCTION_VALUE = -1001\n    FUNCTION_GAS = -1002\n    FUNCTION_ADDRESS = -1003\n\n    USER_DEFINED_VALUE_TYPE_WRAP = -1100\n    USER_DEFINED_VALUE_TYPE_UNWRAP = -1101\n</code></pre>"},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.ABI","title":"<code>ABI = -1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.ABI_DECODE","title":"<code>ABI_DECODE = -400</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.ABI_ENCODE","title":"<code>ABI_ENCODE = -401</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.ABI_ENCODE_CALL","title":"<code>ABI_ENCODE_CALL = -405</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.ABI_ENCODE_PACKED","title":"<code>ABI_ENCODE_PACKED = -402</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.ABI_ENCODE_WITH_SELECTOR","title":"<code>ABI_ENCODE_WITH_SELECTOR = -403</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.ABI_ENCODE_WITH_SIGNATURE","title":"<code>ABI_ENCODE_WITH_SIGNATURE = -404</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.ADDMOD","title":"<code>ADDMOD = -2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.ADDRESS_BALANCE","title":"<code>ADDRESS_BALANCE = -700</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.ADDRESS_CALL","title":"<code>ADDRESS_CALL = -705</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.ADDRESS_CODE","title":"<code>ADDRESS_CODE = -701</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.ADDRESS_CODEHASH","title":"<code>ADDRESS_CODEHASH = -702</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.ADDRESS_DELEGATECALL","title":"<code>ADDRESS_DELEGATECALL = -706</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.ADDRESS_SEND","title":"<code>ADDRESS_SEND = -704</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.ADDRESS_STATICCALL","title":"<code>ADDRESS_STATICCALL = -707</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.ADDRESS_TRANSFER","title":"<code>ADDRESS_TRANSFER = -703</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.ARRAY_LENGTH","title":"<code>ARRAY_LENGTH = -900</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.ARRAY_POP","title":"<code>ARRAY_POP = -902</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.ARRAY_PUSH","title":"<code>ARRAY_PUSH = -901</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.ASSERT","title":"<code>ASSERT = -3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.BLOBHASH","title":"<code>BLOBHASH = -29</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.BLOCK","title":"<code>BLOCK = -4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.BLOCKHASH","title":"<code>BLOCKHASH = -5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.BLOCK_BASEFEE","title":"<code>BLOCK_BASEFEE = -100</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.BLOCK_BLOBBASEFEE","title":"<code>BLOCK_BLOBBASEFEE = -108</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.BLOCK_CHAINID","title":"<code>BLOCK_CHAINID = -101</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.BLOCK_COINBASE","title":"<code>BLOCK_COINBASE = -102</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.BLOCK_DIFFICULTY","title":"<code>BLOCK_DIFFICULTY = -103</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.BLOCK_GASLIMIT","title":"<code>BLOCK_GASLIMIT = -104</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.BLOCK_NUMBER","title":"<code>BLOCK_NUMBER = -105</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.BLOCK_PREVRANDAO","title":"<code>BLOCK_PREVRANDAO = -107</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.BLOCK_TIMESTAMP","title":"<code>BLOCK_TIMESTAMP = -106</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.BYTES_CONCAT","title":"<code>BYTES_CONCAT = -500</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.BYTES_LENGTH","title":"<code>BYTES_LENGTH = -501</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.BYTES_POP","title":"<code>BYTES_POP = -503</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.BYTES_PUSH","title":"<code>BYTES_PUSH = -502</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.ECRECOVER","title":"<code>ECRECOVER = -6</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.FUNCTION_ADDRESS","title":"<code>FUNCTION_ADDRESS = -1003</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.FUNCTION_GAS","title":"<code>FUNCTION_GAS = -1002</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.FUNCTION_SELECTOR","title":"<code>FUNCTION_SELECTOR = -1000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.FUNCTION_VALUE","title":"<code>FUNCTION_VALUE = -1001</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.GASLEFT","title":"<code>GASLEFT = -7</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.KECCAK256","title":"<code>KECCAK256 = -8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.LOG0","title":"<code>LOG0 = -10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.LOG1","title":"<code>LOG1 = -11</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.LOG2","title":"<code>LOG2 = -12</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.LOG3","title":"<code>LOG3 = -13</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.LOG4","title":"<code>LOG4 = -14</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.MSG","title":"<code>MSG = -15</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.MSG_DATA","title":"<code>MSG_DATA = -200</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.MSG_SENDER","title":"<code>MSG_SENDER = -201</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.MSG_SIG","title":"<code>MSG_SIG = -202</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.MSG_VALUE","title":"<code>MSG_VALUE = -203</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.MULMOD","title":"<code>MULMOD = -16</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.NOW","title":"<code>NOW = -17</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.REQUIRE","title":"<code>REQUIRE = -18</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.REVERT","title":"<code>REVERT = -19</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.RIPEMD160","title":"<code>RIPEMD160 = -20</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.SELFDESTRUCT","title":"<code>SELFDESTRUCT = -21</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.SHA256","title":"<code>SHA256 = -22</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.SHA3","title":"<code>SHA3 = -23</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.STRING_CONCAT","title":"<code>STRING_CONCAT = -600</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.SUICIDE","title":"<code>SUICIDE = -24</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.SUPER","title":"<code>SUPER = -25</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.THIS","title":"<code>THIS = -28</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.TX","title":"<code>TX = -26</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.TX_GASPRICE","title":"<code>TX_GASPRICE = -300</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.TX_ORIGIN","title":"<code>TX_ORIGIN = -301</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.TYPE","title":"<code>TYPE = -27</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.TYPE_CREATION_CODE","title":"<code>TYPE_CREATION_CODE = -801</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.TYPE_INTERFACE_ID","title":"<code>TYPE_INTERFACE_ID = -803</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.TYPE_MAX","title":"<code>TYPE_MAX = -805</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.TYPE_MIN","title":"<code>TYPE_MIN = -804</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.TYPE_NAME","title":"<code>TYPE_NAME = -800</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.TYPE_RUNTIME_CODE","title":"<code>TYPE_RUNTIME_CODE = -802</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.USER_DEFINED_VALUE_TYPE_UNWRAP","title":"<code>USER_DEFINED_VALUE_TYPE_UNWRAP = -1101</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.GlobalSymbol.USER_DEFINED_VALUE_TYPE_WRAP","title":"<code>USER_DEFINED_VALUE_TYPE_WRAP = -1100</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.InlineAssemblyEvmVersion","title":"<code>InlineAssemblyEvmVersion</code>  <code>class</code>","text":"<p>         Bases: <code>StrEnum</code></p> Source code in <code>wake/ir/enums.py</code> <pre><code>class InlineAssemblyEvmVersion(StrEnum):\n    HOMESTEAD = \"homestead\"\n    TANGERINE_WHISTLE = \"tangerineWhistle\"\n    SPURIOUS_DRAGON = \"spuriousDragon\"\n    BYZANTIUM = \"byzantium\"\n    CONSTANTINOPLE = \"constantinople\"\n    PETERSBURG = \"petersburg\"\n    ISTANBUL = \"istanbul\"\n    BERLIN = \"berlin\"\n    LONDON = \"london\"\n    PARIS = \"paris\"\n    SHANGHAI = \"shanghai\"\n    CANCUN = \"cancun\"\n</code></pre>"},{"location":"api-reference/ir/enums/#wake.ir.enums.InlineAssemblyEvmVersion.BERLIN","title":"<code>BERLIN = 'berlin'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.InlineAssemblyEvmVersion.BYZANTIUM","title":"<code>BYZANTIUM = 'byzantium'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.InlineAssemblyEvmVersion.CANCUN","title":"<code>CANCUN = 'cancun'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.InlineAssemblyEvmVersion.CONSTANTINOPLE","title":"<code>CONSTANTINOPLE = 'constantinople'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.InlineAssemblyEvmVersion.HOMESTEAD","title":"<code>HOMESTEAD = 'homestead'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.InlineAssemblyEvmVersion.ISTANBUL","title":"<code>ISTANBUL = 'istanbul'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.InlineAssemblyEvmVersion.LONDON","title":"<code>LONDON = 'london'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.InlineAssemblyEvmVersion.PARIS","title":"<code>PARIS = 'paris'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.InlineAssemblyEvmVersion.PETERSBURG","title":"<code>PETERSBURG = 'petersburg'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.InlineAssemblyEvmVersion.SHANGHAI","title":"<code>SHANGHAI = 'shanghai'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.InlineAssemblyEvmVersion.SPURIOUS_DRAGON","title":"<code>SPURIOUS_DRAGON = 'spuriousDragon'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.InlineAssemblyEvmVersion.TANGERINE_WHISTLE","title":"<code>TANGERINE_WHISTLE = 'tangerineWhistle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.InlineAssemblyFlag","title":"<code>InlineAssemblyFlag</code>  <code>class</code>","text":"<p>         Bases: <code>StrEnum</code></p> Source code in <code>wake/ir/enums.py</code> <pre><code>class InlineAssemblyFlag(StrEnum):\n    MEMORY_SAFE = \"memory-safe\"\n</code></pre>"},{"location":"api-reference/ir/enums/#wake.ir.enums.InlineAssemblyFlag.MEMORY_SAFE","title":"<code>MEMORY_SAFE = 'memory-safe'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.InlineAssemblySuffix","title":"<code>InlineAssemblySuffix</code>  <code>class</code>","text":"<p>         Bases: <code>StrEnum</code></p> Source code in <code>wake/ir/enums.py</code> <pre><code>class InlineAssemblySuffix(StrEnum):\n    SLOT = \"slot\"\n    OFFSET = \"offset\"\n    LENGTH = \"length\"\n    ADDRESS = \"address\"\n    SELECTOR = \"selector\"\n</code></pre>"},{"location":"api-reference/ir/enums/#wake.ir.enums.InlineAssemblySuffix.ADDRESS","title":"<code>ADDRESS = 'address'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.InlineAssemblySuffix.LENGTH","title":"<code>LENGTH = 'length'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.InlineAssemblySuffix.OFFSET","title":"<code>OFFSET = 'offset'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.InlineAssemblySuffix.SELECTOR","title":"<code>SELECTOR = 'selector'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.InlineAssemblySuffix.SLOT","title":"<code>SLOT = 'slot'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.LiteralKind","title":"<code>LiteralKind</code>  <code>class</code>","text":"<p>         Bases: <code>StrEnum</code></p> <p>Kind of a Literal expression node.</p> Source code in <code>wake/ir/enums.py</code> <pre><code>class LiteralKind(StrEnum):\n    \"\"\"\n    Kind of a [Literal][wake.ir.expressions.literal.Literal] expression node.\n    \"\"\"\n\n    BOOL = \"bool\"\n    NUMBER = \"number\"\n    STRING = \"string\"\n    HEX_STRING = \"hexString\"\n    UNICODE_STRING = \"unicodeString\"\n</code></pre>"},{"location":"api-reference/ir/enums/#wake.ir.enums.LiteralKind.BOOL","title":"<code>BOOL = 'bool'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.LiteralKind.HEX_STRING","title":"<code>HEX_STRING = 'hexString'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.LiteralKind.NUMBER","title":"<code>NUMBER = 'number'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.LiteralKind.STRING","title":"<code>STRING = 'string'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.LiteralKind.UNICODE_STRING","title":"<code>UNICODE_STRING = 'unicodeString'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.MagicTypeKind","title":"<code>MagicTypeKind</code>  <code>class</code>","text":"<p>         Bases: <code>StrEnum</code></p> <p>Kind of a Magic type.</p> Source code in <code>wake/ir/enums.py</code> <pre><code>class MagicTypeKind(StrEnum):\n    \"\"\"\n    Kind of a [Magic][wake.ir.types.Magic] type.\n    \"\"\"\n\n    BLOCK = \"block\"\n    MESSAGE = \"message\"\n    TRANSACTION = \"transaction\"\n    ABI = \"abi\"\n    META_TYPE = \"meta_type\"\n</code></pre>"},{"location":"api-reference/ir/enums/#wake.ir.enums.MagicTypeKind.ABI","title":"<code>ABI = 'abi'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.MagicTypeKind.BLOCK","title":"<code>BLOCK = 'block'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.MagicTypeKind.MESSAGE","title":"<code>MESSAGE = 'message'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.MagicTypeKind.META_TYPE","title":"<code>META_TYPE = 'meta_type'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.MagicTypeKind.TRANSACTION","title":"<code>TRANSACTION = 'transaction'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.ModifierInvocationKind","title":"<code>ModifierInvocationKind</code>  <code>class</code>","text":"<p>         Bases: <code>StrEnum</code></p> <p>Kind of a ModifierInvocation meta node.</p> Source code in <code>wake/ir/enums.py</code> <pre><code>class ModifierInvocationKind(StrEnum):\n    \"\"\"\n    Kind of a [ModifierInvocation][wake.ir.meta.modifier_invocation.ModifierInvocation] meta node.\n    \"\"\"\n\n    MODIFIER_INVOCATION = \"modifierInvocation\"\n    BASE_CONSTRUCTOR_SPECIFIER = \"baseConstructorSpecifier\"\n</code></pre>"},{"location":"api-reference/ir/enums/#wake.ir.enums.ModifierInvocationKind.BASE_CONSTRUCTOR_SPECIFIER","title":"<code>BASE_CONSTRUCTOR_SPECIFIER = 'baseConstructorSpecifier'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.ModifierInvocationKind.MODIFIER_INVOCATION","title":"<code>MODIFIER_INVOCATION = 'modifierInvocation'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.Mutability","title":"<code>Mutability</code>  <code>class</code>","text":"<p>         Bases: <code>StrEnum</code></p> <p>Mutability of a VariableDeclaration declaration node.</p> Source code in <code>wake/ir/enums.py</code> <pre><code>class Mutability(StrEnum):\n    \"\"\"\n    Mutability of a [VariableDeclaration][wake.ir.declarations.variable_declaration.VariableDeclaration] declaration node.\n    \"\"\"\n\n    MUTABLE = \"mutable\"\n    IMMUTABLE = \"immutable\"\n    CONSTANT = \"constant\"\n</code></pre>"},{"location":"api-reference/ir/enums/#wake.ir.enums.Mutability.CONSTANT","title":"<code>CONSTANT = 'constant'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.Mutability.IMMUTABLE","title":"<code>IMMUTABLE = 'immutable'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.Mutability.MUTABLE","title":"<code>MUTABLE = 'mutable'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.StateMutability","title":"<code>StateMutability</code>  <code>class</code>","text":"<p>         Bases: <code>StrEnum</code></p> <p>State mutability of:</p> <ul> <li>Function type,</li> <li>FunctionDefinition declaration,</li> <li>ElementaryTypeName and FunctionTypeName type names.</li> </ul> <p>In the case of ElementaryTypeName, the state mutability is specified only for the <code>address</code> type and can be either NONPAYABLE or PAYABLE.</p> Source code in <code>wake/ir/enums.py</code> <pre><code>class StateMutability(StrEnum):\n    \"\"\"\n    State mutability of:\n\n    - [Function][wake.ir.types.Function] type,\n    - [FunctionDefinition][wake.ir.declarations.function_definition.FunctionDefinition] declaration,\n    - [ElementaryTypeName][wake.ir.type_names.elementary_type_name.ElementaryTypeName] and [FunctionTypeName][wake.ir.type_names.function_type_name.FunctionTypeName] type names.\n\n    In the case of [ElementaryTypeName][wake.ir.type_names.elementary_type_name.ElementaryTypeName], the state mutability is specified only for the `address` type and can be either [NONPAYABLE][wake.ir.enums.StateMutability.NONPAYABLE] or [PAYABLE][wake.ir.enums.StateMutability.PAYABLE].\n    \"\"\"\n\n    PAYABLE = \"payable\"\n    PURE = \"pure\"\n    NONPAYABLE = \"nonpayable\"\n    VIEW = \"view\"\n</code></pre>"},{"location":"api-reference/ir/enums/#wake.ir.enums.StateMutability.NONPAYABLE","title":"<code>NONPAYABLE = 'nonpayable'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.StateMutability.PAYABLE","title":"<code>PAYABLE = 'payable'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.StateMutability.PURE","title":"<code>PURE = 'pure'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.StateMutability.VIEW","title":"<code>VIEW = 'view'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.UnaryOpOperator","title":"<code>UnaryOpOperator</code>  <code>class</code>","text":"<p>         Bases: <code>StrEnum</code></p> <p>Unary operation operator used in an UnaryOperation expression.</p> Source code in <code>wake/ir/enums.py</code> <pre><code>class UnaryOpOperator(StrEnum):\n    \"\"\"\n    Unary operation operator used in an [UnaryOperation][wake.ir.expressions.unary_operation.UnaryOperation] expression.\n    \"\"\"\n\n    PLUS_PLUS = r\"++\"\n    MINUS_MINUS = r\"--\"\n    MINUS = r\"-\"\n    NOT = r\"!\"\n    TILDE = r\"~\"\n    DELETE = \"delete\"\n</code></pre>"},{"location":"api-reference/ir/enums/#wake.ir.enums.UnaryOpOperator.DELETE","title":"<code>DELETE = 'delete'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.UnaryOpOperator.MINUS","title":"<code>MINUS = '-'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.UnaryOpOperator.MINUS_MINUS","title":"<code>MINUS_MINUS = '--'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.UnaryOpOperator.NOT","title":"<code>NOT = '!'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.UnaryOpOperator.PLUS_PLUS","title":"<code>PLUS_PLUS = '++'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.UnaryOpOperator.TILDE","title":"<code>TILDE = '~'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.Visibility","title":"<code>Visibility</code>  <code>class</code>","text":"<p>         Bases: <code>StrEnum</code></p> <p>Visibility of:</p> <ul> <li>FunctionTypeName type name,</li> <li>FunctionDefinition, ModifierDefinition, StructDefinition and VariableDeclaration declarations.</li> </ul> Source code in <code>wake/ir/enums.py</code> <pre><code>class Visibility(StrEnum):\n    \"\"\"\n    Visibility of:\n\n    - [FunctionTypeName][wake.ir.type_names.function_type_name.FunctionTypeName] type name,\n    - [FunctionDefinition][wake.ir.declarations.function_definition.FunctionDefinition], [ModifierDefinition][wake.ir.declarations.modifier_definition.ModifierDefinition], [StructDefinition][wake.ir.declarations.struct_definition.StructDefinition] and [VariableDeclaration][wake.ir.declarations.variable_declaration.VariableDeclaration] declarations.\n    \"\"\"\n\n    EXTERNAL = \"external\"\n    PUBLIC = \"public\"\n    INTERNAL = \"internal\"\n    PRIVATE = \"private\"\n</code></pre>"},{"location":"api-reference/ir/enums/#wake.ir.enums.Visibility.EXTERNAL","title":"<code>EXTERNAL = 'external'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.Visibility.INTERNAL","title":"<code>INTERNAL = 'internal'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.Visibility.PRIVATE","title":"<code>PRIVATE = 'private'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.Visibility.PUBLIC","title":"<code>PUBLIC = 'public'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.YulLiteralKind","title":"<code>YulLiteralKind</code>  <code>class</code>","text":"<p>         Bases: <code>StrEnum</code></p> <p>Kind of a YulLiteral node.</p> Source code in <code>wake/ir/enums.py</code> <pre><code>class YulLiteralKind(StrEnum):\n    \"\"\"\n    Kind of a [YulLiteral][wake.ir.yul.literal.YulLiteral] node.\n    \"\"\"\n\n    NUMBER = \"number\"\n    STRING = \"string\"\n    BOOL = \"bool\"\n</code></pre>"},{"location":"api-reference/ir/enums/#wake.ir.enums.YulLiteralKind.BOOL","title":"<code>BOOL = 'bool'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.YulLiteralKind.NUMBER","title":"<code>NUMBER = 'number'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/enums/#wake.ir.enums.YulLiteralKind.STRING","title":"<code>STRING = 'string'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api-reference/ir/reference-resolver/","title":"reference_resolver","text":""},{"location":"api-reference/ir/reference-resolver/#wake.ir.reference_resolver","title":"<code>wake.ir.reference_resolver</code>  <code>module</code>","text":""},{"location":"api-reference/ir/reference-resolver/#wake.ir.reference_resolver.ReferenceResolver","title":"<code>ReferenceResolver</code>  <code>class</code>","text":"<p>The reference resolver is responsible for resolving references between IR nodes.</p> <p>A single Solidity source file can be compiled in multiple compilation units (CUs). Each CU may use different AST node IDs for the same AST node. The reference resolver can map between different AST node IDs for the same AST node by indexing the AST IDs by their file path and traversal order. Different compiler versions may produce (structurally) different ASTs for the same source code. All of these cases should be handled by the reference resolver.</p> <p>Wake holds only a single SourceUnit IR node for each source file. If a source file is compiled in multiple CUs, a canonical AST representation is chosen and the other CUs only perform indexing of the AST nodes. Which CU is chosen as the canonical is internal to Wake and should not be relied upon.</p> <p>A unique identifier across all CUs is a tuple (path, traversal_order).</p> Source code in <code>wake/ir/reference_resolver.py</code> <pre><code>class ReferenceResolver:\n    \"\"\"\n    The reference resolver is responsible for resolving references between IR nodes.\n\n    A single Solidity source file can be compiled in multiple compilation units (CUs).\n    Each CU may use different AST node IDs for the same AST node.\n    The reference resolver can map between different AST node IDs for the same AST node by indexing the AST IDs by their file path and traversal order.\n    Different compiler versions may produce (structurally) different ASTs for the same source code. All of these cases should be handled by the reference resolver.\n\n    Wake holds only a single [SourceUnit][wake.ir.meta.source_unit.SourceUnit] IR node for each source file.\n    If a source file is compiled in multiple CUs, a canonical AST representation is chosen and the other CUs only perform indexing of the AST nodes.\n    Which CU is chosen as the canonical is internal to Wake and should not be relied upon.\n\n    A unique identifier across all CUs is a tuple (path, traversal_order).\n    \"\"\"\n\n    _ordered_nodes: DefaultDict[bytes, Dict[AstNodeId, Tuple[Path, int]]]\n    _ordered_nodes_inverted: DefaultDict[bytes, Dict[Tuple[Path, int], AstNodeId]]\n    _registered_source_files: DefaultDict[bytes, Dict[int, Path]]\n    _registered_nodes: Dict[Tuple[Path, int], SolidityAbc]\n    _post_process_callbacks: List[PostProcessQueueItem]\n    _destroy_callbacks: DefaultDict[Path, List[Callable[[], None]]]\n    _global_symbol_references: DefaultDict[\n        GlobalSymbol, List[Union[Identifier, MemberAccess]]\n    ]\n    _node_types: Dict[Path, Dict[int, str]]\n\n    def __init__(self):\n        self._ordered_nodes = defaultdict(dict)\n        self._ordered_nodes_inverted = defaultdict(dict)\n        self._registered_source_files = defaultdict(dict)\n        self._registered_nodes = {}\n        self._post_process_callbacks = []\n        self._destroy_callbacks = defaultdict(list)\n        self._global_symbol_references = defaultdict(list)\n        self._node_types = {}\n\n    def clear_indexed_nodes(self, paths: Iterable[Path]) -&gt; None:\n        for path in paths:\n            self._node_types.pop(path, None)\n\n    def clear_all_indexed_nodes(self) -&gt; None:\n        self._node_types.clear()\n\n    def index_nodes(self, root_node: AstSolc, path: Path, cu_hash: bytes) -&gt; None:\n        if path not in self._node_types:\n            self._node_types[path] = {}\n            self._node_types[path][0] = root_node.node_type\n            check = False\n        else:\n            assert self._node_types[path][0] == root_node.node_type\n            check = True\n        prev_type = root_node.node_type\n\n        self._ordered_nodes[cu_hash][root_node.id] = (path, 0)\n        self._ordered_nodes_inverted[cu_hash][(path, 0)] = root_node.id\n        index = 1\n        for node in root_node:\n            if check:\n                skip = False\n                prev_other_type = self._node_types[path].get(index - 1)\n                other_type = self._node_types[path].get(index)\n\n                while other_type != node.node_type:\n                    if other_type == \"StructuredDocumentation\":\n                        index += 1\n                        other_type = self._node_types[path].get(index)\n                        continue\n                    elif node.node_type == \"StructuredDocumentation\":\n                        skip = True\n                        prev_type = \"StructuredDocumentation\"\n                        break\n                    elif (\n                        prev_other_type == \"UserDefinedTypeName\"\n                        and prev_type == \"UserDefinedTypeName\"\n                    ):\n                        if other_type == \"IdentifierPath\":\n                            index += 1\n                            other_type = self._node_types[path].get(index)\n                            continue\n                        elif node.node_type == \"IdentifierPath\":\n                            skip = True\n                            prev_type = \"IdentifierPath\"\n                            break\n                    elif (\n                        other_type == \"IdentifierPath\"\n                        and node.node_type == \"UserDefinedTypeName\"\n                    ) or (\n                        other_type == \"UserDefinedTypeName\"\n                        and node.node_type == \"IdentifierPath\"\n                    ):\n                        break\n\n                    assert (\n                        other_type == node.node_type\n                    ), f\"Expected {other_type} but got {node.node_type} at {path}:{index} {node.id}\"\n\n                if skip:\n                    continue\n            else:\n                self._node_types[path][index] = node.node_type\n\n            self._ordered_nodes[cu_hash][node.id] = (path, index)\n            self._ordered_nodes_inverted[cu_hash][(path, index)] = node.id\n\n            prev_type = node.node_type\n            index += 1\n\n    def register_source_file_id(self, source_file_id: int, path: Path, cu_hash: bytes):\n        self._registered_source_files[cu_hash][source_file_id] = path\n\n    def get_node_path_order(\n        self, node_id: AstNodeId, cu_hash: bytes\n    ) -&gt; Tuple[Path, int]:\n        \"\"\"\n        Get the (path, traversal_order) for a given AST node ID in a given CU.\n\n        Args:\n            node_id: AST node ID\n            cu_hash: hash of the compilation unit that contains the AST node ID\n\n        Returns:\n            Tuple of (path, traversal_order) for the AST node ID\n        \"\"\"\n        return self._ordered_nodes[cu_hash][node_id]\n\n    def get_ast_id_from_cu_node_path_order(\n        self, node_path_order: Tuple[Path, int], cu_hash: bytes\n    ) -&gt; AstNodeId:\n        \"\"\"\n        Get the AST node ID for a given (path, traversal_order) in a given CU.\n\n        Args:\n            node_path_order: (path, traversal_order) tuple\n            cu_hash: hash of the compilation unit that contains the returned AST node ID\n\n        Returns:\n            AST node ID for the given (path, traversal_order) tuple in the given CU\n        \"\"\"\n        return self._ordered_nodes_inverted[cu_hash][node_path_order]\n\n    def register_node(self, node: SolidityAbc, node_id: AstNodeId, cu_hash: bytes):\n        assert cu_hash in self._ordered_nodes\n        assert node_id in self._ordered_nodes[cu_hash]\n        node_path_order = self._ordered_nodes[cu_hash][node_id]\n        self._registered_nodes[node_path_order] = node\n\n    def resolve_node(self, node_id: AstNodeId, cu_hash: bytes) -&gt; SolidityAbc:\n        \"\"\"\n        Get the IR node for a given AST node ID in a given CU.\n\n        Args:\n            node_id: AST node ID\n            cu_hash: hash of the compilation unit that contains the AST node ID\n\n        Returns:\n            IR node for the given AST node ID in the given CU\n        \"\"\"\n        node_path_order = self._ordered_nodes[cu_hash][node_id]\n        return self._registered_nodes[node_path_order]\n\n    def resolve_source_file_id(self, source_file_id: int, cu_hash: bytes) -&gt; Path:\n        \"\"\"\n        `solc` compiler output also assigns integer IDs to source files.\n        This function can be used to get the absolute path to the source file for a given source file ID in a given CU.\n\n        Args:\n            source_file_id: source file ID\n            cu_hash: hash of the compilation unit that contains the source file ID\n\n        Returns:\n            Absolute path to the source file for the given source file ID in the given CU\n        \"\"\"\n        return self._registered_source_files[cu_hash][source_file_id]\n\n    def register_post_process_callback(\n        self, callback: Callable[[CallbackParams], None], priority: int = 0\n    ):\n        heapq.heappush(\n            self._post_process_callbacks, PostProcessQueueItem(priority, callback)\n        )\n\n    def register_destroy_callback(self, file: Path, callback: Callable[[], None]):\n        self._destroy_callbacks[file].append(callback)\n\n    def run_post_process_callbacks(self, callback_params: CallbackParams):\n        while len(self._post_process_callbacks):\n            callback = heapq.heappop(self._post_process_callbacks).callback\n            callback(callback_params)\n\n    def run_destroy_callbacks(self, file: Path):\n        for callback in self._destroy_callbacks[file]:\n            callback()\n        del self._destroy_callbacks[file]\n\n    def register_global_symbol_reference(\n        self, node_id: GlobalSymbol, node: Union[Identifier, MemberAccess]\n    ):\n        self._global_symbol_references[node_id].append(node)\n\n    def unregister_global_symbol_reference(\n        self, node_id: GlobalSymbol, node: Union[Identifier, MemberAccess]\n    ):\n        self._global_symbol_references[node_id].remove(node)\n\n    def get_global_symbol_references(\n        self, node_id: GlobalSymbol\n    ) -&gt; Tuple[Union[Identifier, MemberAccess], ...]:\n        \"\"\"\n        Get all references to a given global symbol.\n\n        Args:\n            node_id: global symbol\n\n        Returns:\n            Tuple of all references to the given global symbol\n        \"\"\"\n        return tuple(self._global_symbol_references[node_id])\n</code></pre>"},{"location":"api-reference/ir/reference-resolver/#wake.ir.reference_resolver.ReferenceResolver.get_ast_id_from_cu_node_path_order","title":"<code>get_ast_id_from_cu_node_path_order(node_path_order, cu_hash)</code>","text":"<p>Get the AST node ID for a given (path, traversal_order) in a given CU.</p> <p>Parameters:</p> Name Type Description Default <code>node_path_order</code> <code>Tuple[Path, int]</code> <p>(path, traversal_order) tuple</p> required <code>cu_hash</code> <code>bytes</code> <p>hash of the compilation unit that contains the returned AST node ID</p> required <p>Returns:</p> Type Description <code>AstNodeId</code> <p>AST node ID for the given (path, traversal_order) tuple in the given CU</p> Source code in <code>wake/ir/reference_resolver.py</code> <pre><code>def get_ast_id_from_cu_node_path_order(\n    self, node_path_order: Tuple[Path, int], cu_hash: bytes\n) -&gt; AstNodeId:\n    \"\"\"\n    Get the AST node ID for a given (path, traversal_order) in a given CU.\n\n    Args:\n        node_path_order: (path, traversal_order) tuple\n        cu_hash: hash of the compilation unit that contains the returned AST node ID\n\n    Returns:\n        AST node ID for the given (path, traversal_order) tuple in the given CU\n    \"\"\"\n    return self._ordered_nodes_inverted[cu_hash][node_path_order]\n</code></pre>"},{"location":"api-reference/ir/reference-resolver/#wake.ir.reference_resolver.ReferenceResolver.get_global_symbol_references","title":"<code>get_global_symbol_references(node_id)</code>","text":"<p>Get all references to a given global symbol.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>GlobalSymbol</code> <p>global symbol</p> required <p>Returns:</p> Type Description <code>Tuple[Union[Identifier, MemberAccess], ...]</code> <p>Tuple of all references to the given global symbol</p> Source code in <code>wake/ir/reference_resolver.py</code> <pre><code>def get_global_symbol_references(\n    self, node_id: GlobalSymbol\n) -&gt; Tuple[Union[Identifier, MemberAccess], ...]:\n    \"\"\"\n    Get all references to a given global symbol.\n\n    Args:\n        node_id: global symbol\n\n    Returns:\n        Tuple of all references to the given global symbol\n    \"\"\"\n    return tuple(self._global_symbol_references[node_id])\n</code></pre>"},{"location":"api-reference/ir/reference-resolver/#wake.ir.reference_resolver.ReferenceResolver.get_node_path_order","title":"<code>get_node_path_order(node_id, cu_hash)</code>","text":"<p>Get the (path, traversal_order) for a given AST node ID in a given CU.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>AstNodeId</code> <p>AST node ID</p> required <code>cu_hash</code> <code>bytes</code> <p>hash of the compilation unit that contains the AST node ID</p> required <p>Returns:</p> Type Description <code>Tuple[Path, int]</code> <p>Tuple of (path, traversal_order) for the AST node ID</p> Source code in <code>wake/ir/reference_resolver.py</code> <pre><code>def get_node_path_order(\n    self, node_id: AstNodeId, cu_hash: bytes\n) -&gt; Tuple[Path, int]:\n    \"\"\"\n    Get the (path, traversal_order) for a given AST node ID in a given CU.\n\n    Args:\n        node_id: AST node ID\n        cu_hash: hash of the compilation unit that contains the AST node ID\n\n    Returns:\n        Tuple of (path, traversal_order) for the AST node ID\n    \"\"\"\n    return self._ordered_nodes[cu_hash][node_id]\n</code></pre>"},{"location":"api-reference/ir/reference-resolver/#wake.ir.reference_resolver.ReferenceResolver.resolve_node","title":"<code>resolve_node(node_id, cu_hash)</code>","text":"<p>Get the IR node for a given AST node ID in a given CU.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>AstNodeId</code> <p>AST node ID</p> required <code>cu_hash</code> <code>bytes</code> <p>hash of the compilation unit that contains the AST node ID</p> required <p>Returns:</p> Type Description <code>SolidityAbc</code> <p>IR node for the given AST node ID in the given CU</p> Source code in <code>wake/ir/reference_resolver.py</code> <pre><code>def resolve_node(self, node_id: AstNodeId, cu_hash: bytes) -&gt; SolidityAbc:\n    \"\"\"\n    Get the IR node for a given AST node ID in a given CU.\n\n    Args:\n        node_id: AST node ID\n        cu_hash: hash of the compilation unit that contains the AST node ID\n\n    Returns:\n        IR node for the given AST node ID in the given CU\n    \"\"\"\n    node_path_order = self._ordered_nodes[cu_hash][node_id]\n    return self._registered_nodes[node_path_order]\n</code></pre>"},{"location":"api-reference/ir/reference-resolver/#wake.ir.reference_resolver.ReferenceResolver.resolve_source_file_id","title":"<code>resolve_source_file_id(source_file_id, cu_hash)</code>","text":"<p><code>solc</code> compiler output also assigns integer IDs to source files. This function can be used to get the absolute path to the source file for a given source file ID in a given CU.</p> <p>Parameters:</p> Name Type Description Default <code>source_file_id</code> <code>int</code> <p>source file ID</p> required <code>cu_hash</code> <code>bytes</code> <p>hash of the compilation unit that contains the source file ID</p> required <p>Returns:</p> Type Description <code>Path</code> <p>Absolute path to the source file for the given source file ID in the given CU</p> Source code in <code>wake/ir/reference_resolver.py</code> <pre><code>def resolve_source_file_id(self, source_file_id: int, cu_hash: bytes) -&gt; Path:\n    \"\"\"\n    `solc` compiler output also assigns integer IDs to source files.\n    This function can be used to get the absolute path to the source file for a given source file ID in a given CU.\n\n    Args:\n        source_file_id: source file ID\n        cu_hash: hash of the compilation unit that contains the source file ID\n\n    Returns:\n        Absolute path to the source file for the given source file ID in the given CU\n    \"\"\"\n    return self._registered_source_files[cu_hash][source_file_id]\n</code></pre>"},{"location":"api-reference/ir/types/","title":"types","text":"<p>Types represent the type of an expression (ExpressionAbc), type name (TypeNameAbc) and VariableDeclaration.</p>"},{"location":"api-reference/ir/types/#wake.ir.types","title":"<code>wake.ir.types</code>  <code>module</code>","text":""},{"location":"api-reference/ir/types/#wake.ir.types.TypeAbc","title":"<code>TypeAbc</code>  <code>class</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Abstract base class for all types.</p> Source code in <code>wake/ir/types.py</code> <pre><code>class TypeAbc(ABC):\n    \"\"\"\n    Abstract base class for all types.\n    \"\"\"\n\n    @classmethod\n    def from_type_identifier(\n        cls,\n        type_identifier: StringReader,\n        reference_resolver: ReferenceResolver,\n        cu_hash: bytes,\n    ) -&gt; typ.Optional[TypeAbc]:\n        if type_identifier.startswith(\"t_address\"):\n            return Address.from_type_identifier(\n                type_identifier, reference_resolver, cu_hash\n            )\n        elif type_identifier.startswith(\"t_bool\"):\n            return Bool.from_type_identifier(\n                type_identifier, reference_resolver, cu_hash\n            )\n        elif type_identifier.startswith(\"t_int\"):\n            return Int.from_type_identifier(\n                type_identifier, reference_resolver, cu_hash\n            )\n        elif type_identifier.startswith(\"t_uint\"):\n            return UInt.from_type_identifier(\n                type_identifier, reference_resolver, cu_hash\n            )\n        elif type_identifier.startswith(\"t_stringliteral_\"):\n            return StringLiteral.from_type_identifier(\n                type_identifier, reference_resolver, cu_hash\n            )\n        elif type_identifier.startswith(\"t_string_\"):\n            return String.from_type_identifier(\n                type_identifier, reference_resolver, cu_hash\n            )\n        elif type_identifier.startswith(\"t_bytes_\"):\n            return Bytes.from_type_identifier(\n                type_identifier, reference_resolver, cu_hash\n            )\n        # must go after t_bytes_ !!\n        elif type_identifier.startswith(\"t_bytes\"):\n            return FixedBytes.from_type_identifier(\n                type_identifier, reference_resolver, cu_hash\n            )\n        elif type_identifier.startswith(\"t_function\"):\n            return Function.from_type_identifier(\n                type_identifier, reference_resolver, cu_hash\n            )\n        elif type_identifier.startswith(\"t_tuple\"):\n            return Tuple.from_type_identifier(\n                type_identifier, reference_resolver, cu_hash\n            )\n        elif type_identifier.startswith(\"t_type\"):\n            return Type.from_type_identifier(\n                type_identifier, reference_resolver, cu_hash\n            )\n        elif type_identifier.startswith(\"t_rational\"):\n            return Rational.from_type_identifier(\n                type_identifier, reference_resolver, cu_hash\n            )\n        elif type_identifier.startswith(\"t_modifier\"):\n            return Modifier.from_type_identifier(\n                type_identifier, reference_resolver, cu_hash\n            )\n        elif type_identifier.startswith(\"t_array\"):\n            return Array.from_type_identifier(\n                type_identifier, reference_resolver, cu_hash\n            )\n        elif type_identifier.startswith(\"t_mapping\"):\n            return Mapping.from_type_identifier(\n                type_identifier, reference_resolver, cu_hash\n            )\n        elif type_identifier.startswith(\"t_contract\") or type_identifier.startswith(\n            \"t_super\"\n        ):\n            return Contract.from_type_identifier(\n                type_identifier, reference_resolver, cu_hash\n            )\n        elif type_identifier.startswith(\"t_struct\"):\n            return Struct.from_type_identifier(\n                type_identifier, reference_resolver, cu_hash\n            )\n        elif type_identifier.startswith(\"t_enum\"):\n            return Enum.from_type_identifier(\n                type_identifier, reference_resolver, cu_hash\n            )\n        elif type_identifier.startswith(\"t_magic\"):\n            return Magic.from_type_identifier(\n                type_identifier, reference_resolver, cu_hash\n            )\n        elif type_identifier.startswith(\"t_userDefinedValueType\"):\n            return UserDefinedValueType.from_type_identifier(\n                type_identifier, reference_resolver, cu_hash\n            )\n        elif type_identifier.startswith(\"t_module\"):\n            return Module.from_type_identifier(\n                type_identifier, reference_resolver, cu_hash\n            )\n        elif type_identifier.startswith(\"t_fixed\"):\n            return Fixed.from_type_identifier(\n                type_identifier, reference_resolver, cu_hash\n            )\n        elif type_identifier.startswith(\"t_ufixed\"):\n            return UFixed.from_type_identifier(\n                type_identifier, reference_resolver, cu_hash\n            )\n        elif type_identifier.startswith(\"t_error\"):\n            return Error.from_type_identifier(\n                type_identifier, reference_resolver, cu_hash\n            )\n        else:\n            return None\n\n    @property\n    @abstractmethod\n    def abi_type(self) -&gt; str:\n        \"\"\"\n        Raises:\n            NotImplementedError: If the type cannot be represented in contract ABI.\n\n        Returns:\n            ABI type string.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api-reference/ir/types/#wake.ir.types.TypeAbc.abi_type","title":"<code>abi_type: str</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the type cannot be represented in contract ABI.</p> <p>Returns:</p> Type Description <code>str</code> <p>ABI type string.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Address","title":"<code>Address</code>  <code>class</code>","text":"<p>         Bases: <code>TypeAbc</code></p> <p>Address type.</p> Source code in <code>wake/ir/types.py</code> <pre><code>class Address(TypeAbc):\n    \"\"\"\n    Address type.\n    \"\"\"\n\n    _is_payable: bool\n\n    def __init__(self, is_payable: bool):\n        self._is_payable = is_payable\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, Address):\n            return False\n        return self._is_payable == other._is_payable\n\n    def __hash__(self):\n        return hash(self._is_payable)\n\n    def __repr__(self):\n        return f\"Address(is_payable={self._is_payable})\"\n\n    @classmethod\n    def from_type_identifier(\n        cls,\n        type_identifier: StringReader,\n        reference_resolver: ReferenceResolver,\n        cu_hash: bytes,\n    ) -&gt; Address:\n        type_identifier.read(\"t_address\")\n\n        if type_identifier.startswith(\"_payable\"):\n            type_identifier.read(\"_payable\")\n            return Address(True)\n        else:\n            return Address(False)\n\n    @property\n    def abi_type(self) -&gt; str:\n        return \"address\"\n\n    @property\n    def is_payable(self) -&gt; bool:\n        \"\"\"\n        Returns:\n            `True` if the address is payable, `False` otherwise.\n        \"\"\"\n        return self._is_payable\n</code></pre>"},{"location":"api-reference/ir/types/#wake.ir.types.Address.is_payable","title":"<code>is_payable: bool</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the address is payable, <code>False</code> otherwise.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Bool","title":"<code>Bool</code>  <code>class</code>","text":"<p>         Bases: <code>TypeAbc</code></p> <p>Boolean type.</p> Source code in <code>wake/ir/types.py</code> <pre><code>class Bool(TypeAbc):\n    \"\"\"\n    Boolean type.\n    \"\"\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        return isinstance(other, Bool)\n\n    def __hash__(self):\n        return hash(\"bool\")\n\n    def __repr__(self):\n        return \"Bool()\"\n\n    @classmethod\n    def from_type_identifier(\n        cls,\n        type_identifier: StringReader,\n        reference_resolver: ReferenceResolver,\n        cu_hash: bytes,\n    ) -&gt; Bool:\n        type_identifier.read(\"t_bool\")\n        return Bool()\n\n    @property\n    def abi_type(self) -&gt; str:\n        return \"bool\"\n</code></pre>"},{"location":"api-reference/ir/types/#wake.ir.types.IntAbc","title":"<code>IntAbc</code>  <code>class</code>","text":"<p>         Bases: <code>TypeAbc</code></p> <p>Base class for Int and UInt types.</p> Source code in <code>wake/ir/types.py</code> <pre><code>class IntAbc(TypeAbc):\n    \"\"\"\n    Base class for [Int][wake.ir.types.Int] and [UInt][wake.ir.types.UInt] types.\n    \"\"\"\n\n    _bits_count: int\n\n    @property\n    def bits_count(self) -&gt; int:\n        \"\"\"\n        Can only be a multiple of 8, with a minimum of 8 and a maximum of 256.\n\n        Returns:\n            Number of bits used to represent this integer.\n        \"\"\"\n        return self._bits_count\n</code></pre>"},{"location":"api-reference/ir/types/#wake.ir.types.IntAbc.bits_count","title":"<code>bits_count: int</code>  <code>property</code>","text":"<p>Can only be a multiple of 8, with a minimum of 8 and a maximum of 256.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of bits used to represent this integer.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Int","title":"<code>Int</code>  <code>class</code>","text":"<p>         Bases: <code>IntAbc</code></p> <p>Signed integer type.</p> Source code in <code>wake/ir/types.py</code> <pre><code>class Int(IntAbc):\n    \"\"\"\n    Signed integer type.\n    \"\"\"\n\n    def __init__(self, bits_count: int):\n        self._bits_count = bits_count\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, Int):\n            return False\n        return self._bits_count == other._bits_count\n\n    def __hash__(self):\n        return hash(self._bits_count)\n\n    def __repr__(self):\n        return f\"Int(bits_count={self._bits_count})\"\n\n    @classmethod\n    def from_type_identifier(\n        cls,\n        type_identifier: StringReader,\n        reference_resolver: ReferenceResolver,\n        cu_hash: bytes,\n    ) -&gt; Int:\n        type_identifier.read(\"t_int\")\n        match = NUMBER_RE.match(type_identifier.data)\n        assert match is not None\n        number = match.group(\"number\")\n        type_identifier.read(number)\n        return Int(int(number))\n\n    @property\n    def abi_type(self) -&gt; str:\n        return f\"int{self._bits_count}\"\n</code></pre>"},{"location":"api-reference/ir/types/#wake.ir.types.UInt","title":"<code>UInt</code>  <code>class</code>","text":"<p>         Bases: <code>IntAbc</code></p> <p>Unsigned integer type.</p> Source code in <code>wake/ir/types.py</code> <pre><code>class UInt(IntAbc):\n    \"\"\"\n    Unsigned integer type.\n    \"\"\"\n\n    def __init__(self, bits_count: int):\n        self._bits_count = bits_count\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, UInt):\n            return False\n        return self._bits_count == other._bits_count\n\n    def __hash__(self):\n        return hash(self._bits_count)\n\n    def __repr__(self):\n        return f\"UInt(bits_count={self._bits_count})\"\n\n    @classmethod\n    def from_type_identifier(\n        cls,\n        type_identifier: StringReader,\n        reference_resolver: ReferenceResolver,\n        cu_hash: bytes,\n    ) -&gt; UInt:\n        type_identifier.read(\"t_uint\")\n        match = NUMBER_RE.match(type_identifier.data)\n        assert match is not None\n        number = match.group(\"number\")\n        type_identifier.read(number)\n        return UInt(int(number))\n\n    @property\n    def abi_type(self) -&gt; str:\n        return f\"uint{self._bits_count}\"\n</code></pre>"},{"location":"api-reference/ir/types/#wake.ir.types.FixedAbc","title":"<code>FixedAbc</code>  <code>class</code>","text":"<p>         Bases: <code>TypeAbc</code></p> <p>Base class for Fixed and UFixed types.</p> <p>Info</p> <p>Currently not fully implemented in Solidity.</p> Source code in <code>wake/ir/types.py</code> <pre><code>class FixedAbc(TypeAbc):\n    \"\"\"\n    Base class for [Fixed][wake.ir.types.Fixed] and [UFixed][wake.ir.types.UFixed] types.\n    !!! info\n        Currently not fully implemented in Solidity.\n    \"\"\"\n\n    _total_bits: int\n    _fractional_digits: int\n\n    @property\n    def total_bits(self) -&gt; int:\n        \"\"\"\n        Returns:\n            Total number of bits used to represent this fixed point number.\n        \"\"\"\n        return self._total_bits\n\n    @property\n    def fractional_digits(self) -&gt; int:\n        \"\"\"\n        Returns:\n            Number of decimal places available.\n        \"\"\"\n        return self._fractional_digits\n</code></pre>"},{"location":"api-reference/ir/types/#wake.ir.types.FixedAbc.total_bits","title":"<code>total_bits: int</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>int</code> <p>Total number of bits used to represent this fixed point number.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.FixedAbc.fractional_digits","title":"<code>fractional_digits: int</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>int</code> <p>Number of decimal places available.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Fixed","title":"<code>Fixed</code>  <code>class</code>","text":"<p>         Bases: <code>FixedAbc</code></p> <p>Signed fixed-point number type as specified by the Solidity docs.</p> <p>Info</p> <p>Currently not fully implemented in Solidity.</p> Source code in <code>wake/ir/types.py</code> <pre><code>class Fixed(FixedAbc):\n    \"\"\"\n    Signed fixed-point number type as specified by the [Solidity docs](https://docs.soliditylang.org/en/latest/types.html?highlight=fixed#fixed-point-numbers).\n    !!! info\n        Currently not fully implemented in Solidity.\n    \"\"\"\n\n    def __init__(self, total_bits: int, fractional_digits: int):\n        self._total_bits = total_bits\n        self._fractional_digits = fractional_digits\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, Fixed):\n            return False\n        return (\n            self._total_bits == other._total_bits\n            and self._fractional_digits == other._fractional_digits\n        )\n\n    def __hash__(self):\n        return hash((self._total_bits, self._fractional_digits))\n\n    def __repr__(self):\n        return f\"Fixed(total_bits={self._total_bits}, fractional_digits={self._fractional_digits})\"\n\n    @classmethod\n    def from_type_identifier(\n        cls,\n        type_identifier: StringReader,\n        reference_resolver: ReferenceResolver,\n        cu_hash: bytes,\n    ) -&gt; Fixed:\n        type_identifier.read(\"t_fixed\")\n        match = NUMBER_RE.match(type_identifier.data)\n        assert match is not None\n        total_bits = match.group(\"number\")\n        type_identifier.read(total_bits)\n\n        type_identifier.read(\"x\")\n\n        match = NUMBER_RE.match(type_identifier.data)\n        assert match is not None\n        fractional_digits = match.group(\"number\")\n        type_identifier.read(fractional_digits)\n        return Fixed(int(total_bits), int(fractional_digits))\n\n    @property\n    def abi_type(self) -&gt; str:\n        return f\"fixed{self._total_bits}x{self._fractional_digits}\"\n</code></pre>"},{"location":"api-reference/ir/types/#wake.ir.types.UFixed","title":"<code>UFixed</code>  <code>class</code>","text":"<p>         Bases: <code>FixedAbc</code></p> <p>Unsigned fixed point number type as specified by the Solidity docs.</p> <p>Info</p> <p>Currently not fully implemented in Solidity.</p> Source code in <code>wake/ir/types.py</code> <pre><code>class UFixed(FixedAbc):\n    \"\"\"\n    Unsigned fixed point number type as specified by the [Solidity docs](https://docs.soliditylang.org/en/latest/types.html?highlight=ufixed#fixed-point-numbers).\n    !!! info\n        Currently not fully implemented in Solidity.\n    \"\"\"\n\n    def __init__(self, total_bits: int, fractional_digits: int):\n        self._total_bits = total_bits\n        self._fractional_digits = fractional_digits\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, UFixed):\n            return False\n        return (\n            self._total_bits == other._total_bits\n            and self._fractional_digits == other._fractional_digits\n        )\n\n    def __hash__(self):\n        return hash((self._total_bits, self._fractional_digits))\n\n    def __repr__(self):\n        return f\"UFixed(total_bits={self._total_bits}, fractional_digits={self._fractional_digits})\"\n\n    @classmethod\n    def from_type_identifier(\n        cls,\n        type_identifier: StringReader,\n        reference_resolver: ReferenceResolver,\n        cu_hash: bytes,\n    ) -&gt; UFixed:\n        type_identifier.read(\"t_ufixed\")\n        match = NUMBER_RE.match(type_identifier.data)\n        assert match is not None\n        total_bits = match.group(\"number\")\n        type_identifier.read(total_bits)\n\n        type_identifier.read(\"x\")\n\n        match = NUMBER_RE.match(type_identifier.data)\n        assert match is not None\n        fractional_digits = match.group(\"number\")\n        type_identifier.read(fractional_digits)\n        return UFixed(int(total_bits), int(fractional_digits))\n\n    @property\n    def abi_type(self) -&gt; str:\n        return f\"ufixed{self._total_bits}x{self._fractional_digits}\"\n</code></pre>"},{"location":"api-reference/ir/types/#wake.ir.types.StringLiteral","title":"<code>StringLiteral</code>  <code>class</code>","text":"<p>         Bases: <code>TypeAbc</code></p> <p>String literal type.</p> <p>Warning</p> <p>This expression is of the StringLiteral type: <pre><code>\"Hello, world!\"\n</code></pre></p> <p>However, this expression is of the String type and contains a child expression of the StringLiteral type: <pre><code>string(\"Hello, world!\")\n</code></pre></p> Source code in <code>wake/ir/types.py</code> <pre><code>class StringLiteral(TypeAbc):\n    \"\"\"\n    String literal type.\n    !!! warning\n        This expression is of the [StringLiteral][wake.ir.types.StringLiteral] type:\n        ```solidity\n        \"Hello, world!\"\n        ```\n\n        However, this expression is of the [String][wake.ir.types.String] type and contains a child expression of the [StringLiteral][wake.ir.types.StringLiteral] type:\n        ```solidity\n        string(\"Hello, world!\")\n        ```\n    \"\"\"\n\n    _keccak256_hash: bytes\n\n    def __init__(self, keccak256_hash: bytes):\n        self._keccak256_hash = keccak256_hash\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, StringLiteral):\n            return False\n        return self._keccak256_hash == other._keccak256_hash\n\n    def __hash__(self):\n        return hash(self._keccak256_hash)\n\n    def __repr__(self):\n        return f'StringLiteral(keccak256_hash=b\"{self._keccak256_hash}\"'\n\n    @classmethod\n    def from_type_identifier(\n        cls,\n        type_identifier: StringReader,\n        reference_resolver: ReferenceResolver,\n        cu_hash: bytes,\n    ) -&gt; StringLiteral:\n        type_identifier.read(\"t_stringliteral_\")\n        match = HEX_RE.match(type_identifier.data)\n        assert match is not None\n        hex = match.group(\"hex\")\n        type_identifier.read(hex)\n        return StringLiteral(bytes.fromhex(hex))\n\n    @property\n    def abi_type(self) -&gt; str:\n        raise NotImplementedError\n\n    @property\n    def keccak256_hash(self) -&gt; bytes:\n        \"\"\"\n        Returns:\n            Keccak256 hash of the string literal.\n        \"\"\"\n        return self._keccak256_hash\n</code></pre>"},{"location":"api-reference/ir/types/#wake.ir.types.StringLiteral.keccak256_hash","title":"<code>keccak256_hash: bytes</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>bytes</code> <p>Keccak256 hash of the string literal.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.String","title":"<code>String</code>  <code>class</code>","text":"<p>         Bases: <code>TypeAbc</code></p> <p>String type.</p> Source code in <code>wake/ir/types.py</code> <pre><code>class String(TypeAbc):\n    \"\"\"\n    String type.\n    \"\"\"\n\n    _data_location: DataLocation\n    _is_pointer: bool\n    _is_slice: bool\n\n    def __init__(self, data_location: DataLocation, is_pointer: bool, is_slice: bool):\n        self._data_location = data_location\n        self._is_pointer = is_pointer\n        self._is_slice = is_slice\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, String):\n            return False\n        return (\n            self._data_location == other._data_location\n            and self._is_pointer == other._is_pointer\n            and self._is_slice == other._is_slice\n        )\n\n    def __hash__(self):\n        return hash((self._data_location, self._is_pointer, self._is_slice))\n\n    def __repr__(self):\n        return f\"String(data_location={self._data_location}, is_pointer={self._is_pointer}, is_slice={self._is_slice})\"\n\n    @classmethod\n    def from_type_identifier(\n        cls,\n        type_identifier: StringReader,\n        reference_resolver: ReferenceResolver,\n        cu_hash: bytes,\n    ) -&gt; String:\n        type_identifier.read(\"t_string\")\n        if type_identifier.startswith(\"_storage\"):\n            data_location = DataLocation.STORAGE\n            type_identifier.read(\"_storage\")\n        elif type_identifier.startswith(\"_memory\"):\n            data_location = DataLocation.MEMORY\n            type_identifier.read(\"_memory\")\n        elif type_identifier.startswith(\"_calldata\"):\n            data_location = DataLocation.CALLDATA\n            type_identifier.read(\"_calldata\")\n        else:\n            assert False, f\"Unexpected string type data location {type_identifier}\"\n\n        if type_identifier.startswith(\"_ptr\"):\n            is_pointer = True\n            type_identifier.read(\"_ptr\")\n        else:\n            is_pointer = False\n\n        if type_identifier.startswith(\"_slice\"):\n            is_slice = True\n            type_identifier.read(\"_slice\")\n        else:\n            is_slice = False\n\n        return String(data_location, is_pointer, is_slice)\n\n    @property\n    def abi_type(self) -&gt; str:\n        return \"string\"\n\n    @property\n    def data_location(self) -&gt; DataLocation:\n        \"\"\"\n        Can be either [CALLDATA][wake.ir.enums.DataLocation.CALLDATA], [MEMORY][wake.ir.enums.DataLocation.MEMORY] or [STORAGE][wake.ir.enums.DataLocation.STORAGE]\n\n        Returns:\n            Data location of the string expression.\n        \"\"\"\n        return self._data_location\n\n    @property\n    def is_pointer(self) -&gt; bool:\n        \"\"\"\n        Storage references can be pointers or bound references. In general, local variables are of\n        pointer type, state variables are bound references. Assignments to pointers or deleting\n        them will not modify storage (that will only change the pointer). Assignment from\n        non-storage objects to a variable of storage pointer type is not possible.\n\n        For anything other than [STORAGE][wake.ir.enums.DataLocation.STORAGE], this always returns `True` because assignments\n        never change the contents of the original value.\n\n        Returns:\n            Whether the string expression is a pointer to storage.\n        \"\"\"\n        return self._is_pointer\n\n    @property\n    def is_slice(self) -&gt; bool:\n        \"\"\"\n        !!! example\n            ```solidity\n            function foo(string calldata s) public pure {\n                s[0:5]; // s[0:5] is a string slice\n            }\n            ```\n\n        Returns:\n            Whether this is a slice of a string expression.\n        \"\"\"\n        return self._is_slice\n</code></pre>"},{"location":"api-reference/ir/types/#wake.ir.types.String.data_location","title":"<code>data_location: DataLocation</code>  <code>property</code>","text":"<p>Can be either CALLDATA, MEMORY or STORAGE</p> <p>Returns:</p> Type Description <code>DataLocation</code> <p>Data location of the string expression.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.String.is_pointer","title":"<code>is_pointer: bool</code>  <code>property</code>","text":"<p>Storage references can be pointers or bound references. In general, local variables are of pointer type, state variables are bound references. Assignments to pointers or deleting them will not modify storage (that will only change the pointer). Assignment from non-storage objects to a variable of storage pointer type is not possible.</p> <p>For anything other than STORAGE, this always returns <code>True</code> because assignments never change the contents of the original value.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the string expression is a pointer to storage.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.String.is_slice","title":"<code>is_slice: bool</code>  <code>property</code>","text":"<p>Example</p> <pre><code>function foo(string calldata s) public pure {\n    s[0:5]; // s[0:5] is a string slice\n}\n</code></pre> <p>Returns:</p> Type Description <code>bool</code> <p>Whether this is a slice of a string expression.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Bytes","title":"<code>Bytes</code>  <code>class</code>","text":"<p>         Bases: <code>TypeAbc</code></p> <p>Bytes type.</p> Source code in <code>wake/ir/types.py</code> <pre><code>class Bytes(TypeAbc):\n    \"\"\"\n    Bytes type.\n    \"\"\"\n\n    _data_location: DataLocation\n    _is_pointer: bool\n    _is_slice: bool\n\n    def __init__(self, data_location: DataLocation, is_pointer: bool, is_slice: bool):\n        self._data_location = data_location\n        self._is_pointer = is_pointer\n        self._is_slice = is_slice\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, Bytes):\n            return False\n        return (\n            self._data_location == other._data_location\n            and self._is_pointer == other._is_pointer\n            and self._is_slice == other._is_slice\n        )\n\n    def __hash__(self):\n        return hash((self._data_location, self._is_pointer, self._is_slice))\n\n    def __repr__(self):\n        return f\"Bytes(data_location={self._data_location}, is_pointer={self._is_pointer}, is_slice={self._is_slice})\"\n\n    @classmethod\n    def from_type_identifier(\n        cls,\n        type_identifier: StringReader,\n        reference_resolver: ReferenceResolver,\n        cu_hash: bytes,\n    ) -&gt; Bytes:\n        type_identifier.read(\"t_bytes\")\n        if type_identifier.startswith(\"_storage\"):\n            data_location = DataLocation.STORAGE\n            type_identifier.read(\"_storage\")\n        elif type_identifier.startswith(\"_memory\"):\n            data_location = DataLocation.MEMORY\n            type_identifier.read(\"_memory\")\n        elif type_identifier.startswith(\"_calldata\"):\n            data_location = DataLocation.CALLDATA\n            type_identifier.read(\"_calldata\")\n        else:\n            assert False, f\"Unexpected string type data location {type_identifier}\"\n\n        if type_identifier.startswith(\"_ptr\"):\n            is_pointer = True\n            type_identifier.read(\"_ptr\")\n        else:\n            is_pointer = False\n\n        if type_identifier.startswith(\"_slice\"):\n            is_slice = True\n            type_identifier.read(\"_slice\")\n        else:\n            is_slice = False\n\n        return Bytes(data_location, is_pointer, is_slice)\n\n    @property\n    def abi_type(self) -&gt; str:\n        return \"bytes\"\n\n    @property\n    def data_location(self) -&gt; DataLocation:\n        \"\"\"\n        Can be either [CALLDATA][wake.ir.enums.DataLocation.CALLDATA], [MEMORY][wake.ir.enums.DataLocation.MEMORY] or [STORAGE][wake.ir.enums.DataLocation.STORAGE]\n\n        Returns:\n            Data location of the bytes expression.\n        \"\"\"\n        return self._data_location\n\n    @property\n    def is_pointer(self) -&gt; bool:\n        \"\"\"\n        Storage references can be pointers or bound references. In general, local variables are of\n        pointer type, state variables are bound references. Assignments to pointers or deleting\n        them will not modify storage (that will only change the pointer). Assignment from\n        non-storage objects to a variable of storage pointer type is not possible.\n\n        For anything other than [STORAGE][wake.ir.enums.DataLocation.STORAGE], this always returns `True` because assignments\n        never change the contents of the original value.\n\n        Returns:\n            Whether the bytes expression is a pointer to storage.\n        \"\"\"\n        return self._is_pointer\n\n    @property\n    def is_slice(self) -&gt; bool:\n        \"\"\"\n        !!! example\n            ```solidity\n            function foo(bytes calldata b) public pure {\n                b[0:5]; // s[0:5] is a bytes slice\n            }\n            ```\n\n        Returns:\n            Whether this is a slice of a bytes expression.\n        \"\"\"\n        return self._is_slice\n</code></pre>"},{"location":"api-reference/ir/types/#wake.ir.types.Bytes.data_location","title":"<code>data_location: DataLocation</code>  <code>property</code>","text":"<p>Can be either CALLDATA, MEMORY or STORAGE</p> <p>Returns:</p> Type Description <code>DataLocation</code> <p>Data location of the bytes expression.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Bytes.is_pointer","title":"<code>is_pointer: bool</code>  <code>property</code>","text":"<p>Storage references can be pointers or bound references. In general, local variables are of pointer type, state variables are bound references. Assignments to pointers or deleting them will not modify storage (that will only change the pointer). Assignment from non-storage objects to a variable of storage pointer type is not possible.</p> <p>For anything other than STORAGE, this always returns <code>True</code> because assignments never change the contents of the original value.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the bytes expression is a pointer to storage.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Bytes.is_slice","title":"<code>is_slice: bool</code>  <code>property</code>","text":"<p>Example</p> <pre><code>function foo(bytes calldata b) public pure {\n    b[0:5]; // s[0:5] is a bytes slice\n}\n</code></pre> <p>Returns:</p> Type Description <code>bool</code> <p>Whether this is a slice of a bytes expression.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.FixedBytes","title":"<code>FixedBytes</code>  <code>class</code>","text":"<p>         Bases: <code>TypeAbc</code></p> <p>Fixed-size byte array type.</p> Source code in <code>wake/ir/types.py</code> <pre><code>class FixedBytes(TypeAbc):\n    \"\"\"\n    Fixed-size byte array type.\n    \"\"\"\n\n    _bytes_count: int\n\n    def __init__(self, bytes_count: int):\n        self._bytes_count = bytes_count\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, FixedBytes):\n            return False\n        return self._bytes_count == other._bytes_count\n\n    def __hash__(self):\n        return hash(self._bytes_count)\n\n    def __repr__(self):\n        return f\"FixedBytes(bytes_count={self._bytes_count})\"\n\n    @classmethod\n    def from_type_identifier(\n        cls,\n        type_identifier: StringReader,\n        reference_resolver: ReferenceResolver,\n        cu_hash: bytes,\n    ) -&gt; FixedBytes:\n        type_identifier.read(\"t_bytes\")\n        match = NUMBER_RE.match(type_identifier.data)\n        assert match is not None\n        number = match.group(\"number\")\n        type_identifier.read(number)\n        return FixedBytes(int(number))\n\n    @property\n    def abi_type(self) -&gt; str:\n        return f\"bytes{self._bytes_count}\"\n\n    @property\n    def bytes_count(self) -&gt; int:\n        \"\"\"\n        Is at least 1 and at most 32.\n\n        Returns:\n            Number of bytes used to represent this fixed-size byte array.\n        \"\"\"\n        return self._bytes_count\n</code></pre>"},{"location":"api-reference/ir/types/#wake.ir.types.FixedBytes.bytes_count","title":"<code>bytes_count: int</code>  <code>property</code>","text":"<p>Is at least 1 and at most 32.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of bytes used to represent this fixed-size byte array.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Function","title":"<code>Function</code>  <code>class</code>","text":"<p>         Bases: <code>TypeAbc</code></p> <p>Function type.</p> <p>Warning</p> <p>Given the following function: <pre><code>function foo(uint a, uint b) public pure returns(uint, uint) {\n    return (a + b, a - b);\n}\n</code></pre> and the following call: <pre><code>foo(1, 2);\n</code></pre> the type of <code>foo</code> is Function, but the type of <code>foo(1, 2)</code> is Tuple.</p> Source code in <code>wake/ir/types.py</code> <pre><code>class Function(TypeAbc):\n    \"\"\"\n    Function type.\n\n    !!! warning\n        Given the following function:\n        ```solidity\n        function foo(uint a, uint b) public pure returns(uint, uint) {\n            return (a + b, a - b);\n        }\n        ```\n        and the following call:\n        ```solidity\n        foo(1, 2);\n        ```\n        the type of `foo` is [Function][wake.ir.types.Function], but the type of `:::solidity foo(1, 2)` is [Tuple][wake.ir.types.Tuple].\n    \"\"\"\n\n    _kind: FunctionTypeKind\n    _state_mutability: StateMutability\n    _parameters: typ.Tuple[TypeAbc, ...]\n    _return_parameters: typ.Tuple[TypeAbc, ...]\n    _gas_set: bool\n    _value_set: bool\n    _salt_set: bool\n    _attached_to: typ.Optional[typ.Tuple[TypeAbc, ...]]\n\n    def __init__(\n        self,\n        kind: FunctionTypeKind,\n        state_mutability: StateMutability,\n        parameters: typ.Iterable[TypeAbc],\n        return_parameters: typ.Iterable[TypeAbc],\n        gas_set: bool,\n        value_set: bool,\n        salt_set: bool,\n        attached_to: typ.Optional[typ.Iterable[TypeAbc]],\n    ):\n        self._kind = kind\n        self._state_mutability = state_mutability\n        self._parameters = tuple(parameters)\n        self._return_parameters = tuple(return_parameters)\n        self._gas_set = gas_set\n        self._value_set = value_set\n        self._salt_set = salt_set\n        if attached_to is not None:\n            self._attached_to = tuple(attached_to)\n        else:\n            self._attached_to = None\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, Function):\n            return False\n        return (\n            self._kind == other._kind\n            and self._state_mutability == other._state_mutability\n            and self._parameters == other._parameters\n            and self._return_parameters == other._return_parameters\n            and self._gas_set == other._gas_set\n            and self._value_set == other._value_set\n            and self._salt_set == other._salt_set\n            and self._attached_to == other._attached_to\n        )\n\n    def __hash__(self):\n        return hash(\n            (\n                self._kind,\n                self._state_mutability,\n                self._parameters,\n                self._return_parameters,\n                self._gas_set,\n                self._value_set,\n                self._salt_set,\n                self._attached_to,\n            )\n        )\n\n    def __repr__(self):\n        return f\"Function(kind={self._kind}, state_mutability={self._state_mutability}, parameters={self._parameters}, return_parameters={self._return_parameters}, gas_set={self._gas_set}, value_set={self._value_set}, salt_set={self._salt_set}, attached_to={self._attached_to})\"\n\n    @classmethod\n    def from_type_identifier(\n        cls,\n        type_identifier: StringReader,\n        reference_resolver: ReferenceResolver,\n        cu_hash: bytes,\n    ) -&gt; Function:\n        type_identifier.read(\"t_function_\")\n\n        matched = []\n        for kind in FunctionTypeKind:\n            if type_identifier.startswith(kind):\n                matched.append(kind)\n        assert len(matched) &gt;= 1, f\"Unexpected function kind {type_identifier}\"\n        kind = FunctionTypeKind(max(matched, key=len))\n        type_identifier.read(kind)\n\n        if type_identifier.startswith(\"_payable\"):\n            state_mutability = StateMutability.PAYABLE\n            type_identifier.read(\"_payable\")\n        elif type_identifier.startswith(\"_pure\"):\n            state_mutability = StateMutability.PURE\n            type_identifier.read(\"_pure\")\n        elif type_identifier.startswith(\"_nonpayable\"):\n            state_mutability = StateMutability.NONPAYABLE\n            type_identifier.read(\"_nonpayable\")\n        elif type_identifier.startswith(\"_view\"):\n            state_mutability = StateMutability.VIEW\n            type_identifier.read(\"_view\")\n        else:\n            assert False, f\"Unexpected function state mutability {type_identifier}\"\n\n        parameters = _parse_list(type_identifier, reference_resolver, cu_hash)\n        assert not any(param is None for param in parameters)\n\n        type_identifier.read(\"returns\")\n        return_parameters = _parse_list(type_identifier, reference_resolver, cu_hash)\n        assert not any(param is None for param in return_parameters)\n\n        if type_identifier.startswith(\"gas\"):\n            gas_set = True\n            type_identifier.read(\"gas\")\n        else:\n            gas_set = False\n\n        if type_identifier.startswith(\"value\"):\n            value_set = True\n            type_identifier.read(\"value\")\n        else:\n            value_set = False\n\n        if type_identifier.startswith(\"salt\"):\n            salt_set = True\n            type_identifier.read(\"salt\")\n        else:\n            salt_set = False\n\n        if type_identifier.startswith(\"bound_to\"):\n            type_identifier.read(\"bound_to\")\n            bound_to = _parse_list(type_identifier, reference_resolver, cu_hash)\n            assert not any(param is None for param in bound_to)\n            attached_to = bound_to\n        elif type_identifier.startswith(\n            \"attached_to\"\n        ):  # bound_to was renamed to attached_to in 0.8.18\n            type_identifier.read(\"attached_to\")\n            attached_to = _parse_list(type_identifier, reference_resolver, cu_hash)\n            assert not any(param is None for param in attached_to)\n        else:\n            attached_to = None\n\n        return Function(\n            kind,\n            state_mutability,\n            parameters,  # pyright: ignore reportArgumentType\n            return_parameters,  # pyright: ignore reportArgumentType\n            gas_set,\n            value_set,\n            salt_set,\n            attached_to,  # pyright: ignore reportArgumentType\n        )\n\n    @property\n    def abi_type(self) -&gt; str:\n        return \"function\"\n\n    @property\n    def kind(self) -&gt; FunctionTypeKind:\n        \"\"\"\n        Returns:\n            Kind of the function type.\n        \"\"\"\n        return self._kind\n\n    @property\n    def state_mutability(self) -&gt; StateMutability:\n        \"\"\"\n        Returns:\n            State mutability of the function type.\n        \"\"\"\n        return self._state_mutability\n\n    @property\n    def parameters(self) -&gt; typ.Tuple[TypeAbc, ...]:\n        \"\"\"\n        Returns:\n            Expression types of the parameters of the function type.\n        \"\"\"\n        return self._parameters\n\n    @property\n    def return_parameters(self) -&gt; typ.Tuple[TypeAbc, ...]:\n        \"\"\"\n        Returns:\n            Expression types of the return parameters of the function type.\n        \"\"\"\n        return self._return_parameters\n\n    @property\n    def gas_set(self) -&gt; bool:\n        \"\"\"\n        !!! example\n            In the case of the old syntax (deprecated), the `gas` [MemberAccess][wake.ir.expressions.member_access.MemberAccess] expression is of the [Function][wake.ir.types.Function] type which returns a [Function][wake.ir.types.Function] with `gas_set` set to `True`.\n            ```solidity\n            foo.gas(10)(1, 2);\n            ```\n\n            In the case of the new syntax, the `{gas: 10}` [FunctionCallOptions][wake.ir.expressions.function_call_options.FunctionCallOptions] expression is of the [Function][wake.ir.types.Function] type with `gas_set` set to `True`.\n            ```solidity\n            foo{gas: 10}(1, 2);\n            ```\n\n        Returns:\n            `True` if the gas is set in the function type.\n        \"\"\"\n        return self._gas_set\n\n    @property\n    def value_set(self) -&gt; bool:\n        \"\"\"\n        !!! example\n            In the case of the old syntax (deprecated), the `value` [MemberAccess][wake.ir.expressions.member_access.MemberAccess] expression is of the [Function][wake.ir.types.Function] type which returns a [Function][wake.ir.types.Function] with `value_set` set to `True`.\n            ```solidity\n            foo.value(1)(1, 2);\n            ```\n\n            In the case of the new syntax, the `{value: 1}` [FunctionCallOptions][wake.ir.expressions.function_call_options.FunctionCallOptions] expression is of the [Function][wake.ir.types.Function] type with `value_set` set to `True`.\n            ```solidity\n            foo{value: 1}(1, 2);\n            ```\n\n        Returns:\n            `True` if the value is set in the function type.\n        \"\"\"\n        return self._value_set\n\n    @property\n    def salt_set(self) -&gt; bool:\n        \"\"\"\n        !!! example\n            In the following example, the `{salt: salt}` [FunctionCallOptions][wake.ir.expressions.function_call_options.FunctionCallOptions] expression is of the [Function][wake.ir.types.Function] type with `salt_set` set to `True`.\n            ```solidity\n            new Foo{salt: salt}();\n            ```\n\n        Returns:\n            `True` if the salt is set in the function type.\n        \"\"\"\n        return self._salt_set\n\n    @property\n    def attached_to(self) -&gt; typ.Optional[typ.Tuple[TypeAbc, ...]]:\n        \"\"\"\n        A function type can be attached to a type using the [UsingForDirective][wake.ir.meta.using_for_directive.UsingForDirective] or internally in the case of a Solidity global symbol.\n        !!! example\n            In the following example, the `add` [MemberAccess][wake.ir.expressions.member_access.MemberAccess] expression on line 9 is of the [Function][wake.ir.types.Function] type and is attached to the [UInt][wake.ir.types.UInt] type.\n            ```solidity linenums=\"1\"\n            function add(uint a, uint b) pure returns (uint) {\n                return a + b;\n            }\n\n            using {add} for uint;\n\n            contract Foo {\n                function bar(uint x) public pure returns(uint) {\n                    return x.add(1);\n                }\n            }\n            ```\n\n            In this example, the `push` [MemberAccess][wake.ir.expressions.member_access.MemberAccess] expression on line 9 is of the [Function][wake.ir.types.Function] type and is attached to the [Array][wake.ir.types.Array] type.\n            ```solidity\n            arr.push(1);\n            ```\n\n        Returns:\n            Type to which the function is attached to.\n        \"\"\"\n        return self._attached_to\n</code></pre>"},{"location":"api-reference/ir/types/#wake.ir.types.Function.kind","title":"<code>kind: FunctionTypeKind</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>FunctionTypeKind</code> <p>Kind of the function type.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Function.state_mutability","title":"<code>state_mutability: StateMutability</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>StateMutability</code> <p>State mutability of the function type.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Function.parameters","title":"<code>parameters: typ.Tuple[TypeAbc, ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[TypeAbc, ...]</code> <p>Expression types of the parameters of the function type.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Function.return_parameters","title":"<code>return_parameters: typ.Tuple[TypeAbc, ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[TypeAbc, ...]</code> <p>Expression types of the return parameters of the function type.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Function.gas_set","title":"<code>gas_set: bool</code>  <code>property</code>","text":"<p>Example</p> <p>In the case of the old syntax (deprecated), the <code>gas</code> MemberAccess expression is of the Function type which returns a Function with <code>gas_set</code> set to <code>True</code>. <pre><code>foo.gas(10)(1, 2);\n</code></pre></p> <p>In the case of the new syntax, the <code>{gas: 10}</code> FunctionCallOptions expression is of the Function type with <code>gas_set</code> set to <code>True</code>. <pre><code>foo{gas: 10}(1, 2);\n</code></pre></p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the gas is set in the function type.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Function.value_set","title":"<code>value_set: bool</code>  <code>property</code>","text":"<p>Example</p> <p>In the case of the old syntax (deprecated), the <code>value</code> MemberAccess expression is of the Function type which returns a Function with <code>value_set</code> set to <code>True</code>. <pre><code>foo.value(1)(1, 2);\n</code></pre></p> <p>In the case of the new syntax, the <code>{value: 1}</code> FunctionCallOptions expression is of the Function type with <code>value_set</code> set to <code>True</code>. <pre><code>foo{value: 1}(1, 2);\n</code></pre></p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the value is set in the function type.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Function.salt_set","title":"<code>salt_set: bool</code>  <code>property</code>","text":"<p>Example</p> <p>In the following example, the <code>{salt: salt}</code> FunctionCallOptions expression is of the Function type with <code>salt_set</code> set to <code>True</code>. <pre><code>new Foo{salt: salt}();\n</code></pre></p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the salt is set in the function type.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Function.attached_to","title":"<code>attached_to: typ.Optional[typ.Tuple[TypeAbc, ...]]</code>  <code>property</code>","text":"<p>A function type can be attached to a type using the UsingForDirective or internally in the case of a Solidity global symbol.</p> <p>Example</p> <p>In the following example, the <code>add</code> MemberAccess expression on line 9 is of the Function type and is attached to the UInt type. <pre><code>function add(uint a, uint b) pure returns (uint) {\n    return a + b;\n}\n\nusing {add} for uint;\n\ncontract Foo {\n    function bar(uint x) public pure returns(uint) {\n        return x.add(1);\n    }\n}\n</code></pre></p> <p>In this example, the <code>push</code> MemberAccess expression on line 9 is of the Function type and is attached to the Array type. <pre><code>arr.push(1);\n</code></pre></p> <p>Returns:</p> Type Description <code>Optional[Tuple[TypeAbc, ...]]</code> <p>Type to which the function is attached to.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Tuple","title":"<code>Tuple</code>  <code>class</code>","text":"<p>         Bases: <code>TypeAbc</code></p> <p>Tuple type.</p> Source code in <code>wake/ir/types.py</code> <pre><code>class Tuple(TypeAbc):\n    \"\"\"\n    Tuple type.\n    \"\"\"\n\n    _components: typ.Tuple[typ.Optional[TypeAbc], ...]\n\n    def __init__(self, components: typ.Iterable[typ.Optional[TypeAbc]]):\n        self._components = tuple(components)\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, Tuple):\n            return False\n        return self._components == other._components\n\n    def __hash__(self):\n        return hash(self._components)\n\n    def __repr__(self):\n        return f\"Tuple(components={self._components})\"\n\n    @classmethod\n    def from_type_identifier(\n        cls,\n        type_identifier: StringReader,\n        reference_resolver: ReferenceResolver,\n        cu_hash: bytes,\n    ) -&gt; Tuple:\n        type_identifier.read(\"t_tuple\")\n        components = _parse_list(type_identifier, reference_resolver, cu_hash)\n        return Tuple(components)\n\n    @property\n    def abi_type(self) -&gt; str:\n        if any(component is None for component in self._components):\n            raise NotImplementedError\n        return (\n            \"(\"\n            + \",\".join(\n                component.abi_type  # pyright: ignore reportOptionalMemberAccess\n                for component in self._components\n            )\n            + \")\"\n        )\n\n    @property\n    def components(self) -&gt; typ.Tuple[typ.Optional[TypeAbc], ...]:\n        \"\"\"\n        A component type can be `None` in the case of a tuple with a missing component.\n        !!! example\n            In the following example, the `(success, )` expression is of the [Tuple][wake.ir.types.Tuple] type with the components of the type [Bool][wake.ir.types.Bool] and `None`.\n            ```solidity\n            bool success;\n            (success, ) = address(addr).call{value: 1}(\"\");\n            ```\n\n        Returns:\n            Expression types of the components of the tuple type.\n        \"\"\"\n        return self._components\n</code></pre>"},{"location":"api-reference/ir/types/#wake.ir.types.Tuple.components","title":"<code>components: typ.Tuple[typ.Optional[TypeAbc], ...]</code>  <code>property</code>","text":"<p>A component type can be <code>None</code> in the case of a tuple with a missing component.</p> <p>Example</p> <p>In the following example, the <code>(success, )</code> expression is of the Tuple type with the components of the type Bool and <code>None</code>. <pre><code>bool success;\n(success, ) = address(addr).call{value: 1}(\"\");\n</code></pre></p> <p>Returns:</p> Type Description <code>Tuple[Optional[TypeAbc], ...]</code> <p>Expression types of the components of the tuple type.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Type","title":"<code>Type</code>  <code>class</code>","text":"<p>         Bases: <code>TypeAbc</code></p> <p>Type type. As opposed to other types, this type describes the type of a type, not the type of an instance of a type.</p> Source code in <code>wake/ir/types.py</code> <pre><code>class Type(TypeAbc):\n    \"\"\"\n    Type type. As opposed to other types, this type describes the type of a type, not the type of an instance of a type.\n    \"\"\"\n\n    _actual_type: TypeAbc\n\n    def __init__(self, actual_type: TypeAbc):\n        self._actual_type = actual_type\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, Type):\n            return False\n        return self._actual_type == other._actual_type\n\n    def __hash__(self):\n        return hash(self._actual_type)\n\n    def __repr__(self):\n        return f\"Type(actual_type={self._actual_type})\"\n\n    @classmethod\n    def from_type_identifier(\n        cls,\n        type_identifier: StringReader,\n        reference_resolver: ReferenceResolver,\n        cu_hash: bytes,\n    ) -&gt; Type:\n        type_identifier.read(\"t_type\")\n        actual_type = _parse_list(type_identifier, reference_resolver, cu_hash)\n        assert len(actual_type) == 1 and actual_type[0] is not None\n        return Type(actual_type[0])\n\n    @property\n    def abi_type(self) -&gt; str:\n        raise NotImplementedError\n\n    @property\n    def actual_type(self) -&gt; TypeAbc:\n        \"\"\"\n        !!! example\n            `payable` in the following example is of the [Type][wake.ir.types.Type] type with the [Address][wake.ir.types.Address] actual type.\n            ```solidity\n            payable(addr);\n            ```\n\n            `super` in the following example is of the [Type][wake.ir.types.Type] type with the [Contract][wake.ir.types.Contract] actual type.\n            ```solidity\n            super.foo();\n            ```\n\n            `string` in the following example is of the [Type][wake.ir.types.Type] type with the [String][wake.ir.types.String] actual type.\n            ```solidity\n            string.concat(\"foo\", \"bar\");\n            ```\n\n            `Foo` in the following example on line 4 is of the [Type][wake.ir.types.Type] type with the [Enum][wake.ir.types.Enum] actual type.\n            ```solidity linenums=\"1\"\n            enum Foo { A, B }\n\n            function bar() pure returns (Foo) {\n                return Foo.A;\n            }\n            ```\n\n        Returns:\n            Actual type of the type type.\n        \"\"\"\n        return self._actual_type\n</code></pre>"},{"location":"api-reference/ir/types/#wake.ir.types.Type.actual_type","title":"<code>actual_type: TypeAbc</code>  <code>property</code>","text":"<p>Example</p> <p><code>payable</code> in the following example is of the Type type with the Address actual type. <pre><code>payable(addr);\n</code></pre></p> <p><code>super</code> in the following example is of the Type type with the Contract actual type. <pre><code>super.foo();\n</code></pre></p> <p><code>string</code> in the following example is of the Type type with the String actual type. <pre><code>string.concat(\"foo\", \"bar\");\n</code></pre></p> <p><code>Foo</code> in the following example on line 4 is of the Type type with the Enum actual type. <pre><code>enum Foo { A, B }\n\nfunction bar() pure returns (Foo) {\n    return Foo.A;\n}\n</code></pre></p> <p>Returns:</p> Type Description <code>TypeAbc</code> <p>Actual type of the type type.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Rational","title":"<code>Rational</code>  <code>class</code>","text":"<p>         Bases: <code>TypeAbc</code></p> <p>Rational type. Represents the type of constants or expressions with constants.</p> <p>Example</p> <p><code>1</code>, <code>0x1234</code>, <code>1e18</code>, <code>1 * 2 / 3</code> are all of the Rational type.</p> Source code in <code>wake/ir/types.py</code> <pre><code>class Rational(TypeAbc):\n    \"\"\"\n    Rational type. Represents the type of constants or expressions with constants.\n\n    !!! example\n        `:::solidity 1`, `:::solidity 0x1234`, `:::solidity 1e18`, `:::solidity 1 * 2 / 3` are all of the [Rational][wake.ir.types.Rational] type.\n    \"\"\"\n\n    _numerator: int\n    _denominator: int\n\n    def __init__(self, numerator: int, denominator: int):\n        self._numerator = numerator\n        self._denominator = denominator\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, Rational):\n            return False\n        return (\n            self._numerator == other._numerator\n            and self._denominator == other._denominator\n        )\n\n    def __hash__(self):\n        return hash((self._numerator, self._denominator))\n\n    def __repr__(self):\n        return f\"Rational(numerator={self._numerator}, denominator={self._denominator})\"\n\n    @classmethod\n    def from_type_identifier(\n        cls,\n        type_identifier: StringReader,\n        reference_resolver: ReferenceResolver,\n        cu_hash: bytes,\n    ) -&gt; Rational:\n        type_identifier.read(\"t_rational_\")\n\n        if type_identifier.startswith(\"minus_\"):\n            type_identifier.read(\"minus_\")\n            numerator = -1\n        else:\n            numerator = 1\n\n        match = NUMBER_RE.match(type_identifier.data)\n        assert match is not None, f\"{type_identifier} is not a valid rational\"\n        number = match.group(\"number\")\n        type_identifier.read(number)\n        numerator *= int(number)\n\n        type_identifier.read(\"_by_\")\n\n        match = NUMBER_RE.match(type_identifier.data)\n        assert match is not None, f\"{type_identifier} is not a valid rational\"\n        number = match.group(\"number\")\n        type_identifier.read(number)\n        denominator = int(number)\n        return Rational(numerator, denominator)\n\n    @property\n    def abi_type(self) -&gt; str:\n        raise NotImplementedError\n\n    @property\n    def numerator(self) -&gt; int:\n        \"\"\"\n        If the rational is negative, the numerator will be negative.\n\n        Returns:\n            Numerator of the rational number.\n        \"\"\"\n        return self._numerator\n\n    @property\n    def denominator(self) -&gt; int:\n        \"\"\"\n        Returns:\n            Denominator of the rational number.\n        \"\"\"\n        return self._denominator\n</code></pre>"},{"location":"api-reference/ir/types/#wake.ir.types.Rational.numerator","title":"<code>numerator: int</code>  <code>property</code>","text":"<p>If the rational is negative, the numerator will be negative.</p> <p>Returns:</p> Type Description <code>int</code> <p>Numerator of the rational number.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Rational.denominator","title":"<code>denominator: int</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>int</code> <p>Denominator of the rational number.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Modifier","title":"<code>Modifier</code>  <code>class</code>","text":"<p>         Bases: <code>TypeAbc</code></p> <p>Modifier type.</p> Source code in <code>wake/ir/types.py</code> <pre><code>class Modifier(TypeAbc):\n    \"\"\"\n    Modifier type.\n    \"\"\"\n\n    _parameters: typ.Tuple[TypeAbc, ...]\n\n    def __init__(self, parameters: typ.Iterable[TypeAbc]):\n        self._parameters = tuple(parameters)\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, Modifier):\n            return False\n        return self._parameters == other._parameters\n\n    def __hash__(self):\n        return hash(self._parameters)\n\n    def __repr__(self):\n        return f\"Modifier(parameters={self._parameters})\"\n\n    @classmethod\n    def from_type_identifier(\n        cls,\n        type_identifier: StringReader,\n        reference_resolver: ReferenceResolver,\n        cu_hash: bytes,\n    ) -&gt; Modifier:\n        type_identifier.read(\"t_modifier\")\n        parameters = _parse_list(type_identifier, reference_resolver, cu_hash)\n        assert not any(param is None for param in parameters)\n        return Modifier(parameters)  # pyright: ignore reportArgumentType\n\n    @property\n    def abi_type(self) -&gt; str:\n        raise NotImplementedError\n\n    @property\n    def parameters(self) -&gt; typ.Tuple[TypeAbc, ...]:\n        \"\"\"\n        Returns:\n            Expression types of the parameters of the modifier.\n        \"\"\"\n        return self._parameters\n</code></pre>"},{"location":"api-reference/ir/types/#wake.ir.types.Modifier.parameters","title":"<code>parameters: typ.Tuple[TypeAbc, ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[TypeAbc, ...]</code> <p>Expression types of the parameters of the modifier.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Array","title":"<code>Array</code>  <code>class</code>","text":"<p>         Bases: <code>TypeAbc</code></p> <p>Array type.</p> Source code in <code>wake/ir/types.py</code> <pre><code>class Array(TypeAbc):\n    \"\"\"\n    Array type.\n    \"\"\"\n\n    _base_type: TypeAbc\n    _length: typ.Optional[int]\n    _data_location: DataLocation\n    _is_pointer: bool\n    _is_slice: bool\n\n    def __init__(\n        self,\n        base_type: TypeAbc,\n        length: typ.Optional[int],\n        data_location: DataLocation,\n        is_pointer: bool,\n        is_slice: bool,\n    ):\n        self._base_type = base_type\n        self._length = length\n        self._data_location = data_location\n        self._is_pointer = is_pointer\n        self._is_slice = is_slice\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, Array):\n            return False\n        return (\n            self._base_type == other._base_type\n            and self._length == other._length\n            and self._data_location == other._data_location\n            and self._is_pointer == other._is_pointer\n            and self._is_slice == other._is_slice\n        )\n\n    def __hash__(self):\n        return hash(\n            (\n                self._base_type,\n                self._length,\n                self._data_location,\n                self._is_pointer,\n                self._is_slice,\n            )\n        )\n\n    def __repr__(self):\n        return f\"Array(base_type={self._base_type}, length={self._length}, data_location={self._data_location}, is_pointer={self._is_pointer}, is_slice={self._is_slice})\"\n\n    @classmethod\n    def from_type_identifier(\n        cls,\n        type_identifier: StringReader,\n        reference_resolver: ReferenceResolver,\n        cu_hash: bytes,\n    ) -&gt; Array:\n        type_identifier.read(\"t_array\")\n        base_type = _parse_list(type_identifier, reference_resolver, cu_hash)\n        assert (\n            len(base_type) == 1 and base_type[0] is not None\n        ), f\"Unexpected array base type {type_identifier}\"\n        base_type = base_type[0]\n\n        if type_identifier.startswith(\"dyn\"):\n            length = None\n            type_identifier.read(\"dyn\")\n        else:\n            match = NUMBER_RE.match(type_identifier.data)\n            assert match is not None, f\"{type_identifier} is not a valid array length\"\n            length = int(match.group(\"number\"))\n            type_identifier.read(match.group(\"number\"))\n\n        if type_identifier.startswith(\"_storage\"):\n            data_location = DataLocation.STORAGE\n            type_identifier.read(\"_storage\")\n        elif type_identifier.startswith(\"_memory\"):\n            data_location = DataLocation.MEMORY\n            type_identifier.read(\"_memory\")\n        elif type_identifier.startswith(\"_calldata\"):\n            data_location = DataLocation.CALLDATA\n            type_identifier.read(\"_calldata\")\n        else:\n            assert False, f\"Unexpected array type data location {type_identifier}\"\n\n        if type_identifier.startswith(\"_ptr\"):\n            is_pointer = True\n            type_identifier.read(\"_ptr\")\n        else:\n            is_pointer = False\n\n        if type_identifier.startswith(\"_slice\"):\n            is_slice = True\n            type_identifier.read(\"_slice\")\n        else:\n            is_slice = False\n\n        return Array(base_type, length, data_location, is_pointer, is_slice)\n\n    @property\n    def abi_type(self) -&gt; str:\n        if self.length is not None:\n            return f\"{self.base_type.abi_type}[{self.length}]\"\n        else:\n            return f\"{self.base_type.abi_type}[]\"\n\n    @property\n    def base_type(self) -&gt; TypeAbc:\n        \"\"\"\n        Returns:\n            Base type of the array.\n        \"\"\"\n        return self._base_type\n\n    @property\n    def length(self) -&gt; typ.Optional[int]:\n        \"\"\"\n        Returns:\n            Length of the array. `None` if the array is dynamic (not fixed size).\n        \"\"\"\n        return self._length\n\n    @property\n    def data_location(self) -&gt; DataLocation:\n        \"\"\"\n        Returns:\n            Data location of the array.\n        \"\"\"\n        return self._data_location\n\n    @property\n    def is_pointer(self) -&gt; bool:\n        \"\"\"\n        Storage references can be pointers or bound references. In general, local variables are of\n        pointer type, state variables are bound references. Assignments to pointers or deleting\n        them will not modify storage (that will only change the pointer). Assignment from\n        non-storage objects to a variable of storage pointer type is not possible.\n\n        For anything other than [STORAGE][wake.ir.enums.DataLocation.STORAGE], this always returns `True` because assignments\n        never change the contents of the original value.\n\n        Returns:\n            Whether the array expression is a pointer to storage.\n        \"\"\"\n        return self._is_pointer\n\n    @property\n    def is_slice(self) -&gt; bool:\n        \"\"\"\n        !!! example\n            ```solidity\n            function foo(uint[] calldata arr) public pure {\n                arr[0:5]; // arr[0:5] is an array slice\n            }\n            ```\n\n        Returns:\n            Whether this is a slice of an array expression.\n        \"\"\"\n        return self._is_slice\n</code></pre>"},{"location":"api-reference/ir/types/#wake.ir.types.Array.base_type","title":"<code>base_type: TypeAbc</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>TypeAbc</code> <p>Base type of the array.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Array.length","title":"<code>length: typ.Optional[int]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Optional[int]</code> <p>Length of the array. <code>None</code> if the array is dynamic (not fixed size).</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Array.data_location","title":"<code>data_location: DataLocation</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>DataLocation</code> <p>Data location of the array.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Array.is_pointer","title":"<code>is_pointer: bool</code>  <code>property</code>","text":"<p>Storage references can be pointers or bound references. In general, local variables are of pointer type, state variables are bound references. Assignments to pointers or deleting them will not modify storage (that will only change the pointer). Assignment from non-storage objects to a variable of storage pointer type is not possible.</p> <p>For anything other than STORAGE, this always returns <code>True</code> because assignments never change the contents of the original value.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the array expression is a pointer to storage.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Array.is_slice","title":"<code>is_slice: bool</code>  <code>property</code>","text":"<p>Example</p> <pre><code>function foo(uint[] calldata arr) public pure {\n    arr[0:5]; // arr[0:5] is an array slice\n}\n</code></pre> <p>Returns:</p> Type Description <code>bool</code> <p>Whether this is a slice of an array expression.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Mapping","title":"<code>Mapping</code>  <code>class</code>","text":"<p>         Bases: <code>TypeAbc</code></p> <p>Mapping type.</p> Source code in <code>wake/ir/types.py</code> <pre><code>class Mapping(TypeAbc):\n    \"\"\"\n    Mapping type.\n    \"\"\"\n\n    _key_type: TypeAbc\n    _value_type: TypeAbc\n\n    def __init__(self, key_type: TypeAbc, value_type: TypeAbc):\n        self._key_type = key_type\n        self._value_type = value_type\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, Mapping):\n            return False\n        return (\n            self._key_type == other._key_type and self._value_type == other._value_type\n        )\n\n    def __hash__(self):\n        return hash((self._key_type, self._value_type))\n\n    def __repr__(self):\n        return f\"Mapping(key_type={self._key_type}, value_type={self._value_type})\"\n\n    @classmethod\n    def from_type_identifier(\n        cls,\n        type_identifier: StringReader,\n        reference_resolver: ReferenceResolver,\n        cu_hash: bytes,\n    ) -&gt; Mapping:\n        type_identifier.read(\"t_mapping\")\n        key_value = _parse_list(type_identifier, reference_resolver, cu_hash)\n        assert len(key_value) == 2, f\"{type_identifier} is not a valid mapping\"\n        assert key_value[0] is not None, f\"{type_identifier} is not a valid mapping\"\n        assert key_value[1] is not None, f\"{type_identifier} is not a valid mapping\"\n        return Mapping(key_value[0], key_value[1])\n\n    @property\n    def abi_type(self) -&gt; str:\n        raise NotImplementedError\n\n    @property\n    def key_type(self) -&gt; TypeAbc:\n        \"\"\"\n        Returns:\n            Key type of the mapping.\n        \"\"\"\n        return self._key_type\n\n    @property\n    def value_type(self) -&gt; TypeAbc:\n        \"\"\"\n        Returns:\n            Value type of the mapping.\n        \"\"\"\n        return self._value_type\n</code></pre>"},{"location":"api-reference/ir/types/#wake.ir.types.Mapping.key_type","title":"<code>key_type: TypeAbc</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>TypeAbc</code> <p>Key type of the mapping.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Mapping.value_type","title":"<code>value_type: TypeAbc</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>TypeAbc</code> <p>Value type of the mapping.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Contract","title":"<code>Contract</code>  <code>class</code>","text":"<p>         Bases: <code>TypeAbc</code></p> Source code in <code>wake/ir/types.py</code> <pre><code>class Contract(TypeAbc):\n    _is_super: bool\n    _name: str\n    _ast_id: AstNodeId\n    _reference_resolver: ReferenceResolver\n    _cu_hash: bytes\n\n    def __init__(\n        self,\n        is_super: bool,\n        name: str,\n        ast_id: AstNodeId,\n        reference_resolver: ReferenceResolver,\n        cu_hash: bytes,\n    ):\n        self._is_super = is_super\n        self._name = name\n        self._ast_id = ast_id\n        self._reference_resolver = reference_resolver\n        self._cu_hash = cu_hash\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, Contract):\n            return False\n        return (\n            self._is_super == other._is_super\n            and self._name == other._name\n            and self.ir_node == other.ir_node\n        )\n\n    def __hash__(self):\n        return hash((self._is_super, self._name, self.ir_node))\n\n    def __repr__(self):\n        return f\"Contract(is_super={self._is_super}, name={self._name}, ir_node={self.ir_node})\"\n\n    @classmethod\n    def from_type_identifier(\n        cls,\n        type_identifier: StringReader,\n        reference_resolver: ReferenceResolver,\n        cu_hash: bytes,\n    ) -&gt; Contract:\n        if type_identifier.startswith(\"t_contract\"):\n            is_super = False\n            type_identifier.read(\"t_contract\")\n        elif type_identifier.startswith(\"t_super\"):\n            is_super = True\n            type_identifier.read(\"t_super\")\n        else:\n            assert False, f\"Unexpected contract type {type_identifier}\"\n        name = _parse_user_identifier(type_identifier)\n\n        match = NUMBER_RE.match(type_identifier.data)\n        assert match is not None, f\"{type_identifier} is not a valid contract\"\n        ast_id = AstNodeId(int(match.group(\"number\")))\n        type_identifier.read(match.group(\"number\"))\n\n        return Contract(is_super, name, ast_id, reference_resolver, cu_hash)\n\n    @property\n    def abi_type(self) -&gt; str:\n        return \"address\"\n\n    @property\n    def is_super(self) -&gt; bool:\n        \"\"\"\n        !!! warning\n            Until 0.7.6, the `super` keyword ([Identifier][wake.ir.expressions.identifier.Identifier]) was of the [Contract][wake.ir.types.Contract] type with `is_super` set to `True`.\n            Since 0.8.0, the `super` keyword is of the [Type][wake.ir.types.Type] type with [Contract][wake.ir.types.Contract] as the `actual_type` and `is_super` set to `True`.\n\n        !!! warning\n            When this is `True`, the `name` and `ir_node` properties refer to the current contract, not the base contract.\n\n        !!! example\n            The `name` and `ir_node` properties of the [Contract][wake.ir.types.Contract] type of the `super` expression in the following example refer to the `Foo` contract, not the `Bar` contract.\n            ```solidity\n            contract Foo is Bar {\n                function foo() public {\n                    super.foo();\n                }\n            }\n            ```\n\n        Returns:\n            `True` if the expression is the `super` keyword.\n        \"\"\"\n        return self._is_super\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"\n        Returns:\n            Name of the contract.\n        \"\"\"\n        return self._name\n\n    @property\n    def ir_node(self) -&gt; ContractDefinition:\n        \"\"\"\n        Returns:\n            Contract definition IR node.\n        \"\"\"\n        from wake.ir.declarations.contract_definition import ContractDefinition\n\n        node = self._reference_resolver.resolve_node(self._ast_id, self._cu_hash)\n        assert isinstance(node, ContractDefinition)\n        return node\n</code></pre>"},{"location":"api-reference/ir/types/#wake.ir.types.Contract.is_super","title":"<code>is_super: bool</code>  <code>property</code>","text":"<p>Warning</p> <p>Until 0.7.6, the <code>super</code> keyword (Identifier) was of the Contract type with <code>is_super</code> set to <code>True</code>. Since 0.8.0, the <code>super</code> keyword is of the Type type with Contract as the <code>actual_type</code> and <code>is_super</code> set to <code>True</code>.</p> <p>Warning</p> <p>When this is <code>True</code>, the <code>name</code> and <code>ir_node</code> properties refer to the current contract, not the base contract.</p> <p>Example</p> <p>The <code>name</code> and <code>ir_node</code> properties of the Contract type of the <code>super</code> expression in the following example refer to the <code>Foo</code> contract, not the <code>Bar</code> contract. <pre><code>contract Foo is Bar {\n    function foo() public {\n        super.foo();\n    }\n}\n</code></pre></p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the expression is the <code>super</code> keyword.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Contract.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>Name of the contract.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Contract.ir_node","title":"<code>ir_node: ContractDefinition</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>ContractDefinition</code> <p>Contract definition IR node.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Struct","title":"<code>Struct</code>  <code>class</code>","text":"<p>         Bases: <code>TypeAbc</code></p> <p>Struct type.</p> Source code in <code>wake/ir/types.py</code> <pre><code>class Struct(TypeAbc):\n    \"\"\"\n    Struct type.\n    \"\"\"\n\n    _name: str\n    _ast_id: AstNodeId\n    _data_location: DataLocation\n    _is_pointer: bool\n    _reference_resolver: ReferenceResolver\n    _cu_hash: bytes\n\n    def __init__(\n        self,\n        name: str,\n        data_location: DataLocation,\n        is_pointer: bool,\n        ast_id: AstNodeId,\n        reference_resolver: ReferenceResolver,\n        cu_hash: bytes,\n    ):\n        self._name = name\n        self._data_location = data_location\n        self._is_pointer = is_pointer\n        self._ast_id = ast_id\n        self._reference_resolver = reference_resolver\n        self._cu_hash = cu_hash\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, Struct):\n            return False\n        return (\n            self._name == other._name\n            and self._data_location == other._data_location\n            and self._is_pointer == other._is_pointer\n            and self.ir_node == other.ir_node\n        )\n\n    def __hash__(self):\n        return hash(\n            (\n                self._name,\n                self._data_location,\n                self._is_pointer,\n                self.ir_node,\n            )\n        )\n\n    def __repr__(self):\n        return f\"Struct(name={self._name}, data_location={self._data_location}, is_pointer={self._is_pointer}, ir_node={self.ir_node})\"\n\n    @classmethod\n    def from_type_identifier(\n        cls,\n        type_identifier: StringReader,\n        reference_resolver: ReferenceResolver,\n        cu_hash: bytes,\n    ) -&gt; Struct:\n        type_identifier.read(\"t_struct\")\n        name = _parse_user_identifier(type_identifier)\n\n        match = NUMBER_RE.match(type_identifier.data)\n        assert match is not None, f\"{type_identifier} is not a valid struct\"\n        ast_id = AstNodeId(int(match.group(\"number\")))\n        type_identifier.read(match.group(\"number\"))\n\n        if type_identifier.startswith(\"_storage\"):\n            data_location = DataLocation.STORAGE\n            type_identifier.read(\"_storage\")\n        elif type_identifier.startswith(\"_memory\"):\n            data_location = DataLocation.MEMORY\n            type_identifier.read(\"_memory\")\n        elif type_identifier.startswith(\"_calldata\"):\n            data_location = DataLocation.CALLDATA\n            type_identifier.read(\"_calldata\")\n        else:\n            assert False, f\"Unexpected array type data location {type_identifier}\"\n\n        if type_identifier.startswith(\"_ptr\"):\n            is_pointer = True\n            type_identifier.read(\"_ptr\")\n        else:\n            is_pointer = False\n\n        return Struct(\n            name, data_location, is_pointer, ast_id, reference_resolver, cu_hash\n        )\n\n    @property\n    def abi_type(self) -&gt; str:\n        return (\n            \"(\"\n            + \",\".join([member.type.abi_type for member in self.ir_node.members])\n            + \")\"\n        )\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"\n        Returns:\n            Name of the struct.\n        \"\"\"\n        return self._name\n\n    @property\n    def data_location(self) -&gt; DataLocation:\n        \"\"\"\n        Returns:\n            Data location of the struct.\n        \"\"\"\n        return self._data_location\n\n    @property\n    def is_pointer(self) -&gt; bool:\n        \"\"\"\n        Storage references can be pointers or bound references. In general, local variables are of\n        pointer type, state variables are bound references. Assignments to pointers or deleting\n        them will not modify storage (that will only change the pointer). Assignment from\n        non-storage objects to a variable of storage pointer type is not possible.\n\n        For anything other than [STORAGE][wake.ir.enums.DataLocation.STORAGE], this always returns `True` because assignments\n        never change the contents of the original value.\n\n        Returns:\n            Whether the struct expression is a pointer to storage.\n        \"\"\"\n        return self._is_pointer\n\n    @property\n    def ir_node(self) -&gt; StructDefinition:\n        \"\"\"\n        Returns:\n            Struct definition IR node.\n        \"\"\"\n        from wake.ir.declarations.struct_definition import StructDefinition\n\n        node = self._reference_resolver.resolve_node(self._ast_id, self._cu_hash)\n        assert isinstance(node, StructDefinition)\n        return node\n</code></pre>"},{"location":"api-reference/ir/types/#wake.ir.types.Struct.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>Name of the struct.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Struct.data_location","title":"<code>data_location: DataLocation</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>DataLocation</code> <p>Data location of the struct.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Struct.is_pointer","title":"<code>is_pointer: bool</code>  <code>property</code>","text":"<p>Storage references can be pointers or bound references. In general, local variables are of pointer type, state variables are bound references. Assignments to pointers or deleting them will not modify storage (that will only change the pointer). Assignment from non-storage objects to a variable of storage pointer type is not possible.</p> <p>For anything other than STORAGE, this always returns <code>True</code> because assignments never change the contents of the original value.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the struct expression is a pointer to storage.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Struct.ir_node","title":"<code>ir_node: StructDefinition</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>StructDefinition</code> <p>Struct definition IR node.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Enum","title":"<code>Enum</code>  <code>class</code>","text":"<p>         Bases: <code>TypeAbc</code></p> <p>Enum type.</p> <p>Warning</p> <p>Enum values are of the Enum type and enums are of the Type type with Enum as the actual_type.</p> Source code in <code>wake/ir/types.py</code> <pre><code>class Enum(TypeAbc):\n    \"\"\"\n    Enum type.\n\n    !!! warning\n        Enum values are of the [Enum][wake.ir.types.Enum] type and enums are of the [Type][wake.ir.types.Type] type with [Enum][wake.ir.types.Enum] as the [actual_type][wake.ir.types.Type.actual_type].\n    \"\"\"\n\n    _name: str\n    _ast_id: AstNodeId\n    _reference_resolver: ReferenceResolver\n    _cu_hash: bytes\n\n    def __init__(\n        self,\n        name: str,\n        ast_id: AstNodeId,\n        reference_resolver: ReferenceResolver,\n        cu_hash: bytes,\n    ):\n        self._name = name\n        self._ast_id = ast_id\n        self._reference_resolver = reference_resolver\n        self._cu_hash = cu_hash\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, Enum):\n            return False\n        return self._name == other._name and self.ir_node == other.ir_node\n\n    def __hash__(self):\n        return hash((self._name, self.ir_node))\n\n    def __repr__(self):\n        return f\"Enum(name={self._name}, ir_node={self.ir_node})\"\n\n    @classmethod\n    def from_type_identifier(\n        cls,\n        type_identifier: StringReader,\n        reference_resolver: ReferenceResolver,\n        cu_hash: bytes,\n    ) -&gt; Enum:\n        type_identifier.read(\"t_enum\")\n        name = _parse_user_identifier(type_identifier)\n\n        match = NUMBER_RE.match(type_identifier.data)\n        assert match is not None, f\"{type_identifier} is not a valid enum\"\n        ast_id = AstNodeId(int(match.group(\"number\")))\n        type_identifier.read(match.group(\"number\"))\n\n        return Enum(name, ast_id, reference_resolver, cu_hash)\n\n    @property\n    def abi_type(self) -&gt; str:\n        return \"uint8\"\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"\n        Returns:\n            Name of the enum.\n        \"\"\"\n        return self._name\n\n    @property\n    def ir_node(self) -&gt; EnumDefinition:\n        \"\"\"\n        Returns:\n            Enum definition IR node.\n        \"\"\"\n        from wake.ir.declarations.enum_definition import EnumDefinition\n\n        node = self._reference_resolver.resolve_node(self._ast_id, self._cu_hash)\n        assert isinstance(node, EnumDefinition)\n        return node\n</code></pre>"},{"location":"api-reference/ir/types/#wake.ir.types.Enum.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>Name of the enum.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Enum.ir_node","title":"<code>ir_node: EnumDefinition</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>EnumDefinition</code> <p>Enum definition IR node.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Magic","title":"<code>Magic</code>  <code>class</code>","text":"<p>         Bases: <code>TypeAbc</code></p> <p>Magic type represents Solidity language built-in objects.</p> Source code in <code>wake/ir/types.py</code> <pre><code>class Magic(TypeAbc):\n    \"\"\"\n    Magic type represents Solidity language built-in objects.\n    \"\"\"\n\n    _kind: MagicTypeKind\n    _meta_argument_type: typ.Optional[TypeAbc]\n\n    def __init__(self, kind: MagicTypeKind, meta_argument_type: typ.Optional[TypeAbc]):\n        self._kind = kind\n        self._meta_argument_type = meta_argument_type\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, Magic):\n            return False\n        return (\n            self._kind == other._kind\n            and self._meta_argument_type == other._meta_argument_type\n        )\n\n    def __hash__(self):\n        return hash((self._kind, self._meta_argument_type))\n\n    def __repr__(self):\n        return (\n            f\"Magic(kind={self._kind}, meta_argument_type={self._meta_argument_type})\"\n        )\n\n    @classmethod\n    def from_type_identifier(\n        cls,\n        type_identifier: StringReader,\n        reference_resolver: ReferenceResolver,\n        cu_hash: bytes,\n    ) -&gt; Magic:\n        type_identifier.read(\"t_magic_\")\n\n        for magic_kind in MagicTypeKind:\n            if type_identifier.startswith(magic_kind):\n                kind = MagicTypeKind(magic_kind)\n                type_identifier.read(magic_kind)\n\n                if kind == MagicTypeKind.META_TYPE:\n                    type_identifier.read(\"_\")\n                    meta_argument_type = TypeAbc.from_type_identifier(\n                        type_identifier, reference_resolver, cu_hash\n                    )\n                    assert meta_argument_type is not None\n                    meta_argument_type = meta_argument_type\n                else:\n                    meta_argument_type = None\n\n                return Magic(kind, meta_argument_type)\n\n        assert False, f\"Unexpected magic type {type_identifier}\"\n\n    @property\n    def abi_type(self) -&gt; str:\n        raise NotImplementedError\n\n    @property\n    def kind(self) -&gt; MagicTypeKind:\n        \"\"\"\n        Returns:\n            Kind of the magic type.\n        \"\"\"\n        return self._kind\n\n    @property\n    def meta_argument_type(self) -&gt; typ.Optional[TypeAbc]:\n        \"\"\"\n        Is only set for [MagicTypeKind.META_TYPE][wake.ir.enums.MagicTypeKind.META_TYPE] kind.\n        !!! example\n            [Contract][wake.ir.types.Contract] in `:::solidity type(IERC20)`, [UInt][wake.ir.types.UInt] in `:::solidity type(uint)`.\n\n        Returns:\n            Type of the meta expression argument.\n        \"\"\"\n        return self._meta_argument_type\n</code></pre>"},{"location":"api-reference/ir/types/#wake.ir.types.Magic.kind","title":"<code>kind: MagicTypeKind</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>MagicTypeKind</code> <p>Kind of the magic type.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Magic.meta_argument_type","title":"<code>meta_argument_type: typ.Optional[TypeAbc]</code>  <code>property</code>","text":"<p>Is only set for MagicTypeKind.META_TYPE kind.</p> <p>Example</p> <p>Contract in <code>type(IERC20)</code>, UInt in <code>type(uint)</code>.</p> <p>Returns:</p> Type Description <code>Optional[TypeAbc]</code> <p>Type of the meta expression argument.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.UserDefinedValueType","title":"<code>UserDefinedValueType</code>  <code>class</code>","text":"<p>         Bases: <code>TypeAbc</code></p> Source code in <code>wake/ir/types.py</code> <pre><code>class UserDefinedValueType(TypeAbc):\n    _name: str\n    _ast_id: AstNodeId\n    _reference_resolver: ReferenceResolver\n    _cu_hash: bytes\n\n    def __init__(\n        self,\n        name: str,\n        ast_id: AstNodeId,\n        reference_resolver: ReferenceResolver,\n        cu_hash: bytes,\n    ):\n        self._name = name\n        self._ast_id = ast_id\n        self._reference_resolver = reference_resolver\n        self._cu_hash = cu_hash\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, UserDefinedValueType):\n            return False\n        return self._name == other._name and self.ir_node == other.ir_node\n\n    def __hash__(self):\n        return hash((self._name, self.ir_node))\n\n    def __repr__(self):\n        return f\"UserDefinedValueType(name={self._name}, ir_node={self.ir_node})\"\n\n    @classmethod\n    def from_type_identifier(\n        cls,\n        type_identifier: StringReader,\n        reference_resolver: ReferenceResolver,\n        cu_hash: bytes,\n    ) -&gt; UserDefinedValueType:\n        type_identifier.read(\"t_userDefinedValueType\")\n        name = _parse_user_identifier(type_identifier)\n\n        match = NUMBER_RE.match(type_identifier.data)\n        assert match is not None, f\"{type_identifier} is not a valid enum\"\n        ast_id = AstNodeId(int(match.group(\"number\")))\n        type_identifier.read(match.group(\"number\"))\n\n        return UserDefinedValueType(name, ast_id, reference_resolver, cu_hash)\n\n    @property\n    def abi_type(self) -&gt; str:\n        return self.ir_node.underlying_type.type.abi_type\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"\n        Returns:\n            Name of the user defined value type.\n        \"\"\"\n        return self._name\n\n    @property\n    def ir_node(self) -&gt; UserDefinedValueTypeDefinition:\n        \"\"\"\n        Returns:\n            User defined value type definition IR node.\n        \"\"\"\n        from wake.ir.declarations.user_defined_value_type_definition import (\n            UserDefinedValueTypeDefinition,\n        )\n\n        node = self._reference_resolver.resolve_node(self._ast_id, self._cu_hash)\n        assert isinstance(node, UserDefinedValueTypeDefinition)\n        return node\n</code></pre>"},{"location":"api-reference/ir/types/#wake.ir.types.UserDefinedValueType.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>Name of the user defined value type.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.UserDefinedValueType.ir_node","title":"<code>ir_node: UserDefinedValueTypeDefinition</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>UserDefinedValueTypeDefinition</code> <p>User defined value type definition IR node.</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Module","title":"<code>Module</code>  <code>class</code>","text":"<p>         Bases: <code>TypeAbc</code></p> <p>Module type.</p> <p>Note</p> <p>It is probably currently not possible to create an expression of this type.</p> Source code in <code>wake/ir/types.py</code> <pre><code>class Module(TypeAbc):\n    \"\"\"\n    Module type.\n    !!! note\n        It is probably currently not possible to create an expression of this type.\n    \"\"\"\n\n    _source_unit_id: int\n    _reference_resolver: ReferenceResolver\n    _cu_hash: bytes\n\n    def __init__(\n        self, source_unit_id: int, reference_resolver: ReferenceResolver, cu_hash: bytes\n    ):\n        self._source_unit_id = source_unit_id\n        self._reference_resolver = reference_resolver\n        self._cu_hash = cu_hash\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, Module):\n            return False\n        return self.file == other.file\n\n    def __hash__(self):\n        return hash(self.file)\n\n    def __repr__(self):\n        return f\"Module(file={self.file})\"\n\n    @classmethod\n    def from_type_identifier(\n        cls,\n        type_identifier: StringReader,\n        reference_resolver: ReferenceResolver,\n        cu_hash: bytes,\n    ) -&gt; Module:\n        type_identifier.read(\"t_module_\")\n\n        match = NUMBER_RE.match(type_identifier.data)\n        assert match is not None, f\"{type_identifier} is not a valid module\"\n        source_unit_id = int(match.group(\"number\"))\n        type_identifier.read(match.group(\"number\"))\n\n        return Module(source_unit_id, reference_resolver, cu_hash)\n\n    @property\n    def abi_type(self) -&gt; str:\n        raise NotImplementedError\n\n    @property\n    def file(self) -&gt; Path:\n        \"\"\"\n        Returns:\n            Path representing the source file (module).\n        \"\"\"\n        return self._reference_resolver.resolve_source_file_id(\n            self._source_unit_id, self._cu_hash\n        )\n</code></pre>"},{"location":"api-reference/ir/types/#wake.ir.types.Module.file","title":"<code>file: Path</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Path</code> <p>Path representing the source file (module).</p>"},{"location":"api-reference/ir/types/#wake.ir.types.Error","title":"<code>Error</code>  <code>class</code>","text":"<p>         Bases: <code>TypeAbc</code></p> <p>Error type.</p> Source code in <code>wake/ir/types.py</code> <pre><code>class Error(TypeAbc):\n    \"\"\"\n    Error type.\n    \"\"\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        return isinstance(other, Error)\n\n    def __hash__(self):\n        return hash(\"Error\")\n\n    def __repr__(self):\n        return \"Error\"\n\n    @classmethod\n    def from_type_identifier(\n        cls,\n        type_identifier: StringReader,\n        reference_resolver: ReferenceResolver,\n        cu_hash: bytes,\n    ) -&gt; Error:\n        type_identifier.read(\"t_error\")\n        return Error()\n\n    @property\n    def abi_type(self) -&gt; str:\n        raise NotImplementedError\n</code></pre>"},{"location":"api-reference/ir/declarations/abc/","title":"abc","text":""},{"location":"api-reference/ir/declarations/abc/#wake.ir.declarations.abc","title":"<code>wake.ir.declarations.abc</code>  <code>module</code>","text":""},{"location":"api-reference/ir/declarations/abc/#wake.ir.declarations.abc.DeclarationAbc","title":"<code>DeclarationAbc</code>  <code>class</code>","text":"<p>         Bases: <code>SolidityAbc</code>, <code>ABC</code></p> <p>Abstract base class for all Solidity declarations.</p> Source code in <code>wake/ir/declarations/abc.py</code> <pre><code>class DeclarationAbc(SolidityAbc, ABC):\n    \"\"\"\n    Abstract base class for all Solidity declarations.\n    \"\"\"\n\n    _name: str\n    _name_location: Optional[Tuple[int, int]]\n    _references: Set[\n        Union[\n            Identifier,\n            IdentifierPathPart,\n            MemberAccess,\n            ExternalReference,\n            UnaryOperation,\n            BinaryOperation,\n        ]\n    ]\n\n    def __init__(\n        self, init: IrInitTuple, solc_node: SolcDeclarationUnion, parent: SolidityAbc\n    ):\n        super().__init__(init, solc_node, parent)\n        self._name = solc_node.name\n        if solc_node.name_location is None or solc_node.name_location.byte_offset &lt; 0:\n            self._name_location = None\n        else:\n            self._name_location = (\n                solc_node.name_location.byte_offset,\n                solc_node.name_location.byte_offset\n                + solc_node.name_location.byte_length,\n            )\n        self._references = set()\n\n    def register_reference(\n        self,\n        reference: Union[\n            Identifier,\n            IdentifierPathPart,\n            MemberAccess,\n            ExternalReference,\n            UnaryOperation,\n            BinaryOperation,\n        ],\n    ):\n        self._references.add(reference)\n\n    def unregister_reference(\n        self,\n        reference: Union[\n            Identifier,\n            IdentifierPathPart,\n            MemberAccess,\n            ExternalReference,\n            UnaryOperation,\n            BinaryOperation,\n        ],\n    ):\n        self._references.remove(reference)\n\n    def get_all_references(\n        self, include_declarations: bool\n    ) -&gt; Iterator[\n        Union[\n            DeclarationAbc,\n            Union[\n                Identifier,\n                IdentifierPathPart,\n                MemberAccess,\n                ExternalReference,\n                UnaryOperation,\n                BinaryOperation,\n            ],\n        ]\n    ]:\n        if include_declarations:\n            yield self\n        yield from self.references\n\n    @abstractmethod\n    def _parse_name_location(self) -&gt; Tuple[int, int]:\n        ...\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"\n        Returns:\n            User-defined name of the declared object.\n        \"\"\"\n        return self._name\n\n    @property\n    @abstractmethod\n    def canonical_name(self) -&gt; str:\n        \"\"\"\n        !!! example\n            `ContractName.StructName.FieldName` in the case of the `FieldName` [VariableDeclaration][wake.ir.declarations.variable_declaration.VariableDeclaration] declaration in the following example:\n            ```solidity\n            contract ContractName {\n                struct StructName {\n                    uint FieldName;\n                }\n            }\n            ```\n\n        Returns:\n            Canonical name of the declared object.\n        \"\"\"\n        ...\n\n    @property\n    @abstractmethod\n    def declaration_string(self) -&gt; str:\n        \"\"\"\n        Declaration string that can be used for example in LSP hover. Does not include the declaration body, if any.\n        Does not need to match the actual declaration string in the source code (may use a different order of keywords, for example).\n        !!! example\n            `:::solidity function foo(uint a, uint b) public payable virtual onlyOwner returns (uint)` of the [FunctionDefinition][wake.ir.declarations.function_definition.FunctionDefinition] declaration in the following example:\n            ```solidity\n            function foo(uint a, uint b) public onlyOwner virtual payable returns( uint ) {\n                return a + b;\n            }\n            ```\n\n        Returns:\n            String representation of the declaration.\n        \"\"\"\n        ...\n\n    @property\n    @abstractmethod\n    def references(\n        self,\n    ) -&gt; FrozenSet[\n        Union[\n            Identifier,\n            IdentifierPathPart,\n            MemberAccess,\n            ExternalReference,\n            UnaryOperation,\n            BinaryOperation,\n        ]\n    ]:\n        \"\"\"\n        Returns:\n            Set of all IR nodes referencing this declaration.\n        \"\"\"\n        ...\n\n    @property\n    def name_location(self) -&gt; Tuple[int, int]:\n        \"\"\"\n        Similar to [byte_location][wake.ir.abc.IrAbc.byte_location], but returns the location of the declaration name in the source code.\n\n        Returns:\n            Tuple of the start and end byte offsets of the declaration name in the source code.\n        \"\"\"\n        if self._name_location is None:\n            self._name_location = self._parse_name_location()\n        return self._name_location\n</code></pre>"},{"location":"api-reference/ir/declarations/abc/#wake.ir.declarations.abc.DeclarationAbc.canonical_name","title":"<code>canonical_name: str</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Example</p> <p><code>ContractName.StructName.FieldName</code> in the case of the <code>FieldName</code> VariableDeclaration declaration in the following example: <pre><code>contract ContractName {\n    struct StructName {\n        uint FieldName;\n    }\n}\n</code></pre></p> <p>Returns:</p> Type Description <code>str</code> <p>Canonical name of the declared object.</p>"},{"location":"api-reference/ir/declarations/abc/#wake.ir.declarations.abc.DeclarationAbc.declaration_string","title":"<code>declaration_string: str</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Declaration string that can be used for example in LSP hover. Does not include the declaration body, if any. Does not need to match the actual declaration string in the source code (may use a different order of keywords, for example).</p> <p>Example</p> <p><code>function foo(uint a, uint b) public payable virtual onlyOwner returns (uint)</code> of the FunctionDefinition declaration in the following example: <pre><code>function foo(uint a, uint b) public onlyOwner virtual payable returns( uint ) {\n    return a + b;\n}\n</code></pre></p> <p>Returns:</p> Type Description <code>str</code> <p>String representation of the declaration.</p>"},{"location":"api-reference/ir/declarations/abc/#wake.ir.declarations.abc.DeclarationAbc.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>User-defined name of the declared object.</p>"},{"location":"api-reference/ir/declarations/abc/#wake.ir.declarations.abc.DeclarationAbc.name_location","title":"<code>name_location: Tuple[int, int]</code>  <code>property</code>","text":"<p>Similar to byte_location, but returns the location of the declaration name in the source code.</p> <p>Returns:</p> Type Description <code>Tuple[int, int]</code> <p>Tuple of the start and end byte offsets of the declaration name in the source code.</p>"},{"location":"api-reference/ir/declarations/abc/#wake.ir.declarations.abc.DeclarationAbc.references","title":"<code>references: FrozenSet[Union[Identifier, IdentifierPathPart, MemberAccess, ExternalReference, UnaryOperation, BinaryOperation]]</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Returns:</p> Type Description <code>FrozenSet[Union[Identifier, IdentifierPathPart, MemberAccess, ExternalReference, UnaryOperation, BinaryOperation]]</code> <p>Set of all IR nodes referencing this declaration.</p>"},{"location":"api-reference/ir/declarations/contract-definition/","title":"contract_definition","text":""},{"location":"api-reference/ir/declarations/contract-definition/#wake.ir.declarations.contract_definition","title":"<code>wake.ir.declarations.contract_definition</code>  <code>module</code>","text":""},{"location":"api-reference/ir/declarations/contract-definition/#wake.ir.declarations.contract_definition.ContractDefinition","title":"<code>ContractDefinition</code>  <code>class</code>","text":"<p>         Bases: <code>DeclarationAbc</code></p> <p>Definition of a contract, library or interface. byte_location also includes the contract body.</p> <p>Example</p> <pre><code>contract C {\n    uint x;\n    function f() public {}\n}\n</code></pre> <pre><code>interface I {\n    function f() external;\n}\n</code></pre> <pre><code>library L {\n    function f() internal pure returns (uint) {\n        return 7;\n    }\n}\n</code></pre> Source code in <code>wake/ir/declarations/contract_definition.py</code> <pre><code>class ContractDefinition(DeclarationAbc):\n    \"\"\"\n    Definition of a contract, library or interface. [byte_location][wake.ir.abc.IrAbc.byte_location] also includes the contract body.\n\n    !!! example\n        ```solidity\n        contract C {\n            uint x;\n            function f() public {}\n        }\n        ```\n\n        ```solidity\n        interface I {\n            function f() external;\n        }\n        ```\n\n        ```solidity\n        library L {\n            function f() internal pure returns (uint) {\n                return 7;\n            }\n        }\n        ```\n    \"\"\"\n\n    _ast_node: SolcContractDefinition\n    _parent: SourceUnit\n\n    _abstract: bool\n    _base_contracts: List[InheritanceSpecifier]\n    # ___dependencies\n    _kind: ContractKind\n    _fully_implemented: Optional[bool]\n    _linearized_base_contracts: List[AstNodeId]\n    # __scope\n    _documentation: Optional[Union[StructuredDocumentation, str]]\n    _compilation_info: Optional[SolcOutputContractInfo]\n    _used_errors: List[AstNodeId]\n    _enums: List[EnumDefinition]\n    _errors: List[ErrorDefinition]\n    _events: List[EventDefinition]\n    _functions: List[FunctionDefinition]\n    _modifiers: List[ModifierDefinition]\n    _structs: List[StructDefinition]\n    _user_defined_value_types: List[UserDefinedValueTypeDefinition]\n    _using_for_directives: List[UsingForDirective]\n    _declared_variables: List[VariableDeclaration]\n\n    _used_event_ids: List[AstNodeId]\n    _used_events: Set[EventDefinition]\n    # _internal_function_ids\n\n    _child_contracts: Set[ContractDefinition]\n\n    def __init__(\n        self, init: IrInitTuple, contract: SolcContractDefinition, parent: SourceUnit\n    ):\n        super().__init__(init, contract, parent)\n        self._abstract = contract.abstract\n        self._kind = contract.contract_kind\n        self._fully_implemented = contract.fully_implemented\n        self._linearized_base_contracts = list(contract.linearized_base_contracts)\n        self._used_errors = (\n            list(contract.used_errors) if contract.used_errors is not None else []\n        )\n        self._used_event_ids = (\n            list(contract.used_events) if contract.used_events is not None else []\n        )\n        self._used_events = set()\n\n        if contract.documentation is None:\n            self._documentation = None\n        elif isinstance(contract.documentation, SolcStructuredDocumentation):\n            self._documentation = StructuredDocumentation(\n                init, contract.documentation, self\n            )\n        elif isinstance(contract.documentation, str):\n            self._documentation = contract.documentation\n        else:\n            raise TypeError(\n                f\"Unknown type of documentation: {type(contract.documentation)}\"\n            )\n        if init.contracts_info is not None and self.name in init.contracts_info:\n            self._compilation_info = init.contracts_info[self.name]\n        else:\n            self._compilation_info = None\n\n        self._base_contracts = []\n        for base_contract in contract.base_contracts:\n            self._base_contracts.append(InheritanceSpecifier(init, base_contract, self))\n        self._child_contracts = set()\n\n        self._enums = []\n        self._errors = []\n        self._events = []\n        self._functions = []\n        self._modifiers = []\n        self._structs = []\n        self._user_defined_value_types = []\n        self._using_for_directives = []\n        self._declared_variables = []\n\n        for node in contract.nodes:\n            if isinstance(node, SolcEnumDefinition):\n                self._enums.append(EnumDefinition(init, node, self))\n            elif isinstance(node, SolcErrorDefinition):\n                self._errors.append(ErrorDefinition(init, node, self))\n            elif isinstance(node, SolcEventDefinition):\n                self._events.append(EventDefinition(init, node, self))\n            elif isinstance(node, SolcFunctionDefinition):\n                self._functions.append(FunctionDefinition(init, node, self))\n            elif isinstance(node, SolcModifierDefinition):\n                self._modifiers.append(ModifierDefinition(init, node, self))\n            elif isinstance(node, SolcStructDefinition):\n                self._structs.append(StructDefinition(init, node, self))\n            elif isinstance(node, SolcUserDefinedValueTypeDefinition):\n                self._user_defined_value_types.append(\n                    UserDefinedValueTypeDefinition(init, node, self)\n                )\n            elif isinstance(node, SolcUsingForDirective):\n                self._using_for_directives.append(UsingForDirective(init, node, self))\n            elif isinstance(node, SolcVariableDeclaration):\n                self._declared_variables.append(VariableDeclaration(init, node, self))\n\n        init.reference_resolver.register_post_process_callback(self._post_process)\n        init.reference_resolver.register_post_process_callback(\n            self._post_process_events, priority=1\n        )\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        for base_contract in self._base_contracts:\n            yield from base_contract\n        if isinstance(self._documentation, StructuredDocumentation):\n            yield from self._documentation\n        for enum in self._enums:\n            yield from enum\n        for error in self._errors:\n            yield from error\n        for event in self._events:\n            yield from event\n        for function in self._functions:\n            yield from function\n        for modifier in self._modifiers:\n            yield from modifier\n        for struct in self._structs:\n            yield from struct\n        for user_defined_value_type in self._user_defined_value_types:\n            yield from user_defined_value_type\n        for using_for_directive in self._using_for_directives:\n            yield from using_for_directive\n        for declared_variable in self._declared_variables:\n            yield from declared_variable\n\n    def _post_process(self, callback_params: CallbackParams):\n        base_contracts = []\n        for base_contract in self._base_contracts:\n            contract = base_contract.base_name.referenced_declaration\n            assert isinstance(contract, ContractDefinition)\n            contract._child_contracts.add(self)\n            base_contracts.append(contract)\n\n        for error in self.used_errors:\n            error._used_in.add(self)\n\n        # in case used_events are set in the AST in solc &gt;= 0.8.20\n        for event_id in self._used_event_ids:\n            event = self._reference_resolver.resolve_node(\n                event_id, self.source_unit.cu_hash\n            )\n            assert isinstance(event, EventDefinition)\n            self._used_events.add(event)\n\n        # in case used_events are not set in the AST in solc &lt; 0.8.20\n        for event in self._events:\n            self._used_events.add(event)\n\n        self._reference_resolver.register_destroy_callback(\n            self.source_unit.file, partial(self._destroy, base_contracts)\n        )\n\n    def _post_process_events(self, callback_params: CallbackParams):\n        for base in self.linearized_base_contracts:\n            self._used_events.update(base.used_events)\n\n        for event in self.used_events:\n            event._used_in.add(self)\n\n        self._reference_resolver.register_destroy_callback(\n            self.source_unit.file, self._destroy_events\n        )\n\n    def _destroy(self, base_contracts: List[ContractDefinition]) -&gt; None:\n        for base_contract in base_contracts:\n            base_contract._child_contracts.remove(self)\n        for error in self.used_errors:\n            error._used_in.remove(self)\n\n    def _destroy_events(self) -&gt; None:\n        for event in self.used_events:\n            event._used_in.remove(self)\n\n    def _parse_name_location(self) -&gt; Tuple[int, int]:\n        IDENTIFIER = r\"[a-zA-Z$_][a-zA-Z0-9$_]*\"\n        CONTRACT_RE = re.compile(\n            r\"^\\s*(abstract\\s)?\\s*contract\\s+(?P&lt;name&gt;{identifier})\".format(\n                identifier=IDENTIFIER\n            ).encode(\"utf-8\")\n        )\n        INTERFACE_RE = re.compile(\n            r\"^\\s*interface\\s+(?P&lt;name&gt;{identifier})\".format(\n                identifier=IDENTIFIER\n            ).encode(\"utf-8\")\n        )\n        LIBRARY_RE = re.compile(\n            r\"^\\s*library\\s+(?P&lt;name&gt;{identifier})\".format(\n                identifier=IDENTIFIER\n            ).encode(\"utf-8\")\n        )\n\n        source = bytearray(self._source)\n        _, stripped_sums = SoliditySourceParser.strip_comments(source)\n\n        if self.kind == ContractKind.CONTRACT:\n            match = CONTRACT_RE.match(source)\n        elif self.kind == ContractKind.INTERFACE:\n            match = INTERFACE_RE.match(source)\n        elif self.kind == ContractKind.LIBRARY:\n            match = LIBRARY_RE.match(source)\n        else:\n            raise ValueError(f\"Unknown contract kind: {self.kind}\")\n        assert match\n\n        if len(stripped_sums) == 0:\n            stripped = 0\n        else:\n            index = bisect([s[0] for s in stripped_sums], match.start(\"name\"))\n            if index == 0:\n                stripped = 0\n            else:\n                stripped = stripped_sums[index - 1][1]\n\n        return (\n            self.byte_location[0] + match.start(\"name\") + stripped,\n            self.byte_location[0] + match.end(\"name\") + stripped,\n        )\n\n    @property\n    def parent(self) -&gt; SourceUnit:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def canonical_name(self) -&gt; str:\n        return self._name\n\n    @property\n    @lru_cache(maxsize=2048)\n    def declaration_string(self) -&gt; str:\n        ret = f\"{'abstract ' if self.abstract else ''}{self.kind} {self.name}\"\n        ret += (\n            \" is \" + \", \".join(spec.source for spec in self.base_contracts)\n            if len(self.base_contracts) &gt; 0\n            else \"\"\n        )\n        if isinstance(self.documentation, StructuredDocumentation):\n            return (\n                \"/// \"\n                + \"\\n///\".join(line for line in self.documentation.text.splitlines())\n                + \"\\n\"\n                + ret\n            )\n        elif isinstance(self.documentation, str):\n            return (\n                \"/// \"\n                + \"\\n///\".join(line for line in self.documentation.splitlines())\n                + \"\\n\"\n                + ret\n            )\n        else:\n            return ret\n\n    @property\n    def abstract(self) -&gt; bool:\n        \"\"\"\n        Is `False` if the [kind][wake.ir.declarations.contract_definition.ContractDefinition.kind] is [ContractKind.LIBRARY][wake.ir.enums.ContractKind.LIBRARY] or [ContractKind.INTERFACE][wake.ir.enums.ContractKind.INTERFACE].\n\n        Returns:\n            `True` if the contract is abstract, `False` otherwise.\n        \"\"\"\n        return self._abstract\n\n    @property\n    def base_contracts(self) -&gt; Tuple[InheritanceSpecifier, ...]:\n        \"\"\"\n        Returns base contracts as specified in the source code. Does not return all base contracts (recursively).\n        !!! example\n            `A1` lists the interface `I` as a base contract.\n\n            `A2` lists the interface `I` as a base contract.\n\n            `B` lists the contracts `A1` and `A2` as base contracts.\n            ```solidity\n            interface I {}\n            contract A1 is I {}\n            contract A2 is I {}\n            contract B is A1, A2 {}\n            ```\n\n        Returns:\n            Base contracts of this contract.\n        \"\"\"\n        return tuple(self._base_contracts)\n\n    @property\n    def child_contracts(self) -&gt; FrozenSet[ContractDefinition]:\n        \"\"\"\n        Does not return all child contracts (recursively).\n\n        Returns:\n            Contracts that list this contract in their [base_contracts][wake.ir.declarations.contract_definition.ContractDefinition.base_contracts] property.\n        \"\"\"\n        return frozenset(self._child_contracts)\n\n    @property\n    def kind(self) -&gt; ContractKind:\n        \"\"\"\n        Returns:\n            Contract kind.\n        \"\"\"\n        return self._kind\n\n    @property\n    def fully_implemented(self) -&gt; Optional[bool]:\n        \"\"\"\n        Is `None` when a file that imports this contract cannot be compiled. This may happen in the LSP server where partial project analysis is supported.\n\n        Returns:\n            `True` if all functions and modifiers of the contract are implemented, `False` otherwise.\n        \"\"\"\n        return self._fully_implemented\n\n    @property\n    def linearized_base_contracts(self) -&gt; Tuple[ContractDefinition, ...]:\n        \"\"\"\n        Returns:\n            C3 linearized list of all base contracts.\n        \"\"\"\n        base_contracts = []\n        for base_contract in self._linearized_base_contracts:\n            node = self._reference_resolver.resolve_node(\n                base_contract, self.source_unit.cu_hash\n            )\n            assert isinstance(node, ContractDefinition)\n            base_contracts.append(node)\n        return tuple(base_contracts)\n\n    @property\n    def used_errors(self) -&gt; FrozenSet[ErrorDefinition]:\n        \"\"\"\n        Returns:\n            Errors used in revert statements in this contract (or its base contracts) as well as all errors defined and inherited by the contract.\n        \"\"\"\n        used_errors = set()\n        for error in self._used_errors:\n            node = self._reference_resolver.resolve_node(\n                error, self.source_unit.cu_hash\n            )\n            assert isinstance(node, ErrorDefinition)\n            used_errors.add(node)\n        return frozenset(used_errors)\n\n    @property\n    def used_events(self) -&gt; FrozenSet[EventDefinition]:\n        \"\"\"\n        Returns:\n            Events emitted by the contract (or its base contracts) as well as all events defined and inherited by the contract.\n        \"\"\"\n        return frozenset(self._used_events)\n\n    @property\n    def documentation(self) -&gt; Optional[Union[StructuredDocumentation, str]]:\n        \"\"\"\n        Of [StructuredDocumentation][wake.ir.meta.structured_documentation.StructuredDocumentation] type since Solidity 0.6.3.\n\n        Returns:\n            [NatSpec](https://docs.soliditylang.org/en/latest/natspec-format.html) documentation of this contract, if any.\n        \"\"\"\n        return self._documentation\n\n    @property\n    def compilation_info(self) -&gt; Optional[SolcOutputContractInfo]:\n        return self._compilation_info\n\n    @property\n    def enums(self) -&gt; Tuple[EnumDefinition, ...]:\n        \"\"\"\n        Returns:\n            Enum definitions contained in this contract.\n        \"\"\"\n        return tuple(self._enums)\n\n    @property\n    def errors(self) -&gt; Tuple[ErrorDefinition, ...]:\n        \"\"\"\n        Returns:\n            Error definitions contained in this contract.\n        \"\"\"\n        return tuple(self._errors)\n\n    @property\n    def events(self) -&gt; Tuple[EventDefinition, ...]:\n        \"\"\"\n        Returns:\n            Event definitions contained in this contract.\n        \"\"\"\n        return tuple(self._events)\n\n    @property\n    def functions(self) -&gt; Tuple[FunctionDefinition, ...]:\n        \"\"\"\n        Returns:\n            Function definitions contained in this contract.\n        \"\"\"\n        return tuple(self._functions)\n\n    @property\n    def modifiers(self) -&gt; Tuple[ModifierDefinition, ...]:\n        \"\"\"\n        Returns:\n            Modifier definitions contained in this contract.\n        \"\"\"\n        return tuple(self._modifiers)\n\n    @property\n    def structs(self) -&gt; Tuple[StructDefinition, ...]:\n        \"\"\"\n        Returns:\n            Struct definitions contained in this contract.\n        \"\"\"\n        return tuple(self._structs)\n\n    @property\n    def user_defined_value_types(self) -&gt; Tuple[UserDefinedValueTypeDefinition, ...]:\n        \"\"\"\n        Returns:\n            User defined value type definitions contained in this contract.\n        \"\"\"\n        return tuple(self._user_defined_value_types)\n\n    @property\n    def using_for_directives(self) -&gt; Tuple[UsingForDirective, ...]:\n        \"\"\"\n        Returns:\n            Using for directives contained in this contract.\n        \"\"\"\n        return tuple(self._using_for_directives)\n\n    @property\n    def declared_variables(self) -&gt; Tuple[VariableDeclaration, ...]:\n        \"\"\"\n        Returns:\n            Variable declarations contained in this contract.\n        \"\"\"\n        return tuple(self._declared_variables)\n\n    def declarations_iter(self) -&gt; Iterator[DeclarationAbc]:\n        \"\"\"\n        Yields:\n            All declarations contained in this contract.\n        \"\"\"\n        yield from self.enums\n        for enum in self.enums:\n            yield from enum.values\n        yield from self.errors\n        yield from self.events\n        yield from self.functions\n        yield from self.modifiers\n        yield from self.structs\n        yield from self.user_defined_value_types\n        yield from self.declared_variables\n\n    @property\n    def references(\n        self,\n    ) -&gt; FrozenSet[Union[Identifier, IdentifierPathPart, MemberAccess,]]:\n        \"\"\"\n        Returns:\n            Set of all IR nodes referencing this contract.\n        \"\"\"\n        from ..expressions.identifier import Identifier\n        from ..expressions.member_access import MemberAccess\n        from ..meta.identifier_path import IdentifierPathPart\n\n        try:\n            ref = next(\n                ref\n                for ref in self._references\n                if not isinstance(ref, (Identifier, IdentifierPathPart, MemberAccess))\n            )\n            raise AssertionError(f\"Unexpected reference type: {ref}\")\n        except StopIteration:\n            return frozenset(\n                self._references\n            )  # pyright: ignore reportGeneralTypeIssues\n</code></pre>"},{"location":"api-reference/ir/declarations/contract-definition/#wake.ir.declarations.contract_definition.ContractDefinition.abstract","title":"<code>abstract: bool</code>  <code>property</code>","text":"<p>Is <code>False</code> if the kind is ContractKind.LIBRARY or ContractKind.INTERFACE.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the contract is abstract, <code>False</code> otherwise.</p>"},{"location":"api-reference/ir/declarations/contract-definition/#wake.ir.declarations.contract_definition.ContractDefinition.base_contracts","title":"<code>base_contracts: Tuple[InheritanceSpecifier, ...]</code>  <code>property</code>","text":"<p>Returns base contracts as specified in the source code. Does not return all base contracts (recursively).</p> <p>Example</p> <p><code>A1</code> lists the interface <code>I</code> as a base contract.</p> <p><code>A2</code> lists the interface <code>I</code> as a base contract.</p> <p><code>B</code> lists the contracts <code>A1</code> and <code>A2</code> as base contracts. <pre><code>interface I {}\ncontract A1 is I {}\ncontract A2 is I {}\ncontract B is A1, A2 {}\n</code></pre></p> <p>Returns:</p> Type Description <code>Tuple[InheritanceSpecifier, ...]</code> <p>Base contracts of this contract.</p>"},{"location":"api-reference/ir/declarations/contract-definition/#wake.ir.declarations.contract_definition.ContractDefinition.child_contracts","title":"<code>child_contracts: FrozenSet[ContractDefinition]</code>  <code>property</code>","text":"<p>Does not return all child contracts (recursively).</p> <p>Returns:</p> Type Description <code>FrozenSet[ContractDefinition]</code> <p>Contracts that list this contract in their base_contracts property.</p>"},{"location":"api-reference/ir/declarations/contract-definition/#wake.ir.declarations.contract_definition.ContractDefinition.declared_variables","title":"<code>declared_variables: Tuple[VariableDeclaration, ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[VariableDeclaration, ...]</code> <p>Variable declarations contained in this contract.</p>"},{"location":"api-reference/ir/declarations/contract-definition/#wake.ir.declarations.contract_definition.ContractDefinition.documentation","title":"<code>documentation: Optional[Union[StructuredDocumentation, str]]</code>  <code>property</code>","text":"<p>Of StructuredDocumentation type since Solidity 0.6.3.</p> <p>Returns:</p> Type Description <code>Optional[Union[StructuredDocumentation, str]]</code> <p>NatSpec documentation of this contract, if any.</p>"},{"location":"api-reference/ir/declarations/contract-definition/#wake.ir.declarations.contract_definition.ContractDefinition.enums","title":"<code>enums: Tuple[EnumDefinition, ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[EnumDefinition, ...]</code> <p>Enum definitions contained in this contract.</p>"},{"location":"api-reference/ir/declarations/contract-definition/#wake.ir.declarations.contract_definition.ContractDefinition.errors","title":"<code>errors: Tuple[ErrorDefinition, ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[ErrorDefinition, ...]</code> <p>Error definitions contained in this contract.</p>"},{"location":"api-reference/ir/declarations/contract-definition/#wake.ir.declarations.contract_definition.ContractDefinition.events","title":"<code>events: Tuple[EventDefinition, ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[EventDefinition, ...]</code> <p>Event definitions contained in this contract.</p>"},{"location":"api-reference/ir/declarations/contract-definition/#wake.ir.declarations.contract_definition.ContractDefinition.fully_implemented","title":"<code>fully_implemented: Optional[bool]</code>  <code>property</code>","text":"<p>Is <code>None</code> when a file that imports this contract cannot be compiled. This may happen in the LSP server where partial project analysis is supported.</p> <p>Returns:</p> Type Description <code>Optional[bool]</code> <p><code>True</code> if all functions and modifiers of the contract are implemented, <code>False</code> otherwise.</p>"},{"location":"api-reference/ir/declarations/contract-definition/#wake.ir.declarations.contract_definition.ContractDefinition.functions","title":"<code>functions: Tuple[FunctionDefinition, ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[FunctionDefinition, ...]</code> <p>Function definitions contained in this contract.</p>"},{"location":"api-reference/ir/declarations/contract-definition/#wake.ir.declarations.contract_definition.ContractDefinition.kind","title":"<code>kind: ContractKind</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>ContractKind</code> <p>Contract kind.</p>"},{"location":"api-reference/ir/declarations/contract-definition/#wake.ir.declarations.contract_definition.ContractDefinition.linearized_base_contracts","title":"<code>linearized_base_contracts: Tuple[ContractDefinition, ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[ContractDefinition, ...]</code> <p>C3 linearized list of all base contracts.</p>"},{"location":"api-reference/ir/declarations/contract-definition/#wake.ir.declarations.contract_definition.ContractDefinition.modifiers","title":"<code>modifiers: Tuple[ModifierDefinition, ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[ModifierDefinition, ...]</code> <p>Modifier definitions contained in this contract.</p>"},{"location":"api-reference/ir/declarations/contract-definition/#wake.ir.declarations.contract_definition.ContractDefinition.parent","title":"<code>parent: SourceUnit</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>SourceUnit</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/declarations/contract-definition/#wake.ir.declarations.contract_definition.ContractDefinition.references","title":"<code>references: FrozenSet[Union[Identifier, IdentifierPathPart, MemberAccess]]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>FrozenSet[Union[Identifier, IdentifierPathPart, MemberAccess]]</code> <p>Set of all IR nodes referencing this contract.</p>"},{"location":"api-reference/ir/declarations/contract-definition/#wake.ir.declarations.contract_definition.ContractDefinition.structs","title":"<code>structs: Tuple[StructDefinition, ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[StructDefinition, ...]</code> <p>Struct definitions contained in this contract.</p>"},{"location":"api-reference/ir/declarations/contract-definition/#wake.ir.declarations.contract_definition.ContractDefinition.used_errors","title":"<code>used_errors: FrozenSet[ErrorDefinition]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>FrozenSet[ErrorDefinition]</code> <p>Errors used in revert statements in this contract (or its base contracts) as well as all errors defined and inherited by the contract.</p>"},{"location":"api-reference/ir/declarations/contract-definition/#wake.ir.declarations.contract_definition.ContractDefinition.used_events","title":"<code>used_events: FrozenSet[EventDefinition]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>FrozenSet[EventDefinition]</code> <p>Events emitted by the contract (or its base contracts) as well as all events defined and inherited by the contract.</p>"},{"location":"api-reference/ir/declarations/contract-definition/#wake.ir.declarations.contract_definition.ContractDefinition.user_defined_value_types","title":"<code>user_defined_value_types: Tuple[UserDefinedValueTypeDefinition, ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[UserDefinedValueTypeDefinition, ...]</code> <p>User defined value type definitions contained in this contract.</p>"},{"location":"api-reference/ir/declarations/contract-definition/#wake.ir.declarations.contract_definition.ContractDefinition.using_for_directives","title":"<code>using_for_directives: Tuple[UsingForDirective, ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[UsingForDirective, ...]</code> <p>Using for directives contained in this contract.</p>"},{"location":"api-reference/ir/declarations/contract-definition/#wake.ir.declarations.contract_definition.ContractDefinition.declarations_iter","title":"<code>declarations_iter()</code>","text":"<p>Yields:</p> Type Description <code>DeclarationAbc</code> <p>All declarations contained in this contract.</p> Source code in <code>wake/ir/declarations/contract_definition.py</code> <pre><code>def declarations_iter(self) -&gt; Iterator[DeclarationAbc]:\n    \"\"\"\n    Yields:\n        All declarations contained in this contract.\n    \"\"\"\n    yield from self.enums\n    for enum in self.enums:\n        yield from enum.values\n    yield from self.errors\n    yield from self.events\n    yield from self.functions\n    yield from self.modifiers\n    yield from self.structs\n    yield from self.user_defined_value_types\n    yield from self.declared_variables\n</code></pre>"},{"location":"api-reference/ir/declarations/enum-definition/","title":"enum_definition","text":""},{"location":"api-reference/ir/declarations/enum-definition/#wake.ir.declarations.enum_definition","title":"<code>wake.ir.declarations.enum_definition</code>  <code>module</code>","text":""},{"location":"api-reference/ir/declarations/enum-definition/#wake.ir.declarations.enum_definition.EnumDefinition","title":"<code>EnumDefinition</code>  <code>class</code>","text":"<p>         Bases: <code>DeclarationAbc</code></p> <p>Definition of an enum.</p> <p>Example</p> <pre><code>enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill }\n</code></pre> Source code in <code>wake/ir/declarations/enum_definition.py</code> <pre><code>class EnumDefinition(DeclarationAbc):\n    \"\"\"\n    Definition of an enum.\n\n    !!! example\n        ```solidity\n        enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill }\n        ```\n    \"\"\"\n\n    _ast_node: SolcEnumDefinition\n    _parent: Union[ContractDefinition, SourceUnit]\n\n    _canonical_name: str\n    _values: List[EnumValue]\n    _documentation: Optional[StructuredDocumentation]\n\n    def __init__(\n        self, init: IrInitTuple, enum: SolcEnumDefinition, parent: SolidityAbc\n    ):\n        super().__init__(init, enum, parent)\n        self._canonical_name = enum.canonical_name\n\n        self._values = []\n        for value in enum.members:\n            self._values.append(EnumValue(init, value, self))\n        self._documentation = (\n            StructuredDocumentation(init, enum.documentation, self)\n            if enum.documentation is not None\n            else None\n        )\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        for value in self._values:\n            yield from value\n\n    def _parse_name_location(self) -&gt; Tuple[int, int]:\n        IDENTIFIER = r\"[a-zA-Z$_][a-zA-Z0-9$_]*\"\n        ENUM_RE = re.compile(\n            r\"^\\s*enum\\s+(?P&lt;name&gt;{identifier})\".format(identifier=IDENTIFIER).encode(\n                \"utf-8\"\n            )\n        )\n\n        source = bytearray(self._source)\n        _, stripped_sums = SoliditySourceParser.strip_comments(source)\n\n        byte_start = self._ast_node.src.byte_offset\n        match = ENUM_RE.match(source)\n        assert match\n\n        if len(stripped_sums) == 0:\n            stripped = 0\n        else:\n            index = bisect([s[0] for s in stripped_sums], match.start(\"name\"))\n            if index == 0:\n                stripped = 0\n            else:\n                stripped = stripped_sums[index - 1][1]\n\n        return (\n            byte_start + match.start(\"name\") + stripped,\n            byte_start + match.end(\"name\") + stripped,\n        )\n\n    @property\n    def parent(self) -&gt; Union[SourceUnit, ContractDefinition]:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def canonical_name(self) -&gt; str:\n        return self._canonical_name\n\n    @property\n    @lru_cache(maxsize=2048)\n    def declaration_string(self) -&gt; str:\n        return (\n            f\"enum {self.name}\"\n            + \" {\\n\"\n            + \",\\n\".join(f\"    {value.name}\" for value in self._values)\n            + \"\\n}\"\n        )\n\n    @property\n    def values(self) -&gt; Tuple[EnumValue, ...]:\n        \"\"\"\n        Returns:\n            Enum values defined in this enum.\n        \"\"\"\n        return tuple(self._values)\n\n    @property\n    def documentation(self) -&gt; Optional[StructuredDocumentation]:\n        \"\"\"\n        Added in Solidity 0.8.20.\n\n        Returns:\n            [NatSpec](https://docs.soliditylang.org/en/latest/natspec-format.html) documentation string, if any.\n        \"\"\"\n        return self._documentation\n\n    @property\n    def references(\n        self,\n    ) -&gt; FrozenSet[Union[Identifier, IdentifierPathPart, MemberAccess,]]:\n        \"\"\"\n        Returns:\n            Set of all IR nodes referencing this enum.\n        \"\"\"\n        from ..expressions.identifier import Identifier\n        from ..expressions.member_access import MemberAccess\n        from ..meta.identifier_path import IdentifierPathPart\n\n        try:\n            ref = next(\n                ref\n                for ref in self._references\n                if not isinstance(ref, (Identifier, IdentifierPathPart, MemberAccess))\n            )\n            raise AssertionError(f\"Unexpected reference type: {ref}\")\n        except StopIteration:\n            return frozenset(\n                self._references\n            )  # pyright: ignore reportGeneralTypeIssues\n</code></pre>"},{"location":"api-reference/ir/declarations/enum-definition/#wake.ir.declarations.enum_definition.EnumDefinition.documentation","title":"<code>documentation: Optional[StructuredDocumentation]</code>  <code>property</code>","text":"<p>Added in Solidity 0.8.20.</p> <p>Returns:</p> Type Description <code>Optional[StructuredDocumentation]</code> <p>NatSpec documentation string, if any.</p>"},{"location":"api-reference/ir/declarations/enum-definition/#wake.ir.declarations.enum_definition.EnumDefinition.parent","title":"<code>parent: Union[SourceUnit, ContractDefinition]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[SourceUnit, ContractDefinition]</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/declarations/enum-definition/#wake.ir.declarations.enum_definition.EnumDefinition.references","title":"<code>references: FrozenSet[Union[Identifier, IdentifierPathPart, MemberAccess]]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>FrozenSet[Union[Identifier, IdentifierPathPart, MemberAccess]]</code> <p>Set of all IR nodes referencing this enum.</p>"},{"location":"api-reference/ir/declarations/enum-definition/#wake.ir.declarations.enum_definition.EnumDefinition.values","title":"<code>values: Tuple[EnumValue, ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[EnumValue, ...]</code> <p>Enum values defined in this enum.</p>"},{"location":"api-reference/ir/declarations/enum-value/","title":"enum_value","text":""},{"location":"api-reference/ir/declarations/enum-value/#wake.ir.declarations.enum_value","title":"<code>wake.ir.declarations.enum_value</code>  <code>module</code>","text":""},{"location":"api-reference/ir/declarations/enum-value/#wake.ir.declarations.enum_value.EnumValue","title":"<code>EnumValue</code>  <code>class</code>","text":"<p>         Bases: <code>DeclarationAbc</code></p> <p>Definition of an enum value inside an enum definition.</p> <p>Example</p> <p><code>GoLeft</code>, <code>GoRight</code>, <code>GoStraight</code>, <code>SitStill</code> in the following enum definition: <pre><code>enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill }\n</code></pre></p> Source code in <code>wake/ir/declarations/enum_value.py</code> <pre><code>class EnumValue(DeclarationAbc):\n    \"\"\"\n    Definition of an enum value inside an enum definition.\n\n    !!! example\n        `GoLeft`, `GoRight`, `GoStraight`, `SitStill` in the following enum definition:\n        ```solidity\n        enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill }\n        ```\n    \"\"\"\n\n    _ast_node: SolcEnumValue\n    _parent: EnumDefinition\n\n    def __init__(self, init: IrInitTuple, value: SolcEnumValue, parent: SolidityAbc):\n        super().__init__(init, value, parent)\n\n    def _parse_name_location(self) -&gt; Tuple[int, int]:\n        src = self._ast_node.src\n        return src.byte_offset, src.byte_offset + src.byte_length\n\n    @property\n    def parent(self) -&gt; EnumDefinition:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def canonical_name(self) -&gt; str:\n        return f\"{self._parent.canonical_name}.{self._name}\"\n\n    @property\n    def declaration_string(self) -&gt; str:\n        return self.name\n\n    @property\n    def references(\n        self,\n    ) -&gt; FrozenSet[MemberAccess]:\n        \"\"\"\n        Returns:\n            Set of all IR nodes referencing this enum value.\n        \"\"\"\n        from ..expressions.member_access import MemberAccess\n\n        try:\n            ref = next(\n                ref for ref in self._references if not isinstance(ref, MemberAccess)\n            )\n            raise AssertionError(f\"Unexpected reference type: {ref}\")\n        except StopIteration:\n            return frozenset(\n                self._references\n            )  # pyright: ignore reportGeneralTypeIssues\n</code></pre>"},{"location":"api-reference/ir/declarations/enum-value/#wake.ir.declarations.enum_value.EnumValue.parent","title":"<code>parent: EnumDefinition</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>EnumDefinition</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/declarations/enum-value/#wake.ir.declarations.enum_value.EnumValue.references","title":"<code>references: FrozenSet[MemberAccess]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>FrozenSet[MemberAccess]</code> <p>Set of all IR nodes referencing this enum value.</p>"},{"location":"api-reference/ir/declarations/error-definition/","title":"error_definition","text":""},{"location":"api-reference/ir/declarations/error-definition/#wake.ir.declarations.error_definition","title":"<code>wake.ir.declarations.error_definition</code>  <code>module</code>","text":""},{"location":"api-reference/ir/declarations/error-definition/#wake.ir.declarations.error_definition.ErrorDefinition","title":"<code>ErrorDefinition</code>  <code>class</code>","text":"<p>         Bases: <code>DeclarationAbc</code></p> <p>Definition of an error.</p> <p>Example</p> <pre><code>error InsufficientBalance(uint256 available, uint256 required);\n</code></pre> Source code in <code>wake/ir/declarations/error_definition.py</code> <pre><code>class ErrorDefinition(DeclarationAbc):\n    \"\"\"\n    Definition of an error.\n\n    !!! example\n        ```solidity\n        error InsufficientBalance(uint256 available, uint256 required);\n        ```\n    \"\"\"\n\n    _ast_node: SolcErrorDefinition\n    _parent: Union[ContractDefinition, SourceUnit]\n\n    _parameters: ParameterList\n    _documentation: Optional[StructuredDocumentation]\n    _error_selector: Optional[bytes]\n\n    # not a part of the AST\n    _used_in: Set[ContractDefinition]\n\n    def __init__(\n        self, init: IrInitTuple, error: SolcErrorDefinition, parent: SolidityAbc\n    ):\n        super().__init__(init, error, parent)\n        self._parameters = ParameterList(init, error.parameters, self)\n        self._documentation = (\n            StructuredDocumentation(init, error.documentation, self)\n            if error.documentation is not None\n            else None\n        )\n        self._error_selector = (\n            bytes.fromhex(error.error_selector) if error.error_selector else None\n        )\n        self._used_in = set()\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        yield from self._parameters\n        if self._documentation is not None:\n            yield from self._documentation\n\n    def _parse_name_location(self) -&gt; Tuple[int, int]:\n        # SolcErrorDefinition node always contains name_location attribute\n        # this method is implemented here just for completeness and to satisfy the linter\n        byte_start = self._ast_node.name_location.byte_offset\n        byte_length = self._ast_node.name_location.byte_length\n        return byte_start, byte_start + byte_length\n\n    @property\n    def parent(self) -&gt; Union[ContractDefinition, SourceUnit]:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    @lru_cache(maxsize=2048)\n    def canonical_name(self) -&gt; str:\n        from .contract_definition import ContractDefinition\n\n        if isinstance(self._parent, ContractDefinition):\n            return f\"{self._parent.canonical_name}.{self._name}\"\n        return self._name\n\n    @property\n    @lru_cache(maxsize=2048)\n    def declaration_string(self) -&gt; str:\n        ret = (\n            f\"error {self._name}(\"\n            + \", \".join(\n                param.declaration_string for param in self.parameters.parameters\n            )\n            + \")\"\n        )\n        if self.documentation is not None:\n            return (\n                \"/// \"\n                + \"\\n///\".join(line for line in self.documentation.text.splitlines())\n                + \"\\n\"\n                + ret\n            )\n        return ret\n\n    @property\n    def parameters(self) -&gt; ParameterList:\n        \"\"\"\n        Returns:\n            Parameter list describing parameters of the error.\n        \"\"\"\n        return self._parameters\n\n    @property\n    def documentation(self) -&gt; Optional[StructuredDocumentation]:\n        \"\"\"\n        Returns:\n            [NatSpec](https://docs.soliditylang.org/en/latest/natspec-format.html) documentation string, if any.\n        \"\"\"\n        return self._documentation\n\n    @property\n    @lru_cache(maxsize=2048)\n    def error_selector(self) -&gt; bytes:\n        \"\"\"\n        Returns:\n            Selector of the error.\n        \"\"\"\n        if self._error_selector is not None:\n            return self._error_selector\n        else:\n            signature = f\"{self._name}(\"\n            signature += \",\".join(\n                param.type.abi_type for param in self.parameters.parameters\n            )\n            signature += \")\"\n            h = keccak.new(data=signature.encode(\"utf-8\"), digest_bits=256)\n            return h.digest()[:4]\n\n    @property\n    def used_in(self) -&gt; FrozenSet[ContractDefinition]:\n        \"\"\"\n        Returns:\n            Contracts (including child contracts) that use this error in a revert statement, a contract that defines this error and contracts that inherit this error.\n        \"\"\"\n        return frozenset(self._used_in)\n\n    @property\n    def references(\n        self,\n    ) -&gt; FrozenSet[Union[Identifier, MemberAccess,]]:\n        \"\"\"\n        Returns:\n            Set of all IR nodes referencing this error.\n        \"\"\"\n        from ..expressions.identifier import Identifier\n        from ..expressions.member_access import MemberAccess\n\n        try:\n            ref = next(\n                ref\n                for ref in self._references\n                if not isinstance(ref, (Identifier, MemberAccess))\n            )\n            raise AssertionError(f\"Unexpected reference type: {ref}\")\n        except StopIteration:\n            return frozenset(\n                self._references\n            )  # pyright: ignore reportGeneralTypeIssues\n</code></pre>"},{"location":"api-reference/ir/declarations/error-definition/#wake.ir.declarations.error_definition.ErrorDefinition.documentation","title":"<code>documentation: Optional[StructuredDocumentation]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Optional[StructuredDocumentation]</code> <p>NatSpec documentation string, if any.</p>"},{"location":"api-reference/ir/declarations/error-definition/#wake.ir.declarations.error_definition.ErrorDefinition.error_selector","title":"<code>error_selector: bytes</code>  <code>cached</code> <code>property</code>","text":"<p>Returns:</p> Type Description <code>bytes</code> <p>Selector of the error.</p>"},{"location":"api-reference/ir/declarations/error-definition/#wake.ir.declarations.error_definition.ErrorDefinition.parameters","title":"<code>parameters: ParameterList</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>ParameterList</code> <p>Parameter list describing parameters of the error.</p>"},{"location":"api-reference/ir/declarations/error-definition/#wake.ir.declarations.error_definition.ErrorDefinition.parent","title":"<code>parent: Union[ContractDefinition, SourceUnit]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[ContractDefinition, SourceUnit]</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/declarations/error-definition/#wake.ir.declarations.error_definition.ErrorDefinition.references","title":"<code>references: FrozenSet[Union[Identifier, MemberAccess]]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>FrozenSet[Union[Identifier, MemberAccess]]</code> <p>Set of all IR nodes referencing this error.</p>"},{"location":"api-reference/ir/declarations/error-definition/#wake.ir.declarations.error_definition.ErrorDefinition.used_in","title":"<code>used_in: FrozenSet[ContractDefinition]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>FrozenSet[ContractDefinition]</code> <p>Contracts (including child contracts) that use this error in a revert statement, a contract that defines this error and contracts that inherit this error.</p>"},{"location":"api-reference/ir/declarations/event-definition/","title":"event_definition","text":""},{"location":"api-reference/ir/declarations/event-definition/#wake.ir.declarations.event_definition","title":"<code>wake.ir.declarations.event_definition</code>  <code>module</code>","text":""},{"location":"api-reference/ir/declarations/event-definition/#wake.ir.declarations.event_definition.EventDefinition","title":"<code>EventDefinition</code>  <code>class</code>","text":"<p>         Bases: <code>DeclarationAbc</code></p> <p>Definition of an event.</p> <p>Example</p> <pre><code>event Transfer(address indexed from, address indexed to, uint256 value);\n</code></pre> Source code in <code>wake/ir/declarations/event_definition.py</code> <pre><code>class EventDefinition(DeclarationAbc):\n    \"\"\"\n    Definition of an event.\n    !!! example\n        ```solidity\n        event Transfer(address indexed from, address indexed to, uint256 value);\n        ```\n    \"\"\"\n\n    _ast_node: SolcEventDefinition\n    _parent: Union[ContractDefinition, SourceUnit]\n\n    _anonymous: bool\n    _parameters: ParameterList\n    _documentation: Optional[Union[StructuredDocumentation, str]]\n    _event_selector: Optional[bytes]\n\n    # not a part of the AST\n    _used_in: Set[ContractDefinition]\n\n    def __init__(\n        self, init: IrInitTuple, event: SolcEventDefinition, parent: SolidityAbc\n    ):\n        super().__init__(init, event, parent)\n        self._anonymous = event.anonymous\n        self._parameters = ParameterList(init, event.parameters, self)\n\n        if event.documentation is None:\n            self._documentation = None\n        elif isinstance(event.documentation, SolcStructuredDocumentation):\n            self._documentation = StructuredDocumentation(\n                init, event.documentation, self\n            )\n        elif isinstance(event.documentation, str):\n            self._documentation = event.documentation\n        else:\n            raise TypeError(\n                f\"Unknown type of documentation: {type(event.documentation)}\"\n            )\n        self._event_selector = (\n            bytes.fromhex(event.event_selector) if event.event_selector else None\n        )\n        self._used_in = set()\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        yield from self._parameters\n        if isinstance(self._documentation, StructuredDocumentation):\n            yield from self._documentation\n\n    def _parse_name_location(self) -&gt; Tuple[int, int]:\n        IDENTIFIER = r\"[a-zA-Z$_][a-zA-Z0-9$_]*\"\n        EVENT_RE = re.compile(\n            r\"^\\s*event\\s+(?P&lt;name&gt;{identifier})\".format(identifier=IDENTIFIER).encode(\n                \"utf-8\"\n            )\n        )\n\n        source = bytearray(self._source)\n        _, stripped_sums = SoliditySourceParser.strip_comments(source)\n\n        byte_start = self._ast_node.src.byte_offset\n        match = EVENT_RE.match(source)\n        assert match\n\n        if len(stripped_sums) == 0:\n            stripped = 0\n        else:\n            index = bisect([s[0] for s in stripped_sums], match.start(\"name\"))\n            if index == 0:\n                stripped = 0\n            else:\n                stripped = stripped_sums[index - 1][1]\n\n        return (\n            byte_start + match.start(\"name\") + stripped,\n            byte_start + match.end(\"name\") + stripped,\n        )\n\n    @property\n    def parent(self) -&gt; Union[ContractDefinition, SourceUnit]:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def canonical_name(self) -&gt; str:\n        from .contract_definition import ContractDefinition\n\n        if isinstance(self._parent, ContractDefinition):\n            return f\"{self._parent.canonical_name}.{self._name}\"\n        return self._name\n\n    @property\n    @lru_cache(maxsize=2048)\n    def declaration_string(self) -&gt; str:\n        ret = (\n            f\"event {self._name}(\"\n            + \", \".join(\n                param.declaration_string for param in self.parameters.parameters\n            )\n            + f\"){' anonymous' if self.anonymous else ''}\"\n        )\n        if isinstance(self.documentation, StructuredDocumentation):\n            return (\n                \"/// \"\n                + \"\\n///\".join(line for line in self.documentation.text.splitlines())\n                + \"\\n\"\n                + ret\n            )\n        elif isinstance(self.documentation, str):\n            return (\n                \"/// \"\n                + \"\\n///\".join(line for line in self.documentation.splitlines())\n                + \"\\n\"\n                + ret\n            )\n        else:\n            return ret\n\n    @property\n    def anonymous(self) -&gt; bool:\n        \"\"\"\n        !!! example\n            ```solidity\n            event Transfer(address indexed from, address indexed to, uint256 value) anonymous;\n            ```\n\n        Returns:\n            `True` if the event is anonymous, `False` otherwise.\n        \"\"\"\n        return self._anonymous\n\n    @property\n    def parameters(self) -&gt; ParameterList:\n        \"\"\"\n        Returns:\n            Parameter list describing parameters of the event.\n        \"\"\"\n        return self._parameters\n\n    @property\n    def documentation(self) -&gt; Optional[Union[StructuredDocumentation, str]]:\n        \"\"\"\n        Of [StructuredDocumentation][wake.ir.meta.structured_documentation.StructuredDocumentation] type since Solidity 0.6.3.\n\n        Returns:\n            [NatSpec](https://docs.soliditylang.org/en/latest/natspec-format.html) documentation string, if any.\n        \"\"\"\n        return self._documentation\n\n    @property\n    @lru_cache(maxsize=2048)\n    def event_selector(self) -&gt; bytes:\n        \"\"\"\n        Returns:\n            Selector of the event.\n        \"\"\"\n        if self._event_selector is not None:\n            return self._event_selector\n        else:\n            signature = f\"{self._name}({','.join(param.type.abi_type for param in self.parameters.parameters)})\"\n            h = keccak.new(data=signature.encode(\"utf-8\"), digest_bits=256)\n            return h.digest()\n\n    @property\n    def used_in(self) -&gt; FrozenSet[ContractDefinition]:\n        \"\"\"\n        Returns:\n            Contracts (including child contracts) that emit this event, a contract that defines this event and contracts that inherit this event.\n        \"\"\"\n        return frozenset(self._used_in)\n\n    @property\n    def references(\n        self,\n    ) -&gt; FrozenSet[Union[Identifier, MemberAccess,]]:\n        \"\"\"\n        Returns:\n            Set of all IR nodes referencing this event.\n        \"\"\"\n        from ..expressions.identifier import Identifier\n        from ..expressions.member_access import MemberAccess\n\n        try:\n            ref = next(\n                ref\n                for ref in self._references\n                if not isinstance(ref, (Identifier, MemberAccess))\n            )\n            raise AssertionError(f\"Unexpected reference type: {ref}\")\n        except StopIteration:\n            return frozenset(\n                self._references\n            )  # pyright: ignore reportGeneralTypeIssues\n</code></pre>"},{"location":"api-reference/ir/declarations/event-definition/#wake.ir.declarations.event_definition.EventDefinition.anonymous","title":"<code>anonymous: bool</code>  <code>property</code>","text":"<p>Example</p> <pre><code>event Transfer(address indexed from, address indexed to, uint256 value) anonymous;\n</code></pre> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the event is anonymous, <code>False</code> otherwise.</p>"},{"location":"api-reference/ir/declarations/event-definition/#wake.ir.declarations.event_definition.EventDefinition.documentation","title":"<code>documentation: Optional[Union[StructuredDocumentation, str]]</code>  <code>property</code>","text":"<p>Of StructuredDocumentation type since Solidity 0.6.3.</p> <p>Returns:</p> Type Description <code>Optional[Union[StructuredDocumentation, str]]</code> <p>NatSpec documentation string, if any.</p>"},{"location":"api-reference/ir/declarations/event-definition/#wake.ir.declarations.event_definition.EventDefinition.event_selector","title":"<code>event_selector: bytes</code>  <code>cached</code> <code>property</code>","text":"<p>Returns:</p> Type Description <code>bytes</code> <p>Selector of the event.</p>"},{"location":"api-reference/ir/declarations/event-definition/#wake.ir.declarations.event_definition.EventDefinition.parameters","title":"<code>parameters: ParameterList</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>ParameterList</code> <p>Parameter list describing parameters of the event.</p>"},{"location":"api-reference/ir/declarations/event-definition/#wake.ir.declarations.event_definition.EventDefinition.parent","title":"<code>parent: Union[ContractDefinition, SourceUnit]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[ContractDefinition, SourceUnit]</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/declarations/event-definition/#wake.ir.declarations.event_definition.EventDefinition.references","title":"<code>references: FrozenSet[Union[Identifier, MemberAccess]]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>FrozenSet[Union[Identifier, MemberAccess]]</code> <p>Set of all IR nodes referencing this event.</p>"},{"location":"api-reference/ir/declarations/event-definition/#wake.ir.declarations.event_definition.EventDefinition.used_in","title":"<code>used_in: FrozenSet[ContractDefinition]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>FrozenSet[ContractDefinition]</code> <p>Contracts (including child contracts) that emit this event, a contract that defines this event and contracts that inherit this event.</p>"},{"location":"api-reference/ir/declarations/function-definition/","title":"function_definition","text":""},{"location":"api-reference/ir/declarations/function-definition/#wake.ir.declarations.function_definition","title":"<code>wake.ir.declarations.function_definition</code>  <code>module</code>","text":""},{"location":"api-reference/ir/declarations/function-definition/#wake.ir.declarations.function_definition.FunctionDefinition","title":"<code>FunctionDefinition</code>  <code>class</code>","text":"<p>         Bases: <code>DeclarationAbc</code></p> <p>Definition of a function.</p> <p>Example</p> <p>Free function (= outside of a contract): <pre><code>function f(uint a, uint b) pure returns (uint) {\n    return a + b;\n}\n</code></pre></p> <p>Function inside a contract (lines 2-4): <pre><code>contract C {\n    function f(uint a, uint b) public pure returns (uint) {\n        return a + b;\n    }\n}\n</code></pre></p> <p>Constructor (lines 3-5): <pre><code>contract C {\n    uint public x;\n    constructor(uint a) public {\n        x = a;\n    }\n}\n</code></pre></p> <p>Fallback function (line 2): <pre><code>contract C {\n    fallback() external payable {}\n}\n</code></pre></p> <p>Receive function (line 2): <pre><code>contract C {\n    receive() external payable {}\n}\n</code></pre></p> Source code in <code>wake/ir/declarations/function_definition.py</code> <pre><code>class FunctionDefinition(DeclarationAbc):\n    \"\"\"\n    Definition of a function.\n\n    !!! example\n        Free function (= outside of a contract):\n        ```solidity linenums=\"1\"\n        function f(uint a, uint b) pure returns (uint) {\n            return a + b;\n        }\n        ```\n\n        Function inside a contract (lines 2-4):\n        ```solidity linenums=\"1\"\n        contract C {\n            function f(uint a, uint b) public pure returns (uint) {\n                return a + b;\n            }\n        }\n        ```\n\n        Constructor (lines 3-5):\n        ```solidity linenums=\"1\"\n        contract C {\n            uint public x;\n            constructor(uint a) public {\n                x = a;\n            }\n        }\n        ```\n\n        Fallback function (line 2):\n        ```solidity linenums=\"1\"\n        contract C {\n            fallback() external payable {}\n        }\n        ```\n\n        Receive function (line 2):\n        ```solidity linenums=\"1\"\n        contract C {\n            receive() external payable {}\n        }\n        ```\n    \"\"\"\n\n    _ast_node: SolcFunctionDefinition\n    _parent: Union[ContractDefinition, SourceUnit]\n    _child_functions: Set[Union[FunctionDefinition, VariableDeclaration]]\n\n    _implemented: bool\n    _kind: FunctionKind\n    _modifiers: List[ModifierInvocation]\n    _parameters: ParameterList\n    _return_parameters: ParameterList\n    # __scope\n    _state_mutability: StateMutability\n    _virtual: bool\n    _visibility: Visibility\n    _base_functions: List[AstNodeId]\n    _documentation: Optional[Union[StructuredDocumentation, str]]\n    _function_selector: Optional[bytes]\n    _body: Optional[Block]\n    _overrides: Optional[OverrideSpecifier]\n\n    def __init__(\n        self, init: IrInitTuple, function: SolcFunctionDefinition, parent: SolidityAbc\n    ):\n        super().__init__(init, function, parent)\n        self._child_functions = set()\n\n        self._implemented = function.implemented\n        self._kind = function.kind\n\n        if self._kind == FunctionKind.CONSTRUCTOR:\n            self._name = \"constructor\"\n        elif self._kind == FunctionKind.FALLBACK:\n            self._name = \"fallback\"\n        elif self._kind == FunctionKind.RECEIVE:\n            self._name = \"receive\"\n\n        self._modifiers = [\n            ModifierInvocation(init, modifier, self) for modifier in function.modifiers\n        ]\n        self._parameters = ParameterList(init, function.parameters, self)\n        self._return_parameters = ParameterList(init, function.return_parameters, self)\n        # self.__scope = function.scope\n        self._state_mutability = function.state_mutability\n        self._virtual = function.virtual\n        self._visibility = function.visibility\n        self._base_functions = (\n            list(function.base_functions) if function.base_functions is not None else []\n        )\n        if function.documentation is None:\n            self._documentation = None\n        elif isinstance(function.documentation, SolcStructuredDocumentation):\n            self._documentation = StructuredDocumentation(\n                init, function.documentation, self\n            )\n        elif isinstance(function.documentation, str):\n            self._documentation = function.documentation\n        else:\n            raise TypeError(\n                f\"Unknown type of documentation: {type(function.documentation)}\"\n            )\n        self._function_selector = (\n            bytes.fromhex(function.function_selector)\n            if function.function_selector\n            else None\n        )\n\n        if (\n            self._visibility in {Visibility.PUBLIC, Visibility.EXTERNAL}\n            and self._kind == FunctionKind.FUNCTION\n        ):\n            assert self._function_selector is not None\n        else:\n            assert self._function_selector is None\n\n        self._body = Block(init, function.body, self) if function.body else None\n        assert (self._body is not None) == self._implemented\n        self._overrides = (\n            OverrideSpecifier(init, function.overrides, self)\n            if function.overrides\n            else None\n        )\n        self._reference_resolver.register_post_process_callback(self._post_process)\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        for modifier in self._modifiers:\n            yield from modifier\n        yield from self._parameters\n        yield from self._return_parameters\n        if isinstance(self._documentation, StructuredDocumentation):\n            yield from self._documentation\n        if self._body is not None:\n            yield from self._body\n        if self._overrides is not None:\n            yield from self._overrides\n\n    def _post_process(self, callback_params: CallbackParams):\n        base_functions = self.base_functions\n        for base_function in base_functions:\n            base_function._child_functions.add(self)\n        self._reference_resolver.register_destroy_callback(\n            self.source_unit.file, partial(self._destroy, base_functions)\n        )\n\n    def _destroy(self, base_functions: Tuple[FunctionDefinition, ...]) -&gt; None:\n        for base_function in base_functions:\n            base_function._child_functions.remove(self)\n\n    def _parse_name_location(self) -&gt; Tuple[int, int]:\n        IDENTIFIER = r\"[a-zA-Z$_][a-zA-Z0-9$_]*\"\n        FUNCTION_RE = re.compile(\n            r\"^\\s*function\\s+(?P&lt;name&gt;{identifier})\".format(\n                identifier=IDENTIFIER\n            ).encode(\"utf-8\")\n        )\n        CONSTRUCTOR_RE = re.compile(r\"^\\s*(?P&lt;name&gt;constructor)\".encode(\"utf-8\"))\n        FALLBACK_RE = re.compile(r\"^\\s*(?P&lt;name&gt;fallback)\".encode(\"utf-8\"))\n        RECEIVE_RE = re.compile(r\"^\\s*(?P&lt;name&gt;receive)\".encode(\"utf-8\"))\n\n        source = bytearray(self._source)\n        _, stripped_sums = SoliditySourceParser.strip_comments(source)\n\n        regexps = [FUNCTION_RE, CONSTRUCTOR_RE, FALLBACK_RE, RECEIVE_RE]\n        matches = [regexp.match(source) for regexp in regexps]\n        assert any(matches)\n\n        byte_start = self._ast_node.src.byte_offset\n        match = next(match for match in matches if match)\n\n        if len(stripped_sums) == 0:\n            stripped = 0\n        else:\n            index = bisect([s[0] for s in stripped_sums], match.start(\"name\"))\n            if index == 0:\n                stripped = 0\n            else:\n                stripped = stripped_sums[index - 1][1]\n\n        return (\n            byte_start + match.start(\"name\") + stripped,\n            byte_start + match.end(\"name\") + stripped,\n        )\n\n    def get_all_references(\n        self, include_declarations: bool\n    ) -&gt; Iterator[\n        Union[\n            DeclarationAbc,\n            Identifier,\n            IdentifierPathPart,\n            MemberAccess,\n            ExternalReference,\n            UnaryOperation,\n            BinaryOperation,\n        ]\n    ]:\n        from .variable_declaration import VariableDeclaration\n\n        processed_declarations: Set[Union[FunctionDefinition, VariableDeclaration]] = {\n            self\n        }\n        declarations_queue: Deque[\n            Union[FunctionDefinition, VariableDeclaration]\n        ] = deque([self])\n\n        while declarations_queue:\n            declaration = declarations_queue.pop()\n            if include_declarations:\n                yield declaration\n            yield from declaration.references\n\n            if isinstance(declaration, (FunctionDefinition, VariableDeclaration)):\n                for base_function in declaration.base_functions:\n                    if base_function not in processed_declarations:\n                        declarations_queue.append(base_function)\n                        processed_declarations.add(base_function)\n            if isinstance(declaration, FunctionDefinition):\n                for child_function in declaration.child_functions:\n                    if child_function not in processed_declarations:\n                        declarations_queue.append(child_function)\n                        processed_declarations.add(child_function)\n\n    @property\n    def parent(self) -&gt; Union[ContractDefinition, SourceUnit]:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    @lru_cache(maxsize=2048)\n    def canonical_name(self) -&gt; str:\n        from .contract_definition import ContractDefinition\n\n        if isinstance(self._parent, ContractDefinition):\n            return f\"{self._parent.canonical_name}.{self._name}({','.join(param.type_name.type_string for param in self._parameters.parameters)})\"\n        return f\"{self._name}({','.join(param.type_name.type_string for param in self._parameters.parameters)})\"\n\n    @property\n    @lru_cache(maxsize=2048)\n    def declaration_string(self) -&gt; str:\n        if self.kind == FunctionKind.CONSTRUCTOR:\n            ret = \"constructor\"\n        elif self.kind == FunctionKind.FALLBACK:\n            ret = \"fallback\"\n        elif self.kind == FunctionKind.RECEIVE:\n            ret = \"receive\"\n        else:\n            ret = f\"function {self.name}\"\n        ret += f\"({', '.join(parameter.declaration_string for parameter in self.parameters.parameters)})\"\n        ret += f\" {self.visibility}\"\n        ret += (\n            f\" {self.state_mutability}\"\n            if self.state_mutability != StateMutability.NONPAYABLE\n            else \"\"\n        )\n        ret += f\" virtual\" if self.virtual else \"\"\n        ret += (\n            (\n                f\" override\"\n                + (\n                    \"(\"\n                    + \", \".join(\n                        override.source for override in self.overrides.overrides\n                    )\n                    + \")\"\n                    if len(self.overrides.overrides) &gt; 0\n                    else \"\"\n                )\n            )\n            if self.overrides is not None\n            else \"\"\n        )\n        ret += (\n            (\" \" + \" \".join(modifier.source for modifier in self.modifiers))\n            if len(self.modifiers) &gt; 0\n            else \"\"\n        )\n        ret += (\n            \" returns (\"\n            + \", \".join(\n                parameter.declaration_string\n                for parameter in self.return_parameters.parameters\n            )\n            + \")\"\n            if len(self.return_parameters.parameters) &gt; 0\n            else \"\"\n        )\n\n        if isinstance(self.documentation, StructuredDocumentation):\n            return (\n                \"/// \"\n                + \"\\n///\".join(line for line in self.documentation.text.splitlines())\n                + \"\\n\"\n                + ret\n            )\n        elif isinstance(self.documentation, str):\n            return (\n                \"/// \"\n                + \"\\n///\".join(line for line in self.documentation.splitlines())\n                + \"\\n\"\n                + ret\n            )\n        else:\n            return ret\n\n    @property\n    def implemented(self) -&gt; bool:\n        \"\"\"\n        Returns:\n            `True` if the function [body][wake.ir.declarations.function_definition.FunctionDefinition.body] is not `None`, `False` otherwise.\n        \"\"\"\n        return self._implemented\n\n    @property\n    def kind(self) -&gt; FunctionKind:\n        \"\"\"\n        Returns:\n            Kind of the function.\n        \"\"\"\n        return self._kind\n\n    @property\n    def modifiers(self) -&gt; Tuple[ModifierInvocation, ...]:\n        \"\"\"\n        Also includes base constructor invocations.\n        !!! example\n            Both `:::solidity ERC20Token(\"My Token\", \"MTK\", msg.sender, 10 ** 18)` and `initializer` are listed by this property.\n            ```solidity\n            contract MyToken is ERC20Token {\n                constructor() ERC20Token(\"My Token\", \"MTK\", msg.sender, 10 ** 18) initializer {}\n            }\n            ```\n\n        Returns:\n            List of modifiers applied to the function.\n        \"\"\"\n        return tuple(self._modifiers)\n\n    @property\n    def parameters(self) -&gt; ParameterList:\n        \"\"\"\n        Returns:\n            Parameter list describing the function parameters.\n        \"\"\"\n        return self._parameters\n\n    @property\n    def return_parameters(self) -&gt; ParameterList:\n        \"\"\"\n        Returns:\n            Parameter list describing the function return parameters.\n        \"\"\"\n        return self._return_parameters\n\n    @property\n    def state_mutability(self) -&gt; StateMutability:\n        \"\"\"\n        Returns:\n            State mutability of the function.\n        \"\"\"\n        return self._state_mutability\n\n    @property\n    def virtual(self) -&gt; bool:\n        \"\"\"\n        Returns:\n            `True` if the function is virtual, `False` otherwise.\n        \"\"\"\n        return self._virtual\n\n    @property\n    def visibility(self) -&gt; Visibility:\n        \"\"\"\n        Returns:\n            Visibility of the function.\n        \"\"\"\n        return self._visibility\n\n    @property\n    def base_functions(self) -&gt; Tuple[FunctionDefinition, ...]:\n        \"\"\"\n        !!! example\n            `A.foo` on lines 6-8 lists `I.foo` on line 2 as a base function.\n\n            `B.foo` on lines 12-14 lists only `A.foo` on lines 6-8 as a base function.\n            ```solidity linenums=\"1\"\n            interface I {\n                function foo() external returns(uint);\n            }\n\n            contract A is I {\n                function foo() external pure virtual override returns(uint) {\n                    return 1;\n                }\n            }\n\n            contract B is A {\n                function foo() external pure override returns(uint) {\n                    return 2;\n                }\n            }\n            ```\n\n        !!! example\n            `A1.foo` on lines 6-8 lists `I.foo` on line 2 as a base function.\n\n            `A2.foo` on lines 12-14 lists `I.foo` on line 2 as a base function.\n\n            `B.foo` on lines 18-20 lists `A1.foo` on lines 6-8 and `A2.foo` on lines 12-14 as base functions.\n            ```solidity linenums=\"1\"\n            interface I {\n                function foo() external returns(uint);\n            }\n\n            contract A1 is I {\n                function foo() external pure virtual override returns(uint) {\n                    return 1;\n                }\n            }\n\n            contract A2 is I {\n                function foo() external pure virtual override returns(uint) {\n                    return 2;\n                }\n            }\n\n            contract B is A1, A2 {\n                function foo() external pure override(A1, A2) returns(uint) {\n                    return 3;\n                }\n            }\n            ```\n\n        Returns:\n            List of base functions overridden by this function.\n        \"\"\"\n        base_functions = []\n        for base_function_id in self._base_functions:\n            base_function = self._reference_resolver.resolve_node(\n                base_function_id, self.source_unit.cu_hash\n            )\n            assert isinstance(base_function, FunctionDefinition)\n            base_functions.append(base_function)\n        return tuple(base_functions)\n\n    @property\n    def child_functions(\n        self,\n    ) -&gt; FrozenSet[Union[FunctionDefinition, VariableDeclaration]]:\n        \"\"\"\n        Returns:\n            Functions that list this function in their [base_functions][wake.ir.declarations.function_definition.FunctionDefinition.base_functions] property.\n        \"\"\"\n        return frozenset(self._child_functions)\n\n    @property\n    def documentation(self) -&gt; Optional[Union[StructuredDocumentation, str]]:\n        \"\"\"\n        Of [StructuredDocumentation][wake.ir.meta.structured_documentation.StructuredDocumentation] type since Solidity 0.6.3.\n\n        Returns:\n            [NatSpec](https://solidity.readthedocs.io/en/latest/natspec-format.html) documentation string, if any.\n        \"\"\"\n        return self._documentation\n\n    @property\n    def function_selector(self) -&gt; Optional[bytes]:\n        \"\"\"\n        Is only set for [Visibility.PUBLIC][wake.ir.enums.Visibility.PUBLIC] and [Visibility.EXTERNAL][wake.ir.enums.Visibility.EXTERNAL] functions of the [FunctionKind.FUNCTION][wake.ir.enums.FunctionKind.FUNCTION] kind.\n\n        Returns:\n            Selector of the function.\n        \"\"\"\n        return self._function_selector\n\n    @property\n    def body(self) -&gt; Optional[Block]:\n        \"\"\"\n        Returns:\n            Body of the function, if any.\n        \"\"\"\n        return self._body\n\n    @property\n    def overrides(self) -&gt; Optional[OverrideSpecifier]:\n        \"\"\"\n        Returns override specifier as present in the source code.\n        !!! example\n            `I.foo` on line 2 does not have an override specifier.\n\n            `A.foo` on lines 6-8 has an override specifier with the [overrides][wake.ir.meta.override_specifier.OverrideSpecifier.overrides] property empty.\n\n            `B.foo` on lines 12-14 has an override specifier with the [overrides][wake.ir.meta.override_specifier.OverrideSpecifier.overrides] property containg one item referencing the contract `A` ([ContractDefinition][wake.ir.declarations.contract_definition.ContractDefinition]).\n            ```solidity linenums=\"1\"\n            interface I {\n                function foo() external returns(uint);\n            }\n\n            contract A is I {\n                function foo() external pure virtual override returns(uint) {\n                    return 1;\n                }\n            }\n\n            contract B is A {\n                function foo() external pure override(A) returns(uint) {\n                    return 2;\n                }\n            }\n            ```\n\n        Returns:\n            Override specifier, if any.\n        \"\"\"\n        return self._overrides\n\n    @property\n    @lru_cache(maxsize=128)\n    def cfg(self) -&gt; ControlFlowGraph:\n        \"\"\"\n        Raises:\n            ValueError: If the function is not implemented.\n\n        Returns:\n            Control flow graph of the function.\n        \"\"\"\n        from wake.analysis.cfg import ControlFlowGraph\n\n        if not self._implemented:\n            raise ValueError(\"Cannot create CFG for unimplemented function\")\n\n        return ControlFlowGraph(self)\n\n    @property\n    def references(\n        self,\n    ) -&gt; FrozenSet[\n        Union[\n            Identifier,\n            IdentifierPathPart,\n            MemberAccess,\n            UnaryOperation,\n            BinaryOperation,\n        ]\n    ]:\n        \"\"\"\n        Returns:\n            Set of all IR nodes referencing this function.\n        \"\"\"\n        from ..expressions.binary_operation import BinaryOperation\n        from ..expressions.identifier import Identifier\n        from ..expressions.member_access import MemberAccess\n        from ..expressions.unary_operation import UnaryOperation\n        from ..meta.identifier_path import IdentifierPathPart\n\n        try:\n            ref = next(\n                ref\n                for ref in self._references\n                if not isinstance(\n                    ref,\n                    (\n                        Identifier,\n                        IdentifierPathPart,\n                        MemberAccess,\n                        UnaryOperation,\n                        BinaryOperation,\n                    ),\n                )\n            )\n            raise AssertionError(f\"Unexpected reference type: {ref}\")\n        except StopIteration:\n            return frozenset(\n                self._references\n            )  # pyright: ignore reportGeneralTypeIssues\n</code></pre>"},{"location":"api-reference/ir/declarations/function-definition/#wake.ir.declarations.function_definition.FunctionDefinition.base_functions","title":"<code>base_functions: Tuple[FunctionDefinition, ...]</code>  <code>property</code>","text":"<p>Example</p> <p><code>A.foo</code> on lines 6-8 lists <code>I.foo</code> on line 2 as a base function.</p> <p><code>B.foo</code> on lines 12-14 lists only <code>A.foo</code> on lines 6-8 as a base function. <pre><code>interface I {\n    function foo() external returns(uint);\n}\n\ncontract A is I {\n    function foo() external pure virtual override returns(uint) {\n        return 1;\n    }\n}\n\ncontract B is A {\n    function foo() external pure override returns(uint) {\n        return 2;\n    }\n}\n</code></pre></p> <p>Example</p> <p><code>A1.foo</code> on lines 6-8 lists <code>I.foo</code> on line 2 as a base function.</p> <p><code>A2.foo</code> on lines 12-14 lists <code>I.foo</code> on line 2 as a base function.</p> <p><code>B.foo</code> on lines 18-20 lists <code>A1.foo</code> on lines 6-8 and <code>A2.foo</code> on lines 12-14 as base functions. <pre><code>interface I {\n    function foo() external returns(uint);\n}\n\ncontract A1 is I {\n    function foo() external pure virtual override returns(uint) {\n        return 1;\n    }\n}\n\ncontract A2 is I {\n    function foo() external pure virtual override returns(uint) {\n        return 2;\n    }\n}\n\ncontract B is A1, A2 {\n    function foo() external pure override(A1, A2) returns(uint) {\n        return 3;\n    }\n}\n</code></pre></p> <p>Returns:</p> Type Description <code>Tuple[FunctionDefinition, ...]</code> <p>List of base functions overridden by this function.</p>"},{"location":"api-reference/ir/declarations/function-definition/#wake.ir.declarations.function_definition.FunctionDefinition.body","title":"<code>body: Optional[Block]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Optional[Block]</code> <p>Body of the function, if any.</p>"},{"location":"api-reference/ir/declarations/function-definition/#wake.ir.declarations.function_definition.FunctionDefinition.cfg","title":"<code>cfg: ControlFlowGraph</code>  <code>cached</code> <code>property</code>","text":"<p>Raises:</p> Type Description <code>ValueError</code> <p>If the function is not implemented.</p> <p>Returns:</p> Type Description <code>ControlFlowGraph</code> <p>Control flow graph of the function.</p>"},{"location":"api-reference/ir/declarations/function-definition/#wake.ir.declarations.function_definition.FunctionDefinition.child_functions","title":"<code>child_functions: FrozenSet[Union[FunctionDefinition, VariableDeclaration]]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>FrozenSet[Union[FunctionDefinition, VariableDeclaration]]</code> <p>Functions that list this function in their base_functions property.</p>"},{"location":"api-reference/ir/declarations/function-definition/#wake.ir.declarations.function_definition.FunctionDefinition.documentation","title":"<code>documentation: Optional[Union[StructuredDocumentation, str]]</code>  <code>property</code>","text":"<p>Of StructuredDocumentation type since Solidity 0.6.3.</p> <p>Returns:</p> Type Description <code>Optional[Union[StructuredDocumentation, str]]</code> <p>NatSpec documentation string, if any.</p>"},{"location":"api-reference/ir/declarations/function-definition/#wake.ir.declarations.function_definition.FunctionDefinition.function_selector","title":"<code>function_selector: Optional[bytes]</code>  <code>property</code>","text":"<p>Is only set for Visibility.PUBLIC and Visibility.EXTERNAL functions of the FunctionKind.FUNCTION kind.</p> <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Selector of the function.</p>"},{"location":"api-reference/ir/declarations/function-definition/#wake.ir.declarations.function_definition.FunctionDefinition.implemented","title":"<code>implemented: bool</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the function body is not <code>None</code>, <code>False</code> otherwise.</p>"},{"location":"api-reference/ir/declarations/function-definition/#wake.ir.declarations.function_definition.FunctionDefinition.kind","title":"<code>kind: FunctionKind</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>FunctionKind</code> <p>Kind of the function.</p>"},{"location":"api-reference/ir/declarations/function-definition/#wake.ir.declarations.function_definition.FunctionDefinition.modifiers","title":"<code>modifiers: Tuple[ModifierInvocation, ...]</code>  <code>property</code>","text":"<p>Also includes base constructor invocations.</p> <p>Example</p> <p>Both <code>ERC20Token(\"My Token\", \"MTK\", msg.sender, 10 ** 18)</code> and <code>initializer</code> are listed by this property. <pre><code>contract MyToken is ERC20Token {\n    constructor() ERC20Token(\"My Token\", \"MTK\", msg.sender, 10 ** 18) initializer {}\n}\n</code></pre></p> <p>Returns:</p> Type Description <code>Tuple[ModifierInvocation, ...]</code> <p>List of modifiers applied to the function.</p>"},{"location":"api-reference/ir/declarations/function-definition/#wake.ir.declarations.function_definition.FunctionDefinition.overrides","title":"<code>overrides: Optional[OverrideSpecifier]</code>  <code>property</code>","text":"<p>Returns override specifier as present in the source code.</p> <p>Example</p> <p><code>I.foo</code> on line 2 does not have an override specifier.</p> <p><code>A.foo</code> on lines 6-8 has an override specifier with the overrides property empty.</p> <p><code>B.foo</code> on lines 12-14 has an override specifier with the overrides property containg one item referencing the contract <code>A</code> (ContractDefinition). <pre><code>interface I {\n    function foo() external returns(uint);\n}\n\ncontract A is I {\n    function foo() external pure virtual override returns(uint) {\n        return 1;\n    }\n}\n\ncontract B is A {\n    function foo() external pure override(A) returns(uint) {\n        return 2;\n    }\n}\n</code></pre></p> <p>Returns:</p> Type Description <code>Optional[OverrideSpecifier]</code> <p>Override specifier, if any.</p>"},{"location":"api-reference/ir/declarations/function-definition/#wake.ir.declarations.function_definition.FunctionDefinition.parameters","title":"<code>parameters: ParameterList</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>ParameterList</code> <p>Parameter list describing the function parameters.</p>"},{"location":"api-reference/ir/declarations/function-definition/#wake.ir.declarations.function_definition.FunctionDefinition.parent","title":"<code>parent: Union[ContractDefinition, SourceUnit]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[ContractDefinition, SourceUnit]</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/declarations/function-definition/#wake.ir.declarations.function_definition.FunctionDefinition.references","title":"<code>references: FrozenSet[Union[Identifier, IdentifierPathPart, MemberAccess, UnaryOperation, BinaryOperation]]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>FrozenSet[Union[Identifier, IdentifierPathPart, MemberAccess, UnaryOperation, BinaryOperation]]</code> <p>Set of all IR nodes referencing this function.</p>"},{"location":"api-reference/ir/declarations/function-definition/#wake.ir.declarations.function_definition.FunctionDefinition.return_parameters","title":"<code>return_parameters: ParameterList</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>ParameterList</code> <p>Parameter list describing the function return parameters.</p>"},{"location":"api-reference/ir/declarations/function-definition/#wake.ir.declarations.function_definition.FunctionDefinition.state_mutability","title":"<code>state_mutability: StateMutability</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>StateMutability</code> <p>State mutability of the function.</p>"},{"location":"api-reference/ir/declarations/function-definition/#wake.ir.declarations.function_definition.FunctionDefinition.virtual","title":"<code>virtual: bool</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the function is virtual, <code>False</code> otherwise.</p>"},{"location":"api-reference/ir/declarations/function-definition/#wake.ir.declarations.function_definition.FunctionDefinition.visibility","title":"<code>visibility: Visibility</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Visibility</code> <p>Visibility of the function.</p>"},{"location":"api-reference/ir/declarations/modifier-definition/","title":"modifier_definition","text":""},{"location":"api-reference/ir/declarations/modifier-definition/#wake.ir.declarations.modifier_definition","title":"<code>wake.ir.declarations.modifier_definition</code>  <code>module</code>","text":""},{"location":"api-reference/ir/declarations/modifier-definition/#wake.ir.declarations.modifier_definition.ModifierDefinition","title":"<code>ModifierDefinition</code>  <code>class</code>","text":"<p>         Bases: <code>DeclarationAbc</code></p> <p>Definition of a modifier.</p> <p>Example</p> <pre><code>modifier onlyOwner {\n    require(msg.sender == owner);\n    _;\n}\n</code></pre> Source code in <code>wake/ir/declarations/modifier_definition.py</code> <pre><code>class ModifierDefinition(DeclarationAbc):\n    \"\"\"\n    Definition of a modifier.\n\n    !!! example\n        ```solidity\n        modifier onlyOwner {\n            require(msg.sender == owner);\n            _;\n        }\n        ```\n    \"\"\"\n\n    _ast_node: SolcModifierDefinition\n    _parent: ContractDefinition\n    _child_modifiers: Set[ModifierDefinition]\n\n    _body: Optional[Block]\n    _implemented: bool\n    _parameters: ParameterList\n    _virtual: bool\n    _visibility: Visibility\n    _base_modifiers: List[AstNodeId]\n    _documentation: Optional[Union[StructuredDocumentation, str]]\n    _overrides: Optional[OverrideSpecifier]\n\n    def __init__(\n        self, init: IrInitTuple, modifier: SolcModifierDefinition, parent: SolidityAbc\n    ):\n        super().__init__(init, modifier, parent)\n        self._child_modifiers = set()\n\n        self._body = Block(init, modifier.body, self) if modifier.body else None\n        self._implemented = self._body is not None\n        self._parameters = ParameterList(init, modifier.parameters, self)\n        self._virtual = modifier.virtual\n        self._visibility = modifier.visibility\n        self._base_modifiers = (\n            list(modifier.base_modifiers) if modifier.base_modifiers is not None else []\n        )\n        if modifier.documentation is None:\n            self._documentation = None\n        elif isinstance(modifier.documentation, SolcStructuredDocumentation):\n            self._documentation = StructuredDocumentation(\n                init, modifier.documentation, self\n            )\n        elif isinstance(modifier.documentation, str):\n            self._documentation = modifier.documentation\n        else:\n            raise TypeError(\n                f\"Unknown type of documentation: {type(modifier.documentation)}\"\n            )\n        self._overrides = (\n            OverrideSpecifier(init, modifier.overrides, self)\n            if modifier.overrides is not None\n            else None\n        )\n        self._reference_resolver.register_post_process_callback(self._post_process)\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        if self._body is not None:\n            yield from self._body\n        yield from self._parameters\n        if isinstance(self._documentation, StructuredDocumentation):\n            yield from self._documentation\n        if self._overrides is not None:\n            yield from self._overrides\n\n    def _post_process(self, callback_params: CallbackParams):\n        base_modifiers = self.base_modifiers\n        for base_modifier in base_modifiers:\n            base_modifier._child_modifiers.add(self)\n        self._reference_resolver.register_destroy_callback(\n            self.source_unit.file, partial(self._destroy, base_modifiers)\n        )\n\n    def _destroy(self, base_modifiers: Tuple[ModifierDefinition, ...]) -&gt; None:\n        for base_modifier in base_modifiers:\n            base_modifier._child_modifiers.remove(self)\n\n    def _parse_name_location(self) -&gt; Tuple[int, int]:\n        IDENTIFIER = r\"[a-zA-Z$_][a-zA-Z0-9$_]*\"\n        MODIFIER_RE = re.compile(\n            r\"^\\s*modifier\\s+(?P&lt;name&gt;{identifier})\".format(\n                identifier=IDENTIFIER\n            ).encode(\"utf-8\")\n        )\n\n        source = bytearray(self._source)\n        _, stripped_sums = SoliditySourceParser.strip_comments(source)\n\n        byte_start = self._ast_node.src.byte_offset\n        match = MODIFIER_RE.match(source)\n        assert match\n\n        if len(stripped_sums) == 0:\n            stripped = 0\n        else:\n            index = bisect([s[0] for s in stripped_sums], match.start(\"name\"))\n            if index == 0:\n                stripped = 0\n            else:\n                stripped = stripped_sums[index - 1][1]\n\n        return (\n            byte_start + match.start(\"name\") + stripped,\n            byte_start + match.end(\"name\") + stripped,\n        )\n\n    def get_all_references(\n        self, include_declarations: bool\n    ) -&gt; Iterator[\n        Union[\n            DeclarationAbc,\n            Identifier,\n            IdentifierPathPart,\n            MemberAccess,\n            ExternalReference,\n            UnaryOperation,\n            BinaryOperation,\n        ]\n    ]:\n        processed_declarations: Set[ModifierDefinition] = {self}\n        declarations_queue: Deque[ModifierDefinition] = deque([self])\n\n        while declarations_queue:\n            declaration = declarations_queue.pop()\n            if include_declarations:\n                yield declaration\n            yield from declaration.references\n\n            for base_modifier in declaration.base_modifiers:\n                if base_modifier not in processed_declarations:\n                    declarations_queue.append(base_modifier)\n                    processed_declarations.add(base_modifier)\n            for child_modifier in declaration.child_modifiers:\n                if child_modifier not in processed_declarations:\n                    declarations_queue.append(child_modifier)\n                    processed_declarations.add(child_modifier)\n\n    @property\n    def parent(self) -&gt; ContractDefinition:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def canonical_name(self) -&gt; str:\n        return f\"{self._parent.canonical_name}.{self._name}\"\n\n    @property\n    @lru_cache(maxsize=2048)\n    def declaration_string(self) -&gt; str:\n        ret = f\"modifier {self._name}\"\n        ret += (\n            f\"({', '.join(param.declaration_string for param in self.parameters.parameters)})\"\n            if len(self.parameters.parameters) &gt; 0\n            else \"\"\n        )\n        ret += \" virtual\" if self.virtual else \"\"\n        ret += (\n            (\n                f\" override\"\n                + (\n                    \"(\"\n                    + \", \".join(\n                        override.source for override in self.overrides.overrides\n                    )\n                    + \")\"\n                    if len(self.overrides.overrides) &gt; 0\n                    else \"\"\n                )\n            )\n            if self.overrides is not None\n            else \"\"\n        )\n\n        if isinstance(self.documentation, StructuredDocumentation):\n            return (\n                \"/// \"\n                + \"\\n///\".join(line for line in self.documentation.text.splitlines())\n                + \"\\n\"\n                + ret\n            )\n        elif isinstance(self.documentation, str):\n            return (\n                \"/// \"\n                + \"\\n///\".join(line for line in self.documentation.splitlines())\n                + \"\\n\"\n                + ret\n            )\n        else:\n            return ret\n\n    @property\n    def body(self) -&gt; Optional[Block]:\n        \"\"\"\n        Returns:\n            Body of the modifier, if any.\n        \"\"\"\n        return self._body\n\n    @property\n    def implemented(self) -&gt; bool:\n        \"\"\"\n        Returns:\n            `True` if the modifier [body][wake.ir.declarations.modifier_definition.ModifierDefinition.body] is not `None`, `False` otherwise.\n        \"\"\"\n        return self._implemented\n\n    @property\n    def parameters(self) -&gt; ParameterList:\n        \"\"\"\n        Returns:\n            Parameter list describing the modifier parameters.\n        \"\"\"\n        return self._parameters\n\n    @property\n    def virtual(self) -&gt; bool:\n        \"\"\"\n        Returns:\n            `True` if the modifier is virtual, `False` otherwise.\n        \"\"\"\n        return self._virtual\n\n    @property\n    def visibility(self) -&gt; Visibility:\n        \"\"\"\n        Returns:\n            Visibility of the modifier.\n        \"\"\"\n        return self._visibility\n\n    @property\n    def base_modifiers(self) -&gt; Tuple[ModifierDefinition, ...]:\n        \"\"\"\n        !!! example\n            `B.mod` on lines 6-8 lists `A.mod` on line 2 as a base modifier.\n\n            `C.mod` on lines 12-14 lists only `B.mod` on lines 6-8 as a base modifier.\n            ```solidity linenums=\"1\"\n            abstract contract A {\n                modifier mod virtual;\n            }\n\n            contract B is A {\n                modifier mod virtual override {\n                    _;\n                }\n            }\n\n            contract C is B {\n                modifier mod override {\n                    _;\n                }\n            }\n            ```\n\n        !!! example\n            `B1.mod` on lines 6-8 lists `A.mod` on line 2 as a base modifier.\n\n            `B2.mod` on lines 12-14 lists `A.mod` on line 2 as a base modifier.\n\n            `C.mod` on lines 18-20 lists `B1.mod` on lines 6-8 and `B2.mod` on lines 12-14 as base modifiers.\n            ```solidity linenums=\"1\"\n            abstract contract A {\n                modifier mod virtual;\n            }\n\n            contract B1 is A {\n                modifier mod virtual override {\n                    _;\n                }\n            }\n\n            contract B2 is A {\n                modifier mod virtual override {\n                    _;\n                }\n            }\n\n            contract C is B1, B2 {\n                modifier mod override(B1, B2) {\n                    _;\n                }\n            }\n            ```\n\n        Returns:\n            List of base modifiers overridden by this modifier.\n        \"\"\"\n        base_modifiers = []\n        for base_modifier_id in self._base_modifiers:\n            base_modifier = self._reference_resolver.resolve_node(\n                base_modifier_id, self.source_unit.cu_hash\n            )\n            assert isinstance(base_modifier, ModifierDefinition)\n            base_modifiers.append(base_modifier)\n        return tuple(base_modifiers)\n\n    @property\n    def child_modifiers(self) -&gt; FrozenSet[ModifierDefinition]:\n        \"\"\"\n        Returns:\n            Modifiers that list this modifier in their [base_modifiers][wake.ir.declarations.modifier_definition.ModifierDefinition.base_modifiers] property.\n        \"\"\"\n        return frozenset(self._child_modifiers)\n\n    @property\n    def documentation(self) -&gt; Optional[Union[StructuredDocumentation, str]]:\n        \"\"\"\n        Of [StructuredDocumentation][wake.ir.meta.structured_documentation.StructuredDocumentation] type since Solidity 0.6.3.\n\n        Returns:\n            [NatSpec](https://docs.soliditylang.org/en/latest/natspec-format.html) documentation string, if any.\n        \"\"\"\n        return self._documentation\n\n    @property\n    def overrides(self) -&gt; Optional[OverrideSpecifier]:\n        \"\"\"\n        Returns override specifier as present in the source code.\n        !!! example\n            `A.mod` on line 2 does not have an override specifier.\n\n            `B1.mod` on lines 6-8 has an override specifier with the [overrides][wake.ir.meta.override_specifier.OverrideSpecifier.overrides] property empty.\n\n            `B2.mod` on lines 12-14 has an override specifier with the [overrides][wake.ir.meta.override_specifier.OverrideSpecifier.overrides] property empty.\n\n            `C.mod` on lines 18-20 has an override specifier with the [overrides][wake.ir.meta.override_specifier.OverrideSpecifier.overrides] property containg two items referencing the contracts `B1` and `B2` ([ContractDefinition][wake.ir.declarations.contract_definition.ContractDefinition]).\n            ```solidity linenums=\"1\"\n            abstract contract A {\n                modifier mod virtual;\n            }\n\n            contract B1 is A {\n                modifier mod virtual override {\n                    _;\n                }\n            }\n\n            contract B2 is A {\n                modifier mod virtual override {\n                    _;\n                }\n            }\n\n            contract C is B1, B2 {\n                modifier mod override(B1, B2) {\n                    _;\n                }\n            }\n            ```\n\n        Returns:\n            Override specifier, if any.\n        \"\"\"\n        return self._overrides\n\n    @property\n    @lru_cache(maxsize=128)\n    def cfg(self) -&gt; ControlFlowGraph:\n        \"\"\"\n        Raises:\n            ValueError: If the modifier is not implemented.\n\n        Returns:\n            Control flow graph of the modifier.\n        \"\"\"\n        from wake.analysis.cfg import ControlFlowGraph\n\n        if not self._implemented:\n            raise ValueError(\"Cannot create CFG for unimplemented modifier\")\n\n        return ControlFlowGraph(self)\n\n    @property\n    def references(\n        self,\n    ) -&gt; FrozenSet[Union[Identifier, IdentifierPathPart]]:\n        \"\"\"\n        Until Solidity 0.8.0, modifiers were referenced in [ModifierInvocations][wake.ir.meta.modifier_invocation.ModifierInvocation]\n        using [Identifiers][wake.ir.expressions.identifier.Identifier]. Version 0.8.0 started using [IdentifierPaths][wake.ir.meta.identifier_path.IdentifierPath] instead.\n\n        Returns:\n            Set of all IR nodes referencing this modifier.\n        \"\"\"\n        from ..expressions.identifier import Identifier\n        from ..meta.identifier_path import IdentifierPathPart\n\n        try:\n            ref = next(\n                ref\n                for ref in self._references\n                if not isinstance(ref, (Identifier, IdentifierPathPart))\n            )\n            raise AssertionError(f\"Unexpected reference type: {ref}\")\n        except StopIteration:\n            return frozenset(\n                self._references\n            )  # pyright: ignore reportGeneralTypeIssues\n</code></pre>"},{"location":"api-reference/ir/declarations/modifier-definition/#wake.ir.declarations.modifier_definition.ModifierDefinition.base_modifiers","title":"<code>base_modifiers: Tuple[ModifierDefinition, ...]</code>  <code>property</code>","text":"<p>Example</p> <p><code>B.mod</code> on lines 6-8 lists <code>A.mod</code> on line 2 as a base modifier.</p> <p><code>C.mod</code> on lines 12-14 lists only <code>B.mod</code> on lines 6-8 as a base modifier. <pre><code>abstract contract A {\n    modifier mod virtual;\n}\n\ncontract B is A {\n    modifier mod virtual override {\n        _;\n    }\n}\n\ncontract C is B {\n    modifier mod override {\n        _;\n    }\n}\n</code></pre></p> <p>Example</p> <p><code>B1.mod</code> on lines 6-8 lists <code>A.mod</code> on line 2 as a base modifier.</p> <p><code>B2.mod</code> on lines 12-14 lists <code>A.mod</code> on line 2 as a base modifier.</p> <p><code>C.mod</code> on lines 18-20 lists <code>B1.mod</code> on lines 6-8 and <code>B2.mod</code> on lines 12-14 as base modifiers. <pre><code>abstract contract A {\n    modifier mod virtual;\n}\n\ncontract B1 is A {\n    modifier mod virtual override {\n        _;\n    }\n}\n\ncontract B2 is A {\n    modifier mod virtual override {\n        _;\n    }\n}\n\ncontract C is B1, B2 {\n    modifier mod override(B1, B2) {\n        _;\n    }\n}\n</code></pre></p> <p>Returns:</p> Type Description <code>Tuple[ModifierDefinition, ...]</code> <p>List of base modifiers overridden by this modifier.</p>"},{"location":"api-reference/ir/declarations/modifier-definition/#wake.ir.declarations.modifier_definition.ModifierDefinition.body","title":"<code>body: Optional[Block]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Optional[Block]</code> <p>Body of the modifier, if any.</p>"},{"location":"api-reference/ir/declarations/modifier-definition/#wake.ir.declarations.modifier_definition.ModifierDefinition.cfg","title":"<code>cfg: ControlFlowGraph</code>  <code>cached</code> <code>property</code>","text":"<p>Raises:</p> Type Description <code>ValueError</code> <p>If the modifier is not implemented.</p> <p>Returns:</p> Type Description <code>ControlFlowGraph</code> <p>Control flow graph of the modifier.</p>"},{"location":"api-reference/ir/declarations/modifier-definition/#wake.ir.declarations.modifier_definition.ModifierDefinition.child_modifiers","title":"<code>child_modifiers: FrozenSet[ModifierDefinition]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>FrozenSet[ModifierDefinition]</code> <p>Modifiers that list this modifier in their base_modifiers property.</p>"},{"location":"api-reference/ir/declarations/modifier-definition/#wake.ir.declarations.modifier_definition.ModifierDefinition.documentation","title":"<code>documentation: Optional[Union[StructuredDocumentation, str]]</code>  <code>property</code>","text":"<p>Of StructuredDocumentation type since Solidity 0.6.3.</p> <p>Returns:</p> Type Description <code>Optional[Union[StructuredDocumentation, str]]</code> <p>NatSpec documentation string, if any.</p>"},{"location":"api-reference/ir/declarations/modifier-definition/#wake.ir.declarations.modifier_definition.ModifierDefinition.implemented","title":"<code>implemented: bool</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the modifier body is not <code>None</code>, <code>False</code> otherwise.</p>"},{"location":"api-reference/ir/declarations/modifier-definition/#wake.ir.declarations.modifier_definition.ModifierDefinition.overrides","title":"<code>overrides: Optional[OverrideSpecifier]</code>  <code>property</code>","text":"<p>Returns override specifier as present in the source code.</p> <p>Example</p> <p><code>A.mod</code> on line 2 does not have an override specifier.</p> <p><code>B1.mod</code> on lines 6-8 has an override specifier with the overrides property empty.</p> <p><code>B2.mod</code> on lines 12-14 has an override specifier with the overrides property empty.</p> <p><code>C.mod</code> on lines 18-20 has an override specifier with the overrides property containg two items referencing the contracts <code>B1</code> and <code>B2</code> (ContractDefinition). <pre><code>abstract contract A {\n    modifier mod virtual;\n}\n\ncontract B1 is A {\n    modifier mod virtual override {\n        _;\n    }\n}\n\ncontract B2 is A {\n    modifier mod virtual override {\n        _;\n    }\n}\n\ncontract C is B1, B2 {\n    modifier mod override(B1, B2) {\n        _;\n    }\n}\n</code></pre></p> <p>Returns:</p> Type Description <code>Optional[OverrideSpecifier]</code> <p>Override specifier, if any.</p>"},{"location":"api-reference/ir/declarations/modifier-definition/#wake.ir.declarations.modifier_definition.ModifierDefinition.parameters","title":"<code>parameters: ParameterList</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>ParameterList</code> <p>Parameter list describing the modifier parameters.</p>"},{"location":"api-reference/ir/declarations/modifier-definition/#wake.ir.declarations.modifier_definition.ModifierDefinition.parent","title":"<code>parent: ContractDefinition</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>ContractDefinition</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/declarations/modifier-definition/#wake.ir.declarations.modifier_definition.ModifierDefinition.references","title":"<code>references: FrozenSet[Union[Identifier, IdentifierPathPart]]</code>  <code>property</code>","text":"<p>Until Solidity 0.8.0, modifiers were referenced in ModifierInvocations using Identifiers. Version 0.8.0 started using IdentifierPaths instead.</p> <p>Returns:</p> Type Description <code>FrozenSet[Union[Identifier, IdentifierPathPart]]</code> <p>Set of all IR nodes referencing this modifier.</p>"},{"location":"api-reference/ir/declarations/modifier-definition/#wake.ir.declarations.modifier_definition.ModifierDefinition.virtual","title":"<code>virtual: bool</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the modifier is virtual, <code>False</code> otherwise.</p>"},{"location":"api-reference/ir/declarations/modifier-definition/#wake.ir.declarations.modifier_definition.ModifierDefinition.visibility","title":"<code>visibility: Visibility</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Visibility</code> <p>Visibility of the modifier.</p>"},{"location":"api-reference/ir/declarations/struct-definition/","title":"struct_definition","text":""},{"location":"api-reference/ir/declarations/struct-definition/#wake.ir.declarations.struct_definition","title":"<code>wake.ir.declarations.struct_definition</code>  <code>module</code>","text":""},{"location":"api-reference/ir/declarations/struct-definition/#wake.ir.declarations.struct_definition.StructDefinition","title":"<code>StructDefinition</code>  <code>class</code>","text":"<p>         Bases: <code>DeclarationAbc</code></p> <p>Definition of a struct.</p> <p>Example</p> <pre><code>struct S {\n    uint a;\n    uint b;\n}\n</code></pre> Source code in <code>wake/ir/declarations/struct_definition.py</code> <pre><code>class StructDefinition(DeclarationAbc):\n    \"\"\"\n    Definition of a struct.\n\n    !!! example\n        ```solidity\n        struct S {\n            uint a;\n            uint b;\n        }\n        ```\n    \"\"\"\n\n    _ast_node: SolcStructDefinition\n    _parent: Union[ContractDefinition, SourceUnit]\n\n    _canonical_name: str\n    _members: List[VariableDeclaration]\n    _visibility: Visibility\n    _documentation: Optional[StructuredDocumentation]\n\n    def __init__(\n        self,\n        init: IrInitTuple,\n        struct_definition: SolcStructDefinition,\n        parent: SolidityAbc,\n    ):\n        super().__init__(init, struct_definition, parent)\n        self._canonical_name = struct_definition.canonical_name\n        # TODO scope\n        self._visibility = struct_definition.visibility\n\n        self._members = []\n        for member in struct_definition.members:\n            self._members.append(VariableDeclaration(init, member, self))\n        self._documentation = (\n            StructuredDocumentation(init, struct_definition.documentation, self)\n            if struct_definition.documentation is not None\n            else None\n        )\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        for member in self._members:\n            yield from member\n\n    def _parse_name_location(self) -&gt; Tuple[int, int]:\n        IDENTIFIER = r\"[a-zA-Z$_][a-zA-Z0-9$_]*\"\n        STRUCT_RE = re.compile(\n            r\"^\\s*struct\\s+(?P&lt;name&gt;{identifier})\".format(identifier=IDENTIFIER).encode(\n                \"utf-8\"\n            )\n        )\n\n        source = bytearray(self._source)\n        _, stripped_sums = SoliditySourceParser.strip_comments(source)\n\n        byte_start = self._ast_node.src.byte_offset\n        match = STRUCT_RE.match(source)\n        assert match\n\n        if len(stripped_sums) == 0:\n            stripped = 0\n        else:\n            index = bisect([s[0] for s in stripped_sums], match.start(\"name\"))\n            if index == 0:\n                stripped = 0\n            else:\n                stripped = stripped_sums[index - 1][1]\n\n        return (\n            byte_start + match.start(\"name\") + stripped,\n            byte_start + match.end(\"name\") + stripped,\n        )\n\n    @property\n    def parent(self) -&gt; Union[ContractDefinition, SourceUnit]:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def canonical_name(self) -&gt; str:\n        return self._canonical_name\n\n    @property\n    @lru_cache(maxsize=2048)\n    def declaration_string(self) -&gt; str:\n        return (\n            f\"struct {self.name}\"\n            + \" {\\n\"\n            + \";\\n\".join(f\"    {member.declaration_string}\" for member in self._members)\n            + \";\\n}\"\n        )\n\n    @property\n    def members(self) -&gt; Tuple[VariableDeclaration, ...]:\n        \"\"\"\n        Returns:\n            Tuple of member variable declarations.\n        \"\"\"\n        return tuple(self._members)\n\n    @property\n    def documentation(self) -&gt; Optional[StructuredDocumentation]:\n        \"\"\"\n        Added in Solidity 0.8.20.\n\n        Returns:\n            [NatSpec](https://docs.soliditylang.org/en/latest/natspec-format.html) documentation string, if any.\n        \"\"\"\n        return self._documentation\n\n    @property\n    def references(\n        self,\n    ) -&gt; FrozenSet[Union[Identifier, IdentifierPathPart, MemberAccess,]]:\n        \"\"\"\n        Returns:\n            Set of all IR nodes referencing this struct.\n        \"\"\"\n        from ..expressions.identifier import Identifier\n        from ..expressions.member_access import MemberAccess\n        from ..meta.identifier_path import IdentifierPathPart\n\n        try:\n            ref = next(\n                ref\n                for ref in self._references\n                if not isinstance(ref, (Identifier, IdentifierPathPart, MemberAccess))\n            )\n            raise AssertionError(f\"Unexpected reference type: {ref}\")\n        except StopIteration:\n            return frozenset(\n                self._references\n            )  # pyright: ignore reportGeneralTypeIssues\n</code></pre>"},{"location":"api-reference/ir/declarations/struct-definition/#wake.ir.declarations.struct_definition.StructDefinition.documentation","title":"<code>documentation: Optional[StructuredDocumentation]</code>  <code>property</code>","text":"<p>Added in Solidity 0.8.20.</p> <p>Returns:</p> Type Description <code>Optional[StructuredDocumentation]</code> <p>NatSpec documentation string, if any.</p>"},{"location":"api-reference/ir/declarations/struct-definition/#wake.ir.declarations.struct_definition.StructDefinition.members","title":"<code>members: Tuple[VariableDeclaration, ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[VariableDeclaration, ...]</code> <p>Tuple of member variable declarations.</p>"},{"location":"api-reference/ir/declarations/struct-definition/#wake.ir.declarations.struct_definition.StructDefinition.parent","title":"<code>parent: Union[ContractDefinition, SourceUnit]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[ContractDefinition, SourceUnit]</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/declarations/struct-definition/#wake.ir.declarations.struct_definition.StructDefinition.references","title":"<code>references: FrozenSet[Union[Identifier, IdentifierPathPart, MemberAccess]]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>FrozenSet[Union[Identifier, IdentifierPathPart, MemberAccess]]</code> <p>Set of all IR nodes referencing this struct.</p>"},{"location":"api-reference/ir/declarations/user-defined-value-type-definition/","title":"user_defined_value_type_definition","text":""},{"location":"api-reference/ir/declarations/user-defined-value-type-definition/#wake.ir.declarations.user_defined_value_type_definition","title":"<code>wake.ir.declarations.user_defined_value_type_definition</code>  <code>module</code>","text":""},{"location":"api-reference/ir/declarations/user-defined-value-type-definition/#wake.ir.declarations.user_defined_value_type_definition.UserDefinedValueTypeDefinition","title":"<code>UserDefinedValueTypeDefinition</code>  <code>class</code>","text":"<p>         Bases: <code>DeclarationAbc</code></p> <p>Definition of a user defined value type.</p> <p>Example</p> <pre><code>type MyInt is uint;\n</code></pre> Source code in <code>wake/ir/declarations/user_defined_value_type_definition.py</code> <pre><code>class UserDefinedValueTypeDefinition(DeclarationAbc):\n    \"\"\"\n    Definition of a user defined value type.\n\n    !!! example\n        ```solidity\n        type MyInt is uint;\n        ```\n    \"\"\"\n\n    _ast_node: SolcUserDefinedValueTypeDefinition\n    _parent: Union[ContractDefinition, SourceUnit]\n\n    _underlying_type: ElementaryTypeName\n\n    def __init__(\n        self,\n        init: IrInitTuple,\n        user_defined_value_type_definition: SolcUserDefinedValueTypeDefinition,\n        parent: SolidityAbc,\n    ):\n        super().__init__(init, user_defined_value_type_definition, parent)\n        self._underlying_type = ElementaryTypeName(\n            init, user_defined_value_type_definition.underlying_type, self\n        )\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        yield from self._underlying_type\n\n    def _parse_name_location(self) -&gt; Tuple[int, int]:\n        IDENTIFIER = r\"[a-zA-Z$_][a-zA-Z0-9$_]*\"\n        USER_DEF_VAL_TYPE_RE = re.compile(\n            r\"^\\s*type\\s+(?P&lt;name&gt;{identifier})\".format(identifier=IDENTIFIER).encode(\n                \"utf-8\"\n            )\n        )\n\n        source = bytearray(self._source)\n        _, stripped_sums = SoliditySourceParser.strip_comments(source)\n\n        byte_start = self._ast_node.src.byte_offset\n        match = USER_DEF_VAL_TYPE_RE.match(source)\n        assert match\n\n        if len(stripped_sums) == 0:\n            stripped = 0\n        else:\n            index = bisect([s[0] for s in stripped_sums], match.start(\"name\"))\n            if index == 0:\n                stripped = 0\n            else:\n                stripped = stripped_sums[index - 1][1]\n\n        return (\n            byte_start + match.start(\"name\") + stripped,\n            byte_start + match.end(\"name\") + stripped,\n        )\n\n    @property\n    def parent(self) -&gt; Union[ContractDefinition, SourceUnit]:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    @lru_cache(maxsize=2048)\n    def canonical_name(self) -&gt; str:\n        from .contract_definition import ContractDefinition\n\n        if isinstance(self._parent, ContractDefinition):\n            return f\"{self._parent.canonical_name}.{self._name}\"\n        return self._name\n\n    @property\n    @lru_cache(maxsize=2048)\n    def declaration_string(self) -&gt; str:\n        return f\"type {self.name} is {self._underlying_type.source}\"\n\n    @property\n    def underlying_type(self) -&gt; ElementaryTypeName:\n        \"\"\"\n        Returns:\n            Underlying type of the user defined value type.\n        \"\"\"\n        return self._underlying_type\n\n    @property\n    def references(\n        self,\n    ) -&gt; FrozenSet[Union[Identifier, IdentifierPathPart, MemberAccess,]]:\n        \"\"\"\n        Returns:\n            Set of all IR nodes referencing this user defined value type.\n        \"\"\"\n        from ..expressions.identifier import Identifier\n        from ..expressions.member_access import MemberAccess\n        from ..meta.identifier_path import IdentifierPathPart\n\n        try:\n            ref = next(\n                ref\n                for ref in self._references\n                if not isinstance(ref, (Identifier, IdentifierPathPart, MemberAccess))\n            )\n            raise AssertionError(f\"Unexpected reference type: {ref}\")\n        except StopIteration:\n            return frozenset(\n                self._references\n            )  # pyright: ignore reportGeneralTypeIssues\n</code></pre>"},{"location":"api-reference/ir/declarations/user-defined-value-type-definition/#wake.ir.declarations.user_defined_value_type_definition.UserDefinedValueTypeDefinition.parent","title":"<code>parent: Union[ContractDefinition, SourceUnit]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[ContractDefinition, SourceUnit]</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/declarations/user-defined-value-type-definition/#wake.ir.declarations.user_defined_value_type_definition.UserDefinedValueTypeDefinition.references","title":"<code>references: FrozenSet[Union[Identifier, IdentifierPathPart, MemberAccess]]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>FrozenSet[Union[Identifier, IdentifierPathPart, MemberAccess]]</code> <p>Set of all IR nodes referencing this user defined value type.</p>"},{"location":"api-reference/ir/declarations/user-defined-value-type-definition/#wake.ir.declarations.user_defined_value_type_definition.UserDefinedValueTypeDefinition.underlying_type","title":"<code>underlying_type: ElementaryTypeName</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>ElementaryTypeName</code> <p>Underlying type of the user defined value type.</p>"},{"location":"api-reference/ir/declarations/variable-declaration/","title":"variable_declaration","text":""},{"location":"api-reference/ir/declarations/variable-declaration/#wake.ir.declarations.variable_declaration","title":"<code>wake.ir.declarations.variable_declaration</code>  <code>module</code>","text":""},{"location":"api-reference/ir/declarations/variable-declaration/#wake.ir.declarations.variable_declaration.VariableDeclaration","title":"<code>VariableDeclaration</code>  <code>class</code>","text":"<p>         Bases: <code>DeclarationAbc</code></p> <p>Example</p> <p>A variable can be declared:</p> <ul> <li>inside a ContractDefinition as a state variable:<ul> <li><code>uint public stateVar</code> on line 4,</li> </ul> </li> <li>inside a ParameterList:<ul> <li>in an ErrorDefinition parameters:<ul> <li><code>uint errorArg</code> on line 5,</li> </ul> </li> <li>in an EventDefinition parameters:<ul> <li><code>uint indexed eventArg</code> on line 6,</li> </ul> </li> <li>in a FunctionDefinition parameters or return parameters:<ul> <li><code>uint funcReturnArg</code> on line 16</li> <li><code>uint x</code> and <code>uint</code> on line 20</li> <li><code>uint</code> on line 30</li> <li><code>function (uint) pure returns(uint) h</code> and the third occurrence <code>uint</code> on line 34,</li> </ul> </li> <li>in a ModifierDefinition parameters:<ul> <li><code>uint modifierArg</code> on line 12,</li> </ul> </li> <li>in a FunctionTypeName parameters or return parameters:<ul> <li>the first two occurrences of <code>uint</code> on line 34,</li> </ul> </li> <li>in a TryCatchClause:<ul> <li><code>uint z</code> on line 22</li> <li><code>string memory reason</code> on line 24,</li> </ul> </li> </ul> </li> <li>inside a SourceUnit only as a constant variable:<ul> <li><code>uint constant CONST = 10</code> on line 1,</li> </ul> </li> <li>inside a StructDefinition as a member variable:<ul> <li><code>uint structMember</code> on line 9,</li> </ul> </li> <li>inside a VariableDeclarationStatement in a FunctionDefinition.body as a local variable:<ul> <li><code>uint y = x</code> on line 21.</li> </ul> </li> </ul> <pre><code>uint constant CONST = 10;\n\ncontract C {\n    uint public stateVar;\n    error E(uint errorArg);\n    event F(uint indexed eventArg);\n\n    struct S {\n        uint structMember;\n    }\n\n    modifier M(uint modifierArg) {\n        _;\n    }\n\n    function foo() public pure returns (uint funcReturnArg) {\n        funcReturnArg = 7;\n    }\n\n    function f(uint x) public view returns (uint) {\n        uint y = x;\n        try this.tmp() returns (uint z) {\n            y = z;\n        } catch Error(string memory reason) {\n            revert(reason);\n        }\n        return y;\n    }\n\n    function tmp() external pure returns(uint) {\n        return CONST;\n    }\n\n    function g(function (uint) pure returns(uint) h) internal pure returns (uint) {\n        return h(7);\n    }\n}\n</code></pre> Source code in <code>wake/ir/declarations/variable_declaration.py</code> <pre><code>class VariableDeclaration(DeclarationAbc):\n    \"\"\"\n    !!! example\n        A variable can be declared:\n\n        - inside a [ContractDefinition][wake.ir.declarations.contract_definition.ContractDefinition] as a state variable:\n            - `:::solidity uint public stateVar` on line 4,\n        - inside a [ParameterList][wake.ir.meta.parameter_list.ParameterList]:\n            - in an [ErrorDefinition][wake.ir.declarations.error_definition.ErrorDefinition] parameters:\n                - `:::solidity uint errorArg` on line 5,\n            - in an [EventDefinition][wake.ir.declarations.event_definition.EventDefinition] parameters:\n                - `:::solidity uint indexed eventArg` on line 6,\n            - in a [FunctionDefinition][wake.ir.declarations.function_definition.FunctionDefinition] parameters or return parameters:\n                - `:::solidity uint funcReturnArg` on line 16\n                - `:::solidity uint x` and `:::solidity uint` on line 20\n                - `:::solidity uint` on line 30\n                - `:::solidity function (uint) pure returns(uint) h` and the third occurrence `:::solidity uint` on line 34,\n            - in a [ModifierDefinition][wake.ir.declarations.modifier_definition.ModifierDefinition] parameters:\n                - `:::solidity uint modifierArg` on line 12,\n            - in a [FunctionTypeName][wake.ir.type_names.function_type_name.FunctionTypeName] parameters or return parameters:\n                - the first two occurrences of `:::solidity uint` on line 34,\n            - in a [TryCatchClause][wake.ir.meta.try_catch_clause.TryCatchClause]:\n                - `:::solidity uint z` on line 22\n                - `:::solidity string memory reason` on line 24,\n        - inside a [SourceUnit][wake.ir.meta.source_unit.SourceUnit] only as a constant variable:\n            - `:::solidity uint constant CONST = 10` on line 1,\n        - inside a [StructDefinition][wake.ir.declarations.struct_definition.StructDefinition] as a member variable:\n            - `:::solidity uint structMember` on line 9,\n        - inside a [VariableDeclarationStatement][wake.ir.statements.variable_declaration_statement.VariableDeclarationStatement] in a [FunctionDefinition.body][wake.ir.declarations.function_definition.FunctionDefinition.body] as a local variable:\n            - `:::solidity uint y = x` on line 21.\n\n        ```solidity linenums=\"1\"\n        uint constant CONST = 10;\n\n        contract C {\n            uint public stateVar;\n            error E(uint errorArg);\n            event F(uint indexed eventArg);\n\n            struct S {\n                uint structMember;\n            }\n\n            modifier M(uint modifierArg) {\n                _;\n            }\n\n            function foo() public pure returns (uint funcReturnArg) {\n                funcReturnArg = 7;\n            }\n\n            function f(uint x) public view returns (uint) {\n                uint y = x;\n                try this.tmp() returns (uint z) {\n                    y = z;\n                } catch Error(string memory reason) {\n                    revert(reason);\n                }\n                return y;\n            }\n\n            function tmp() external pure returns(uint) {\n                return CONST;\n            }\n\n            function g(function (uint) pure returns(uint) h) internal pure returns (uint) {\n                return h(7);\n            }\n        }\n        ```\n    \"\"\"\n\n    _ast_node: SolcVariableDeclaration\n    _parent: Union[\n        ContractDefinition,\n        ParameterList,\n        SourceUnit,\n        StructDefinition,\n        VariableDeclarationStatement,\n    ]\n\n    _constant: bool\n    # __scope\n    _mutability: Optional[Mutability]\n    _state_variable: bool\n    _data_location: DataLocation\n    _visibility: Visibility\n    _base_functions: List[AstNodeId]\n    _documentation: Optional[StructuredDocumentation]\n    _function_selector: Optional[bytes]\n    _indexed: bool\n    _overrides: Optional[OverrideSpecifier]\n    _type_name: TypeNameAbc\n    _value: Optional[ExpressionAbc]\n    _type_descriptions: TypeDescriptionsModel\n\n    def __init__(\n        self,\n        init: IrInitTuple,\n        variable_declaration: SolcVariableDeclaration,\n        parent: SolidityAbc,\n    ):\n        super().__init__(init, variable_declaration, parent)\n        self._constant = variable_declaration.constant\n        self._mutability = variable_declaration.mutability\n        # TODO scope\n        self._state_variable = variable_declaration.state_variable\n        self._data_location = variable_declaration.storage_location\n        self._visibility = variable_declaration.visibility\n        self._base_functions = (\n            list(variable_declaration.base_functions)\n            if variable_declaration.base_functions is not None\n            else []\n        )\n        self._documentation = (\n            StructuredDocumentation(init, variable_declaration.documentation, self)\n            if variable_declaration.documentation\n            else None\n        )\n        self._function_selector = (\n            bytes.fromhex(variable_declaration.function_selector)\n            if variable_declaration.function_selector\n            else None\n        )\n        self._indexed = variable_declaration.indexed or False\n        self._overrides = (\n            OverrideSpecifier(init, variable_declaration.overrides, self)\n            if variable_declaration.overrides\n            else None\n        )\n\n        # type name should not be None\n        # prior 0.5.0, there was a `var` keyword which resulted in the type name being None\n        assert (\n            variable_declaration.type_name is not None\n        ), \"Variable declaration must have a type name\"\n        self._type_name = TypeNameAbc.from_ast(\n            init, variable_declaration.type_name, self\n        )\n        self._value = (\n            ExpressionAbc.from_ast(init, variable_declaration.value, self)\n            if variable_declaration.value is not None\n            else None\n        )\n        self._type_descriptions = variable_declaration.type_descriptions\n        self._reference_resolver.register_post_process_callback(self._post_process)\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        if self._documentation is not None:\n            yield from self._documentation\n        if self._overrides is not None:\n            yield from self._overrides\n        yield from self._type_name\n        if self._value is not None:\n            yield from self._value\n\n    def _post_process(self, callback_params: CallbackParams):\n        base_functions = self.base_functions\n        for base_function in base_functions:\n            base_function._child_functions.add(self)\n        self._reference_resolver.register_destroy_callback(\n            self.source_unit.file, partial(self._destroy, base_functions)\n        )\n\n    def _destroy(self, base_functions: Tuple[FunctionDefinition, ...]) -&gt; None:\n        for base_function in base_functions:\n            base_function._child_functions.discard(self)\n\n    def _parse_name_location(self) -&gt; Tuple[int, int]:\n        # this one is a bit tricky\n        # it is easier to parse the variable declaration from the end (while omitting an optional assigned expression)\n        if self._value is None:\n            source_without_value = self._source\n        else:\n            length_without_value = self._value.byte_location[0] - self.byte_location[0]\n            source_without_value = self._source[:length_without_value]\n        source_without_value = bytearray(source_without_value)\n        _, stripped_sums = SoliditySourceParser.strip_comments(source_without_value)\n\n        IDENTIFIER = r\"[a-zA-Z$_][a-zA-Z0-9$_]*\"\n        VARIABLE_RE = re.compile(\n            r\"(?P&lt;name&gt;{identifier})(\\s*=)?\\s*$\".format(identifier=IDENTIFIER).encode(\n                \"utf-8\"\n            )\n        )\n        match = VARIABLE_RE.search(source_without_value)\n        assert match\n        byte_start = self._ast_node.src.byte_offset\n\n        if len(stripped_sums) == 0:\n            stripped = 0\n        else:\n            index = bisect([s[0] for s in stripped_sums], match.start(\"name\"))\n            if index == 0:\n                stripped = 0\n            else:\n                stripped = stripped_sums[index - 1][1]\n\n        return (\n            byte_start + match.start(\"name\") + stripped,\n            byte_start + match.end(\"name\") + stripped,\n        )\n\n    def get_all_references(\n        self, include_declarations: bool\n    ) -&gt; Iterator[\n        Union[\n            DeclarationAbc,\n            Identifier,\n            IdentifierPathPart,\n            MemberAccess,\n            ExternalReference,\n            UnaryOperation,\n            BinaryOperation,\n        ]\n    ]:\n        from .function_definition import FunctionDefinition\n\n        processed_declarations: Set[Union[FunctionDefinition, VariableDeclaration]] = {\n            self\n        }\n        declarations_queue: Deque[\n            Union[FunctionDefinition, VariableDeclaration]\n        ] = deque([self])\n\n        while declarations_queue:\n            declaration = declarations_queue.pop()\n            if include_declarations:\n                yield declaration\n            yield from declaration.references\n\n            if isinstance(declaration, (FunctionDefinition, VariableDeclaration)):\n                for base_function in declaration.base_functions:\n                    if base_function not in processed_declarations:\n                        declarations_queue.append(base_function)\n                        processed_declarations.add(base_function)\n            if isinstance(declaration, FunctionDefinition):\n                for child_function in declaration.child_functions:\n                    if child_function not in processed_declarations:\n                        declarations_queue.append(child_function)\n                        processed_declarations.add(child_function)\n\n    @property\n    def parent(\n        self,\n    ) -&gt; Union[\n        ContractDefinition,\n        ParameterList,\n        SourceUnit,\n        StructDefinition,\n        VariableDeclarationStatement,\n    ]:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    @lru_cache(maxsize=2048)\n    def canonical_name(self) -&gt; str:\n        node = self.parent\n        while node is not None:\n            if isinstance(node, DeclarationAbc):\n                break\n            node = node.parent\n        if node is None:\n            return self.name\n        return f\"{node.canonical_name}.{self.name}\"\n\n    @property\n    @lru_cache(maxsize=2048)\n    def declaration_string(self) -&gt; str:\n        ret = self.type_name.source\n        ret += f\" {self.visibility}\" if self.is_state_variable else \"\"\n        ret += f\" {self.mutability}\" if self.mutability != Mutability.MUTABLE else \"\"\n        ret += (\n            f\" {self.data_location}\"\n            if self.data_location != DataLocation.DEFAULT\n            else \"\"\n        )\n        ret += (\n            (\n                f\" override\"\n                + \", \".join(override.source for override in self.overrides.overrides)\n            )\n            if self.overrides is not None\n            else \"\"\n        )\n        ret += f\" {self.name}\" if len(self.name) &gt; 0 else \"\"\n        ret += (\n            f\" = {self.value.source}\"\n            if self.value is not None and self.mutability == Mutability.CONSTANT\n            else \"\"\n        )\n\n        if self.documentation is not None:\n            return (\n                \"/// \"\n                + \"\\n///\".join(line for line in self.documentation.text.splitlines())\n                + \"\\n\"\n                + ret\n            )\n        return ret\n\n    @property\n    def mutability(self) -&gt; Mutability:\n        \"\"\"\n        Returns:\n            Mutability of the variable.\n        \"\"\"\n        if self._mutability is None:\n            relative_type_end = self._type_name.byte_location[1] - self.byte_location[0]\n            relative_name_start = self.name_location[0] - self.byte_location[0]\n            keywords_source = self._source[relative_type_end:relative_name_start]\n\n            if b\"immutable\" in keywords_source:\n                self._mutability = Mutability.IMMUTABLE\n            elif self._constant:\n                self._mutability = Mutability.CONSTANT\n            else:\n                self._mutability = Mutability.MUTABLE\n        return self._mutability\n\n    @property\n    def is_state_variable(self) -&gt; bool:\n        \"\"\"\n        Returns:\n            `True` if the variable is a state variable, `False` otherwise.\n        \"\"\"\n        return self._state_variable\n\n    @property\n    def data_location(self) -&gt; DataLocation:\n        \"\"\"\n        [DataLocation.DEFAULT][wake.ir.enums.DataLocation.DEFAULT] is returned if the data location is not specified in the source code.\n\n        Returns:\n            Data location of the variable.\n        \"\"\"\n        return self._data_location\n\n    @property\n    def visibility(self) -&gt; Visibility:\n        \"\"\"\n        Returns:\n            Visibility of the variable.\n        \"\"\"\n        return self._visibility\n\n    @property\n    def base_functions(self) -&gt; Tuple[FunctionDefinition, ...]:\n        \"\"\"\n        !!! example\n            `C.foo` on line 6 lists `I.foo` on line 2 as a base function.\n            ```solidity linenums=\"1\"\n            interface I {\n                function foo(uint, bool) external returns(uint);\n            }\n\n            contract C is I {\n                mapping(uint =&gt; mapping(bool =&gt; uint)) public override foo;\n            }\n            ```\n\n        !!! example\n            `B.foo` on line 14 lists `A1.foo` on lines 2-4 and `A2.foo` on lines 8-10 as base functions.\n            ```solidity linenums=\"1\"\n            contract A1 {\n                function foo(uint, bool) external virtual returns(uint) {\n                    return 1;\n                }\n            }\n\n            contract A2 {\n                function foo(uint, bool) external virtual returns(uint) {\n                    return 2;\n                }\n            }\n\n            contract B is A1, A2 {\n                mapping(uint =&gt; mapping(bool =&gt; uint)) public override(A1, A2) foo;\n            }\n            ```\n\n        Returns:\n            List of base functions overridden by this function.\n        \"\"\"\n        from ..declarations.function_definition import FunctionDefinition\n\n        base_functions = []\n        for base_function_id in self._base_functions:\n            base_function = self._reference_resolver.resolve_node(\n                base_function_id, self.source_unit.cu_hash\n            )\n            assert isinstance(base_function, FunctionDefinition)\n            base_functions.append(base_function)\n        return tuple(base_functions)\n\n    @property\n    def documentation(self) -&gt; Optional[StructuredDocumentation]:\n        \"\"\"\n        Returns:\n            [NatSpec](https://docs.soliditylang.org/en/latest/natspec-format.html) documentation string, if any.\n        \"\"\"\n        return self._documentation\n\n    @property\n    def function_selector(self) -&gt; Optional[bytes]:\n        \"\"\"\n        Is only set for public state variables.\n\n        Returns:\n            Function selector of the getter function generated for this variable, if any.\n        \"\"\"\n        return self._function_selector\n\n    @property\n    def indexed(self) -&gt; bool:\n        \"\"\"\n        Returns:\n            `True` if the variable is indexed, `False` otherwise.\n        \"\"\"\n        return self._indexed\n\n    @property\n    def overrides(self) -&gt; Optional[OverrideSpecifier]:\n        \"\"\"\n        Returns override specified as specified in the source code.\n\n        !!! example\n            `A1.foo` on lines 2-4 and `A2.foo` on lines 8-10 do not have an override specifier.\n\n            `B.foo` on line 14 has an override specifier with the [overrides][wake.ir.meta.override_specifier.OverrideSpecifier.overrides] property containing two items referencing the contracts `A1` and `A2` ([ContractDefinition][wake.ir.declarations.contract_definition.ContractDefinition]).\n            ```solidity linenums=\"1\"\n            contract A1 {\n                function foo(uint, bool) external virtual returns(uint) {\n                    return 1;\n                }\n            }\n\n            contract A2 {\n                function foo(uint, bool) external virtual returns(uint) {\n                    return 2;\n                }\n            }\n\n            contract B is A1, A2 {\n                mapping(uint =&gt; mapping(bool =&gt; uint)) public override(A1, A2) foo;\n            }\n            ```\n\n        Returns:\n            Override specifier, if any.\n        \"\"\"\n        return self._overrides\n\n    @property\n    def type_name(self) -&gt; TypeNameAbc:\n        \"\"\"\n        Returns:\n            Type name IR node as present in the source code.\n        \"\"\"\n        return self._type_name\n\n    @property\n    def value(self) -&gt; Optional[ExpressionAbc]:\n        \"\"\"\n        Is not set if the parent is a [VariableDeclarationStatement][wake.ir.statements.variable_declaration_statement.VariableDeclarationStatement].\n        In this case, the initial value (if any) is set in the [VariableDeclarationStatement.initial_value][wake.ir.statements.variable_declaration_statement.VariableDeclarationStatement.initial_value] property.\n\n        Returns:\n            Initial value expression assigned to the variable in this declaration, if any.\n        \"\"\"\n        return self._value\n\n    @property\n    @lru_cache(maxsize=2048)\n    def type(self) -&gt; TypeAbc:\n        \"\"\"\n        Returns:\n            Type of the variable.\n        \"\"\"\n        assert self._type_descriptions.type_identifier is not None\n\n        type_identifier = StringReader(self._type_descriptions.type_identifier)\n        ret = TypeAbc.from_type_identifier(\n            type_identifier, self._reference_resolver, self.source_unit.cu_hash\n        )\n        assert (\n            len(type_identifier) == 0 and ret is not None\n        ), f\"Failed to parse type identifier: {self._type_descriptions.type_identifier}\"\n        return ret\n\n    @property\n    def type_identifier(self) -&gt; str:\n        assert self._type_descriptions.type_identifier is not None\n        return self._type_descriptions.type_identifier\n\n    @property\n    def type_string(self) -&gt; str:\n        \"\"\"\n        Returns:\n            User-friendly string describing the variable type.\n        \"\"\"\n        assert self._type_descriptions.type_string is not None\n        return self._type_descriptions.type_string\n\n    @property\n    def references(\n        self,\n    ) -&gt; FrozenSet[Union[Identifier, MemberAccess, ExternalReference,]]:\n        \"\"\"\n        Returns:\n            Set of all IR nodes referencing this variable.\n        \"\"\"\n        from ..expressions.identifier import Identifier\n        from ..expressions.member_access import MemberAccess\n        from ..statements.inline_assembly import ExternalReference\n\n        try:\n            ref = next(\n                ref\n                for ref in self._references\n                if not isinstance(ref, (Identifier, MemberAccess, ExternalReference))\n            )\n            raise AssertionError(f\"Unexpected reference type: {ref}\")\n        except StopIteration:\n            return frozenset(\n                self._references\n            )  # pyright: ignore reportGeneralTypeIssues\n</code></pre>"},{"location":"api-reference/ir/declarations/variable-declaration/#wake.ir.declarations.variable_declaration.VariableDeclaration.base_functions","title":"<code>base_functions: Tuple[FunctionDefinition, ...]</code>  <code>property</code>","text":"<p>Example</p> <p><code>C.foo</code> on line 6 lists <code>I.foo</code> on line 2 as a base function. <pre><code>interface I {\n    function foo(uint, bool) external returns(uint);\n}\n\ncontract C is I {\n    mapping(uint =&gt; mapping(bool =&gt; uint)) public override foo;\n}\n</code></pre></p> <p>Example</p> <p><code>B.foo</code> on line 14 lists <code>A1.foo</code> on lines 2-4 and <code>A2.foo</code> on lines 8-10 as base functions. <pre><code>contract A1 {\n    function foo(uint, bool) external virtual returns(uint) {\n        return 1;\n    }\n}\n\ncontract A2 {\n    function foo(uint, bool) external virtual returns(uint) {\n        return 2;\n    }\n}\n\ncontract B is A1, A2 {\n    mapping(uint =&gt; mapping(bool =&gt; uint)) public override(A1, A2) foo;\n}\n</code></pre></p> <p>Returns:</p> Type Description <code>Tuple[FunctionDefinition, ...]</code> <p>List of base functions overridden by this function.</p>"},{"location":"api-reference/ir/declarations/variable-declaration/#wake.ir.declarations.variable_declaration.VariableDeclaration.data_location","title":"<code>data_location: DataLocation</code>  <code>property</code>","text":"<p>DataLocation.DEFAULT is returned if the data location is not specified in the source code.</p> <p>Returns:</p> Type Description <code>DataLocation</code> <p>Data location of the variable.</p>"},{"location":"api-reference/ir/declarations/variable-declaration/#wake.ir.declarations.variable_declaration.VariableDeclaration.documentation","title":"<code>documentation: Optional[StructuredDocumentation]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Optional[StructuredDocumentation]</code> <p>NatSpec documentation string, if any.</p>"},{"location":"api-reference/ir/declarations/variable-declaration/#wake.ir.declarations.variable_declaration.VariableDeclaration.function_selector","title":"<code>function_selector: Optional[bytes]</code>  <code>property</code>","text":"<p>Is only set for public state variables.</p> <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Function selector of the getter function generated for this variable, if any.</p>"},{"location":"api-reference/ir/declarations/variable-declaration/#wake.ir.declarations.variable_declaration.VariableDeclaration.indexed","title":"<code>indexed: bool</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the variable is indexed, <code>False</code> otherwise.</p>"},{"location":"api-reference/ir/declarations/variable-declaration/#wake.ir.declarations.variable_declaration.VariableDeclaration.is_state_variable","title":"<code>is_state_variable: bool</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the variable is a state variable, <code>False</code> otherwise.</p>"},{"location":"api-reference/ir/declarations/variable-declaration/#wake.ir.declarations.variable_declaration.VariableDeclaration.mutability","title":"<code>mutability: Mutability</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Mutability</code> <p>Mutability of the variable.</p>"},{"location":"api-reference/ir/declarations/variable-declaration/#wake.ir.declarations.variable_declaration.VariableDeclaration.overrides","title":"<code>overrides: Optional[OverrideSpecifier]</code>  <code>property</code>","text":"<p>Returns override specified as specified in the source code.</p> <p>Example</p> <p><code>A1.foo</code> on lines 2-4 and <code>A2.foo</code> on lines 8-10 do not have an override specifier.</p> <p><code>B.foo</code> on line 14 has an override specifier with the overrides property containing two items referencing the contracts <code>A1</code> and <code>A2</code> (ContractDefinition). <pre><code>contract A1 {\n    function foo(uint, bool) external virtual returns(uint) {\n        return 1;\n    }\n}\n\ncontract A2 {\n    function foo(uint, bool) external virtual returns(uint) {\n        return 2;\n    }\n}\n\ncontract B is A1, A2 {\n    mapping(uint =&gt; mapping(bool =&gt; uint)) public override(A1, A2) foo;\n}\n</code></pre></p> <p>Returns:</p> Type Description <code>Optional[OverrideSpecifier]</code> <p>Override specifier, if any.</p>"},{"location":"api-reference/ir/declarations/variable-declaration/#wake.ir.declarations.variable_declaration.VariableDeclaration.parent","title":"<code>parent: Union[ContractDefinition, ParameterList, SourceUnit, StructDefinition, VariableDeclarationStatement]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[ContractDefinition, ParameterList, SourceUnit, StructDefinition, VariableDeclarationStatement]</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/declarations/variable-declaration/#wake.ir.declarations.variable_declaration.VariableDeclaration.references","title":"<code>references: FrozenSet[Union[Identifier, MemberAccess, ExternalReference]]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>FrozenSet[Union[Identifier, MemberAccess, ExternalReference]]</code> <p>Set of all IR nodes referencing this variable.</p>"},{"location":"api-reference/ir/declarations/variable-declaration/#wake.ir.declarations.variable_declaration.VariableDeclaration.type","title":"<code>type: TypeAbc</code>  <code>cached</code> <code>property</code>","text":"<p>Returns:</p> Type Description <code>TypeAbc</code> <p>Type of the variable.</p>"},{"location":"api-reference/ir/declarations/variable-declaration/#wake.ir.declarations.variable_declaration.VariableDeclaration.type_name","title":"<code>type_name: TypeNameAbc</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>TypeNameAbc</code> <p>Type name IR node as present in the source code.</p>"},{"location":"api-reference/ir/declarations/variable-declaration/#wake.ir.declarations.variable_declaration.VariableDeclaration.type_string","title":"<code>type_string: str</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>User-friendly string describing the variable type.</p>"},{"location":"api-reference/ir/declarations/variable-declaration/#wake.ir.declarations.variable_declaration.VariableDeclaration.value","title":"<code>value: Optional[ExpressionAbc]</code>  <code>property</code>","text":"<p>Is not set if the parent is a VariableDeclarationStatement. In this case, the initial value (if any) is set in the VariableDeclarationStatement.initial_value property.</p> <p>Returns:</p> Type Description <code>Optional[ExpressionAbc]</code> <p>Initial value expression assigned to the variable in this declaration, if any.</p>"},{"location":"api-reference/ir/declarations/variable-declaration/#wake.ir.declarations.variable_declaration.VariableDeclaration.visibility","title":"<code>visibility: Visibility</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Visibility</code> <p>Visibility of the variable.</p>"},{"location":"api-reference/ir/expressions/abc/","title":"abc","text":""},{"location":"api-reference/ir/expressions/abc/#wake.ir.expressions.abc","title":"<code>wake.ir.expressions.abc</code>  <code>module</code>","text":""},{"location":"api-reference/ir/expressions/abc/#wake.ir.expressions.abc.ExpressionAbc","title":"<code>ExpressionAbc</code>  <code>class</code>","text":"<p>         Bases: <code>SolidityAbc</code>, <code>ABC</code></p> <p>Abstract base class for all IR expression nodes.</p> <p>Something that has a value.</p> Source code in <code>wake/ir/expressions/abc.py</code> <pre><code>class ExpressionAbc(SolidityAbc, ABC):\n    \"\"\"\n    Abstract base class for all IR expression nodes.\n    &gt; Something that has a value.\n    \"\"\"\n\n    _type_descriptions: TypeDescriptionsModel\n\n    def __init__(\n        self, init: IrInitTuple, expression: SolcExpressionUnion, parent: SolidityAbc\n    ):\n        super().__init__(init, expression, parent)\n        self._type_descriptions = expression.type_descriptions\n\n    @staticmethod\n    def from_ast(\n        init: IrInitTuple, expression: SolcExpressionUnion, parent: SolidityAbc\n    ) -&gt; ExpressionAbc:\n        from .assignment import Assignment\n        from .binary_operation import BinaryOperation\n        from .conditional import Conditional\n        from .elementary_type_name_expression import ElementaryTypeNameExpression\n        from .function_call import FunctionCall\n        from .function_call_options import FunctionCallOptions\n        from .identifier import Identifier\n        from .index_access import IndexAccess\n        from .index_range_access import IndexRangeAccess\n        from .literal import Literal\n        from .member_access import MemberAccess\n        from .new_expression import NewExpression\n        from .tuple_expression import TupleExpression\n        from .unary_operation import UnaryOperation\n\n        if isinstance(expression, SolcAssignment):\n            return Assignment(init, expression, parent)\n        elif isinstance(expression, SolcBinaryOperation):\n            return BinaryOperation(init, expression, parent)\n        elif isinstance(expression, SolcConditional):\n            return Conditional(init, expression, parent)\n        elif isinstance(expression, SolcElementaryTypeNameExpression):\n            return ElementaryTypeNameExpression(init, expression, parent)\n        elif isinstance(expression, SolcFunctionCall):\n            return FunctionCall(init, expression, parent)\n        elif isinstance(expression, SolcFunctionCallOptions):\n            return FunctionCallOptions(init, expression, parent)\n        elif isinstance(expression, SolcIdentifier):\n            return Identifier(init, expression, parent)\n        elif isinstance(expression, SolcIndexAccess):\n            return IndexAccess(init, expression, parent)\n        elif isinstance(expression, SolcIndexRangeAccess):\n            return IndexRangeAccess(init, expression, parent)\n        elif isinstance(expression, SolcLiteral):\n            return Literal(init, expression, parent)\n        elif isinstance(expression, SolcMemberAccess):\n            return MemberAccess(init, expression, parent)\n        elif isinstance(expression, SolcNewExpression):\n            return NewExpression(init, expression, parent)\n        elif isinstance(expression, SolcTupleExpression):\n            return TupleExpression(init, expression, parent)\n        elif isinstance(expression, SolcUnaryOperation):\n            return UnaryOperation(init, expression, parent)\n\n    @property\n    @lru_cache(maxsize=2048)\n    def type(self) -&gt; Optional[TypeAbc]:\n        \"\"\"\n        Can be `None` in case of an [Identifier][wake.ir.expressions.identifier.Identifier] in an [ImportDirective][wake.ir.meta.import_directive.ImportDirective].\n        !!! example\n            `Ownable` in the following example has no type information:\n            ```solidity\n            import { Ownable } from './Ownable.sol';\n            ```\n\n        Returns:\n            Type of the expression.\n        \"\"\"\n        if self._type_descriptions.type_identifier is None:\n            return None\n\n        type_identifier = StringReader(self._type_descriptions.type_identifier)\n        ret = TypeAbc.from_type_identifier(\n            type_identifier, self._reference_resolver, self.source_unit.cu_hash\n        )\n        assert (\n            len(type_identifier) == 0\n        ), f\"Failed to parse type_identifier: {self._type_descriptions.type_identifier}\"\n        return ret\n\n    @property\n    def type_identifier(self) -&gt; Optional[str]:\n        return self._type_descriptions.type_identifier\n\n    @property\n    def type_string(self) -&gt; Optional[str]:\n        \"\"\"\n        !!! example\n            `:::solidity function (uint256,uint256) returns (uint256)` in the case of the `foo` [Identifier][wake.ir.expressions.identifier.Identifier] in the `:::solidity foo(1, 2)` expression for the following function:\n            ```solidity\n            function foo(uint a, uint b) public onlyOwner payable virtual onlyOwner returns(uint) {\n                return a + b;\n            }\n            ```\n\n        Can be `None` in case of an [Identifier][wake.ir.expressions.identifier.Identifier] in an [ImportDirective][wake.ir.meta.import_directive.ImportDirective].\n        !!! example\n            `Ownable` in the following example has no type information:\n            ```solidity\n            import { Ownable } from './Ownable.sol';\n            ```\n\n        Returns:\n            User-friendly string describing the expression type.\n        \"\"\"\n        return self._type_descriptions.type_string\n\n    @property\n    @abstractmethod\n    def is_ref_to_state_variable(self) -&gt; bool:\n        \"\"\"\n        In many cases it may be useful to know if an [Assignment][wake.ir.expressions.assignment.Assignment] to an expression modifies a state variable or not.\n        This may not be straightforward to determine, e.g. if the expression is a [MemberAccess][wake.ir.expressions.member_access.MemberAccess] or [IndexAccess][wake.ir.expressions.index_access.IndexAccess] to a state variable.\n\n        WARNING:\n            Is not considered stable and so is not exported in the documentation.\n\n        Returns:\n            `True` if the expression (possibly) is a reference to a state variable.\n        \"\"\"\n        ...\n\n    @property\n    @abstractmethod\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        \"\"\"\n        WARNING:\n            Is not considered stable and so is not exported in the documentation.\n\n        Returns:\n            Set of child IR nodes (including `self`) that modify the blockchain state and flags describing how the state is modified.\n        \"\"\"\n        ...\n\n    @property\n    @lru_cache(maxsize=512)\n    def statement(self) -&gt; Optional[StatementAbc]:\n        \"\"\"\n        May be `None` if the expression is not part of a function or modifier body.\n        This may happen in:\n\n        - [ModifierInvocation][wake.ir.meta.modifier_invocation.ModifierInvocation] arguments,\n        - [InheritanceSpecifier][wake.ir.meta.inheritance_specifier.InheritanceSpecifier] arguments,\n        - [ArrayTypeName][wake.ir.type_names.array_type_name.ArrayTypeName] length value,\n        - [VariableDeclaration][wake.ir.declarations.variable_declaration.VariableDeclaration] initializer.\n\n        Returns:\n            Statement that contains the expression.\n        \"\"\"\n        from ..statements.abc import StatementAbc\n\n        node = self\n        while node is not None:\n            if isinstance(node, StatementAbc):\n                return node\n            node = node.parent\n        return None\n</code></pre>"},{"location":"api-reference/ir/expressions/abc/#wake.ir.expressions.abc.ExpressionAbc.statement","title":"<code>statement: Optional[StatementAbc]</code>  <code>cached</code> <code>property</code>","text":"<p>May be <code>None</code> if the expression is not part of a function or modifier body. This may happen in:</p> <ul> <li>ModifierInvocation arguments,</li> <li>InheritanceSpecifier arguments,</li> <li>ArrayTypeName length value,</li> <li>VariableDeclaration initializer.</li> </ul> <p>Returns:</p> Type Description <code>Optional[StatementAbc]</code> <p>Statement that contains the expression.</p>"},{"location":"api-reference/ir/expressions/abc/#wake.ir.expressions.abc.ExpressionAbc.type","title":"<code>type: Optional[TypeAbc]</code>  <code>cached</code> <code>property</code>","text":"<p>Can be <code>None</code> in case of an Identifier in an ImportDirective.</p> <p>Example</p> <p><code>Ownable</code> in the following example has no type information: <pre><code>import { Ownable } from './Ownable.sol';\n</code></pre></p> <p>Returns:</p> Type Description <code>Optional[TypeAbc]</code> <p>Type of the expression.</p>"},{"location":"api-reference/ir/expressions/abc/#wake.ir.expressions.abc.ExpressionAbc.type_string","title":"<code>type_string: Optional[str]</code>  <code>property</code>","text":"<p>Example</p> <p><code>function (uint256,uint256) returns (uint256)</code> in the case of the <code>foo</code> Identifier in the <code>foo(1, 2)</code> expression for the following function: <pre><code>function foo(uint a, uint b) public onlyOwner payable virtual onlyOwner returns(uint) {\n    return a + b;\n}\n</code></pre></p> <p>Can be <code>None</code> in case of an Identifier in an ImportDirective.</p> <p>Example</p> <p><code>Ownable</code> in the following example has no type information: <pre><code>import { Ownable } from './Ownable.sol';\n</code></pre></p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>User-friendly string describing the expression type.</p>"},{"location":"api-reference/ir/expressions/assignment/","title":"assignment","text":""},{"location":"api-reference/ir/expressions/assignment/#wake.ir.expressions.assignment","title":"<code>wake.ir.expressions.assignment</code>  <code>module</code>","text":""},{"location":"api-reference/ir/expressions/assignment/#wake.ir.expressions.assignment.Assignment","title":"<code>Assignment</code>  <code>class</code>","text":"<p>         Bases: <code>ExpressionAbc</code></p> <p>Example</p> <pre><code>x = 1;\ny = x = 1;\n</code></pre> Source code in <code>wake/ir/expressions/assignment.py</code> <pre><code>class Assignment(ExpressionAbc):\n    \"\"\"\n    !!! example\n        ```solidity\n        x = 1;\n        y = x = 1;\n        ```\n    \"\"\"\n\n    _ast_node: SolcAssignment\n    _parent: SolidityAbc  # TODO: make this more specific\n\n    _left_expression: ExpressionAbc\n    _right_expression: ExpressionAbc\n    _operator: AssignmentOperator\n\n    def __init__(\n        self, init: IrInitTuple, assignment: SolcAssignment, parent: SolidityAbc\n    ):\n        super().__init__(init, assignment, parent)\n        self._operator = assignment.operator\n        self._left_expression = ExpressionAbc.from_ast(\n            init, assignment.left_hand_side, self\n        )\n        self._right_expression = ExpressionAbc.from_ast(\n            init, assignment.right_hand_side, self\n        )\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        yield from self._left_expression\n        yield from self._right_expression\n\n    @property\n    def parent(self) -&gt; SolidityAbc:\n        return self._parent\n\n    @property\n    def left_expression(self) -&gt; ExpressionAbc:\n        \"\"\"\n        Must be L-value (something that can be assigned to).\n\n        Returns:\n            Left expression of the assignment.\n        \"\"\"\n        return self._left_expression\n\n    @property\n    def right_expression(self) -&gt; ExpressionAbc:\n        \"\"\"\n        Returns:\n            Right expression of the assignment.\n        \"\"\"\n        return self._right_expression\n\n    @property\n    def operator(self) -&gt; AssignmentOperator:\n        \"\"\"\n        Returns:\n            Operator used in the assignment.\n        \"\"\"\n        return self._operator\n\n    @property\n    @lru_cache(maxsize=2048)\n    def is_ref_to_state_variable(self) -&gt; bool:\n        return self.left_expression.is_ref_to_state_variable\n\n    @property\n    @lru_cache(maxsize=2048)\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        ret = self.left_expression.modifies_state | self.right_expression.modifies_state\n        if self.left_expression.is_ref_to_state_variable:\n            ret |= {(self, ModifiesStateFlag.MODIFIES_STATE_VAR)}\n        return ret\n\n    @property\n    @lru_cache(maxsize=2048)\n    def assigned_variables(self) -&gt; Tuple[Optional[Set[AssignedVariablePath]], ...]:\n        \"\"\"\n        WARNING:\n            Is not considered stable and so is not exported in the documentation.\n        \"\"\"\n\n        def resolve_node(node: ExpressionAbc) -&gt; Set[AssignedVariablePath]:\n            if isinstance(node, Conditional):\n                return resolve_node(node.true_expression) | resolve_node(\n                    node.false_expression\n                )\n            elif isinstance(node, Identifier):\n                referenced_declaration = node.referenced_declaration\n                assert isinstance(referenced_declaration, (DeclarationAbc, SourceUnit))\n                return {(referenced_declaration,)}\n            elif isinstance(node, IndexAccess):\n                return {\n                    path + (\"IndexAccess\",)\n                    for path in resolve_node(node.base_expression)\n                }\n            elif isinstance(node, MemberAccess):\n                referenced_declaration = node.referenced_declaration\n                assert isinstance(referenced_declaration, (DeclarationAbc, SourceUnit))\n                return {\n                    path + (referenced_declaration,)\n                    for path in resolve_node(node.expression)\n                }\n            elif isinstance(node, FunctionCall):\n                function_called = node.function_called\n                if function_called is None:\n                    return set()\n                elif isinstance(function_called, (GlobalSymbol, VariableDeclaration)):\n                    # global function or variable getter called\n                    # variable getter may return different type than variable declaration (structs with arrays and mappings)\n                    # return empty set for now\n                    return set()\n                elif isinstance(function_called, FunctionDefinition):\n                    # cannot be handled in the current implementation, return empty set for now\n                    return set()\n                elif isinstance(function_called, StructDefinition):\n                    return {(function_called,)}\n                else:\n                    assert False, f\"Unexpected node type: {type(node)}\\n{self.source}\"\n            else:\n                assert False, f\"Unexpected node type: {type(node)}\\n{self.source}\"\n\n        node = self.left_expression\n        if isinstance(node, TupleExpression):\n            return tuple(\n                resolve_node(expression) if expression is not None else None\n                for expression in node.components\n            )\n        else:\n            return (resolve_node(node),)\n</code></pre>"},{"location":"api-reference/ir/expressions/assignment/#wake.ir.expressions.assignment.Assignment.left_expression","title":"<code>left_expression: ExpressionAbc</code>  <code>property</code>","text":"<p>Must be L-value (something that can be assigned to).</p> <p>Returns:</p> Type Description <code>ExpressionAbc</code> <p>Left expression of the assignment.</p>"},{"location":"api-reference/ir/expressions/assignment/#wake.ir.expressions.assignment.Assignment.operator","title":"<code>operator: AssignmentOperator</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>AssignmentOperator</code> <p>Operator used in the assignment.</p>"},{"location":"api-reference/ir/expressions/assignment/#wake.ir.expressions.assignment.Assignment.right_expression","title":"<code>right_expression: ExpressionAbc</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>ExpressionAbc</code> <p>Right expression of the assignment.</p>"},{"location":"api-reference/ir/expressions/binary-operation/","title":"binary_operation","text":""},{"location":"api-reference/ir/expressions/binary-operation/#wake.ir.expressions.binary_operation","title":"<code>wake.ir.expressions.binary_operation</code>  <code>module</code>","text":""},{"location":"api-reference/ir/expressions/binary-operation/#wake.ir.expressions.binary_operation.BinaryOperation","title":"<code>BinaryOperation</code>  <code>class</code>","text":"<p>         Bases: <code>ExpressionAbc</code></p> <p>Example</p> <pre><code>x + y\n</code></pre> Source code in <code>wake/ir/expressions/binary_operation.py</code> <pre><code>class BinaryOperation(ExpressionAbc):\n    \"\"\"\n    !!! example\n        ```solidity\n        x + y\n        ```\n    \"\"\"\n\n    _ast_node: SolcBinaryOperation\n    _parent: SolidityAbc  # TODO: make this more specific\n\n    _left_expression: ExpressionAbc\n    _operator: BinaryOpOperator\n    _right_expression: ExpressionAbc\n    _function_id: Optional[AstNodeId]\n\n    def __init__(\n        self,\n        init: IrInitTuple,\n        binary_operation: SolcBinaryOperation,\n        parent: SolidityAbc,\n    ):\n        super().__init__(init, binary_operation, parent)\n        self._operator = binary_operation.operator\n        self._left_expression = ExpressionAbc.from_ast(\n            init, binary_operation.left_expression, self\n        )\n        self._right_expression = ExpressionAbc.from_ast(\n            init, binary_operation.right_expression, self\n        )\n        self._function_id = binary_operation.function\n        if self._function_id is not None:\n            init.reference_resolver.register_post_process_callback(self._post_process)\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        yield from self._left_expression\n        yield from self._right_expression\n\n    def _post_process(self, callback_params: CallbackParams):\n        function = self.function\n        assert function is not None\n        function.register_reference(self)\n        self._reference_resolver.register_destroy_callback(\n            self.source_unit.file, partial(self._destroy, function)\n        )\n\n    def _destroy(self, function: FunctionDefinition) -&gt; None:\n        function.unregister_reference(self)\n\n    @property\n    def parent(self) -&gt; SolidityAbc:\n        return self._parent\n\n    @property\n    def operator(self) -&gt; BinaryOpOperator:\n        \"\"\"\n        Returns:\n            Operator of the binary operation.\n        \"\"\"\n        return self._operator\n\n    @property\n    def left_expression(self) -&gt; ExpressionAbc:\n        \"\"\"\n        Returns:\n            Left expression of the binary operation.\n        \"\"\"\n        return self._left_expression\n\n    @property\n    def right_expression(self) -&gt; ExpressionAbc:\n        \"\"\"\n        Returns:\n            Right expression of the binary operation.\n        \"\"\"\n        return self._right_expression\n\n    @property\n    def is_ref_to_state_variable(self) -&gt; bool:\n        return False\n\n    @property\n    @lru_cache(maxsize=2048)\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        return (\n            self.left_expression.modifies_state | self.right_expression.modifies_state\n        )\n\n    @property\n    def function(self) -&gt; Optional[FunctionDefinition]:\n        \"\"\"\n        Is not `None` if the binary operation operates on user-defined value types with custom operators.\n\n        !!! example\n            The binary operation `a + b` on line 11 of the following example references the function `add` on line 6:\n            ```solidity linenums=\"1\"\n            pragma solidity ^0.8.19;\n\n            type Int is int;\n            using {add as +} for Int global;\n\n            function add(Int a, Int b) pure returns (Int) {\n                return Int.wrap(Int.unwrap(a) + Int.unwrap(b));\n            }\n\n            function test(Int a, Int b) pure returns (Int) {\n                return a + b; // Equivalent to add(a, b)\n            }\n            ```\n\n        Returns:\n            Function representing the user-defined operator.\n        \"\"\"\n        if self._function_id is None:\n            return None\n        node = self._reference_resolver.resolve_node(\n            self._function_id, self.source_unit.cu_hash\n        )\n        assert isinstance(node, FunctionDefinition)\n        return node\n</code></pre>"},{"location":"api-reference/ir/expressions/binary-operation/#wake.ir.expressions.binary_operation.BinaryOperation.function","title":"<code>function: Optional[FunctionDefinition]</code>  <code>property</code>","text":"<p>Is not <code>None</code> if the binary operation operates on user-defined value types with custom operators.</p> <p>Example</p> <p>The binary operation <code>a + b</code> on line 11 of the following example references the function <code>add</code> on line 6: <pre><code>pragma solidity ^0.8.19;\n\ntype Int is int;\nusing {add as +} for Int global;\n\nfunction add(Int a, Int b) pure returns (Int) {\n    return Int.wrap(Int.unwrap(a) + Int.unwrap(b));\n}\n\nfunction test(Int a, Int b) pure returns (Int) {\n    return a + b; // Equivalent to add(a, b)\n}\n</code></pre></p> <p>Returns:</p> Type Description <code>Optional[FunctionDefinition]</code> <p>Function representing the user-defined operator.</p>"},{"location":"api-reference/ir/expressions/binary-operation/#wake.ir.expressions.binary_operation.BinaryOperation.left_expression","title":"<code>left_expression: ExpressionAbc</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>ExpressionAbc</code> <p>Left expression of the binary operation.</p>"},{"location":"api-reference/ir/expressions/binary-operation/#wake.ir.expressions.binary_operation.BinaryOperation.operator","title":"<code>operator: BinaryOpOperator</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>BinaryOpOperator</code> <p>Operator of the binary operation.</p>"},{"location":"api-reference/ir/expressions/binary-operation/#wake.ir.expressions.binary_operation.BinaryOperation.right_expression","title":"<code>right_expression: ExpressionAbc</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>ExpressionAbc</code> <p>Right expression of the binary operation.</p>"},{"location":"api-reference/ir/expressions/conditional/","title":"conditional","text":""},{"location":"api-reference/ir/expressions/conditional/#wake.ir.expressions.conditional","title":"<code>wake.ir.expressions.conditional</code>  <code>module</code>","text":""},{"location":"api-reference/ir/expressions/conditional/#wake.ir.expressions.conditional.Conditional","title":"<code>Conditional</code>  <code>class</code>","text":"<p>         Bases: <code>ExpressionAbc</code></p> <p>Example</p> <pre><code>x ? y : z\n</code></pre> Source code in <code>wake/ir/expressions/conditional.py</code> <pre><code>class Conditional(ExpressionAbc):\n    \"\"\"\n    !!! example\n        ```solidity\n        x ? y : z\n        ```\n    \"\"\"\n\n    _ast_node: SolcConditional\n    _parent: SolidityAbc  # TODO: make this more specific\n\n    _condition: ExpressionAbc\n    _false_expression: ExpressionAbc\n    _true_expression: ExpressionAbc\n\n    def __init__(\n        self, init: IrInitTuple, conditional: SolcConditional, parent: SolidityAbc\n    ):\n        super().__init__(init, conditional, parent)\n        self._condition = ExpressionAbc.from_ast(init, conditional.condition, self)\n        self._false_expression = ExpressionAbc.from_ast(\n            init, conditional.false_expression, self\n        )\n        self._true_expression = ExpressionAbc.from_ast(\n            init, conditional.true_expression, self\n        )\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        yield from self._condition\n        yield from self._false_expression\n        yield from self._true_expression\n\n    @property\n    def parent(self) -&gt; SolidityAbc:\n        return self._parent\n\n    @property\n    def condition(self) -&gt; ExpressionAbc:\n        \"\"\"\n        Returns:\n            Condition expression.\n        \"\"\"\n        return self._condition\n\n    @property\n    def false_expression(self) -&gt; ExpressionAbc:\n        \"\"\"\n        Returns:\n            Expression evaluated when the condition is false.\n        \"\"\"\n        return self._false_expression\n\n    @property\n    def true_expression(self) -&gt; ExpressionAbc:\n        \"\"\"\n        Returns:\n            Expression evaluated when the condition is true.\n        \"\"\"\n        return self._true_expression\n\n    @property\n    @lru_cache(maxsize=2048)\n    def is_ref_to_state_variable(self) -&gt; bool:\n        return (\n            self.true_expression.is_ref_to_state_variable\n            or self.false_expression.is_ref_to_state_variable\n        )\n\n    @property\n    @lru_cache(maxsize=2048)\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        return (\n            self.condition.modifies_state\n            | self.true_expression.modifies_state\n            | self.false_expression.modifies_state\n        )\n</code></pre>"},{"location":"api-reference/ir/expressions/conditional/#wake.ir.expressions.conditional.Conditional.condition","title":"<code>condition: ExpressionAbc</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>ExpressionAbc</code> <p>Condition expression.</p>"},{"location":"api-reference/ir/expressions/conditional/#wake.ir.expressions.conditional.Conditional.false_expression","title":"<code>false_expression: ExpressionAbc</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>ExpressionAbc</code> <p>Expression evaluated when the condition is false.</p>"},{"location":"api-reference/ir/expressions/conditional/#wake.ir.expressions.conditional.Conditional.true_expression","title":"<code>true_expression: ExpressionAbc</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>ExpressionAbc</code> <p>Expression evaluated when the condition is true.</p>"},{"location":"api-reference/ir/expressions/elementary-type-name-expression/","title":"elementary_type_name_expression","text":""},{"location":"api-reference/ir/expressions/elementary-type-name-expression/#wake.ir.expressions.elementary_type_name_expression","title":"<code>wake.ir.expressions.elementary_type_name_expression</code>  <code>module</code>","text":""},{"location":"api-reference/ir/expressions/elementary-type-name-expression/#wake.ir.expressions.elementary_type_name_expression.ElementaryTypeNameExpression","title":"<code>ElementaryTypeNameExpression</code>  <code>class</code>","text":"<p>         Bases: <code>ExpressionAbc</code></p> <p>May be used:</p> <ul> <li>in a FunctionCall type conversion expressions, e.g. <code>address(this)</code>,</li> <li>as <code>type</code> argument, e.g. <code>type(uint256).max</code>,</li> <li>as a FunctionCall argument, e.g. <code>abi.decode(x, (uint256))</code>.</li> </ul> Source code in <code>wake/ir/expressions/elementary_type_name_expression.py</code> <pre><code>class ElementaryTypeNameExpression(ExpressionAbc):\n    \"\"\"\n    May be used:\n\n    - in a [FunctionCall][wake.ir.expressions.function_call.FunctionCall] type conversion expressions, e.g. `:::solidity address(this)`,\n    - as `type` argument, e.g. `:::solidity type(uint256).max`,\n    - as a [FunctionCall][wake.ir.expressions.function_call.FunctionCall] argument, e.g. `:::solidity abi.decode(x, (uint256))`.\n    \"\"\"\n\n    _ast_node: SolcElementaryTypeNameExpression\n    _parent: SolidityAbc  # TODO: make this more specific\n\n    _type_name: ElementaryTypeName\n\n    def __init__(\n        self,\n        init: IrInitTuple,\n        elementary_type_name_expression: SolcElementaryTypeNameExpression,\n        parent: SolidityAbc,\n    ):\n        super().__init__(init, elementary_type_name_expression, parent)\n        self._type_name = ElementaryTypeName(\n            init, elementary_type_name_expression.type_name, self\n        )\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        yield from self._type_name\n\n    @property\n    def parent(self) -&gt; SolidityAbc:\n        return self._parent\n\n    @property\n    def type_name(self) -&gt; ElementaryTypeName:\n        \"\"\"\n        Returns:\n            Type name referenced by the expression.\n        \"\"\"\n        return self._type_name\n\n    @property\n    def is_ref_to_state_variable(self) -&gt; bool:\n        return False\n\n    @property\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        return set()\n</code></pre>"},{"location":"api-reference/ir/expressions/elementary-type-name-expression/#wake.ir.expressions.elementary_type_name_expression.ElementaryTypeNameExpression.type_name","title":"<code>type_name: ElementaryTypeName</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>ElementaryTypeName</code> <p>Type name referenced by the expression.</p>"},{"location":"api-reference/ir/expressions/function-call-options/","title":"function_call_options","text":""},{"location":"api-reference/ir/expressions/function-call-options/#wake.ir.expressions.function_call_options","title":"<code>wake.ir.expressions.function_call_options</code>  <code>module</code>","text":""},{"location":"api-reference/ir/expressions/function-call-options/#wake.ir.expressions.function_call_options.FunctionCallOptions","title":"<code>FunctionCallOptions</code>  <code>class</code>","text":"<p>         Bases: <code>ExpressionAbc</code></p> <p>Sets <code>gas</code>, <code>value</code> and <code>salt</code> function call options.</p> <p>Serves as a replacement for old-style syntax, e.g. <code>this.foo.gas(1000).value(1)()</code>.</p> <p>Example</p> <p><code>this.foo{gas: 1000, value: 1}</code> in the following example: <pre><code>function foo() public {\n    this.foo{gas: 1000, value: 1}();\n}\n</code></pre></p> Source code in <code>wake/ir/expressions/function_call_options.py</code> <pre><code>class FunctionCallOptions(ExpressionAbc):\n    \"\"\"\n    Sets `gas`, `value` and `salt` function call options.\n\n    Serves as a replacement for old-style syntax, e.g. `:::solidity this.foo.gas(1000).value(1)()`.\n\n    !!! example\n        `:::solidity this.foo{gas: 1000, value: 1}` in the following example:\n        ```solidity\n        function foo() public {\n            this.foo{gas: 1000, value: 1}();\n        }\n        ```\n    \"\"\"\n\n    _ast_node: SolcFunctionCallOptions\n    _parent: SolidityAbc  # TODO: make this more specific\n\n    _expression: ExpressionAbc\n    _names: List[str]\n    _options: List[ExpressionAbc]\n\n    def __init__(\n        self,\n        init: IrInitTuple,\n        function_call_options: SolcFunctionCallOptions,\n        parent: SolidityAbc,\n    ):\n        super().__init__(init, function_call_options, parent)\n        self._expression = ExpressionAbc.from_ast(\n            init, function_call_options.expression, self\n        )\n        self._names = list(function_call_options.names)\n        self._options = [\n            ExpressionAbc.from_ast(init, option, self)\n            for option in function_call_options.options\n        ]\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        yield from self._expression\n        for option in self._options:\n            yield from option\n\n    @property\n    def parent(self) -&gt; SolidityAbc:\n        return self._parent\n\n    @property\n    def expression(self) -&gt; ExpressionAbc:\n        \"\"\"\n        !!! example\n            `:::solidity address(this).call` and `:::solidity new MyToken` in the following example:\n\n            ```solidity\n            function f() public {\n                address(this).call{value: 1}(\"\");\n                new MyToken{salt: 0x1234}();\n            }\n            ```\n\n        Returns:\n            Sub-expression the function call options are applied to.\n        \"\"\"\n        return self._expression\n\n    @property\n    def names(self) -&gt; Tuple[str, ...]:\n        \"\"\"\n        Returns:\n            Names of the function call options in the order they appear in the source code.\n        \"\"\"\n        return tuple(self._names)\n\n    @property\n    def options(self) -&gt; Tuple[ExpressionAbc, ...]:\n        \"\"\"\n        Returns:\n            Values of the function call options in the order they appear in the source code.\n        \"\"\"\n        return tuple(self._options)\n\n    @property\n    def is_ref_to_state_variable(self) -&gt; bool:\n        return False\n\n    @property\n    @lru_cache(maxsize=2048)\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        ret = self.expression.modifies_state | reduce(\n            or_,\n            (option.modifies_state for option in self.options),\n            set(),\n        )\n        if \"value\" in self.names:\n            ret |= {(self, ModifiesStateFlag.SENDS_ETHER)}\n        return ret\n</code></pre>"},{"location":"api-reference/ir/expressions/function-call-options/#wake.ir.expressions.function_call_options.FunctionCallOptions.expression","title":"<code>expression: ExpressionAbc</code>  <code>property</code>","text":"<p>Example</p> <p><code>address(this).call</code> and <code>new MyToken</code> in the following example:</p> <pre><code>function f() public {\n    address(this).call{value: 1}(\"\");\n    new MyToken{salt: 0x1234}();\n}\n</code></pre> <p>Returns:</p> Type Description <code>ExpressionAbc</code> <p>Sub-expression the function call options are applied to.</p>"},{"location":"api-reference/ir/expressions/function-call-options/#wake.ir.expressions.function_call_options.FunctionCallOptions.names","title":"<code>names: Tuple[str, ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[str, ...]</code> <p>Names of the function call options in the order they appear in the source code.</p>"},{"location":"api-reference/ir/expressions/function-call-options/#wake.ir.expressions.function_call_options.FunctionCallOptions.options","title":"<code>options: Tuple[ExpressionAbc, ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[ExpressionAbc, ...]</code> <p>Values of the function call options in the order they appear in the source code.</p>"},{"location":"api-reference/ir/expressions/function-call/","title":"function_call","text":""},{"location":"api-reference/ir/expressions/function-call/#wake.ir.expressions.function_call","title":"<code>wake.ir.expressions.function_call</code>  <code>module</code>","text":""},{"location":"api-reference/ir/expressions/function-call/#wake.ir.expressions.function_call.FunctionCall","title":"<code>FunctionCall</code>  <code>class</code>","text":"<p>         Bases: <code>ExpressionAbc</code></p> <p>Represents:</p> <ul> <li>function calls, e.g. <code>address(this).call(\"\")</code>,</li> <li>type conversions, e.g. <code>address(this)</code>,</li> <li>struct constructor calls, e.g. <code>MyStruct({a: 1, b: 2})</code>,</li> <li>contract creation calls, e.g. <code>new MyContract{value: 1}()</code>,</li> <li>dynamic array creations calls (including <code>bytes</code> and <code>string</code>), e.g. <code>new uint[](10)</code> or <code>new bytes(10)</code>,</li> <li>event emit calls, e.g. <code>MyEvent(1, 2)</code> in <code>emit MyEvent(1, 2)</code>,</li> <li>error revert calls, e.g. <code>MyError(1, 2)</code> in <code>revert MyError(1, 2)</code>,</li> <li>variable getter calls.</li> </ul> Source code in <code>wake/ir/expressions/function_call.py</code> <pre><code>class FunctionCall(ExpressionAbc):\n    \"\"\"\n    Represents:\n\n    - function calls, e.g. `:::solidity address(this).call(\"\")`,\n    - type conversions, e.g. `:::solidity address(this)`,\n    - struct constructor calls, e.g. `:::solidity MyStruct({a: 1, b: 2})`,\n    - contract creation calls, e.g. `:::solidity new MyContract{value: 1}()`,\n    - dynamic array creations calls (including `:::solidity bytes` and `:::solidity string`), e.g. `:::solidity new uint[](10)` or `:::solidity new bytes(10)`,\n    - event emit calls, e.g. `:::solidity MyEvent(1, 2)` in `emit MyEvent(1, 2)`,\n    - error revert calls, e.g. `:::solidity MyError(1, 2)` in `revert MyError(1, 2)`,\n    - variable getter calls.\n    \"\"\"\n\n    _ast_node: SolcFunctionCall\n    _parent: SolidityAbc  # TODO: make this more specific\n\n    _arguments: List[ExpressionAbc]\n    _expression: ExpressionAbc\n    _kind: FunctionCallKind\n    _names: List[str]\n    _try_call: bool\n\n    def __init__(\n        self, init: IrInitTuple, function_call: SolcFunctionCall, parent: SolidityAbc\n    ):\n        super().__init__(init, function_call, parent)\n        self._kind = function_call.kind\n        self._names = list(function_call.names)\n        self._try_call = function_call.try_call\n\n        self._expression = ExpressionAbc.from_ast(init, function_call.expression, self)\n        self._arguments = [\n            ExpressionAbc.from_ast(init, argument, self)\n            for argument in function_call.arguments\n        ]\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        for argument in self._arguments:\n            yield from argument\n        yield from self._expression\n\n    @property\n    def parent(self) -&gt; SolidityAbc:\n        return self._parent\n\n    @property\n    def kind(self) -&gt; FunctionCallKind:\n        \"\"\"\n        [FunctionCallKind.FUNCTION_CALL][wake.ir.enums.FunctionCallKind.FUNCTION_CALL] is except for\n        function calls also used for:\n\n        - contract construction using [NewExpression][wake.ir.expressions.new_expression.NewExpression]\n        - new dynamic array creation using [NewExpression][wake.ir.expressions.new_expression.NewExpression]\n        - variable getter calls\n\n        Returns:\n            Kind of function call.\n        \"\"\"\n        return self._kind\n\n    @property\n    def names(self) -&gt; Tuple[str, ...]:\n        \"\"\"\n        Is empty if the function call does not use named arguments.\n\n        !!! example\n            `(\"to\", \"value\")` for the following function call:\n            ```solidity\n            token.transfer({to: msg.sender, value: 100});\n            ```\n\n        Returns:\n            Tuple of names of the named arguments in the order they appear in the source code.\n        \"\"\"\n        return tuple(self._names)\n\n    @property\n    def try_call(self) -&gt; bool:\n        \"\"\"\n        !!! example\n            Is `True` for `this.foo()` in the following code:\n            ```solidity\n            try this.foo() {} catch {}\n            ```\n\n        Returns:\n            True if the function call is a try call, False otherwise.\n        \"\"\"\n        return self._try_call\n\n    @property\n    def expression(self) -&gt; ExpressionAbc:\n        \"\"\"\n        Returns:\n            Expression that evaluates to the function being called.\n        \"\"\"\n        return self._expression\n\n    @property\n    def arguments(self) -&gt; Tuple[ExpressionAbc, ...]:\n        \"\"\"\n        Returns:\n            Tuple of arguments of the function call in the order they appear in the source code.\n        \"\"\"\n        return tuple(self._arguments)\n\n    @property\n    @lru_cache(maxsize=2048)\n    def function_called(\n        self,\n    ) -&gt; Optional[\n        Union[\n            ContractDefinition,  # contract construction\n            ArrayTypeName,  # new dynamic array\n            ElementaryTypeName,  # new string or bytes\n            EventDefinition,\n            ErrorDefinition,\n            FunctionDefinition,\n            GlobalSymbol,\n            StructDefinition,\n            VariableDeclaration,\n        ]\n    ]:\n        if self.kind == FunctionCallKind.TYPE_CONVERSION:\n            return None\n\n        node = self.expression\n        while True:\n            if isinstance(node, Identifier):\n                referenced_declaration = node.referenced_declaration\n                if isinstance(\n                    referenced_declaration,\n                    (\n                        EventDefinition,\n                        ErrorDefinition,\n                        FunctionDefinition,\n                        GlobalSymbol,\n                        StructDefinition,\n                        VariableDeclaration,\n                    ),\n                ):\n                    return referenced_declaration\n                else:\n                    assert (\n                        False\n                    ), f\"Unexpected function call referenced declaration type: {referenced_declaration}\"\n            elif isinstance(node, MemberAccess):\n                referenced_declaration = node.referenced_declaration\n                if isinstance(\n                    referenced_declaration,\n                    (\n                        EventDefinition,\n                        ErrorDefinition,\n                        FunctionDefinition,\n                        GlobalSymbol,\n                        StructDefinition,\n                        VariableDeclaration,\n                    ),\n                ):\n                    return referenced_declaration\n                else:\n                    assert (\n                        False\n                    ), f\"Unexpected function call referenced declaration type: {referenced_declaration}\"\n            elif isinstance(node, FunctionCall):\n                node = node.expression\n                while isinstance(\n                    node, MemberAccess\n                ) and node.referenced_declaration in {\n                    GlobalSymbol.FUNCTION_VALUE,\n                    GlobalSymbol.FUNCTION_GAS,\n                }:\n                    node = node.expression\n            elif isinstance(node, FunctionCallOptions):\n                node = node.expression\n            elif isinstance(node, NewExpression):\n                type_name = node.type_name\n                if isinstance(type_name, (ArrayTypeName, ElementaryTypeName)):\n                    return type_name\n                elif isinstance(type_name, UserDefinedTypeName):\n                    assert isinstance(\n                        type_name.referenced_declaration, ContractDefinition\n                    )\n                    return type_name.referenced_declaration\n                else:\n                    assert (\n                        False\n                    ), f\"Unexpected function call child node: {node}\\n{self.source}\"\n            elif isinstance(node, TupleExpression):\n                if len(node.components) != 1:\n                    assert (\n                        False\n                    ), f\"Unexpected function call child node: {node}\\n{self.source}\"\n                node = node.components[0]\n            else:\n                assert (\n                    False\n                ), f\"Unexpected function call child node: {node}\\n{self.source}\"\n\n    @property\n    @lru_cache(maxsize=2048)\n    def is_ref_to_state_variable(self) -&gt; bool:\n        if self.kind == FunctionCallKind.TYPE_CONVERSION:\n            return self.expression.is_ref_to_state_variable\n        return False\n\n    @property\n    @cached_return_on_recursion(frozenset())\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        ret = self.expression.modifies_state | reduce(\n            or_, (arg.modifies_state for arg in self.arguments), set()\n        )\n\n        if self.kind == FunctionCallKind.FUNCTION_CALL:\n            called_function = self.function_called\n            if called_function in {\n                GlobalSymbol.SELFDESTRUCT,\n                GlobalSymbol.SUICIDE,\n            }:\n                ret |= {(self, ModifiesStateFlag.SELFDESTRUCTS)}\n            elif called_function in {\n                GlobalSymbol.ADDRESS_TRANSFER,\n                GlobalSymbol.ADDRESS_SEND,\n            }:\n                ret |= {(self, ModifiesStateFlag.SENDS_ETHER)}\n            elif called_function == GlobalSymbol.ADDRESS_CALL:\n                ret |= {(self, ModifiesStateFlag.PERFORMS_CALL)}\n            elif called_function == GlobalSymbol.ADDRESS_DELEGATECALL:\n                ret |= {(self, ModifiesStateFlag.PERFORMS_DELEGATECALL)}\n            elif (\n                called_function\n                in {\n                    GlobalSymbol.ARRAY_PUSH,\n                    GlobalSymbol.ARRAY_POP,\n                    GlobalSymbol.BYTES_PUSH,\n                    GlobalSymbol.BYTES_POP,\n                }\n                and self.expression.is_ref_to_state_variable\n            ):\n                ret |= {(self, ModifiesStateFlag.MODIFIES_STATE_VAR)}\n            elif called_function == GlobalSymbol.FUNCTION_VALUE:\n                ret |= {(self, ModifiesStateFlag.SENDS_ETHER)}\n            elif isinstance(called_function, FunctionDefinition):\n                if called_function.state_mutability in {\n                    StateMutability.PURE,\n                    StateMutability.VIEW,\n                }:\n                    pass\n                elif called_function.body is not None:\n                    ret |= called_function.body.modifies_state\n                    for modifier in called_function.modifiers:\n                        modifier_def = modifier.modifier_name.referenced_declaration\n                        assert isinstance(modifier_def, ModifierDefinition)\n                        if modifier_def.body is not None:\n                            ret |= modifier_def.body.modifies_state\n                elif called_function.state_mutability == StateMutability.NONPAYABLE:\n                    ret |= {\n                        (\n                            self,\n                            ModifiesStateFlag.CALLS_UNIMPLEMENTED_NONPAYABLE_FUNCTION,\n                        )\n                    }\n                elif called_function.state_mutability == StateMutability.PAYABLE:\n                    ret |= {\n                        (self, ModifiesStateFlag.CALLS_UNIMPLEMENTED_PAYABLE_FUNCTION)\n                    }\n                else:\n                    assert False\n        return ret\n</code></pre>"},{"location":"api-reference/ir/expressions/function-call/#wake.ir.expressions.function_call.FunctionCall.arguments","title":"<code>arguments: Tuple[ExpressionAbc, ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[ExpressionAbc, ...]</code> <p>Tuple of arguments of the function call in the order they appear in the source code.</p>"},{"location":"api-reference/ir/expressions/function-call/#wake.ir.expressions.function_call.FunctionCall.expression","title":"<code>expression: ExpressionAbc</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>ExpressionAbc</code> <p>Expression that evaluates to the function being called.</p>"},{"location":"api-reference/ir/expressions/function-call/#wake.ir.expressions.function_call.FunctionCall.kind","title":"<code>kind: FunctionCallKind</code>  <code>property</code>","text":"<p>FunctionCallKind.FUNCTION_CALL is except for function calls also used for:</p> <ul> <li>contract construction using NewExpression</li> <li>new dynamic array creation using NewExpression</li> <li>variable getter calls</li> </ul> <p>Returns:</p> Type Description <code>FunctionCallKind</code> <p>Kind of function call.</p>"},{"location":"api-reference/ir/expressions/function-call/#wake.ir.expressions.function_call.FunctionCall.names","title":"<code>names: Tuple[str, ...]</code>  <code>property</code>","text":"<p>Is empty if the function call does not use named arguments.</p> <p>Example</p> <p><code>(\"to\", \"value\")</code> for the following function call: <pre><code>token.transfer({to: msg.sender, value: 100});\n</code></pre></p> <p>Returns:</p> Type Description <code>Tuple[str, ...]</code> <p>Tuple of names of the named arguments in the order they appear in the source code.</p>"},{"location":"api-reference/ir/expressions/function-call/#wake.ir.expressions.function_call.FunctionCall.try_call","title":"<code>try_call: bool</code>  <code>property</code>","text":"<p>Example</p> <p>Is <code>True</code> for <code>this.foo()</code> in the following code: <pre><code>try this.foo() {} catch {}\n</code></pre></p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the function call is a try call, False otherwise.</p>"},{"location":"api-reference/ir/expressions/identifier/","title":"identifier","text":""},{"location":"api-reference/ir/expressions/identifier/#wake.ir.expressions.identifier","title":"<code>wake.ir.expressions.identifier</code>  <code>module</code>","text":""},{"location":"api-reference/ir/expressions/identifier/#wake.ir.expressions.identifier.Identifier","title":"<code>Identifier</code>  <code>class</code>","text":"<p>         Bases: <code>ExpressionAbc</code></p> <p>Represents a single identifier referencing a declaration (or multiple overloaded declarations).</p> Source code in <code>wake/ir/expressions/identifier.py</code> <pre><code>class Identifier(ExpressionAbc):\n    \"\"\"\n    Represents a single identifier referencing a declaration (or multiple overloaded declarations).\n    \"\"\"\n\n    _ast_node: SolcIdentifier\n    _parent: SolidityAbc  # TODO: make this more specific\n\n    _name: str\n    _overloaded_declarations: List[AstNodeId]\n    _referenced_declaration_ids: Set[AstNodeId]\n\n    def __init__(\n        self, init: IrInitTuple, identifier: SolcIdentifier, parent: SolidityAbc\n    ):\n        from ..meta.import_directive import ImportDirective\n\n        super().__init__(init, identifier, parent)\n        self._name = identifier.name\n        self._overloaded_declarations = list(identifier.overloaded_declarations)\n        if identifier.referenced_declaration is None:\n            assert isinstance(self._parent, ImportDirective)\n            self._referenced_declaration_ids = set()\n        else:\n            self._referenced_declaration_ids = {identifier.referenced_declaration}\n        init.reference_resolver.register_post_process_callback(\n            self._post_process, priority=-1\n        )\n\n    def _post_process(self, callback_params: CallbackParams):\n        from ..meta.import_directive import ImportDirective\n\n        new_referenced_declaration_ids = set()\n\n        for referenced_declaration_id in self._referenced_declaration_ids:\n            if referenced_declaration_id &lt; 0:\n                global_symbol = GlobalSymbol(referenced_declaration_id)\n                self._reference_resolver.register_global_symbol_reference(\n                    global_symbol, self\n                )\n                self._reference_resolver.register_destroy_callback(\n                    self.source_unit.file, partial(self._destroy, global_symbol)\n                )\n                new_referenced_declaration_ids.add(referenced_declaration_id)\n            else:\n                node = self._reference_resolver.resolve_node(\n                    referenced_declaration_id, self.source_unit.cu_hash\n                )\n\n                if isinstance(node, DeclarationAbc):\n                    node.register_reference(self)\n                    self._reference_resolver.register_destroy_callback(\n                        self.source_unit.file, partial(self._destroy, node)\n                    )\n                    new_referenced_declaration_ids.add(referenced_declaration_id)\n                elif isinstance(node, ImportDirective):\n                    # make this node to reference the source unit directly\n                    assert node.unit_alias is not None\n                    source_unit = callback_params.source_units[node.imported_file]\n                    node_path_order = self._reference_resolver.get_node_path_order(\n                        AstNodeId(source_unit.ast_node_id),\n                        source_unit.cu_hash,\n                    )\n                    new_referenced_declaration_ids.add(\n                        self._reference_resolver.get_ast_id_from_cu_node_path_order(\n                            node_path_order, self.source_unit.cu_hash\n                        )\n                    )\n                else:\n                    raise TypeError(f\"Unexpected type: {type(node)}\")\n\n        self._referenced_declaration_ids = new_referenced_declaration_ids\n\n    def _destroy(\n        self, referenced_declaration: Union[GlobalSymbol, DeclarationAbc]\n    ) -&gt; None:\n        if isinstance(referenced_declaration, GlobalSymbol):\n            self._reference_resolver.unregister_global_symbol_reference(\n                referenced_declaration, self\n            )\n        elif isinstance(referenced_declaration, DeclarationAbc):\n            referenced_declaration.unregister_reference(self)\n        else:\n            raise TypeError(f\"Unexpected type: {type(referenced_declaration)}\")\n\n    @property\n    def parent(self) -&gt; SolidityAbc:\n        return self._parent\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"\n        Returns:\n            Name of the referenced declaration.\n        \"\"\"\n        return self._name\n\n    @property\n    def overloaded_declarations(self) -&gt; FrozenSet[FunctionDefinition]:\n        \"\"\"\n        Returns:\n            Empty set if [referenced_declaration][wake.ir.expressions.identifier.Identifier.referenced_declaration] is not overloaded.\n                Otherwise, set of all overloaded declarations (including [referenced_declaration][wake.ir.expressions.identifier.Identifier.referenced_declaration]) with the same name as the identifier.\n        \"\"\"\n        from ..declarations.function_definition import FunctionDefinition\n\n        overloaded_declarations = set()\n        for overloaded_declaration_id in self._overloaded_declarations:\n            assert overloaded_declaration_id &gt;= 0\n\n            overloaded_declaration = self._reference_resolver.resolve_node(\n                overloaded_declaration_id, self.source_unit.cu_hash\n            )\n            assert isinstance(overloaded_declaration, FunctionDefinition)\n            overloaded_declarations.add(overloaded_declaration)\n\n        # fix overloaded declarations are not set for identifiers in ImportDirective symbol alias\n        if len(overloaded_declarations) == 0:\n            ref_decl = self.referenced_declaration\n            if isinstance(ref_decl, set):\n                return frozenset(ref_decl)\n\n        return frozenset(overloaded_declarations)\n\n    @property\n    def referenced_declaration(\n        self,\n    ) -&gt; Union[DeclarationAbc, GlobalSymbol, SourceUnit, FrozenSet[FunctionDefinition]]:\n        \"\"\"\n        If the referenced function name is overloaded and a single function cannot be inferred from the context, returns a set of all overloaded functions.\n        This is the case of identifiers in [ImportDirectives][wake.ir.meta.import_directive.ImportDirective].\n        In the following example, the identifier `max` in the example import directive references both `max` functions from `Math.sol`:\n\n        ```solidity title=\"Math.sol\"\n        function max(uint256 a, uint256 b) pure returns (uint256) {\n            return a &gt;= b ? a : b;\n        }\n        function max(int256 a, int256 b) pure returns (int256) {\n            return a &gt;= b ? a : b;\n        }\n        ```\n\n        ```solidity title=\"A.sol\"\n        import { max } from \"./Math.sol\";\n        ```\n\n        If the referenced function name is overloaded and a single function can be inferred from the context, returns the inferred function.\n\n        A [SourceUnit][wake.ir.meta.source_unit.SourceUnit] is returned if the identifier references a source unit alias defined in an [ImportDirective][wake.ir.meta.import_directive.ImportDirective].\n        For example, `Math` in `Math.max(-1, 2)` references the source unit `Math.sol`:\n\n        ```solidity\n        import \"./Math.sol\" as Math;\n\n        contract C {\n            function test() public {\n                Math.max(-1, 2);\n            }\n        }\n        ```\n\n        Returns:\n            Referenced declaration(s).\n        \"\"\"\n\n        def resolve(referenced_declaration_id: AstNodeId):\n            if referenced_declaration_id &lt; 0:\n                return GlobalSymbol(referenced_declaration_id)\n\n            node = self._reference_resolver.resolve_node(\n                referenced_declaration_id, self.source_unit.cu_hash\n            )\n            assert isinstance(\n                node, (DeclarationAbc, SourceUnit)\n            ), f\"Unexpected type: {type(node)}\\n{node.source}\\n{self.source}\\n{self.source_unit.file}\"\n            return node\n\n        from ..declarations.function_definition import FunctionDefinition\n        from ..meta.source_unit import SourceUnit\n\n        assert len(self._referenced_declaration_ids) != 0\n        if len(self._referenced_declaration_ids) == 1:\n            return resolve(next(iter(self._referenced_declaration_ids)))\n        else:\n            # Identifier in ImportDirective symbol alias referencing multiple overloaded functions\n            ret = set(map(resolve, self._referenced_declaration_ids))\n            assert all(isinstance(x, FunctionDefinition) for x in ret)\n            return ret  # pyright: ignore reportGeneralTypeIssues\n\n    @property\n    @lru_cache(maxsize=2048)\n    def is_ref_to_state_variable(self) -&gt; bool:\n        referenced_declaration = self.referenced_declaration\n        return (\n            isinstance(referenced_declaration, VariableDeclaration)\n            and referenced_declaration.is_state_variable\n        )\n\n    @property\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        return set()\n</code></pre>"},{"location":"api-reference/ir/expressions/identifier/#wake.ir.expressions.identifier.Identifier.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>Name of the referenced declaration.</p>"},{"location":"api-reference/ir/expressions/identifier/#wake.ir.expressions.identifier.Identifier.overloaded_declarations","title":"<code>overloaded_declarations: FrozenSet[FunctionDefinition]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>FrozenSet[FunctionDefinition]</code> <p>Empty set if referenced_declaration is not overloaded. Otherwise, set of all overloaded declarations (including referenced_declaration) with the same name as the identifier.</p>"},{"location":"api-reference/ir/expressions/identifier/#wake.ir.expressions.identifier.Identifier.referenced_declaration","title":"<code>referenced_declaration: Union[DeclarationAbc, GlobalSymbol, SourceUnit, FrozenSet[FunctionDefinition]]</code>  <code>property</code>","text":"<p>If the referenced function name is overloaded and a single function cannot be inferred from the context, returns a set of all overloaded functions. This is the case of identifiers in ImportDirectives. In the following example, the identifier <code>max</code> in the example import directive references both <code>max</code> functions from <code>Math.sol</code>:</p> Math.sol<pre><code>function max(uint256 a, uint256 b) pure returns (uint256) {\n    return a &gt;= b ? a : b;\n}\nfunction max(int256 a, int256 b) pure returns (int256) {\n    return a &gt;= b ? a : b;\n}\n</code></pre> A.sol<pre><code>import { max } from \"./Math.sol\";\n</code></pre> <p>If the referenced function name is overloaded and a single function can be inferred from the context, returns the inferred function.</p> <p>A SourceUnit is returned if the identifier references a source unit alias defined in an ImportDirective. For example, <code>Math</code> in <code>Math.max(-1, 2)</code> references the source unit <code>Math.sol</code>:</p> <pre><code>import \"./Math.sol\" as Math;\n\ncontract C {\n    function test() public {\n        Math.max(-1, 2);\n    }\n}\n</code></pre> <p>Returns:</p> Type Description <code>Union[DeclarationAbc, GlobalSymbol, SourceUnit, FrozenSet[FunctionDefinition]]</code> <p>Referenced declaration(s).</p>"},{"location":"api-reference/ir/expressions/index-access/","title":"index_access","text":""},{"location":"api-reference/ir/expressions/index-access/#wake.ir.expressions.index_access","title":"<code>wake.ir.expressions.index_access</code>  <code>module</code>","text":""},{"location":"api-reference/ir/expressions/index-access/#wake.ir.expressions.index_access.IndexAccess","title":"<code>IndexAccess</code>  <code>class</code>","text":"<p>         Bases: <code>ExpressionAbc</code></p> <p>Represents an index access to an array, bytes or mapping.</p> Source code in <code>wake/ir/expressions/index_access.py</code> <pre><code>class IndexAccess(ExpressionAbc):\n    \"\"\"\n    Represents an index access to an array, bytes or mapping.\n    \"\"\"\n\n    _ast_node: SolcIndexAccess\n    _parent: SolidityAbc  # TODO: make this more specific\n\n    _base_expression: ExpressionAbc\n    _index_expression: Optional[ExpressionAbc]\n\n    def __init__(\n        self, init: IrInitTuple, index_access: SolcIndexAccess, parent: SolidityAbc\n    ):\n        super().__init__(init, index_access, parent)\n        self._base_expression = ExpressionAbc.from_ast(\n            init, index_access.base_expression, self\n        )\n\n        if index_access.index_expression is None:\n            self._index_expression = None\n        else:\n            self._index_expression = ExpressionAbc.from_ast(\n                init, index_access.index_expression, self\n            )\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        yield from self._base_expression\n        if self._index_expression is not None:\n            yield from self._index_expression\n\n    @property\n    def parent(self) -&gt; SolidityAbc:\n        return self._parent\n\n    @property\n    def base_expression(self) -&gt; ExpressionAbc:\n        \"\"\"\n        Returns:\n            Base expression being indexed.\n        \"\"\"\n        return self._base_expression\n\n    @property\n    def index_expression(self) -&gt; Optional[ExpressionAbc]:\n        \"\"\"\n        !!! example\n            Is `None` for `:::solidity uint[]` in the following example:\n\n            ```solidity\n            abi.decode(data, (uint[]))\n            ```\n\n        Returns:\n            Index expression or `None` if the index is not specified.\n        \"\"\"\n        return self._index_expression\n\n    @property\n    @lru_cache(maxsize=2048)\n    def is_ref_to_state_variable(self) -&gt; bool:\n        return self.base_expression.is_ref_to_state_variable\n\n    @property\n    @lru_cache(maxsize=2048)\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        ret = self.base_expression.modifies_state\n        if self.index_expression is not None:\n            ret |= self.index_expression.modifies_state\n        return ret\n</code></pre>"},{"location":"api-reference/ir/expressions/index-access/#wake.ir.expressions.index_access.IndexAccess.base_expression","title":"<code>base_expression: ExpressionAbc</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>ExpressionAbc</code> <p>Base expression being indexed.</p>"},{"location":"api-reference/ir/expressions/index-access/#wake.ir.expressions.index_access.IndexAccess.index_expression","title":"<code>index_expression: Optional[ExpressionAbc]</code>  <code>property</code>","text":"<p>Example</p> <p>Is <code>None</code> for <code>uint[]</code> in the following example:</p> <pre><code>abi.decode(data, (uint[]))\n</code></pre> <p>Returns:</p> Type Description <code>Optional[ExpressionAbc]</code> <p>Index expression or <code>None</code> if the index is not specified.</p>"},{"location":"api-reference/ir/expressions/index-range-access/","title":"index_range_access","text":""},{"location":"api-reference/ir/expressions/index-range-access/#wake.ir.expressions.index_range_access","title":"<code>wake.ir.expressions.index_range_access</code>  <code>module</code>","text":""},{"location":"api-reference/ir/expressions/index-range-access/#wake.ir.expressions.index_range_access.IndexRangeAccess","title":"<code>IndexRangeAccess</code>  <code>class</code>","text":"<p>         Bases: <code>ExpressionAbc</code></p> <p>Represents an index range access to a dynamic calldata array (other types are not currently supported). Both start and end indices are optional.</p> <p>Example</p> <p><code>arr[1:2]</code> in the following example: <pre><code>function foo(uint[] calldata arr) external {\n    arr[1:2];\n}\n</code></pre></p> Source code in <code>wake/ir/expressions/index_range_access.py</code> <pre><code>class IndexRangeAccess(ExpressionAbc):\n    \"\"\"\n    Represents an index range access to a dynamic calldata array (other types are not currently supported).\n    Both start and end indices are optional.\n\n    !!! example\n        `:::solidity arr[1:2]` in the following example:\n        ```solidity\n        function foo(uint[] calldata arr) external {\n            arr[1:2];\n        }\n        ```\n    \"\"\"\n\n    _ast_node: SolcIndexRangeAccess\n    _parent: SolidityAbc  # TODO: make this more specific\n\n    _base_expression: ExpressionAbc\n    _start_expression: Optional[ExpressionAbc]\n    _end_expression: Optional[ExpressionAbc]\n\n    def __init__(\n        self,\n        init: IrInitTuple,\n        index_range_access: SolcIndexRangeAccess,\n        parent: SolidityAbc,\n    ):\n        super().__init__(init, index_range_access, parent)\n        self._base_expression = ExpressionAbc.from_ast(\n            init, index_range_access.base_expression, self\n        )\n\n        if index_range_access.start_expression is None:\n            self._start_expression = None\n        else:\n            self._start_expression = ExpressionAbc.from_ast(\n                init, index_range_access.start_expression, self\n            )\n\n        if index_range_access.end_expression is None:\n            self._end_expression = None\n        else:\n            self._end_expression = ExpressionAbc.from_ast(\n                init, index_range_access.end_expression, self\n            )\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        yield from self._base_expression\n        if self._start_expression is not None:\n            yield from self._start_expression\n        if self._end_expression is not None:\n            yield from self._end_expression\n\n    @property\n    def parent(self) -&gt; SolidityAbc:\n        return self._parent\n\n    @property\n    def base_expression(self) -&gt; ExpressionAbc:\n        \"\"\"\n        Returns:\n            Calldata array expression being indexed.\n        \"\"\"\n        return self._base_expression\n\n    @property\n    def start_expression(self) -&gt; Optional[ExpressionAbc]:\n        \"\"\"\n        If not specified, the start index is assumed to be `0`.\n\n        Returns:\n            Start expression or `None` if the start index is not specified.\n        \"\"\"\n        return self._start_expression\n\n    @property\n    def end_expression(self) -&gt; Optional[ExpressionAbc]:\n        \"\"\"\n        If not specified, the end index is assumed to be the length of the array.\n\n        Returns:\n            End expression or `None` if the end index is not specified.\n        \"\"\"\n        return self._end_expression\n\n    @property\n    def is_ref_to_state_variable(self) -&gt; bool:\n        # index range access in only supported for dynamic calldata arrays\n        return False\n\n    @property\n    @lru_cache(maxsize=2048)\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        ret = self.base_expression.modifies_state\n        if self.start_expression is not None:\n            ret |= self.start_expression.modifies_state\n        if self.end_expression is not None:\n            ret |= self.end_expression.modifies_state\n        return ret\n</code></pre>"},{"location":"api-reference/ir/expressions/index-range-access/#wake.ir.expressions.index_range_access.IndexRangeAccess.base_expression","title":"<code>base_expression: ExpressionAbc</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>ExpressionAbc</code> <p>Calldata array expression being indexed.</p>"},{"location":"api-reference/ir/expressions/index-range-access/#wake.ir.expressions.index_range_access.IndexRangeAccess.end_expression","title":"<code>end_expression: Optional[ExpressionAbc]</code>  <code>property</code>","text":"<p>If not specified, the end index is assumed to be the length of the array.</p> <p>Returns:</p> Type Description <code>Optional[ExpressionAbc]</code> <p>End expression or <code>None</code> if the end index is not specified.</p>"},{"location":"api-reference/ir/expressions/index-range-access/#wake.ir.expressions.index_range_access.IndexRangeAccess.start_expression","title":"<code>start_expression: Optional[ExpressionAbc]</code>  <code>property</code>","text":"<p>If not specified, the start index is assumed to be <code>0</code>.</p> <p>Returns:</p> Type Description <code>Optional[ExpressionAbc]</code> <p>Start expression or <code>None</code> if the start index is not specified.</p>"},{"location":"api-reference/ir/expressions/literal/","title":"literal","text":""},{"location":"api-reference/ir/expressions/literal/#wake.ir.expressions.literal","title":"<code>wake.ir.expressions.literal</code>  <code>module</code>","text":""},{"location":"api-reference/ir/expressions/literal/#wake.ir.expressions.literal.Literal","title":"<code>Literal</code>  <code>class</code>","text":"<p>         Bases: <code>ExpressionAbc</code></p> <p>May represent a literal of the following types (see LiteralKind):</p> <ul> <li>boolean, e.g. <code>true</code>, <code>false</code>,</li> <li>integer, e.g. <code>-1</code>, <code>.2</code>, <code>3e10</code>, <code>123_456</code>, <code>0x123</code>, <code>1_002e34</code>,</li> <li>string, e.g. <code>\"Hello World!\"</code>,</li> <li>hex string, e.g. <code>hex\"1234aabb\"</code>,</li> <li>unicode string, e.g. <code>unicode\"Hello World! \ud83d\ude03\"</code>,</li> </ul> Source code in <code>wake/ir/expressions/literal.py</code> <pre><code>class Literal(ExpressionAbc):\n    \"\"\"\n    May represent a literal of the following types (see [LiteralKind][wake.ir.enums.LiteralKind]):\n\n    - boolean, e.g. `true`, `false`,\n    - integer, e.g. `-1`, `.2`, `3e10`, `123_456`, `0x123`, `1_002e34`,\n    - string, e.g. `\"Hello World!\"`,\n    - hex string, e.g. `hex\"1234aabb\"`,\n    - unicode string, e.g. `unicode\"Hello World! \ud83d\ude03\"`,\n    \"\"\"\n\n    _ast_node: SolcLiteral\n    _parent: SolidityAbc  # TODO: make this more specific\n\n    _hex_value: bytes\n    _kind: LiteralKind\n    _subdenomination: Optional[str]\n    _value: Optional[str]\n\n    def __init__(self, init: IrInitTuple, literal: SolcLiteral, parent: SolidityAbc):\n        super().__init__(init, literal, parent)\n        self._hex_value = bytes.fromhex(literal.hex_value)\n        self._kind = literal.kind\n        self._subdenomination = literal.subdenomination\n        self._value = literal.value\n\n        # fix prior to 0.7.0 hex string literals had kind `string` instead of `hexString`\n        if self._value is None:\n            self._kind = LiteralKind.HEX_STRING\n\n    @property\n    def parent(self) -&gt; SolidityAbc:\n        return self._parent\n\n    @property\n    def hex_value(self) -&gt; bytes:\n        \"\"\"\n        !!! important\n            Does not return the hexadecimal representation, but rather the [value][wake.ir.expressions.literal.Literal.value] encoded into bytes.\n            For example, `hex\"1234aabb\"` would return `b'\\x124\\xaa\\xbb'` and `.2` would return `b'.2'`.\n\n        Returns:\n            Hex string literal value.\n        \"\"\"\n        return self._hex_value\n\n    @property\n    def kind(self) -&gt; LiteralKind:\n        \"\"\"\n        Returns:\n            Literal kind.\n        \"\"\"\n        return self._kind\n\n    @property\n    def subdenomination(self) -&gt; Optional[str]:\n        \"\"\"\n        !!! example\n            For example `wei`, `ether`, `seconds`, `days`, etc.\n\n        Returns:\n            Literal subdenomination, if any.\n        \"\"\"\n        return self._subdenomination\n\n    @property\n    def value(self) -&gt; Optional[str]:\n        \"\"\"\n        Is `None` for hex string literals.\n\n        Returns:\n            Literal value.\n        \"\"\"\n        return self._value\n\n    @property\n    def is_ref_to_state_variable(self) -&gt; bool:\n        return False\n\n    @property\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        return set()\n</code></pre>"},{"location":"api-reference/ir/expressions/literal/#wake.ir.expressions.literal.Literal.hex_value","title":"<code>hex_value: bytes</code>  <code>property</code>","text":"<p>Important</p> <p>Does not return the hexadecimal representation, but rather the value encoded into bytes. For example, <code>hex\"1234aabb\"</code> would return <code>b'\u00124\u00aa\u00bb'</code> and <code>.2</code> would return <code>b'.2'</code>.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>Hex string literal value.</p>"},{"location":"api-reference/ir/expressions/literal/#wake.ir.expressions.literal.Literal.kind","title":"<code>kind: LiteralKind</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>LiteralKind</code> <p>Literal kind.</p>"},{"location":"api-reference/ir/expressions/literal/#wake.ir.expressions.literal.Literal.subdenomination","title":"<code>subdenomination: Optional[str]</code>  <code>property</code>","text":"<p>Example</p> <p>For example <code>wei</code>, <code>ether</code>, <code>seconds</code>, <code>days</code>, etc.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Literal subdenomination, if any.</p>"},{"location":"api-reference/ir/expressions/literal/#wake.ir.expressions.literal.Literal.value","title":"<code>value: Optional[str]</code>  <code>property</code>","text":"<p>Is <code>None</code> for hex string literals.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Literal value.</p>"},{"location":"api-reference/ir/expressions/member-access/","title":"member_access","text":""},{"location":"api-reference/ir/expressions/member-access/#wake.ir.expressions.member_access","title":"<code>wake.ir.expressions.member_access</code>  <code>module</code>","text":""},{"location":"api-reference/ir/expressions/member-access/#wake.ir.expressions.member_access.MemberAccess","title":"<code>MemberAccess</code>  <code>class</code>","text":"<p>         Bases: <code>ExpressionAbc</code></p> <p>Represents a member access using the dot notation.</p> Source code in <code>wake/ir/expressions/member_access.py</code> <pre><code>class MemberAccess(ExpressionAbc):\n    \"\"\"\n    Represents a member access using the dot notation.\n    \"\"\"\n\n    _ast_node: SolcMemberAccess\n    _parent: SolidityAbc  # TODO: make this more specific\n\n    _expression: ExpressionAbc\n    _member_name: str\n    _referenced_declaration_id: Optional[AstNodeId]\n\n    def __init__(\n        self, init: IrInitTuple, member_access: SolcMemberAccess, parent: SolidityAbc\n    ):\n        super().__init__(init, member_access, parent)\n        self._expression = ExpressionAbc.from_ast(init, member_access.expression, self)\n        assert self._expression.byte_location[0] == self.byte_location[0]\n        assert self._expression.byte_location[1] &lt; self.byte_location[1]\n\n        self._member_name = member_access.member_name\n        self._referenced_declaration_id = member_access.referenced_declaration\n\n        self._reference_resolver.register_post_process_callback(\n            self._post_process, priority=-1\n        )\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        yield from self._expression\n\n    def _post_process(self, callback_params: CallbackParams):\n        # workaround for enum value bug in Solidity versions prior to 0.8.2\n        if self._referenced_declaration_id is None:\n            if isinstance(self._expression, Identifier) or (\n                isinstance(self._expression, MemberAccess)\n                and self._expression._referenced_declaration_id is not None\n            ):\n                referenced_declaration = self._expression.referenced_declaration\n                if isinstance(referenced_declaration, EnumDefinition):\n                    for enum_value in referenced_declaration.values:\n                        if enum_value.name == self._member_name:\n                            node_path_order = (\n                                self._reference_resolver.get_node_path_order(\n                                    AstNodeId(enum_value.ast_node_id),\n                                    enum_value.source_unit.cu_hash,\n                                )\n                            )\n                            this_cu_id = self._reference_resolver.get_ast_id_from_cu_node_path_order(\n                                node_path_order, self.source_unit.cu_hash\n                            )\n                            self._referenced_declaration_id = this_cu_id\n                            break\n\n        if self._referenced_declaration_id is None:\n            expr_type = self.expression.type\n\n            if isinstance(expr_type, Address):\n                if self.member_name == \"balance\":\n                    self._referenced_declaration_id = AstNodeId(\n                        GlobalSymbol.ADDRESS_BALANCE\n                    )\n                elif self.member_name == \"code\":\n                    self._referenced_declaration_id = AstNodeId(\n                        GlobalSymbol.ADDRESS_CODE\n                    )\n                elif self.member_name == \"codehash\":\n                    self._referenced_declaration_id = AstNodeId(\n                        GlobalSymbol.ADDRESS_CODEHASH\n                    )\n                elif self.member_name == \"transfer\":\n                    self._referenced_declaration_id = AstNodeId(\n                        GlobalSymbol.ADDRESS_TRANSFER\n                    )\n                elif self.member_name == \"send\":\n                    self._referenced_declaration_id = AstNodeId(\n                        GlobalSymbol.ADDRESS_SEND\n                    )\n                elif self.member_name == \"call\":\n                    self._referenced_declaration_id = AstNodeId(\n                        GlobalSymbol.ADDRESS_CALL\n                    )\n                elif self.member_name == \"delegatecall\":\n                    self._referenced_declaration_id = AstNodeId(\n                        GlobalSymbol.ADDRESS_DELEGATECALL\n                    )\n                elif self.member_name == \"staticcall\":\n                    self._referenced_declaration_id = AstNodeId(\n                        GlobalSymbol.ADDRESS_STATICCALL\n                    )\n                else:\n                    assert False, f\"Unknown address member: {self.member_name}\"\n            elif isinstance(expr_type, Array):\n                if self.member_name == \"length\":\n                    self._referenced_declaration_id = AstNodeId(\n                        GlobalSymbol.ARRAY_LENGTH\n                    )\n                elif self.member_name == \"push\":\n                    self._referenced_declaration_id = AstNodeId(GlobalSymbol.ARRAY_PUSH)\n                elif self.member_name == \"pop\":\n                    self._referenced_declaration_id = AstNodeId(GlobalSymbol.ARRAY_POP)\n                else:\n                    assert False, f\"Unknown array member: {self.member_name}\"\n            elif isinstance(expr_type, (Bytes, FixedBytes)):\n                if self.member_name == \"length\":\n                    self._referenced_declaration_id = AstNodeId(\n                        GlobalSymbol.BYTES_LENGTH\n                    )\n                elif self.member_name == \"push\":\n                    self._referenced_declaration_id = AstNodeId(GlobalSymbol.BYTES_PUSH)\n                elif self.member_name == \"pop\":\n                    self._referenced_declaration_id = AstNodeId(GlobalSymbol.BYTES_POP)\n                else:\n                    assert False, f\"Unknown bytes member: {self.member_name}\"\n            elif isinstance(expr_type, Function):\n                if self.member_name == \"selector\":\n                    self._referenced_declaration_id = AstNodeId(\n                        GlobalSymbol.FUNCTION_SELECTOR\n                    )\n                elif self.member_name == \"value\":\n                    self._referenced_declaration_id = AstNodeId(\n                        GlobalSymbol.FUNCTION_VALUE\n                    )\n                elif self.member_name == \"gas\":\n                    self._referenced_declaration_id = AstNodeId(\n                        GlobalSymbol.FUNCTION_GAS\n                    )\n                elif self.member_name == \"address\":\n                    self._referenced_declaration_id = AstNodeId(\n                        GlobalSymbol.FUNCTION_ADDRESS\n                    )\n                else:\n                    assert False, f\"Unknown function member: {self.member_name}\"\n            elif isinstance(expr_type, Magic):\n                if expr_type.kind == MagicTypeKind.BLOCK:\n                    if self.member_name == \"basefee\":\n                        self._referenced_declaration_id = AstNodeId(\n                            GlobalSymbol.BLOCK_BASEFEE\n                        )\n                    elif self.member_name == \"chainid\":\n                        self._referenced_declaration_id = AstNodeId(\n                            GlobalSymbol.BLOCK_CHAINID\n                        )\n                    elif self.member_name == \"coinbase\":\n                        self._referenced_declaration_id = AstNodeId(\n                            GlobalSymbol.BLOCK_COINBASE\n                        )\n                    elif self.member_name == \"difficulty\":\n                        self._referenced_declaration_id = AstNodeId(\n                            GlobalSymbol.BLOCK_DIFFICULTY\n                        )\n                    elif self.member_name == \"gaslimit\":\n                        self._referenced_declaration_id = AstNodeId(\n                            GlobalSymbol.BLOCK_GASLIMIT\n                        )\n                    elif self.member_name == \"number\":\n                        self._referenced_declaration_id = AstNodeId(\n                            GlobalSymbol.BLOCK_NUMBER\n                        )\n                    elif self.member_name == \"timestamp\":\n                        self._referenced_declaration_id = AstNodeId(\n                            GlobalSymbol.BLOCK_TIMESTAMP\n                        )\n                    elif self.member_name == \"prevrandao\":\n                        self._referenced_declaration_id = AstNodeId(\n                            GlobalSymbol.BLOCK_PREVRANDAO\n                        )\n                    elif self.member_name == \"blobbasefee\":\n                        self._referenced_declaration_id = AstNodeId(\n                            GlobalSymbol.BLOCK_BLOBBASEFEE\n                        )\n                    else:\n                        assert False, f\"Unknown block member {self.member_name}\"\n                elif expr_type.kind == MagicTypeKind.MESSAGE:\n                    if self.member_name == \"data\":\n                        self._referenced_declaration_id = AstNodeId(\n                            GlobalSymbol.MSG_DATA\n                        )\n                    elif self.member_name == \"sender\":\n                        self._referenced_declaration_id = AstNodeId(\n                            GlobalSymbol.MSG_SENDER\n                        )\n                    elif self.member_name == \"sig\":\n                        self._referenced_declaration_id = AstNodeId(\n                            GlobalSymbol.MSG_SIG\n                        )\n                    elif self.member_name == \"value\":\n                        self._referenced_declaration_id = AstNodeId(\n                            GlobalSymbol.MSG_VALUE\n                        )\n                    else:\n                        assert False, f\"Unknown msg member {self.member_name}\"\n                elif expr_type.kind == MagicTypeKind.TRANSACTION:\n                    if self.member_name == \"gasprice\":\n                        self._referenced_declaration_id = AstNodeId(\n                            GlobalSymbol.TX_GASPRICE\n                        )\n                    elif self.member_name == \"origin\":\n                        self._referenced_declaration_id = AstNodeId(\n                            GlobalSymbol.TX_ORIGIN\n                        )\n                    else:\n                        assert False, f\"Unknown tx member {self.member_name}\"\n                elif expr_type.kind == MagicTypeKind.ABI:\n                    if self.member_name == \"decode\":\n                        self._referenced_declaration_id = AstNodeId(\n                            GlobalSymbol.ABI_DECODE\n                        )\n                    elif self.member_name == \"encode\":\n                        self._referenced_declaration_id = AstNodeId(\n                            GlobalSymbol.ABI_ENCODE\n                        )\n                    elif self.member_name == \"encodePacked\":\n                        self._referenced_declaration_id = AstNodeId(\n                            GlobalSymbol.ABI_ENCODE_PACKED\n                        )\n                    elif self.member_name == \"encodeWithSelector\":\n                        self._referenced_declaration_id = AstNodeId(\n                            GlobalSymbol.ABI_ENCODE_WITH_SELECTOR\n                        )\n                    elif self.member_name == \"encodeWithSignature\":\n                        self._referenced_declaration_id = AstNodeId(\n                            GlobalSymbol.ABI_ENCODE_WITH_SIGNATURE\n                        )\n                    elif self.member_name == \"encodeCall\":\n                        self._referenced_declaration_id = AstNodeId(\n                            GlobalSymbol.ABI_ENCODE_CALL\n                        )\n                    else:\n                        assert False, f\"Unknown abi member {self.member_name}\"\n                elif expr_type.kind == MagicTypeKind.META_TYPE:\n                    if self.member_name == \"name\":\n                        self._referenced_declaration_id = AstNodeId(\n                            GlobalSymbol.TYPE_NAME\n                        )\n                    elif self.member_name == \"creationCode\":\n                        self._referenced_declaration_id = AstNodeId(\n                            GlobalSymbol.TYPE_CREATION_CODE\n                        )\n                    elif self.member_name == \"runtimeCode\":\n                        self._referenced_declaration_id = AstNodeId(\n                            GlobalSymbol.TYPE_RUNTIME_CODE\n                        )\n                    elif self.member_name == \"interfaceId\":\n                        self._referenced_declaration_id = AstNodeId(\n                            GlobalSymbol.TYPE_INTERFACE_ID\n                        )\n                    elif self.member_name == \"min\":\n                        self._referenced_declaration_id = AstNodeId(\n                            GlobalSymbol.TYPE_MIN\n                        )\n                    elif self.member_name == \"max\":\n                        self._referenced_declaration_id = AstNodeId(\n                            GlobalSymbol.TYPE_MAX\n                        )\n                    else:\n                        assert False, f\"Unknown type member {self.member_name}\"\n            elif isinstance(expr_type, Type):\n                if isinstance(expr_type.actual_type, Bytes):\n                    if self.member_name == \"concat\":\n                        self._referenced_declaration_id = AstNodeId(\n                            GlobalSymbol.BYTES_CONCAT\n                        )\n                    else:\n                        assert False, f\"Unknown bytes member {self.member_name}\"\n                elif isinstance(expr_type.actual_type, String):\n                    if self.member_name == \"concat\":\n                        self._referenced_declaration_id = AstNodeId(\n                            GlobalSymbol.STRING_CONCAT\n                        )\n                    else:\n                        assert False, f\"Unknown string member {self.member_name}\"\n                elif isinstance(expr_type.actual_type, UserDefinedValueType):\n                    if self.member_name == \"wrap\":\n                        self._referenced_declaration_id = AstNodeId(\n                            GlobalSymbol.USER_DEFINED_VALUE_TYPE_WRAP\n                        )\n                    elif self.member_name == \"unwrap\":\n                        self._referenced_declaration_id = AstNodeId(\n                            GlobalSymbol.USER_DEFINED_VALUE_TYPE_UNWRAP\n                        )\n                    else:\n                        assert (\n                            False\n                        ), f\"Unknown user defined value type member {self.member_name}\"\n                else:\n                    assert (\n                        False\n                    ), f\"Unknown type member {self.member_name} {expr_type.actual_type}\"\n\n        assert (\n            self._referenced_declaration_id is not None\n        ), f\"Unknown member {self.member_name}\"\n\n        if self._referenced_declaration_id &lt; 0:\n            global_symbol = GlobalSymbol(self._referenced_declaration_id)\n            self._reference_resolver.register_global_symbol_reference(\n                global_symbol, self\n            )\n            self._reference_resolver.register_destroy_callback(\n                self.source_unit.file, partial(self._destroy, global_symbol)\n            )\n        else:\n            node = self._reference_resolver.resolve_node(\n                self._referenced_declaration_id, self.source_unit.cu_hash\n            )\n\n            if isinstance(node, DeclarationAbc):\n                node.register_reference(self)\n                self._reference_resolver.register_destroy_callback(\n                    self.source_unit.file, partial(self._destroy, node)\n                )\n            elif isinstance(node, ImportDirective):\n                # make this node to reference the source unit directly\n                assert node.unit_alias is not None\n                source_unit = callback_params.source_units[node.imported_file]\n                node_path_order = self._reference_resolver.get_node_path_order(\n                    AstNodeId(source_unit.ast_node_id),\n                    source_unit.cu_hash,\n                )\n                self._referenced_declaration_id = (\n                    self._reference_resolver.get_ast_id_from_cu_node_path_order(\n                        node_path_order, self.source_unit.cu_hash\n                    )\n                )\n            else:\n                raise TypeError(f\"Unexpected type: {type(node)}\")\n\n    def _destroy(\n        self, referenced_declaration: Union[GlobalSymbol, DeclarationAbc]\n    ) -&gt; None:\n        if isinstance(referenced_declaration, GlobalSymbol):\n            self._reference_resolver.unregister_global_symbol_reference(\n                referenced_declaration, self\n            )\n        elif isinstance(referenced_declaration, DeclarationAbc):\n            referenced_declaration.unregister_reference(self)\n        else:\n            raise TypeError(f\"Unexpected type: {type(referenced_declaration)}\")\n\n    @property\n    def parent(self) -&gt; SolidityAbc:\n        return self._parent\n\n    @property\n    def expression(self) -&gt; ExpressionAbc:\n        \"\"\"\n        Returns:\n            Expression, whose member is accessed.\n        \"\"\"\n        return self._expression\n\n    @property\n    def member_name(self) -&gt; str:\n        \"\"\"\n        Returns:\n            Name of the member being accessed.\n        \"\"\"\n        return self._member_name\n\n    @property\n    @lru_cache(maxsize=2048)\n    def member_location(self) -&gt; Tuple[int, int]:\n        \"\"\"\n        In the case of [MemberAccess][wake.ir.expressions.member_access.MemberAccess], [byte_location][wake.ir.abc.IrAbc.byte_location] returns the byte location including the expression, whose member is accessed.\n        This property returns the byte location of the member name only.\n\n        Returns:\n            Byte location of the member name.\n        \"\"\"\n        relative_expression_end = (\n            self._expression.byte_location[1] - self.byte_location[0]\n        )\n        source = bytearray(self._source[relative_expression_end:])\n        _, stripped_sums = SoliditySourceParser.strip_comments(source)\n\n        match = MEMBER_RE.match(source)\n        assert match\n\n        if len(stripped_sums) == 0:\n            stripped = 0\n        else:\n            index = bisect([s[0] for s in stripped_sums], match.start(\"member\"))\n            if index == 0:\n                stripped = 0\n            else:\n                stripped = stripped_sums[index - 1][1]\n\n        return (\n            self._expression.byte_location[1] + match.start(\"member\") + stripped,\n            self._expression.byte_location[1] + match.end(\"member\") + stripped,\n        )\n\n    @property\n    def referenced_declaration(\n        self,\n    ) -&gt; Union[DeclarationAbc, GlobalSymbol, SourceUnit]:\n        \"\"\"\n        Returns:\n            Referenced declaration.\n        \"\"\"\n        assert self._referenced_declaration_id is not None\n        if self._referenced_declaration_id &lt; 0:\n            return GlobalSymbol(self._referenced_declaration_id)\n\n        node = self._reference_resolver.resolve_node(\n            self._referenced_declaration_id, self.source_unit.cu_hash\n        )\n        assert isinstance(node, (DeclarationAbc, SourceUnit))\n        return node\n\n    @property\n    @lru_cache(maxsize=2048)\n    def is_ref_to_state_variable(self) -&gt; bool:\n        referenced_declaration = self.referenced_declaration\n        return (\n            isinstance(referenced_declaration, VariableDeclaration)\n            and referenced_declaration.is_state_variable\n            or self.expression.is_ref_to_state_variable\n        )\n\n    @property\n    @lru_cache(maxsize=2048)\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        return self.expression.modifies_state\n</code></pre>"},{"location":"api-reference/ir/expressions/member-access/#wake.ir.expressions.member_access.MemberAccess.expression","title":"<code>expression: ExpressionAbc</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>ExpressionAbc</code> <p>Expression, whose member is accessed.</p>"},{"location":"api-reference/ir/expressions/member-access/#wake.ir.expressions.member_access.MemberAccess.member_location","title":"<code>member_location: Tuple[int, int]</code>  <code>cached</code> <code>property</code>","text":"<p>In the case of MemberAccess, byte_location returns the byte location including the expression, whose member is accessed. This property returns the byte location of the member name only.</p> <p>Returns:</p> Type Description <code>Tuple[int, int]</code> <p>Byte location of the member name.</p>"},{"location":"api-reference/ir/expressions/member-access/#wake.ir.expressions.member_access.MemberAccess.member_name","title":"<code>member_name: str</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>Name of the member being accessed.</p>"},{"location":"api-reference/ir/expressions/member-access/#wake.ir.expressions.member_access.MemberAccess.referenced_declaration","title":"<code>referenced_declaration: Union[DeclarationAbc, GlobalSymbol, SourceUnit]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[DeclarationAbc, GlobalSymbol, SourceUnit]</code> <p>Referenced declaration.</p>"},{"location":"api-reference/ir/expressions/new-expression/","title":"new_expression","text":""},{"location":"api-reference/ir/expressions/new-expression/#wake.ir.expressions.new_expression","title":"<code>wake.ir.expressions.new_expression</code>  <code>module</code>","text":""},{"location":"api-reference/ir/expressions/new-expression/#wake.ir.expressions.new_expression.NewExpression","title":"<code>NewExpression</code>  <code>class</code>","text":"<p>         Bases: <code>ExpressionAbc</code></p> <p>A new expression may create:</p> <ul> <li>a new contract, e.g. <code>new ERC20()</code>,</li> <li>a new array, e.g. <code>new uint[](10)</code>,</li> <li>a new <code>bytes</code> or <code>string</code>, e.g. <code>new bytes(10)</code>.</li> </ul> Source code in <code>wake/ir/expressions/new_expression.py</code> <pre><code>class NewExpression(ExpressionAbc):\n    \"\"\"\n    A new expression may create:\n\n    - a new contract, e.g. `:::solidity new ERC20()`,\n    - a new array, e.g. `:::solidity new uint[](10)`,\n    - a new `:::solidity bytes` or `:::solidity string`, e.g. `:::solidity new bytes(10)`.\n    \"\"\"\n\n    _ast_node: SolcNewExpression\n    _parent: SolidityAbc  # TODO: make this more specific\n\n    _type_name: TypeNameAbc\n\n    def __init__(\n        self, init: IrInitTuple, new_expression: SolcNewExpression, parent: SolidityAbc\n    ):\n        super().__init__(init, new_expression, parent)\n        self._type_name = TypeNameAbc.from_ast(init, new_expression.type_name, self)\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        yield from self._type_name\n\n    @property\n    def parent(self) -&gt; SolidityAbc:\n        return self._parent\n\n    @property\n    def type_name(self) -&gt; TypeNameAbc:\n        \"\"\"\n        Is:\n\n        - [UserDefinedTypeName][wake.ir.type_names.user_defined_type_name.UserDefinedTypeName] referencing [ContractDefinition][wake.ir.declarations.contract_definition.ContractDefinition] when creating a new contract,\n        - [ArrayTypeName][wake.ir.type_names.array_type_name.ArrayTypeName] when creating a new array,\n        - [ElementaryTypeName][wake.ir.type_names.elementary_type_name.ElementaryTypeName] when creating new `:::solidity bytes` or `:::solidity string`.\n\n        Returns:\n            Type name of the object to be created.\n        \"\"\"\n        return self._type_name\n\n    @property\n    def is_ref_to_state_variable(self) -&gt; bool:\n        return False\n\n    @property\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        if isinstance(self.type, Contract):\n            return {(self, ModifiesStateFlag.DEPLOYS_CONTRACT)}\n        else:\n            return set()\n</code></pre>"},{"location":"api-reference/ir/expressions/new-expression/#wake.ir.expressions.new_expression.NewExpression.type_name","title":"<code>type_name: TypeNameAbc</code>  <code>property</code>","text":"<p>Is:</p> <ul> <li>UserDefinedTypeName referencing ContractDefinition when creating a new contract,</li> <li>ArrayTypeName when creating a new array,</li> <li>ElementaryTypeName when creating new <code>bytes</code> or <code>string</code>.</li> </ul> <p>Returns:</p> Type Description <code>TypeNameAbc</code> <p>Type name of the object to be created.</p>"},{"location":"api-reference/ir/expressions/tuple-expression/","title":"tuple_expression","text":""},{"location":"api-reference/ir/expressions/tuple-expression/#wake.ir.expressions.tuple_expression","title":"<code>wake.ir.expressions.tuple_expression</code>  <code>module</code>","text":""},{"location":"api-reference/ir/expressions/tuple-expression/#wake.ir.expressions.tuple_expression.TupleExpression","title":"<code>TupleExpression</code>  <code>class</code>","text":"<p>         Bases: <code>ExpressionAbc</code></p> <p>Represents multiple expressions enclosed in parentheses.</p> <p>Example</p> <p><code>(uint256, uint256)</code> in:</p> <pre><code>abi.decode(data, (uint256, uint256))\n</code></pre> Source code in <code>wake/ir/expressions/tuple_expression.py</code> <pre><code>class TupleExpression(ExpressionAbc):\n    \"\"\"\n    Represents multiple expressions enclosed in parentheses.\n\n    !!! example\n        `:::solidity (uint256, uint256)` in:\n\n        ```solidity\n        abi.decode(data, (uint256, uint256))\n        ```\n    \"\"\"\n\n    _ast_node: SolcTupleExpression\n    _parent: SolidityAbc  # TODO: make this more specific\n\n    _components: List[Optional[ExpressionAbc]]\n    _is_inline_array: bool\n\n    def __init__(\n        self,\n        init: IrInitTuple,\n        tuple_expression: SolcTupleExpression,\n        parent: SolidityAbc,\n    ):\n        super().__init__(init, tuple_expression, parent)\n        self._is_inline_array = tuple_expression.is_inline_array\n\n        self._components = []\n        for component in tuple_expression.components:\n            if component is None:\n                self._components.append(None)\n            else:\n                self._components.append(ExpressionAbc.from_ast(init, component, self))\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        for component in self._components:\n            if component is not None:\n                yield from component\n\n    @property\n    def parent(self) -&gt; SolidityAbc:\n        return self._parent\n\n    @property\n    def is_inline_array(self) -&gt; bool:\n        \"\"\"\n        !!! example\n            Returns `True` for `:::solidity [2, 3, 5, 7, 11, 13]` in the following example:\n\n            ```solidity\n            uint8[6] memory primes = [2, 3, 5, 7, 11, 13];\n            ```\n\n        Returns:\n            `True` if the tuple expression is an inline array, `False` otherwise.\n        \"\"\"\n        return self._is_inline_array\n\n    @property\n    def components(self) -&gt; Tuple[Optional[ExpressionAbc], ...]:\n        \"\"\"\n        !!! example\n            A component may be `None` if it is omitted, for example `:::solidity (success, )` in the following code snippet:\n\n            ```solidity\n            bool success;\n            (success, ) = target.call{gas: 1000}(data);\n            ```\n\n        Returns:\n            Tuple of expressions enclosed in parentheses in the order they appear in the source code.\n        \"\"\"\n        return tuple(self._components)\n\n    @property\n    @lru_cache(maxsize=2048)\n    def is_ref_to_state_variable(self) -&gt; bool:\n        return any(\n            component.is_ref_to_state_variable\n            for component in self._components\n            if component is not None\n        )\n\n    @property\n    @lru_cache(maxsize=2048)\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        return reduce(\n            or_,\n            (\n                component.modifies_state\n                for component in self._components\n                if component is not None\n            ),\n            set(),\n        )\n</code></pre>"},{"location":"api-reference/ir/expressions/tuple-expression/#wake.ir.expressions.tuple_expression.TupleExpression.components","title":"<code>components: Tuple[Optional[ExpressionAbc], ...]</code>  <code>property</code>","text":"<p>Example</p> <p>A component may be <code>None</code> if it is omitted, for example <code>(success, )</code> in the following code snippet:</p> <pre><code>bool success;\n(success, ) = target.call{gas: 1000}(data);\n</code></pre> <p>Returns:</p> Type Description <code>Tuple[Optional[ExpressionAbc], ...]</code> <p>Tuple of expressions enclosed in parentheses in the order they appear in the source code.</p>"},{"location":"api-reference/ir/expressions/tuple-expression/#wake.ir.expressions.tuple_expression.TupleExpression.is_inline_array","title":"<code>is_inline_array: bool</code>  <code>property</code>","text":"<p>Example</p> <p>Returns <code>True</code> for <code>[2, 3, 5, 7, 11, 13]</code> in the following example:</p> <pre><code>uint8[6] memory primes = [2, 3, 5, 7, 11, 13];\n</code></pre> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the tuple expression is an inline array, <code>False</code> otherwise.</p>"},{"location":"api-reference/ir/expressions/unary-operation/","title":"unary_operation","text":""},{"location":"api-reference/ir/expressions/unary-operation/#wake.ir.expressions.unary_operation","title":"<code>wake.ir.expressions.unary_operation</code>  <code>module</code>","text":""},{"location":"api-reference/ir/expressions/unary-operation/#wake.ir.expressions.unary_operation.UnaryOperation","title":"<code>UnaryOperation</code>  <code>class</code>","text":"<p>         Bases: <code>ExpressionAbc</code></p> <p>Example</p> <pre><code>-x\n</code></pre> Source code in <code>wake/ir/expressions/unary_operation.py</code> <pre><code>class UnaryOperation(ExpressionAbc):\n    \"\"\"\n    !!! example\n        ```solidity\n        -x\n        ```\n    \"\"\"\n\n    _ast_node: SolcUnaryOperation\n    _parent: SolidityAbc\n\n    _operator: UnaryOpOperator\n    _prefix: bool\n    _sub_expression: ExpressionAbc\n    _function_id: Optional[AstNodeId]\n\n    def __init__(\n        self,\n        init: IrInitTuple,\n        unary_operation: SolcUnaryOperation,\n        parent: SolidityAbc,\n    ):\n        super().__init__(init, unary_operation, parent)\n        self._operator = unary_operation.operator\n        self._prefix = unary_operation.prefix\n        self._sub_expression = ExpressionAbc.from_ast(\n            init, unary_operation.sub_expression, self\n        )\n        self._function_id = unary_operation.function\n        if self._function_id is not None:\n            init.reference_resolver.register_post_process_callback(self._post_process)\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        yield from self._sub_expression\n\n    def _post_process(self, callback_params: CallbackParams):\n        function = self.function\n        assert function is not None\n        function.register_reference(self)\n        self._reference_resolver.register_destroy_callback(\n            self.source_unit.file, partial(self._destroy, function)\n        )\n\n    def _destroy(self, function: FunctionDefinition) -&gt; None:\n        function.unregister_reference(self)\n\n    @property\n    def parent(self) -&gt; SolidityAbc:\n        return self._parent\n\n    @property\n    def operator(self) -&gt; UnaryOpOperator:\n        \"\"\"\n        Returns:\n            Operator of the unary operation.\n        \"\"\"\n        return self._operator\n\n    @property\n    def prefix(self) -&gt; bool:\n        \"\"\"\n        Returns:\n            `False` for `++` and `--` operators applied as postfix operators, `True` otherwise.\n        \"\"\"\n        return self._prefix\n\n    @property\n    def sub_expression(self) -&gt; ExpressionAbc:\n        \"\"\"\n        Returns:\n            Sub-expression the unary operator is applied to.\n        \"\"\"\n        return self._sub_expression\n\n    @property\n    def is_ref_to_state_variable(self) -&gt; bool:\n        return False\n\n    @property\n    @lru_cache(maxsize=2048)\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        ret = self.sub_expression.modifies_state\n\n        if (\n            self.operator\n            in {\n                UnaryOpOperator.PLUS_PLUS,\n                UnaryOpOperator.MINUS_MINUS,\n                UnaryOpOperator.DELETE,\n            }\n            and self.sub_expression.is_ref_to_state_variable\n        ):\n            ret |= {(self, ModifiesStateFlag.MODIFIES_STATE_VAR)}\n        return ret\n\n    @property\n    def function(self) -&gt; Optional[FunctionDefinition]:\n        \"\"\"\n        Is not `None` if the unary operation operates on user-defined value types with custom operators.\n\n        !!! note\n            Only `~` and `-` may be defined as user-defined unary operators.\n\n        !!! example\n            The unary operation `:::solidity ~a` on line 11 of the following example references the function `negate` on line 6:\n            ```solidity linenums=\"1\"\n            pragma solidity ^0.8.19;\n\n            type Int is int;\n            using {negate as ~} for Int global;\n\n            function negate(Int a) pure returns (Int) {\n                return Int.wrap(-Int.unwrap(a));\n            }\n\n            function test(Int a) pure returns (Int) {\n                return ~a;\n            }\n            ```\n\n        Returns:\n            Function representing the user-defined operator.\n        \"\"\"\n        if self._function_id is None:\n            return None\n        node = self._reference_resolver.resolve_node(\n            self._function_id, self.source_unit.cu_hash\n        )\n        assert isinstance(node, FunctionDefinition)\n        return node\n</code></pre>"},{"location":"api-reference/ir/expressions/unary-operation/#wake.ir.expressions.unary_operation.UnaryOperation.function","title":"<code>function: Optional[FunctionDefinition]</code>  <code>property</code>","text":"<p>Is not <code>None</code> if the unary operation operates on user-defined value types with custom operators.</p> <p>Note</p> <p>Only <code>~</code> and <code>-</code> may be defined as user-defined unary operators.</p> <p>Example</p> <p>The unary operation <code>~a</code> on line 11 of the following example references the function <code>negate</code> on line 6: <pre><code>pragma solidity ^0.8.19;\n\ntype Int is int;\nusing {negate as ~} for Int global;\n\nfunction negate(Int a) pure returns (Int) {\n    return Int.wrap(-Int.unwrap(a));\n}\n\nfunction test(Int a) pure returns (Int) {\n    return ~a;\n}\n</code></pre></p> <p>Returns:</p> Type Description <code>Optional[FunctionDefinition]</code> <p>Function representing the user-defined operator.</p>"},{"location":"api-reference/ir/expressions/unary-operation/#wake.ir.expressions.unary_operation.UnaryOperation.operator","title":"<code>operator: UnaryOpOperator</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>UnaryOpOperator</code> <p>Operator of the unary operation.</p>"},{"location":"api-reference/ir/expressions/unary-operation/#wake.ir.expressions.unary_operation.UnaryOperation.prefix","title":"<code>prefix: bool</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>bool</code> <p><code>False</code> for <code>++</code> and <code>--</code> operators applied as postfix operators, <code>True</code> otherwise.</p>"},{"location":"api-reference/ir/expressions/unary-operation/#wake.ir.expressions.unary_operation.UnaryOperation.sub_expression","title":"<code>sub_expression: ExpressionAbc</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>ExpressionAbc</code> <p>Sub-expression the unary operator is applied to.</p>"},{"location":"api-reference/ir/meta/identifier-path/","title":"identifier_path","text":""},{"location":"api-reference/ir/meta/identifier-path/#wake.ir.meta.identifier_path","title":"<code>wake.ir.meta.identifier_path</code>  <code>module</code>","text":""},{"location":"api-reference/ir/meta/identifier-path/#wake.ir.meta.identifier_path.IdentifierPath","title":"<code>IdentifierPath</code>  <code>class</code>","text":"<p>         Bases: <code>SolidityAbc</code></p> <p>Identifier path represents a path name of identifiers separated by dots. It was introduced in Solidity 0.8.0 to replace UserDefinedTypeName in some cases.</p> Source code in <code>wake/ir/meta/identifier_path.py</code> <pre><code>class IdentifierPath(SolidityAbc):\n    \"\"\"\n    Identifier path represents a path name of identifiers separated by dots. It was introduced in Solidity 0.8.0 to replace\n    [UserDefinedTypeName][wake.ir.type_names.user_defined_type_name.UserDefinedTypeName] in some cases.\n    \"\"\"\n\n    _ast_node: SolcIdentifierPath\n    _parent: Union[\n        InheritanceSpecifier,\n        ModifierInvocation,\n        OverrideSpecifier,\n        UsingForDirective,\n        UserDefinedTypeName,\n    ]\n\n    _name: str\n    _referenced_declaration_id: AstNodeId\n    _parts: IntervalTree\n\n    def __init__(\n        self,\n        init: IrInitTuple,\n        identifier_path: SolcIdentifierPath,\n        parent: SolidityAbc,\n    ):\n        super().__init__(init, identifier_path, parent)\n        self._name = identifier_path.name\n        self._referenced_declaration_id = identifier_path.referenced_declaration\n        assert self._referenced_declaration_id &gt;= 0\n\n        self._reference_resolver.register_post_process_callback(self._post_process)\n\n    def _post_process(self, callback_params: CallbackParams):\n        def find_referenced_source_unit(\n            searched_name: str, start_source_unit: SourceUnit\n        ) -&gt; SourceUnit:\n            source_units_queue: Deque[SourceUnit] = deque([start_source_unit])\n            processed_source_units: Set[Path] = {start_source_unit.file}\n            referenced_declaration = None\n\n            while source_units_queue and referenced_declaration is None:\n                source_unit = source_units_queue.popleft()\n\n                for import_ in source_unit.imports:\n                    if import_.unit_alias == searched_name:\n                        referenced_declaration = callback_params.source_units[\n                            import_.imported_file\n                        ]\n                        break\n                    for symbol_alias in import_.symbol_aliases:\n                        if symbol_alias.local == searched_name:\n                            ref = symbol_alias.foreign.referenced_declaration\n                            assert isinstance(ref, SourceUnit)\n                            referenced_declaration = ref\n\n                    if referenced_declaration is not None:\n                        break\n\n                    if import_.imported_file not in processed_source_units:\n                        source_units_queue.append(\n                            callback_params.source_units[import_.imported_file]\n                        )\n                        processed_source_units.add(import_.imported_file)\n\n            assert referenced_declaration is not None\n            return referenced_declaration\n\n        from ..meta.source_unit import SourceUnit\n\n        source = bytearray(self._source)\n        _, stripped_sums = SoliditySourceParser.strip_comments(source)\n\n        matches = list(IDENTIFIER_RE.finditer(source))\n        groups_count = len(matches)\n        assert groups_count &gt; 0\n\n        self._parts = IntervalTree()\n        start_source_unit = callback_params.source_units[self.source_unit.file]\n\n        ref = self.referenced_declaration\n        refs = []\n        for _ in range(groups_count):\n            refs.append(ref)\n            if ref is not None:\n                ref = ref.parent\n\n        for match, ref in zip(matches, reversed(refs)):\n            name = match.group(0).decode(\"utf-8\")\n\n            if ref is None:\n                start_source_unit = find_referenced_source_unit(name, start_source_unit)\n                referenced_node = start_source_unit\n            elif isinstance(ref, (DeclarationAbc, SourceUnit)):\n                referenced_node = ref\n            else:\n                raise TypeError(\n                    f\"Unexpected type of referenced declaration: {type(ref)}\"\n                )\n\n            node_path_order = self._reference_resolver.get_node_path_order(\n                AstNodeId(referenced_node.ast_node_id),\n                referenced_node.source_unit.cu_hash,\n            )\n            referenced_node_id = (\n                self._reference_resolver.get_ast_id_from_cu_node_path_order(\n                    node_path_order, self.source_unit.cu_hash\n                )\n            )\n\n            if len(stripped_sums) == 0:\n                stripped = 0\n            else:\n                index = bisect([s[0] for s in stripped_sums], match.start())\n                if index == 0:\n                    stripped = 0\n                else:\n                    stripped = stripped_sums[index - 1][1]\n\n            start = self.byte_location[0] + match.start() + stripped\n            end = self.byte_location[0] + match.end() + stripped\n            self._parts[start:end] = IdentifierPathPart(\n                self,\n                (start, end),\n                name,\n                referenced_node_id,\n                self._reference_resolver,\n                self.source_unit,\n            )\n\n    @property\n    def parent(\n        self,\n    ) -&gt; Union[\n        InheritanceSpecifier,\n        ModifierInvocation,\n        OverrideSpecifier,\n        UsingForDirective,\n        UserDefinedTypeName,\n    ]:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"\n        Returns:\n            Name (as it appears in the source code) of the user-defined type referenced by this identifier path.\n        \"\"\"\n        return self._name\n\n    @property\n    def identifier_path_parts(self) -&gt; Tuple[IdentifierPathPart, ...]:\n        \"\"\"\n        Returns:\n            Parts of the identifier path.\n        \"\"\"\n        return tuple(\n            interval.data  # pyright: ignore reportGeneralTypeIssues\n            for interval in sorted(self._parts)\n        )\n\n    def identifier_path_part_at(self, byte_offset: int) -&gt; Optional[IdentifierPathPart]:\n        \"\"\"\n        Parameters:\n            byte_offset: Byte offset in the source code.\n\n        Returns:\n            Identifier path part at the given byte offset, if any.\n        \"\"\"\n        intervals = self._parts.at(byte_offset)\n        assert len(intervals) &lt;= 1\n        if len(intervals) == 0:\n            return None\n        return intervals.pop().data\n\n    @property\n    def referenced_declaration(self) -&gt; DeclarationAbc:\n        \"\"\"\n        Returns:\n            Declaration referenced by this identifier path.\n        \"\"\"\n        node = self._reference_resolver.resolve_node(\n            self._referenced_declaration_id, self.source_unit.cu_hash\n        )\n        assert isinstance(node, DeclarationAbc)\n        return node\n</code></pre>"},{"location":"api-reference/ir/meta/identifier-path/#wake.ir.meta.identifier_path.IdentifierPath.identifier_path_parts","title":"<code>identifier_path_parts: Tuple[IdentifierPathPart, ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[IdentifierPathPart, ...]</code> <p>Parts of the identifier path.</p>"},{"location":"api-reference/ir/meta/identifier-path/#wake.ir.meta.identifier_path.IdentifierPath.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>Name (as it appears in the source code) of the user-defined type referenced by this identifier path.</p>"},{"location":"api-reference/ir/meta/identifier-path/#wake.ir.meta.identifier_path.IdentifierPath.parent","title":"<code>parent: Union[InheritanceSpecifier, ModifierInvocation, OverrideSpecifier, UsingForDirective, UserDefinedTypeName]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[InheritanceSpecifier, ModifierInvocation, OverrideSpecifier, UsingForDirective, UserDefinedTypeName]</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/meta/identifier-path/#wake.ir.meta.identifier_path.IdentifierPath.referenced_declaration","title":"<code>referenced_declaration: DeclarationAbc</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>DeclarationAbc</code> <p>Declaration referenced by this identifier path.</p>"},{"location":"api-reference/ir/meta/identifier-path/#wake.ir.meta.identifier_path.IdentifierPath.identifier_path_part_at","title":"<code>identifier_path_part_at(byte_offset)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>byte_offset</code> <code>int</code> <p>Byte offset in the source code.</p> required <p>Returns:</p> Type Description <code>Optional[IdentifierPathPart]</code> <p>Identifier path part at the given byte offset, if any.</p> Source code in <code>wake/ir/meta/identifier_path.py</code> <pre><code>def identifier_path_part_at(self, byte_offset: int) -&gt; Optional[IdentifierPathPart]:\n    \"\"\"\n    Parameters:\n        byte_offset: Byte offset in the source code.\n\n    Returns:\n        Identifier path part at the given byte offset, if any.\n    \"\"\"\n    intervals = self._parts.at(byte_offset)\n    assert len(intervals) &lt;= 1\n    if len(intervals) == 0:\n        return None\n    return intervals.pop().data\n</code></pre>"},{"location":"api-reference/ir/meta/identifier-path/#wake.ir.meta.identifier_path.IdentifierPathPart","title":"<code>IdentifierPathPart</code>  <code>class</code>","text":"<p>A class representing a part of an identifier path. Is almost the same as Identifier, but it is not generated in the AST output of the compiler and so it is not an IR node.</p> Source code in <code>wake/ir/meta/identifier_path.py</code> <pre><code>class IdentifierPathPart:\n    \"\"\"\n    A class representing a part of an identifier path. Is almost the same as [Identifier][wake.ir.expressions.identifier.Identifier], but it is not generated in the AST output of the compiler and so it is not an IR node.\n    \"\"\"\n\n    _reference_resolver: ReferenceResolver\n    _underlying_node: Union[IdentifierPath, UserDefinedTypeName]\n    _referenced_declaration_id: Optional[AstNodeId]\n    _byte_location: Tuple[int, int]\n    _name: str\n    _source_unit: SourceUnit\n\n    def __init__(\n        self,\n        underlying_node: Union[IdentifierPath, UserDefinedTypeName],\n        byte_location: Tuple[int, int],\n        name: str,\n        referenced_declaration_id: AstNodeId,\n        reference_resolver: ReferenceResolver,\n        source_unit: SourceUnit,\n    ):\n        self._underlying_node = underlying_node\n        self._reference_resolver = reference_resolver\n        self._referenced_declaration_id = referenced_declaration_id\n        self._byte_location = byte_location\n        self._name = name\n        self._source_unit = source_unit\n\n        self._reference_resolver.register_post_process_callback(self._post_process)\n\n    def _post_process(self, callback_params: CallbackParams):\n        referenced_declaration = self.referenced_declaration\n        if isinstance(referenced_declaration, DeclarationAbc):\n            referenced_declaration.register_reference(self)\n            self._reference_resolver.register_destroy_callback(\n                self._source_unit.file, partial(self._destroy, referenced_declaration)\n            )\n\n    def _destroy(self, referenced_declaration: DeclarationAbc) -&gt; None:\n        referenced_declaration.unregister_reference(self)\n\n    @property\n    def underlying_node(self) -&gt; Union[IdentifierPath, UserDefinedTypeName]:\n        \"\"\"\n        Returns:\n            Underlying IR node (parent) of this identifier path part.\n        \"\"\"\n        return self._underlying_node\n\n    @property\n    def byte_location(self) -&gt; Tuple[int, int]:\n        \"\"\"\n\n        Returns:\n            Tuple of the start and end byte offsets of this node in the source file.\n        \"\"\"\n        return self._byte_location\n\n    @property\n    def source_unit(self) -&gt; SourceUnit:\n        \"\"\"\n        Returns:\n            Source unit that contains this node.\n        \"\"\"\n        return self._source_unit\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"\n        !!! example\n            `Contract` or `Event` in `Contract.Event`.\n\n        Returns:\n            Name of the identifier path part as it appears in the source code.\n        \"\"\"\n        return self._name\n\n    @property\n    def referenced_declaration(self) -&gt; Union[DeclarationAbc, SourceUnit]:\n        \"\"\"\n        !!! example\n            In the case of `Contract.Struct` [IdentifierPath][wake.ir.meta.identifier_path.IdentifierPath], the referenced declaration of `Struct` is the declaration of the struct `Struct` in the contract `Contract`.\n        !!! example\n            Can be a [SourceUnit][wake.ir.meta.source_unit.SourceUnit] in the following case:\n            ```solidity\n            import * as Utils from \"./Utils.sol\";\n            ```\n\n        Returns:\n            Declaration referenced by this identifier path part.\n        \"\"\"\n        from .source_unit import SourceUnit\n\n        assert self._referenced_declaration_id is not None\n        node = self._reference_resolver.resolve_node(\n            self._referenced_declaration_id, self._source_unit.cu_hash\n        )\n        assert isinstance(node, (DeclarationAbc, SourceUnit))\n        return node\n</code></pre>"},{"location":"api-reference/ir/meta/identifier-path/#wake.ir.meta.identifier_path.IdentifierPathPart.byte_location","title":"<code>byte_location: Tuple[int, int]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[int, int]</code> <p>Tuple of the start and end byte offsets of this node in the source file.</p>"},{"location":"api-reference/ir/meta/identifier-path/#wake.ir.meta.identifier_path.IdentifierPathPart.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Example</p> <p><code>Contract</code> or <code>Event</code> in <code>Contract.Event</code>.</p> <p>Returns:</p> Type Description <code>str</code> <p>Name of the identifier path part as it appears in the source code.</p>"},{"location":"api-reference/ir/meta/identifier-path/#wake.ir.meta.identifier_path.IdentifierPathPart.referenced_declaration","title":"<code>referenced_declaration: Union[DeclarationAbc, SourceUnit]</code>  <code>property</code>","text":"<p>Example</p> <p>In the case of <code>Contract.Struct</code> IdentifierPath, the referenced declaration of <code>Struct</code> is the declaration of the struct <code>Struct</code> in the contract <code>Contract</code>.</p> <p>Example</p> <p>Can be a SourceUnit in the following case: <pre><code>import * as Utils from \"./Utils.sol\";\n</code></pre></p> <p>Returns:</p> Type Description <code>Union[DeclarationAbc, SourceUnit]</code> <p>Declaration referenced by this identifier path part.</p>"},{"location":"api-reference/ir/meta/identifier-path/#wake.ir.meta.identifier_path.IdentifierPathPart.source_unit","title":"<code>source_unit: SourceUnit</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>SourceUnit</code> <p>Source unit that contains this node.</p>"},{"location":"api-reference/ir/meta/identifier-path/#wake.ir.meta.identifier_path.IdentifierPathPart.underlying_node","title":"<code>underlying_node: Union[IdentifierPath, UserDefinedTypeName]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[IdentifierPath, UserDefinedTypeName]</code> <p>Underlying IR node (parent) of this identifier path part.</p>"},{"location":"api-reference/ir/meta/import-directive/","title":"import_directive","text":""},{"location":"api-reference/ir/meta/import-directive/#wake.ir.meta.import_directive","title":"<code>wake.ir.meta.import_directive</code>  <code>module</code>","text":""},{"location":"api-reference/ir/meta/import-directive/#wake.ir.meta.import_directive.ImportDirective","title":"<code>ImportDirective</code>  <code>class</code>","text":"<p>         Bases: <code>SolidityAbc</code></p> <p>Example</p> <p><pre><code>import \"SafeLib.sol\";\n</code></pre> <pre><code>import \"SafeLib.sol\" as SafeLib;\n</code></pre> <pre><code>import * as SafeLib from \"SafeLib.sol\";\n</code></pre> <pre><code>import { SafeType as CustomSafeType } from \"SafeLib.sol\";\n</code></pre></p> Source code in <code>wake/ir/meta/import_directive.py</code> <pre><code>class ImportDirective(SolidityAbc):\n    \"\"\"\n    !!! example\n        ```solidity\n        import \"SafeLib.sol\";\n        ```\n        ```solidity\n        import \"SafeLib.sol\" as SafeLib;\n        ```\n        ```solidity\n        import * as SafeLib from \"SafeLib.sol\";\n        ```\n        ```solidity\n        import { SafeType as CustomSafeType } from \"SafeLib.sol\";\n        ```\n    \"\"\"\n\n    _ast_node: SolcImportDirective\n    _parent: SourceUnit\n\n    _imported_source_unit_name: str\n    _import_string: str\n    _imported_file: Path\n    _imported_source_unit_id: AstNodeId\n    _symbol_aliases: List[SymbolAlias]\n    _unit_alias: Optional[str]\n\n    def __init__(\n        self,\n        init: IrInitTuple,\n        import_directive: SolcImportDirective,\n        parent: SolidityAbc,\n    ):\n        super().__init__(init, import_directive, parent)\n        self._imported_source_unit_name = import_directive.absolute_path\n        self._import_string = import_directive.file\n        self._imported_file = init.cu.source_unit_name_to_path(\n            self._imported_source_unit_name\n        )\n        self._imported_source_unit_id = import_directive.source_unit\n        self._symbol_aliases = []\n        if len(import_directive.unit_alias) &gt; 0:\n            self._unit_alias = import_directive.unit_alias\n        else:\n            self._unit_alias = None\n\n        for alias in import_directive.symbol_aliases:\n            self._symbol_aliases.append(\n                SymbolAlias(Identifier(init, alias.foreign, self), alias.local)\n            )\n        self._reference_resolver.register_post_process_callback(\n            self._post_process, priority=-2\n        )\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        for symbol_alias in self._symbol_aliases:\n            yield from symbol_alias.foreign\n\n    def _post_process(self, callback_params: CallbackParams):\n        from ..declarations.function_definition import FunctionDefinition\n\n        # referenced declaration ID is missing in import directive symbol aliases\n        # the reason is that the Identifier may refer to multiple overloaded functions\n        # for example `import { SafeType } from \"SafeLib.sol\";`\n        # fix: find these reference IDs manually\n        for symbol_alias in self._symbol_aliases:\n            if len(symbol_alias.foreign._referenced_declaration_ids) != 0:\n                continue\n\n            source_units_queue: Deque[SourceUnit] = deque(\n                [callback_params.source_units[self._imported_file]]\n            )\n            processed_source_units: Set[Path] = {self._imported_file}\n            referenced_declarations = set()\n            search = True\n            searched_name = symbol_alias.foreign.name\n\n            while source_units_queue and search:\n                imported_source_unit = source_units_queue.pop()\n\n                for declaration in imported_source_unit.declarations_iter():\n                    if declaration.name == searched_name:\n                        referenced_declarations.add(declaration)\n                        if not isinstance(declaration, FunctionDefinition):\n                            search = False\n                            break\n\n                for import_ in imported_source_unit.imports:\n                    if import_.unit_alias == searched_name:\n                        referenced_declarations.add(import_)\n                        break\n\n                    # handle the case when an imported symbol is an alias of another symbol\n                    for alias in import_.symbol_aliases:\n                        if alias.local == symbol_alias.foreign.name:\n                            searched_name = alias.foreign.name\n                    if import_.imported_file not in processed_source_units:\n                        source_units_queue.append(\n                            callback_params.source_units[import_.imported_file]\n                        )\n                        processed_source_units.add(import_.imported_file)\n\n            assert len(referenced_declarations) &gt; 0\n\n            referenced_declaration_ids = set()\n            for referenced_declaration in referenced_declarations:\n                node_path_order = self._reference_resolver.get_node_path_order(\n                    AstNodeId(referenced_declaration.ast_node_id),\n                    referenced_declaration.source_unit.cu_hash,\n                )\n                referenced_declaration_ids.add(\n                    self._reference_resolver.get_ast_id_from_cu_node_path_order(\n                        node_path_order, self.source_unit.cu_hash\n                    )\n                )\n            symbol_alias.foreign._referenced_declaration_ids = (\n                referenced_declaration_ids\n            )\n\n    @property\n    def parent(self) -&gt; SourceUnit:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def imported_source_unit_name(self) -&gt; str:\n        \"\"\"\n        Returns:\n            Source unit name of the imported file.\n        \"\"\"\n        return self._imported_source_unit_name\n\n    @property\n    def imported_file(self) -&gt; Path:\n        \"\"\"\n        Returns:\n            Absolute path of the imported file.\n        \"\"\"\n        return self._imported_file\n\n    @property\n    def import_string(self) -&gt; str:\n        \"\"\"\n        Returns:\n            Import string as it appears in the source code.\n        \"\"\"\n        return self._import_string\n\n    @property\n    def imported_source_unit(self) -&gt; SourceUnit:\n        \"\"\"\n        Returns:\n            Source unit imported by this import directive.\n        \"\"\"\n        from .source_unit import SourceUnit\n\n        node = self._reference_resolver.resolve_node(\n            self._imported_source_unit_id, self.source_unit.cu_hash\n        )\n        assert isinstance(node, SourceUnit)\n        return node\n\n    @property\n    def symbol_aliases(self) -&gt; Tuple[SymbolAlias, ...]:\n        \"\"\"\n        Is only set in the case of `:::solidity import { SafeType as CustomSafeType } from \"SafeLib.sol\";` import directive type.\n\n        Returns:\n            Symbol aliases present in the import directive.\n        \"\"\"\n        return tuple(self._symbol_aliases)\n\n    @property\n    def unit_alias(self) -&gt; Optional[str]:\n        \"\"\"\n        !!! example\n            Is `SafeLib` in the case of these import directives:\n            ```solidity\n            import \"SafeLib.sol\" as SafeLib;\n            ```\n            ```solidity\n            import * as SafeLib from \"SafeLib.sol\";\n            ```\n\n            Is `None` in the case of these import directives:\n            ```solidity\n            import \"SafeLib.sol\";\n            ```\n            ```solidity\n            import { SafeType as CustomSafeType } from \"SafeLib.sol\";\n            ```\n\n        Returns:\n            Alias for the namespace of the imported source unit.\n        \"\"\"\n        return self._unit_alias\n\n    @property\n    @lru_cache(maxsize=2048)\n    def import_string_location(self) -&gt; Tuple[int, int]:\n        \"\"\"\n        Returns:\n            Byte offsets (start, end) of the import string in the source file.\n        \"\"\"\n        source_start = self._ast_node.src.byte_offset\n\n        res = (\n            IMPORT_FILENAME_RE,\n            IMPORT_AS_FROM_RE,\n            IMPORT_AS_RE,\n            IMPORT_ALIAS_LIST,\n        )\n\n        source = bytearray(self._source)\n        _, stripped_sums = SoliditySourceParser.strip_comments(source)\n\n        matches = list(re.match(source) for re in res)\n        assert any(matches)\n        match = next(m for m in matches if m)\n\n        if len(stripped_sums) == 0:\n            stripped = 0\n        else:\n            index = bisect([s[0] for s in stripped_sums], match.start(\"filename\"))\n            if index == 0:\n                stripped = 0\n            else:\n                stripped = stripped_sums[index - 1][1]\n\n        return (\n            source_start + match.start(\"filename\") + stripped,\n            source_start + match.end(\"filename\") + stripped,\n        )\n</code></pre>"},{"location":"api-reference/ir/meta/import-directive/#wake.ir.meta.import_directive.ImportDirective.import_string","title":"<code>import_string: str</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>Import string as it appears in the source code.</p>"},{"location":"api-reference/ir/meta/import-directive/#wake.ir.meta.import_directive.ImportDirective.import_string_location","title":"<code>import_string_location: Tuple[int, int]</code>  <code>cached</code> <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[int, int]</code> <p>Byte offsets (start, end) of the import string in the source file.</p>"},{"location":"api-reference/ir/meta/import-directive/#wake.ir.meta.import_directive.ImportDirective.imported_file","title":"<code>imported_file: Path</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Path</code> <p>Absolute path of the imported file.</p>"},{"location":"api-reference/ir/meta/import-directive/#wake.ir.meta.import_directive.ImportDirective.imported_source_unit","title":"<code>imported_source_unit: SourceUnit</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>SourceUnit</code> <p>Source unit imported by this import directive.</p>"},{"location":"api-reference/ir/meta/import-directive/#wake.ir.meta.import_directive.ImportDirective.imported_source_unit_name","title":"<code>imported_source_unit_name: str</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>Source unit name of the imported file.</p>"},{"location":"api-reference/ir/meta/import-directive/#wake.ir.meta.import_directive.ImportDirective.parent","title":"<code>parent: SourceUnit</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>SourceUnit</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/meta/import-directive/#wake.ir.meta.import_directive.ImportDirective.symbol_aliases","title":"<code>symbol_aliases: Tuple[SymbolAlias, ...]</code>  <code>property</code>","text":"<p>Is only set in the case of <code>import { SafeType as CustomSafeType } from \"SafeLib.sol\";</code> import directive type.</p> <p>Returns:</p> Type Description <code>Tuple[SymbolAlias, ...]</code> <p>Symbol aliases present in the import directive.</p>"},{"location":"api-reference/ir/meta/import-directive/#wake.ir.meta.import_directive.ImportDirective.unit_alias","title":"<code>unit_alias: Optional[str]</code>  <code>property</code>","text":"<p>Example</p> <p>Is <code>SafeLib</code> in the case of these import directives: <pre><code>import \"SafeLib.sol\" as SafeLib;\n</code></pre> <pre><code>import * as SafeLib from \"SafeLib.sol\";\n</code></pre></p> <p>Is <code>None</code> in the case of these import directives: <pre><code>import \"SafeLib.sol\";\n</code></pre> <pre><code>import { SafeType as CustomSafeType } from \"SafeLib.sol\";\n</code></pre></p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Alias for the namespace of the imported source unit.</p>"},{"location":"api-reference/ir/meta/import-directive/#wake.ir.meta.import_directive.SymbolAlias","title":"<code>SymbolAlias</code>  <code>class</code>","text":"<p>Helper class representing a symbol alias in an import directive of the<code>import {symbol as alias} from \"file.sol\";</code> form.</p> <p>Example</p> <p><code>symbol</code> is the <code>foreign</code> attribute and <code>alias</code> is the <code>local</code> attribute in the following example: <pre><code>import {symbol as alias} from \"file.sol\";\n</code></pre></p> <p>Attributes:</p> Name Type Description <code>foreign</code> <code>Identifier</code> <p>Identifier referencing the symbol in the imported file.</p> <code>local</code> <code>Optional[str]</code> <p>Alias name of the imported symbol (if any).</p> Source code in <code>wake/ir/meta/import_directive.py</code> <pre><code>@dataclass\nclass SymbolAlias:\n    \"\"\"\n    Helper class representing a symbol alias in an import directive of the`:::solidity import {symbol as alias} from \"file.sol\";` form.\n\n    !!! example\n        `symbol` is the `foreign` attribute and `alias` is the `local` attribute in the following example:\n        ```solidity\n        import {symbol as alias} from \"file.sol\";\n        ```\n\n    Attributes:\n        foreign (Identifier): Identifier referencing the symbol in the imported file.\n        local (Optional[str]): Alias name of the imported symbol (if any).\n    \"\"\"\n\n    foreign: Identifier\n    local: Optional[str]\n</code></pre>"},{"location":"api-reference/ir/meta/inheritance-specifier/","title":"inheritance_specifier","text":""},{"location":"api-reference/ir/meta/inheritance-specifier/#wake.ir.meta.inheritance_specifier","title":"<code>wake.ir.meta.inheritance_specifier</code>  <code>module</code>","text":""},{"location":"api-reference/ir/meta/inheritance-specifier/#wake.ir.meta.inheritance_specifier.InheritanceSpecifier","title":"<code>InheritanceSpecifier</code>  <code>class</code>","text":"<p>         Bases: <code>SolidityAbc</code></p> <p>Example</p> <p><code>A(0x1234567890123456789012345678901234567890)</code> in the following code: <pre><code>contract A {\n    address immutable owner;\n\n    constructor(address _owner) {\n        owner = _owner;\n    }\n}\n\ncontract B is A(0x1234567890123456789012345678901234567890) {}\n</code></pre></p> Source code in <code>wake/ir/meta/inheritance_specifier.py</code> <pre><code>class InheritanceSpecifier(SolidityAbc):\n    \"\"\"\n    !!! example\n        `:::solidity A(0x1234567890123456789012345678901234567890)` in the following code:\n        ```solidity\n        contract A {\n            address immutable owner;\n\n            constructor(address _owner) {\n                owner = _owner;\n            }\n        }\n\n        contract B is A(0x1234567890123456789012345678901234567890) {}\n        ```\n    \"\"\"\n\n    _ast_node: SolcInheritanceSpecifier\n    _parent: ContractDefinition\n\n    _base_name: Union[IdentifierPath, UserDefinedTypeName]\n    _arguments: Optional[List[ExpressionAbc]]\n\n    def __init__(\n        self,\n        init: IrInitTuple,\n        inheritance_specifier: SolcInheritanceSpecifier,\n        parent: ContractDefinition,\n    ):\n        super().__init__(init, inheritance_specifier, parent)\n\n        if isinstance(inheritance_specifier.base_name, SolcIdentifierPath):\n            self._base_name = IdentifierPath(\n                init, inheritance_specifier.base_name, self\n            )\n        elif isinstance(inheritance_specifier.base_name, SolcUserDefinedTypeName):\n            self._base_name = UserDefinedTypeName(\n                init, inheritance_specifier.base_name, self\n            )\n\n        if inheritance_specifier.arguments is None:\n            self._arguments = None\n        else:\n            self._arguments = []\n            for argument in inheritance_specifier.arguments:\n                self._arguments.append(ExpressionAbc.from_ast(init, argument, self))\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        yield from self._base_name\n        if self._arguments is not None:\n            for argument in self._arguments:\n                yield from argument\n\n    @property\n    def parent(self) -&gt; ContractDefinition:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def base_name(self) -&gt; Union[IdentifierPath, UserDefinedTypeName]:\n        \"\"\"\n        The returned IR node holds a reference to the base contract definition ([ContractDefinition][wake.ir.declarations.contract_definition.ContractDefinition]).\n        !!! example\n            `A` in the following code:\n            ```solidity\n            contract B is A(0x1234567890123456789012345678901234567890) {}\n            ```\n\n        Returns:\n            IR node representing the base contract name.\n        \"\"\"\n        return self._base_name\n\n    @property\n    def arguments(self) -&gt; Optional[List[ExpressionAbc]]:\n        \"\"\"\n        !!! warning\n            Is `None` when there are no round brackets after the inheritance specifier name.\n            ```solidity\n            contract B is A {}\n            ```\n\n            Is an empty list when there are round brackets but no arguments.\n            ```solidity\n            contract B is A() {}\n            ```\n        !!! example\n            `:::solidity 0x1234567890123456789012345678901234567890` in the following code:\n            ```solidity\n            contract B is A(0x1234567890123456789012345678901234567890) {}\n            ```\n\n        Returns:\n            Arguments of the base constructor call, if provided.\n        \"\"\"\n        return self._arguments\n</code></pre>"},{"location":"api-reference/ir/meta/inheritance-specifier/#wake.ir.meta.inheritance_specifier.InheritanceSpecifier.arguments","title":"<code>arguments: Optional[List[ExpressionAbc]]</code>  <code>property</code>","text":"<p>Warning</p> <p>Is <code>None</code> when there are no round brackets after the inheritance specifier name. <pre><code>contract B is A {}\n</code></pre></p> <p>Is an empty list when there are round brackets but no arguments. <pre><code>contract B is A() {}\n</code></pre></p> <p>Example</p> <p><code>0x1234567890123456789012345678901234567890</code> in the following code: <pre><code>contract B is A(0x1234567890123456789012345678901234567890) {}\n</code></pre></p> <p>Returns:</p> Type Description <code>Optional[List[ExpressionAbc]]</code> <p>Arguments of the base constructor call, if provided.</p>"},{"location":"api-reference/ir/meta/inheritance-specifier/#wake.ir.meta.inheritance_specifier.InheritanceSpecifier.base_name","title":"<code>base_name: Union[IdentifierPath, UserDefinedTypeName]</code>  <code>property</code>","text":"<p>The returned IR node holds a reference to the base contract definition (ContractDefinition).</p> <p>Example</p> <p><code>A</code> in the following code: <pre><code>contract B is A(0x1234567890123456789012345678901234567890) {}\n</code></pre></p> <p>Returns:</p> Type Description <code>Union[IdentifierPath, UserDefinedTypeName]</code> <p>IR node representing the base contract name.</p>"},{"location":"api-reference/ir/meta/inheritance-specifier/#wake.ir.meta.inheritance_specifier.InheritanceSpecifier.parent","title":"<code>parent: ContractDefinition</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>ContractDefinition</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/meta/modifier-invocation/","title":"modifier_invocation","text":""},{"location":"api-reference/ir/meta/modifier-invocation/#wake.ir.meta.modifier_invocation","title":"<code>wake.ir.meta.modifier_invocation</code>  <code>module</code>","text":""},{"location":"api-reference/ir/meta/modifier-invocation/#wake.ir.meta.modifier_invocation.ModifierInvocation","title":"<code>ModifierInvocation</code>  <code>class</code>","text":"<p>         Bases: <code>SolidityAbc</code></p> <p>Warning</p> <p>Also represents a base constructor invocation.</p> <p>Example</p> <ul> <li><code>ERC20(\"MyToken\", \"MTK\")</code> (ModifierInvocationKind.BASE_CONSTRUCTOR_SPECIFIER),</li> <li><code>initializer</code> (ModifierInvocationKind.MODIFIER_INVOCATION)</li> </ul> <p>in the following code: <pre><code>import Initializable from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\ncontract MyContract is ERC20, Initializable {\n    constructor() ERC20(\"MyToken\", \"MTK\") initializer {\n        // ...\n    }\n}\n</code></pre></p> Source code in <code>wake/ir/meta/modifier_invocation.py</code> <pre><code>class ModifierInvocation(SolidityAbc):\n    \"\"\"\n    !!! warning\n        Also represents a base constructor invocation.\n    !!! example\n        - `:::solidity ERC20(\"MyToken\", \"MTK\")` ([ModifierInvocationKind.BASE_CONSTRUCTOR_SPECIFIER][wake.ir.enums.ModifierInvocationKind.BASE_CONSTRUCTOR_SPECIFIER]),\n        - `:::solidity initializer` ([ModifierInvocationKind.MODIFIER_INVOCATION][wake.ir.enums.ModifierInvocationKind.MODIFIER_INVOCATION])\n\n        in the following code:\n        ```solidity\n        import Initializable from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n        contract MyContract is ERC20, Initializable {\n            constructor() ERC20(\"MyToken\", \"MTK\") initializer {\n                // ...\n            }\n        }\n        ```\n    \"\"\"\n\n    _ast_node: SolcModifierInvocation\n    _parent: FunctionDefinition\n\n    _kind: Optional[ModifierInvocationKind]\n    _modifier_name: Union[Identifier, IdentifierPath]\n    _arguments: Optional[List[ExpressionAbc]]\n\n    def __init__(\n        self,\n        init: IrInitTuple,\n        modifier_invocation: SolcModifierInvocation,\n        parent: SolidityAbc,\n    ):\n        super().__init__(init, modifier_invocation, parent)\n        self._kind = None\n        if isinstance(modifier_invocation.modifier_name, SolcIdentifier):\n            self._modifier_name = Identifier(\n                init, modifier_invocation.modifier_name, self\n            )\n        elif isinstance(modifier_invocation.modifier_name, SolcIdentifierPath):\n            self._modifier_name = IdentifierPath(\n                init, modifier_invocation.modifier_name, self\n            )\n\n        if modifier_invocation.arguments is None:\n            self._arguments = None\n        else:\n            self._arguments = [\n                ExpressionAbc.from_ast(init, argument, self)\n                for argument in modifier_invocation.arguments\n            ]\n\n        self._reference_resolver.register_post_process_callback(self._post_process)\n\n    def _post_process(self, callback_params: CallbackParams):\n        from ..declarations.contract_definition import ContractDefinition\n        from ..declarations.modifier_definition import ModifierDefinition\n\n        referenced_declaration = self.modifier_name.referenced_declaration\n        if isinstance(referenced_declaration, ModifierDefinition):\n            self._kind = ModifierInvocationKind.MODIFIER_INVOCATION\n        elif isinstance(referenced_declaration, ContractDefinition):\n            self._kind = ModifierInvocationKind.BASE_CONSTRUCTOR_SPECIFIER\n        else:\n            assert False, f\"Unexpected declaration type: {referenced_declaration}\"\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        yield from self._modifier_name\n        if self._arguments is not None:\n            for argument in self._arguments:\n                yield from argument\n\n    @property\n    def parent(self) -&gt; FunctionDefinition:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def kind(self) -&gt; ModifierInvocationKind:\n        \"\"\"\n        Returns:\n            Kind of the modifier invocation.\n        \"\"\"\n        assert self._kind is not None\n        return self._kind\n\n    @property\n    def modifier_name(self) -&gt; Union[Identifier, IdentifierPath]:\n        \"\"\"\n        The returned IR node holds a reference to the [ModifierDefinition][wake.ir.declarations.modifier_definition.ModifierDefinition] declaration of the modifier being invoked in the case of the [ModifierInvocationKind.MODIFIER_INVOCATION][wake.ir.enums.ModifierInvocationKind.MODIFIER_INVOCATION] kind.\n        In the case of the [ModifierInvocationKind.BASE_CONSTRUCTOR_SPECIFIER][wake.ir.enums.ModifierInvocationKind.BASE_CONSTRUCTOR_SPECIFIER] kind, the returned IR node holds a reference to the [ContractDefinition][wake.ir.declarations.contract_definition.ContractDefinition] whose constructor is being invoked.\n        !!! example\n            `ERC20` and `initializer` in the following code:\n            ```solidity\n            constructor() ERC20(\"MyToken\", \"MTK\") initializer {\n                // ...\n            }\n            ```\n\n        Until Solidity 0.8.0, modifiers were referenced in [ModifierInvocations][wake.ir.meta.modifier_invocation.ModifierInvocation]\n        using [Identifiers][wake.ir.expressions.identifier.Identifier]. Version 0.8.0 started using [IdentifierPaths][wake.ir.meta.identifier_path.IdentifierPath] instead.\n\n        Returns:\n            IR node representing the name of the modifier.\n        \"\"\"\n        return self._modifier_name\n\n    @property\n    def arguments(self) -&gt; Optional[Tuple[ExpressionAbc, ...]]:\n        \"\"\"\n        !!! warning\n            Is `None` when there are no round brackets after the modifier name.\n            ```solidity\n            constructor() initializer {}\n            ```\n\n            Is an empty list when there are round brackets but no arguments.\n            ```solidity\n            constructor() initializer() {}\n            ```\n        !!! example\n            `:::solidity \"MyToken\"` and `:::solidity \"MTK\"` in the following code:\n            ```solidity\n            constructor() ERC20(\"MyToken\", \"MTK\") initializer {\n                // ...\n            }\n            ```\n\n        Returns:\n            Arguments of the base constructor or modifier invocation (if any).\n        \"\"\"\n        if self._arguments is None:\n            return None\n        return tuple(self._arguments)\n</code></pre>"},{"location":"api-reference/ir/meta/modifier-invocation/#wake.ir.meta.modifier_invocation.ModifierInvocation.arguments","title":"<code>arguments: Optional[Tuple[ExpressionAbc, ...]]</code>  <code>property</code>","text":"<p>Warning</p> <p>Is <code>None</code> when there are no round brackets after the modifier name. <pre><code>constructor() initializer {}\n</code></pre></p> <p>Is an empty list when there are round brackets but no arguments. <pre><code>constructor() initializer() {}\n</code></pre></p> <p>Example</p> <p><code>\"MyToken\"</code> and <code>\"MTK\"</code> in the following code: <pre><code>constructor() ERC20(\"MyToken\", \"MTK\") initializer {\n    // ...\n}\n</code></pre></p> <p>Returns:</p> Type Description <code>Optional[Tuple[ExpressionAbc, ...]]</code> <p>Arguments of the base constructor or modifier invocation (if any).</p>"},{"location":"api-reference/ir/meta/modifier-invocation/#wake.ir.meta.modifier_invocation.ModifierInvocation.kind","title":"<code>kind: ModifierInvocationKind</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>ModifierInvocationKind</code> <p>Kind of the modifier invocation.</p>"},{"location":"api-reference/ir/meta/modifier-invocation/#wake.ir.meta.modifier_invocation.ModifierInvocation.modifier_name","title":"<code>modifier_name: Union[Identifier, IdentifierPath]</code>  <code>property</code>","text":"<p>The returned IR node holds a reference to the ModifierDefinition declaration of the modifier being invoked in the case of the ModifierInvocationKind.MODIFIER_INVOCATION kind. In the case of the ModifierInvocationKind.BASE_CONSTRUCTOR_SPECIFIER kind, the returned IR node holds a reference to the ContractDefinition whose constructor is being invoked.</p> <p>Example</p> <p><code>ERC20</code> and <code>initializer</code> in the following code: <pre><code>constructor() ERC20(\"MyToken\", \"MTK\") initializer {\n    // ...\n}\n</code></pre></p> <p>Until Solidity 0.8.0, modifiers were referenced in ModifierInvocations using Identifiers. Version 0.8.0 started using IdentifierPaths instead.</p> <p>Returns:</p> Type Description <code>Union[Identifier, IdentifierPath]</code> <p>IR node representing the name of the modifier.</p>"},{"location":"api-reference/ir/meta/modifier-invocation/#wake.ir.meta.modifier_invocation.ModifierInvocation.parent","title":"<code>parent: FunctionDefinition</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>FunctionDefinition</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/meta/override-specifier/","title":"override_specifier","text":""},{"location":"api-reference/ir/meta/override-specifier/#wake.ir.meta.override_specifier","title":"<code>wake.ir.meta.override_specifier</code>  <code>module</code>","text":""},{"location":"api-reference/ir/meta/override-specifier/#wake.ir.meta.override_specifier.OverrideSpecifier","title":"<code>OverrideSpecifier</code>  <code>class</code>","text":"<p>         Bases: <code>SolidityAbc</code></p> <p>Example</p> <p>An override specifier can be used:</p> <ul> <li>in a FunctionDefinition:<ul> <li><code>override</code> on line 19,</li> </ul> </li> <li>in a ModifierDefinition:<ul> <li><code>override</code> on line 12,</li> </ul> </li> <li>in a VariableDeclaration:<ul> <li><code>override(IERC20)</code> on line 17.</li> </ul> </li> </ul> <pre><code>interface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n}\n\nabstract contract ERC20 is IERC20 {\n    modifier EOA() virtual;\n}\n\ncontract C is ERC20 {\n    modifier EOA() override {\n        require(msg.sender == tx.origin);\n        _;\n    }\n\n    mapping(address =&gt; mapping(address =&gt; uint256)) public override(IERC20) allowance;\n\n    function transfer(address to, uint256 value) external override returns (bool) {\n        // ...\n    }\n}\n</code></pre> Source code in <code>wake/ir/meta/override_specifier.py</code> <pre><code>class OverrideSpecifier(SolidityAbc):\n    \"\"\"\n    !!! example\n        An override specifier can be used:\n\n        - in a [FunctionDefinition][wake.ir.declarations.function_definition.FunctionDefinition]:\n            - `:::solidity override` on line 19,\n        - in a [ModifierDefinition][wake.ir.declarations.modifier_definition.ModifierDefinition]:\n            - `:::solidity override` on line 12,\n        - in a [VariableDeclaration][wake.ir.declarations.variable_declaration.VariableDeclaration]:\n            - `:::solidity override(IERC20)` on line 17.\n\n        ```solidity linenums=\"1\"\n        interface IERC20 {\n            function transfer(address to, uint256 value) external returns (bool);\n\n            function allowance(address owner, address spender) external view returns (uint256);\n        }\n\n        abstract contract ERC20 is IERC20 {\n            modifier EOA() virtual;\n        }\n\n        contract C is ERC20 {\n            modifier EOA() override {\n                require(msg.sender == tx.origin);\n                _;\n            }\n\n            mapping(address =&gt; mapping(address =&gt; uint256)) public override(IERC20) allowance;\n\n            function transfer(address to, uint256 value) external override returns (bool) {\n                // ...\n            }\n        }\n        ```\n    \"\"\"\n\n    _ast_node: SolcOverrideSpecifier\n    _parent: Union[FunctionDefinition, ModifierDefinition, VariableDeclaration]\n\n    _overrides: List[Union[IdentifierPath, UserDefinedTypeName]]\n\n    def __init__(\n        self,\n        init: IrInitTuple,\n        override_specifier: SolcOverrideSpecifier,\n        parent: SolidityAbc,\n    ):\n        super().__init__(init, override_specifier, parent)\n        self._overrides = []\n\n        for override in override_specifier.overrides:\n            if isinstance(override, SolcIdentifierPath):\n                self._overrides.append(IdentifierPath(init, override, self))\n            elif isinstance(override, SolcUserDefinedTypeName):\n                self._overrides.append(UserDefinedTypeName(init, override, self))\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        for override in self._overrides:\n            yield from override\n\n    @property\n    def parent(\n        self,\n    ) -&gt; Union[FunctionDefinition, ModifierDefinition, VariableDeclaration]:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def overrides(self) -&gt; Tuple[Union[IdentifierPath, UserDefinedTypeName], ...]:\n        \"\"\"\n        !!! note\n            Is empty when there are no round brackets after the `:::solidity override` keyword.\n\n        Returns:\n            Tuple of IR nodes referencing the contract or interface whose declaration is being overridden.\n        \"\"\"\n        return tuple(self._overrides)\n</code></pre>"},{"location":"api-reference/ir/meta/override-specifier/#wake.ir.meta.override_specifier.OverrideSpecifier.overrides","title":"<code>overrides: Tuple[Union[IdentifierPath, UserDefinedTypeName], ...]</code>  <code>property</code>","text":"<p>Note</p> <p>Is empty when there are no round brackets after the <code>override</code> keyword.</p> <p>Returns:</p> Type Description <code>Tuple[Union[IdentifierPath, UserDefinedTypeName], ...]</code> <p>Tuple of IR nodes referencing the contract or interface whose declaration is being overridden.</p>"},{"location":"api-reference/ir/meta/override-specifier/#wake.ir.meta.override_specifier.OverrideSpecifier.parent","title":"<code>parent: Union[FunctionDefinition, ModifierDefinition, VariableDeclaration]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[FunctionDefinition, ModifierDefinition, VariableDeclaration]</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/meta/parameter-list/","title":"parameter_list","text":""},{"location":"api-reference/ir/meta/parameter-list/#wake.ir.meta.parameter_list","title":"<code>wake.ir.meta.parameter_list</code>  <code>module</code>","text":""},{"location":"api-reference/ir/meta/parameter-list/#wake.ir.meta.parameter_list.ParameterList","title":"<code>ParameterList</code>  <code>class</code>","text":"<p>         Bases: <code>SolidityAbc</code></p> <p>Example</p> <p>A parameter list can be used:</p> <ul> <li>in an ErrorDefinition:<ul> <li><code>(uint requested, uint available)</code> on line 2,</li> </ul> </li> <li>in an EventDefinition:<ul> <li><code>(address indexed previousOwner, address indexed newOwner)</code> on line 3,</li> </ul> </li> <li>in a FunctionDefinition:<ul> <li><code>(uint a, uint b)</code> on line 12 as function parameters,</li> <li><code>(uint256)</code> on line 12 as function return parameters,</li> </ul> </li> <li>in a FunctionTypeName:<ul> <li><code>(string memory, uint)</code> on line 5 as function type name parameters,</li> <li><code>(bool)</code> on line 5 as function type name return parameters,</li> </ul> </li> <li>in a ModifierDefinition:<ul> <li><code>(uint x)</code> on line 7,</li> </ul> </li> <li>in a TryCatchClause:<ul> <li><code>(bool success)</code> on line 17 as try clause parameters,</li> <li><code>(string memory reason)</code> on line 19 as catch clause parameters.</li> </ul> </li> </ul> <pre><code>contract C {\n    error InsufficientBalance(uint requested, uint available);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function (string memory, uint) external returns (bool) externalFunction;\n\n    modifier onlyPositive(uint x) {\n        require(x &gt; 0, \"x must be positive\");\n        _;\n    }\n\n    function add(uint a, uint b) onlyPositive(a) public pure returns (uint256) {\n        return a + b;\n    }\n\n    function callExternalFunction() public {\n        try externalFunction(\"abc\", 123) returns (bool success) {\n            // ...\n        } catch Error(string memory reason) {\n            // ...\n        }\n    }\n}\n</code></pre> Source code in <code>wake/ir/meta/parameter_list.py</code> <pre><code>class ParameterList(SolidityAbc):\n    \"\"\"\n    !!! example\n        A parameter list can be used:\n\n        - in an [ErrorDefinition][wake.ir.declarations.error_definition.ErrorDefinition]:\n            - `:::solidity (uint requested, uint available)` on line 2,\n        - in an [EventDefinition][wake.ir.declarations.event_definition.EventDefinition]:\n            - `:::solidity (address indexed previousOwner, address indexed newOwner)` on line 3,\n        - in a [FunctionDefinition][wake.ir.declarations.function_definition.FunctionDefinition]:\n            - `:::solidity (uint a, uint b)` on line 12 as function parameters,\n            - `:::solidity (uint256)` on line 12 as function return parameters,\n        - in a [FunctionTypeName][wake.ir.type_names.function_type_name.FunctionTypeName]:\n            - `:::solidity (string memory, uint)` on line 5 as function type name parameters,\n            - `:::solidity (bool)` on line 5 as function type name return parameters,\n        - in a [ModifierDefinition][wake.ir.declarations.modifier_definition.ModifierDefinition]:\n            - `:::solidity (uint x)` on line 7,\n        - in a [TryCatchClause][wake.ir.meta.try_catch_clause.TryCatchClause]:\n            - `:::solidity (bool success)` on line 17 as try clause parameters,\n            - `:::solidity (string memory reason)` on line 19 as catch clause parameters.\n\n        ```solidity linenums=\"1\"\n        contract C {\n            error InsufficientBalance(uint requested, uint available);\n            event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n            function (string memory, uint) external returns (bool) externalFunction;\n\n            modifier onlyPositive(uint x) {\n                require(x &gt; 0, \"x must be positive\");\n                _;\n            }\n\n            function add(uint a, uint b) onlyPositive(a) public pure returns (uint256) {\n                return a + b;\n            }\n\n            function callExternalFunction() public {\n                try externalFunction(\"abc\", 123) returns (bool success) {\n                    // ...\n                } catch Error(string memory reason) {\n                    // ...\n                }\n            }\n        }\n        ```\n    \"\"\"\n\n    _ast_node: SolcParameterList\n    _parent: Union[\n        ErrorDefinition,\n        EventDefinition,\n        FunctionDefinition,\n        FunctionTypeName,\n        ModifierDefinition,\n        TryCatchClause,\n    ]\n\n    _parameters: List[VariableDeclaration]\n\n    def __init__(\n        self, init: IrInitTuple, parameter_list: SolcParameterList, parent: SolidityAbc\n    ):\n        super().__init__(init, parameter_list, parent)\n\n        self._parameters = []\n        for parameter in parameter_list.parameters:\n            self._parameters.append(VariableDeclaration(init, parameter, self))\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        for parameter in self._parameters:\n            yield from parameter\n\n    @property\n    def parent(\n        self,\n    ) -&gt; Union[\n        ErrorDefinition,\n        EventDefinition,\n        FunctionDefinition,\n        FunctionTypeName,\n        ModifierDefinition,\n        TryCatchClause,\n    ]:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def parameters(self) -&gt; Tuple[VariableDeclaration, ...]:\n        \"\"\"\n        Can be empty.\n\n        Returns:\n            Variable declarations of the parameter list.\n        \"\"\"\n        return tuple(self._parameters)\n</code></pre>"},{"location":"api-reference/ir/meta/parameter-list/#wake.ir.meta.parameter_list.ParameterList.parameters","title":"<code>parameters: Tuple[VariableDeclaration, ...]</code>  <code>property</code>","text":"<p>Can be empty.</p> <p>Returns:</p> Type Description <code>Tuple[VariableDeclaration, ...]</code> <p>Variable declarations of the parameter list.</p>"},{"location":"api-reference/ir/meta/parameter-list/#wake.ir.meta.parameter_list.ParameterList.parent","title":"<code>parent: Union[ErrorDefinition, EventDefinition, FunctionDefinition, FunctionTypeName, ModifierDefinition, TryCatchClause]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[ErrorDefinition, EventDefinition, FunctionDefinition, FunctionTypeName, ModifierDefinition, TryCatchClause]</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/meta/pragma-directive/","title":"pragma_directive","text":""},{"location":"api-reference/ir/meta/pragma-directive/#wake.ir.meta.pragma_directive","title":"<code>wake.ir.meta.pragma_directive</code>  <code>module</code>","text":""},{"location":"api-reference/ir/meta/pragma-directive/#wake.ir.meta.pragma_directive.PragmaDirective","title":"<code>PragmaDirective</code>  <code>class</code>","text":"<p>         Bases: <code>SolidityAbc</code></p> Source code in <code>wake/ir/meta/pragma_directive.py</code> <pre><code>class PragmaDirective(SolidityAbc):\n    _ast_node: SolcPragmaDirective\n    _parent: SourceUnit\n\n    _literals: List[str]\n\n    def __init__(\n        self, init: IrInitTuple, pragma: SolcPragmaDirective, parent: SolidityAbc\n    ):\n        super().__init__(init, pragma, parent)\n        self._literals = list(pragma.literals)\n\n    @property\n    def parent(self) -&gt; SourceUnit:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def literals(self) -&gt; Tuple[str, ...]:\n        \"\"\"\n        !!! example\n            `:::py ('solidity', '^', '0.8', '||', '0.7', '.1', '-', '0.7', '.6')` for the following pragma:\n            ```solidity\n            pragma solidity ^0.8 || 0.7.1 - 0.7.6;\n            ```\n        !!! example\n            `:::py ('abicoder', 'v2')` for the following pragma:\n            ```solidity\n            pragma abicoder v2;\n            ```\n        !!! example\n            `:::py ('experimental', 'SMTChecker')` for the following pragma:\n            ```solidity\n            pragma experimental SMTChecker;\n            ```\n\n        Returns:\n            Literals of the pragma directive.\n        \"\"\"\n        return tuple(self._literals)\n</code></pre>"},{"location":"api-reference/ir/meta/pragma-directive/#wake.ir.meta.pragma_directive.PragmaDirective.literals","title":"<code>literals: Tuple[str, ...]</code>  <code>property</code>","text":"<p>Example</p> <p><code>('solidity', '^', '0.8', '||', '0.7', '.1', '-', '0.7', '.6')</code> for the following pragma: <pre><code>pragma solidity ^0.8 || 0.7.1 - 0.7.6;\n</code></pre></p> <p>Example</p> <p><code>('abicoder', 'v2')</code> for the following pragma: <pre><code>pragma abicoder v2;\n</code></pre></p> <p>Example</p> <p><code>('experimental', 'SMTChecker')</code> for the following pragma: <pre><code>pragma experimental SMTChecker;\n</code></pre></p> <p>Returns:</p> Type Description <code>Tuple[str, ...]</code> <p>Literals of the pragma directive.</p>"},{"location":"api-reference/ir/meta/pragma-directive/#wake.ir.meta.pragma_directive.PragmaDirective.parent","title":"<code>parent: SourceUnit</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>SourceUnit</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/meta/source-unit/","title":"source_unit","text":""},{"location":"api-reference/ir/meta/source-unit/#wake.ir.meta.source_unit","title":"<code>wake.ir.meta.source_unit</code>  <code>module</code>","text":""},{"location":"api-reference/ir/meta/source-unit/#wake.ir.meta.source_unit.SourceUnit","title":"<code>SourceUnit</code>  <code>class</code>","text":"<p>         Bases: <code>SolidityAbc</code></p> <p>Source unit is the root node.</p> <p>Warning</p> <p>Source unit byte_location does not cover the whole file. Only lines 3-7 are covered by the source unit in the following example: <pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8;\n\ncontract Foo {\n    function bar() public {}\n}\n</code></pre> Also trailing newlines are not covered by the source unit.</p> Source code in <code>wake/ir/meta/source_unit.py</code> <pre><code>class SourceUnit(SolidityAbc):\n    \"\"\"\n    Source unit is the root node.\n\n    !!! warning\n        Source unit [byte_location][wake.ir.abc.IrAbc.byte_location] does not cover the whole file.\n        Only lines 3-7 are covered by the source unit in the following example:\n        ```solidity linenums=\"1\"\n        // SPDX-License-Identifier: MIT\n\n        pragma solidity ^0.8;\n\n        contract Foo {\n            function bar() public {}\n        }\n        ```\n        Also trailing newlines are not covered by the source unit.\n    \"\"\"\n\n    _ast_node: SolcSourceUnit\n\n    _file_source: bytes\n    _license: Optional[str]\n    _source_unit_name: str\n    _pragmas: List[PragmaDirective]\n    _imports: List[ImportDirective]\n    _declared_variables: List[VariableDeclaration]\n    _enums: List[EnumDefinition]\n    _functions: List[FunctionDefinition]\n    _structs: List[StructDefinition]\n    _errors: List[ErrorDefinition]\n    _user_defined_value_types: List[UserDefinedValueTypeDefinition]\n    _contracts: List[ContractDefinition]\n    _using_for_directives: List[UsingForDirective]\n    _events: List[EventDefinition]\n\n    _version_ranges: SolidityVersionRanges\n    _file: Path\n    _cu_hash: bytes\n    # TODO strip this from pickle?\n    _lines_index: Optional[List[Tuple[bytes, int]]]  # lines with prefix length\n\n    def __init__(\n        self,\n        init: IrInitTuple,\n        source_unit: SolcSourceUnit,\n    ):\n        init.source_unit = self\n        self._file = init.file\n        self._cu_hash = init.cu.hash\n        super().__init__(init, source_unit, None)\n        self._file_source = init.source\n        self._license = source_unit.license\n        self._source_unit_name = source_unit.absolute_path\n        self._version_ranges = init.cu.versions\n        self._lines_index = None\n\n        self._pragmas = []\n        self._imports = []\n        self._declared_variables = []\n        self._enums = []\n        self._functions = []\n        self._structs = []\n        self._errors = []\n        self._user_defined_value_types = []\n        self._contracts = []\n        self._using_for_directives = []\n        self._events = []\n        for node in source_unit.nodes:\n            if isinstance(node, SolcPragmaDirective):\n                self._pragmas.append(PragmaDirective(init, node, self))\n            elif isinstance(node, SolcImportDirective):\n                self._imports.append(ImportDirective(init, node, self))\n            elif isinstance(node, SolcVariableDeclaration):\n                self._declared_variables.append(VariableDeclaration(init, node, self))\n            elif isinstance(node, SolcEnumDefinition):\n                self._enums.append(EnumDefinition(init, node, self))\n            elif isinstance(node, SolcFunctionDefinition):\n                self._functions.append(FunctionDefinition(init, node, self))\n            elif isinstance(node, SolcStructDefinition):\n                self._structs.append(StructDefinition(init, node, self))\n            elif isinstance(node, SolcErrorDefinition):\n                self._errors.append(ErrorDefinition(init, node, self))\n            elif isinstance(node, SolcUserDefinedValueTypeDefinition):\n                self._user_defined_value_types.append(\n                    UserDefinedValueTypeDefinition(init, node, self)\n                )\n            elif isinstance(node, SolcContractDefinition):\n                self._contracts.append(ContractDefinition(init, node, self))\n            elif isinstance(node, SolcUsingForDirective):\n                self._using_for_directives.append(UsingForDirective(init, node, self))\n            elif isinstance(node, SolcEventDefinition):\n                self._events.append(EventDefinition(init, node, self))\n            else:\n                assert False, f\"Unknown node type: {node}\"\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        for pragma in self._pragmas:\n            yield from pragma\n        for import_directive in self._imports:\n            yield from import_directive\n        for variable_declaration in self._declared_variables:\n            yield from variable_declaration\n        for enum in self._enums:\n            yield from enum\n        for function in self._functions:\n            yield from function\n        for struct in self._structs:\n            yield from struct\n        for error in self._errors:\n            yield from error\n        for user_defined_value_type in self._user_defined_value_types:\n            yield from user_defined_value_type\n        for contract in self._contracts:\n            yield from contract\n        for using_for_directive in self._using_for_directives:\n            yield from using_for_directive\n        for event in self._events:\n            yield from event\n\n    @property\n    def parent(self) -&gt; None:\n        \"\"\"\n        Returns:\n            Does not have a parent.\n        \"\"\"\n        return None\n\n    @property\n    def file_source(self) -&gt; bytes:\n        \"\"\"\n        As opposed to [source][wake.ir.abc.IrAbc.source], this property returns the whole file source.\n\n        Returns:\n            Source code of the file including trailing newlines and license string.\n        \"\"\"\n        return self._file_source\n\n    @property\n    def license(self) -&gt; Optional[str]:\n        \"\"\"\n        !!! example\n            Returns `MIT` for the following license comment:\n            ```solidity\n            // SPDX-License-Identifier: MIT\n            ```\n\n        Returns:\n            License string of the file, if any.\n        \"\"\"\n        return self._license\n\n    @property\n    def source_unit_name(self) -&gt; str:\n        \"\"\"\n        Returns:\n            Source unit name of the file.\n        \"\"\"\n        return self._source_unit_name\n\n    @property\n    def pragmas(self) -&gt; Tuple[PragmaDirective, ...]:\n        \"\"\"\n        Returns:\n            Pragma directives present in the file.\n        \"\"\"\n        return tuple(self._pragmas)\n\n    @property\n    def imports(self) -&gt; Tuple[ImportDirective, ...]:\n        \"\"\"\n        Returns:\n            Import directives present in the file.\n        \"\"\"\n        return tuple(self._imports)\n\n    @property\n    def declared_variables(self) -&gt; Tuple[VariableDeclaration, ...]:\n        \"\"\"\n        Should only return constants.\n\n        Returns:\n            Top-level variable declarations present in the file.\n        \"\"\"\n        return tuple(self._declared_variables)\n\n    @property\n    def enums(self) -&gt; Tuple[EnumDefinition, ...]:\n        \"\"\"\n        Returns:\n            Top-level enum definitions present in the file.\n        \"\"\"\n        return tuple(self._enums)\n\n    @property\n    def functions(self) -&gt; Tuple[FunctionDefinition, ...]:\n        \"\"\"\n        Should only return [FunctionDefinitions][wake.ir.declarations.function_definition.FunctionDefinition] of the [FunctionKind.FREE_FUNCTION][wake.ir.enums.FunctionKind.FREE_FUNCTION] kind.\n\n        Returns:\n            Top-level function definitions present in the file.\n        \"\"\"\n        return tuple(self._functions)\n\n    @property\n    def structs(self) -&gt; Tuple[StructDefinition, ...]:\n        \"\"\"\n        Returns:\n            Top-level struct definitions present in the file.\n        \"\"\"\n        return tuple(self._structs)\n\n    @property\n    def errors(self) -&gt; Tuple[ErrorDefinition, ...]:\n        \"\"\"\n        Returns:\n            Top-level error definitions present in the file.\n        \"\"\"\n        return tuple(self._errors)\n\n    @property\n    def user_defined_value_types(self) -&gt; Tuple[UserDefinedValueTypeDefinition, ...]:\n        \"\"\"\n        Returns:\n            Top-level user-defined value type definitions present in the file.\n        \"\"\"\n        return tuple(self._user_defined_value_types)\n\n    @property\n    def contracts(self) -&gt; Tuple[ContractDefinition, ...]:\n        \"\"\"\n        Returns:\n            Contract definitions present in the file.\n        \"\"\"\n        return tuple(self._contracts)\n\n    @property\n    def using_for_directives(self) -&gt; Tuple[UsingForDirective, ...]:\n        \"\"\"\n        Returns:\n            Top-level using for directives present in the file.\n        \"\"\"\n        return tuple(self._using_for_directives)\n\n    @property\n    def events(self) -&gt; Tuple[EventDefinition, ...]:\n        \"\"\"\n        Returns:\n            Top-level event definitions present in the file.\n        \"\"\"\n        return tuple(self._events)\n\n    @property\n    def version_ranges(self) -&gt; SolidityVersionRanges:\n        \"\"\"\n        !!! example\n            ```python\n            if \"0.8.0\" in node.version_ranges:\n                print(\"The given file can be compiled with solc 0.8.0\")\n            ```\n\n        Returns:\n            Object listing all `solc` versions that can be used to compile the file containing this node.\n        \"\"\"\n        return self._version_ranges\n\n    @property\n    def cu_hash(self) -&gt; bytes:\n        \"\"\"\n        Refer to [ReferenceResolver][wake.ir.reference_resolver.ReferenceResolver] for more information about compilation units.\n\n        Returns:\n            Hash of the compilation unit that produced this source unit.\n        \"\"\"\n        return self._cu_hash\n\n    @property\n    def file(self) -&gt; Path:\n        \"\"\"\n        The absolute path to the source file that is represented by this node.\n\n        Returns:\n            Absolute path to the file containing this node.\n        \"\"\"\n        return self._file\n\n    def declarations_iter(self) -&gt; Iterator[DeclarationAbc]:\n        \"\"\"\n        Yields:\n            All declarations present in the file (recursively).\n        \"\"\"\n        yield from self.declared_variables\n        yield from self.enums\n        for enum in self.enums:\n            yield from enum.values\n        yield from self.functions\n        yield from self.structs\n        yield from self.errors\n        yield from self.user_defined_value_types\n        yield from self.contracts\n        yield from self.events\n        for contract in self.contracts:\n            yield from contract.declarations_iter()\n\n    def get_line_col_from_byte_offset(self, byte_offset: int) -&gt; Tuple[int, int]:\n        if self._lines_index is None:\n            self._lines_index = []\n            prefix_sum = 0\n\n            for line in self._file_source.splitlines(keepends=True):\n                self._lines_index.append((line, prefix_sum))\n                prefix_sum += len(line)\n\n        line_prefix_sums = [line[1] for line in self._lines_index]\n        line = bisect_right(line_prefix_sums, byte_offset)\n        # TODO different modes: UTF-16 code units, UTF-8 code units (bytes), UTF-8 code points (len of str)\n        col = (\n            len(\n                self._lines_index[line - 1][0][\n                    : byte_offset - self._lines_index[line - 1][1]\n                ]\n                .decode(\"utf-8\")\n                .encode(\"utf-16-le\")\n            )\n            // 2\n            + 1\n        )\n        # TODO line col zero-indexed or one-indexed?\n        # currently returning one-indexed\n        return line, col\n</code></pre>"},{"location":"api-reference/ir/meta/source-unit/#wake.ir.meta.source_unit.SourceUnit.contracts","title":"<code>contracts: Tuple[ContractDefinition, ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[ContractDefinition, ...]</code> <p>Contract definitions present in the file.</p>"},{"location":"api-reference/ir/meta/source-unit/#wake.ir.meta.source_unit.SourceUnit.cu_hash","title":"<code>cu_hash: bytes</code>  <code>property</code>","text":"<p>Refer to ReferenceResolver for more information about compilation units.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>Hash of the compilation unit that produced this source unit.</p>"},{"location":"api-reference/ir/meta/source-unit/#wake.ir.meta.source_unit.SourceUnit.declared_variables","title":"<code>declared_variables: Tuple[VariableDeclaration, ...]</code>  <code>property</code>","text":"<p>Should only return constants.</p> <p>Returns:</p> Type Description <code>Tuple[VariableDeclaration, ...]</code> <p>Top-level variable declarations present in the file.</p>"},{"location":"api-reference/ir/meta/source-unit/#wake.ir.meta.source_unit.SourceUnit.enums","title":"<code>enums: Tuple[EnumDefinition, ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[EnumDefinition, ...]</code> <p>Top-level enum definitions present in the file.</p>"},{"location":"api-reference/ir/meta/source-unit/#wake.ir.meta.source_unit.SourceUnit.errors","title":"<code>errors: Tuple[ErrorDefinition, ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[ErrorDefinition, ...]</code> <p>Top-level error definitions present in the file.</p>"},{"location":"api-reference/ir/meta/source-unit/#wake.ir.meta.source_unit.SourceUnit.events","title":"<code>events: Tuple[EventDefinition, ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[EventDefinition, ...]</code> <p>Top-level event definitions present in the file.</p>"},{"location":"api-reference/ir/meta/source-unit/#wake.ir.meta.source_unit.SourceUnit.file","title":"<code>file: Path</code>  <code>property</code>","text":"<p>The absolute path to the source file that is represented by this node.</p> <p>Returns:</p> Type Description <code>Path</code> <p>Absolute path to the file containing this node.</p>"},{"location":"api-reference/ir/meta/source-unit/#wake.ir.meta.source_unit.SourceUnit.file_source","title":"<code>file_source: bytes</code>  <code>property</code>","text":"<p>As opposed to source, this property returns the whole file source.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>Source code of the file including trailing newlines and license string.</p>"},{"location":"api-reference/ir/meta/source-unit/#wake.ir.meta.source_unit.SourceUnit.functions","title":"<code>functions: Tuple[FunctionDefinition, ...]</code>  <code>property</code>","text":"<p>Should only return FunctionDefinitions of the FunctionKind.FREE_FUNCTION kind.</p> <p>Returns:</p> Type Description <code>Tuple[FunctionDefinition, ...]</code> <p>Top-level function definitions present in the file.</p>"},{"location":"api-reference/ir/meta/source-unit/#wake.ir.meta.source_unit.SourceUnit.imports","title":"<code>imports: Tuple[ImportDirective, ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[ImportDirective, ...]</code> <p>Import directives present in the file.</p>"},{"location":"api-reference/ir/meta/source-unit/#wake.ir.meta.source_unit.SourceUnit.license","title":"<code>license: Optional[str]</code>  <code>property</code>","text":"<p>Example</p> <p>Returns <code>MIT</code> for the following license comment: <pre><code>// SPDX-License-Identifier: MIT\n</code></pre></p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>License string of the file, if any.</p>"},{"location":"api-reference/ir/meta/source-unit/#wake.ir.meta.source_unit.SourceUnit.parent","title":"<code>parent: None</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>None</code> <p>Does not have a parent.</p>"},{"location":"api-reference/ir/meta/source-unit/#wake.ir.meta.source_unit.SourceUnit.pragmas","title":"<code>pragmas: Tuple[PragmaDirective, ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[PragmaDirective, ...]</code> <p>Pragma directives present in the file.</p>"},{"location":"api-reference/ir/meta/source-unit/#wake.ir.meta.source_unit.SourceUnit.source_unit_name","title":"<code>source_unit_name: str</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>Source unit name of the file.</p>"},{"location":"api-reference/ir/meta/source-unit/#wake.ir.meta.source_unit.SourceUnit.structs","title":"<code>structs: Tuple[StructDefinition, ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[StructDefinition, ...]</code> <p>Top-level struct definitions present in the file.</p>"},{"location":"api-reference/ir/meta/source-unit/#wake.ir.meta.source_unit.SourceUnit.user_defined_value_types","title":"<code>user_defined_value_types: Tuple[UserDefinedValueTypeDefinition, ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[UserDefinedValueTypeDefinition, ...]</code> <p>Top-level user-defined value type definitions present in the file.</p>"},{"location":"api-reference/ir/meta/source-unit/#wake.ir.meta.source_unit.SourceUnit.using_for_directives","title":"<code>using_for_directives: Tuple[UsingForDirective, ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[UsingForDirective, ...]</code> <p>Top-level using for directives present in the file.</p>"},{"location":"api-reference/ir/meta/source-unit/#wake.ir.meta.source_unit.SourceUnit.version_ranges","title":"<code>version_ranges: SolidityVersionRanges</code>  <code>property</code>","text":"<p>Example</p> <pre><code>if \"0.8.0\" in node.version_ranges:\n    print(\"The given file can be compiled with solc 0.8.0\")\n</code></pre> <p>Returns:</p> Type Description <code>SolidityVersionRanges</code> <p>Object listing all <code>solc</code> versions that can be used to compile the file containing this node.</p>"},{"location":"api-reference/ir/meta/source-unit/#wake.ir.meta.source_unit.SourceUnit.declarations_iter","title":"<code>declarations_iter()</code>","text":"<p>Yields:</p> Type Description <code>DeclarationAbc</code> <p>All declarations present in the file (recursively).</p> Source code in <code>wake/ir/meta/source_unit.py</code> <pre><code>def declarations_iter(self) -&gt; Iterator[DeclarationAbc]:\n    \"\"\"\n    Yields:\n        All declarations present in the file (recursively).\n    \"\"\"\n    yield from self.declared_variables\n    yield from self.enums\n    for enum in self.enums:\n        yield from enum.values\n    yield from self.functions\n    yield from self.structs\n    yield from self.errors\n    yield from self.user_defined_value_types\n    yield from self.contracts\n    yield from self.events\n    for contract in self.contracts:\n        yield from contract.declarations_iter()\n</code></pre>"},{"location":"api-reference/ir/meta/structured-documentation/","title":"structured_documentation","text":""},{"location":"api-reference/ir/meta/structured-documentation/#wake.ir.meta.structured_documentation","title":"<code>wake.ir.meta.structured_documentation</code>  <code>module</code>","text":""},{"location":"api-reference/ir/meta/structured-documentation/#wake.ir.meta.structured_documentation.StructuredDocumentation","title":"<code>StructuredDocumentation</code>  <code>class</code>","text":"<p>         Bases: <code>SolidityAbc</code></p> <p>Example</p> <p>Lines 1-4 in the following example: <pre><code>/// @title A simulator for trees\n/// @author John\n/// @notice You can use this contract for only the most basic simulation\n/// @dev All function calls are currently implemented without side effects\ncontract Tree {\n    function multiply(uint a) public pure returns(uint) {\n        return a * 7;\n    }\n}\n</code></pre></p> Source code in <code>wake/ir/meta/structured_documentation.py</code> <pre><code>class StructuredDocumentation(SolidityAbc):\n    \"\"\"\n    !!! example\n        Lines 1-4 in the following example:\n        ```solidity linenums=\"1\"\n        /// @title A simulator for trees\n        /// @author John\n        /// @notice You can use this contract for only the most basic simulation\n        /// @dev All function calls are currently implemented without side effects\n        contract Tree {\n            function multiply(uint a) public pure returns(uint) {\n                return a * 7;\n            }\n        }\n        ```\n    \"\"\"\n\n    _ast_node: SolcStructuredDocumentation\n    _parent: Union[\n        ContractDefinition,\n        EnumDefinition,\n        ErrorDefinition,\n        EventDefinition,\n        FunctionDefinition,\n        ModifierDefinition,\n        StructDefinition,\n        VariableDeclaration,\n    ]\n\n    _text: str\n\n    def __init__(\n        self,\n        init: IrInitTuple,\n        structured_documentation: SolcStructuredDocumentation,\n        parent: SolidityAbc,\n    ):\n        super().__init__(init, structured_documentation, parent)\n        self._text = structured_documentation.text\n\n    @property\n    def parent(\n        self,\n    ) -&gt; Union[\n        ContractDefinition,\n        EnumDefinition,\n        ErrorDefinition,\n        EventDefinition,\n        FunctionDefinition,\n        ModifierDefinition,\n        StructDefinition,\n        VariableDeclaration,\n    ]:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def text(self) -&gt; str:\n        \"\"\"\n        Does not include the leading `///` or `/**` and trailing `*/`.\n\n        Returns:\n            [NatSpec](https://docs.soliditylang.org/en/latest/natspec-format.html) documentation string.\n        \"\"\"\n        return self._text\n</code></pre>"},{"location":"api-reference/ir/meta/structured-documentation/#wake.ir.meta.structured_documentation.StructuredDocumentation.parent","title":"<code>parent: Union[ContractDefinition, EnumDefinition, ErrorDefinition, EventDefinition, FunctionDefinition, ModifierDefinition, StructDefinition, VariableDeclaration]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[ContractDefinition, EnumDefinition, ErrorDefinition, EventDefinition, FunctionDefinition, ModifierDefinition, StructDefinition, VariableDeclaration]</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/meta/structured-documentation/#wake.ir.meta.structured_documentation.StructuredDocumentation.text","title":"<code>text: str</code>  <code>property</code>","text":"<p>Does not include the leading <code>///</code> or <code>/**</code> and trailing <code>*/</code>.</p> <p>Returns:</p> Type Description <code>str</code> <p>NatSpec documentation string.</p>"},{"location":"api-reference/ir/meta/try-catch-clause/","title":"try_catch_clause","text":""},{"location":"api-reference/ir/meta/try-catch-clause/#wake.ir.meta.try_catch_clause","title":"<code>wake.ir.meta.try_catch_clause</code>  <code>module</code>","text":""},{"location":"api-reference/ir/meta/try-catch-clause/#wake.ir.meta.try_catch_clause.TryCatchClause","title":"<code>TryCatchClause</code>  <code>class</code>","text":"<p>         Bases: <code>SolidityAbc</code></p> <p>Example</p> <p>All the following are try/catch clauses in the example below:</p> <ul> <li><code>returns(uint x) {}</code>,</li> <li><code>catch Error(string memory reason) {}</code>,</li> <li><code>catch Panic(uint errorCode) {}</code>,</li> <li><code>catch (bytes memory lowLevelData) {}</code>.</li> </ul> <pre><code>contract C {\n    function foo() public view {\n        try this.bar(10) returns(uint x) {}\n        catch Error(string memory reason) {}\n        catch Panic(uint errorCode) {}\n        catch (bytes memory lowLevelData) {}\n    }\n\n    function bar(uint x) external pure returns(uint) {\n        return x;\n    }\n}\n</code></pre> Source code in <code>wake/ir/meta/try_catch_clause.py</code> <pre><code>class TryCatchClause(SolidityAbc):\n    \"\"\"\n    !!! example\n        All the following are try/catch clauses in the example below:\n\n        - `:::solidity returns(uint x) {}`,\n        - `:::solidity catch Error(string memory reason) {}`,\n        - `:::solidity catch Panic(uint errorCode) {}`,\n        - `:::solidity catch (bytes memory lowLevelData) {}`.\n\n        ```solidity\n        contract C {\n            function foo() public view {\n                try this.bar(10) returns(uint x) {}\n                catch Error(string memory reason) {}\n                catch Panic(uint errorCode) {}\n                catch (bytes memory lowLevelData) {}\n            }\n\n            function bar(uint x) external pure returns(uint) {\n                return x;\n            }\n        }\n        ```\n    \"\"\"\n\n    _ast_node: SolcTryCatchClause\n    _parent: TryStatement\n\n    _block: Block\n    _error_name: str\n    _parameters: Optional[ParameterList]\n\n    def __init__(\n        self,\n        init: IrInitTuple,\n        try_catch_clause: SolcTryCatchClause,\n        parent: TryStatement,\n    ):\n        super().__init__(init, try_catch_clause, parent)\n        self._block = Block(init, try_catch_clause.block, self)\n        self._error_name = try_catch_clause.error_name\n\n        if try_catch_clause.parameters is None:\n            self._parameters = None\n        else:\n            self._parameters = ParameterList(init, try_catch_clause.parameters, self)\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        yield from self._block\n        if self._parameters is not None:\n            yield from self._parameters\n\n    @property\n    def parent(self) -&gt; TryStatement:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def block(self) -&gt; Block:\n        \"\"\"\n        Returns:\n            Body of the try/catch clause.\n        \"\"\"\n        return self._block\n\n    @property\n    def error_name(self) -&gt; str:\n        \"\"\"\n        !!! example\n            For the following snippet:\n            ```solidity\n            try this.f() returns (uint256) {\n                // ...\n            } catch Error(string memory reason) {\n                // ...\n            } catch Panic(uint errorCode) {\n                // ...\n            } catch (bytes memory lowLevelData) {\n                // ...\n            }\n            ```\n\n            - is empty for the first (try) clause,\n            - is `Error` for the second (catch) clause,\n            - is `Panic` for the third (catch) clause,\n            - is empty for the fourth (catch) clause.\n\n        Returns:\n            Error name of the try/catch clause.\n        \"\"\"\n        return self._error_name\n\n    @property\n    def parameters(self) -&gt; Optional[ParameterList]:\n        \"\"\"\n        Can be `None` if the try clause does not have return parameters or if the catch clause does not accept parameters.\n        !!! example\n            Both clauses in the following example do not have parameters:\n            ```solidity\n            try this.f() {\n                // ...\n            } catch {\n                // ...\n            }\n            ```\n\n        !!! example\n            `:::solidity (uint x)`, `:::solidity (string memory reason)`, `:::solidity (uint errorCode)` and `:::solidity (bytes memory lowLevelData)` are the parameters of the try/catch clauses in the following example:\n            ```solidity\n            try this.f() returns (uint x) {\n                // ...\n            } catch Error(string memory reason) {\n                // ...\n            } catch Panic(uint errorCode) {\n                // ...\n            } catch (bytes memory lowLevelData) {\n                // ...\n            }\n            ```\n\n        Returns:\n            Return parameters in the case of a try clause, or error parameters in the case of a catch clause.\n        \"\"\"\n        return self._parameters\n\n    @property\n    @lru_cache(maxsize=2048)\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        return self.block.modifies_state\n</code></pre>"},{"location":"api-reference/ir/meta/try-catch-clause/#wake.ir.meta.try_catch_clause.TryCatchClause.block","title":"<code>block: Block</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Block</code> <p>Body of the try/catch clause.</p>"},{"location":"api-reference/ir/meta/try-catch-clause/#wake.ir.meta.try_catch_clause.TryCatchClause.error_name","title":"<code>error_name: str</code>  <code>property</code>","text":"<p>Example</p> <p>For the following snippet: <pre><code>try this.f() returns (uint256) {\n    // ...\n} catch Error(string memory reason) {\n    // ...\n} catch Panic(uint errorCode) {\n    // ...\n} catch (bytes memory lowLevelData) {\n    // ...\n}\n</code></pre></p> <ul> <li>is empty for the first (try) clause,</li> <li>is <code>Error</code> for the second (catch) clause,</li> <li>is <code>Panic</code> for the third (catch) clause,</li> <li>is empty for the fourth (catch) clause.</li> </ul> <p>Returns:</p> Type Description <code>str</code> <p>Error name of the try/catch clause.</p>"},{"location":"api-reference/ir/meta/try-catch-clause/#wake.ir.meta.try_catch_clause.TryCatchClause.parameters","title":"<code>parameters: Optional[ParameterList]</code>  <code>property</code>","text":"<p>Can be <code>None</code> if the try clause does not have return parameters or if the catch clause does not accept parameters.</p> <p>Example</p> <p>Both clauses in the following example do not have parameters: <pre><code>try this.f() {\n    // ...\n} catch {\n    // ...\n}\n</code></pre></p> <p>Example</p> <p><code>(uint x)</code>, <code>(string memory reason)</code>, <code>(uint errorCode)</code> and <code>(bytes memory lowLevelData)</code> are the parameters of the try/catch clauses in the following example: <pre><code>try this.f() returns (uint x) {\n    // ...\n} catch Error(string memory reason) {\n    // ...\n} catch Panic(uint errorCode) {\n    // ...\n} catch (bytes memory lowLevelData) {\n    // ...\n}\n</code></pre></p> <p>Returns:</p> Type Description <code>Optional[ParameterList]</code> <p>Return parameters in the case of a try clause, or error parameters in the case of a catch clause.</p>"},{"location":"api-reference/ir/meta/try-catch-clause/#wake.ir.meta.try_catch_clause.TryCatchClause.parent","title":"<code>parent: TryStatement</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>TryStatement</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/meta/using-for-directive/","title":"using_for_directive","text":""},{"location":"api-reference/ir/meta/using-for-directive/#wake.ir.meta.using_for_directive","title":"<code>wake.ir.meta.using_for_directive</code>  <code>module</code>","text":""},{"location":"api-reference/ir/meta/using-for-directive/#wake.ir.meta.using_for_directive.UsingForDirective","title":"<code>UsingForDirective</code>  <code>class</code>","text":"<p>         Bases: <code>SolidityAbc</code></p> <p>Note</p> <p>Either library_name must be set or one of functions or operator_functions must be non-empty.</p> <p>Example</p> <p>Lines 18, 21 and 22 in the following example: <pre><code>type I8 is int8;\n\nfunction add(uint a, uint b) pure returns (uint) {\n    return a + b;\n}\n\nfunction sub(I8 a, I8 b) pure returns (I8) {\n    return I8.wrap(I8.unwrap(a) - I8.unwrap(b));\n}\n\nlibrary SafeMath {\n    function sub(uint a, uint b) public pure returns (uint) {\n        require(b &lt;= a);\n        return a - b;\n    }\n}\n\nusing {sub as -} for I8 global;\n\ncontract C {\n    using SafeMath for uint;\n    using {add} for uint;\n}\n</code></pre></p> Source code in <code>wake/ir/meta/using_for_directive.py</code> <pre><code>class UsingForDirective(SolidityAbc):\n    \"\"\"\n    !!! note\n        Either [library_name][wake.ir.meta.using_for_directive.UsingForDirective.library_name] must be set or one of [functions][wake.ir.meta.using_for_directive.UsingForDirective.functions] or [operator_functions][wake.ir.meta.using_for_directive.UsingForDirective.operator_functions] must be non-empty.\n    !!! example\n        Lines 18, 21 and 22 in the following example:\n        ```solidity linenums=\"1\"\n        type I8 is int8;\n\n        function add(uint a, uint b) pure returns (uint) {\n            return a + b;\n        }\n\n        function sub(I8 a, I8 b) pure returns (I8) {\n            return I8.wrap(I8.unwrap(a) - I8.unwrap(b));\n        }\n\n        library SafeMath {\n            function sub(uint a, uint b) public pure returns (uint) {\n                require(b &lt;= a);\n                return a - b;\n            }\n        }\n\n        using {sub as -} for I8 global;\n\n        contract C {\n            using SafeMath for uint;\n            using {add} for uint;\n        }\n        ```\n    \"\"\"\n\n    _ast_node: SolcUsingForDirective\n    _parent: Union[ContractDefinition, SourceUnit]\n\n    _functions: List[IdentifierPath]\n    _operator_functions: List[\n        Tuple[IdentifierPath, Union[UnaryOpOperator, BinaryOpOperator]]\n    ]\n    _library_name: Optional[Union[IdentifierPath, UserDefinedTypeName]]\n    _type_name: Optional[TypeNameAbc]\n    # TODO add _global\n\n    def __init__(\n        self,\n        init: IrInitTuple,\n        using_for_directive: SolcUsingForDirective,\n        parent: Union[ContractDefinition, SourceUnit],\n    ):\n        super().__init__(init, using_for_directive, parent)\n\n        if using_for_directive.function_list is None:\n            self._functions = []\n            self._operator_functions = []\n        else:\n            self._functions = [\n                IdentifierPath(init, function.function, self)\n                for function in using_for_directive.function_list\n                if function.function is not None\n            ]\n            self._operator_functions = [\n                (\n                    IdentifierPath(init, function.definition, self),\n                    function.operator,\n                )\n                for function in using_for_directive.function_list\n                if function.definition is not None and function.operator is not None\n            ]\n\n        if using_for_directive.library_name is None:\n            self._library_name = None\n        elif isinstance(using_for_directive.library_name, SolcUserDefinedTypeName):\n            self._library_name = UserDefinedTypeName(\n                init, using_for_directive.library_name, self\n            )\n        elif isinstance(using_for_directive.library_name, SolcIdentifierPath):\n            self._library_name = IdentifierPath(\n                init, using_for_directive.library_name, self\n            )\n\n        if using_for_directive.type_name is None:\n            self._type_name = None\n        else:\n            self._type_name = TypeNameAbc.from_ast(\n                init, using_for_directive.type_name, self\n            )\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        for function in self._functions:\n            yield from function\n        for function, _ in self._operator_functions:\n            yield from function\n        if self._library_name is not None:\n            yield from self._library_name\n        if self._type_name is not None:\n            yield from self._type_name\n\n    @property\n    def parent(self) -&gt; Union[ContractDefinition, SourceUnit]:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def functions(self) -&gt; Tuple[IdentifierPath, ...]:\n        \"\"\"\n        Returns:\n            List of functions that are attached to the target type.\n        \"\"\"\n        return tuple(self._functions)\n\n    @property\n    def operator_functions(\n        self,\n    ) -&gt; Tuple[Tuple[IdentifierPath, Union[UnaryOpOperator, BinaryOpOperator]], ...]:\n        \"\"\"\n        Returns:\n            List of operator functions and their operators that are attached to the target type.\n        \"\"\"\n        return tuple(self._operator_functions)\n\n    @property\n    def library_name(self) -&gt; Optional[Union[IdentifierPath, UserDefinedTypeName]]:\n        \"\"\"\n        Is only set in the case of `:::solidity using LibraryName for TypeName;` directive type.\n\n        Returns:\n            IR node referencing the library ([ContractDefinition][wake.ir.declarations.contract_definition.ContractDefinition] of the [ContractKind.LIBRARY][wake.ir.enums.ContractKind.LIBRARY] kind) that is attached to the target type.\n        \"\"\"\n        return self._library_name\n\n    @property\n    def type_name(self) -&gt; Optional[TypeNameAbc]:\n        \"\"\"\n        Is `None` in the case of `:::solidity using Lib for *;`.\n\n        Returns:\n            Type name that is attached to the functions or library.\n        \"\"\"\n        return self._type_name\n</code></pre>"},{"location":"api-reference/ir/meta/using-for-directive/#wake.ir.meta.using_for_directive.UsingForDirective.functions","title":"<code>functions: Tuple[IdentifierPath, ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[IdentifierPath, ...]</code> <p>List of functions that are attached to the target type.</p>"},{"location":"api-reference/ir/meta/using-for-directive/#wake.ir.meta.using_for_directive.UsingForDirective.library_name","title":"<code>library_name: Optional[Union[IdentifierPath, UserDefinedTypeName]]</code>  <code>property</code>","text":"<p>Is only set in the case of <code>using LibraryName for TypeName;</code> directive type.</p> <p>Returns:</p> Type Description <code>Optional[Union[IdentifierPath, UserDefinedTypeName]]</code> <p>IR node referencing the library (ContractDefinition of the ContractKind.LIBRARY kind) that is attached to the target type.</p>"},{"location":"api-reference/ir/meta/using-for-directive/#wake.ir.meta.using_for_directive.UsingForDirective.operator_functions","title":"<code>operator_functions: Tuple[Tuple[IdentifierPath, Union[UnaryOpOperator, BinaryOpOperator]], ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[Tuple[IdentifierPath, Union[UnaryOpOperator, BinaryOpOperator]], ...]</code> <p>List of operator functions and their operators that are attached to the target type.</p>"},{"location":"api-reference/ir/meta/using-for-directive/#wake.ir.meta.using_for_directive.UsingForDirective.parent","title":"<code>parent: Union[ContractDefinition, SourceUnit]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[ContractDefinition, SourceUnit]</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/meta/using-for-directive/#wake.ir.meta.using_for_directive.UsingForDirective.type_name","title":"<code>type_name: Optional[TypeNameAbc]</code>  <code>property</code>","text":"<p>Is <code>None</code> in the case of <code>using Lib for *;</code>.</p> <p>Returns:</p> Type Description <code>Optional[TypeNameAbc]</code> <p>Type name that is attached to the functions or library.</p>"},{"location":"api-reference/ir/statements/abc/","title":"abc","text":""},{"location":"api-reference/ir/statements/abc/#wake.ir.statements.abc","title":"<code>wake.ir.statements.abc</code>  <code>module</code>","text":""},{"location":"api-reference/ir/statements/abc/#wake.ir.statements.abc.StatementAbc","title":"<code>StatementAbc</code>  <code>class</code>","text":"<p>         Bases: <code>SolidityAbc</code>, <code>ABC</code></p> <p>Abstract base class for all Solidity statements.</p> Source code in <code>wake/ir/statements/abc.py</code> <pre><code>class StatementAbc(SolidityAbc, ABC):\n    \"\"\"\n    Abstract base class for all Solidity statements.\n    \"\"\"\n\n    _documentation: Optional[str]\n\n    def __init__(\n        self, init: IrInitTuple, statement: SolcStatementUnion, parent: SolidityAbc\n    ):\n        super().__init__(init, statement, parent)\n        self._documentation = statement.documentation\n\n    @staticmethod\n    def from_ast(\n        init: IrInitTuple, statement: SolcStatementUnion, parent: SolidityAbc\n    ) -&gt; StatementAbc:\n        from .block import Block\n        from .break_statement import Break\n        from .continue_statement import Continue\n        from .do_while_statement import DoWhileStatement\n        from .emit_statement import EmitStatement\n        from .expression_statement import ExpressionStatement\n        from .for_statement import ForStatement\n        from .if_statement import IfStatement\n        from .inline_assembly import InlineAssembly\n        from .placeholder_statement import PlaceholderStatement\n        from .return_statement import Return\n        from .revert_statement import RevertStatement\n        from .try_statement import TryStatement\n        from .unchecked_block import UncheckedBlock\n        from .variable_declaration_statement import VariableDeclarationStatement\n        from .while_statement import WhileStatement\n\n        if isinstance(statement, SolcBlock):\n            return Block(init, statement, parent)\n        elif isinstance(statement, SolcBreak):\n            return Break(init, statement, parent)\n        elif isinstance(statement, SolcContinue):\n            return Continue(init, statement, parent)\n        elif isinstance(statement, SolcDoWhileStatement):\n            return DoWhileStatement(init, statement, parent)\n        elif isinstance(statement, SolcEmitStatement):\n            return EmitStatement(init, statement, parent)\n        elif isinstance(statement, SolcExpressionStatement):\n            return ExpressionStatement(init, statement, parent)\n        elif isinstance(statement, SolcForStatement):\n            return ForStatement(init, statement, parent)\n        elif isinstance(statement, SolcIfStatement):\n            return IfStatement(init, statement, parent)\n        elif isinstance(statement, SolcInlineAssembly):\n            return InlineAssembly(init, statement, parent)\n        elif isinstance(statement, SolcPlaceholderStatement):\n            return PlaceholderStatement(init, statement, parent)\n        elif isinstance(statement, SolcReturn):\n            return Return(init, statement, parent)\n        elif isinstance(statement, SolcRevertStatement):\n            return RevertStatement(init, statement, parent)\n        elif isinstance(statement, SolcTryStatement):\n            return TryStatement(init, statement, parent)\n        elif isinstance(statement, SolcUncheckedBlock):\n            return UncheckedBlock(init, statement, parent)\n        elif isinstance(statement, SolcVariableDeclarationStatement):\n            return VariableDeclarationStatement(init, statement, parent)\n        elif isinstance(statement, SolcWhileStatement):\n            return WhileStatement(init, statement, parent)\n        assert False, f\"Unknown statement type: {type(statement)}\"\n\n    @property\n    @abstractmethod\n    def parent(\n        self,\n    ) -&gt; Union[\n        Block,\n        DoWhileStatement,\n        ForStatement,\n        IfStatement,\n        UncheckedBlock,\n        WhileStatement,\n        FunctionDefinition,\n        ModifierDefinition,\n        TryCatchClause,\n    ]:\n        \"\"\"\n        Returns:\n            Parent node of the statement.\n        \"\"\"\n        ...\n\n    @property\n    @abstractmethod\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        \"\"\"\n        WARNING:\n            Is not considered stable and so is not exported in the documentation.\n\n        Returns:\n            Set of child IR nodes (including `self`) that modify the blockchain state and flags describing how the state is modified.\n        \"\"\"\n        ...\n\n    def statements_iter(self) -&gt; Iterator[StatementAbc]:\n        \"\"\"\n        Yields:\n            Child statements of the statement (recursively) including `self`.\n        \"\"\"\n        yield self\n\n    @property\n    def documentation(self) -&gt; Optional[str]:\n        \"\"\"\n        Statement documentation strings should be placed above the statement.\n\n        Returns:\n            [NatSpec](https://docs.soliditylang.org/en/latest/natspec-format.html) documentation string, if any.\n        \"\"\"\n        return self._documentation\n\n    @property\n    @lru_cache(maxsize=512)\n    def declaration(self) -&gt; Union[FunctionDefinition, ModifierDefinition]:\n        \"\"\"\n        Returns:\n            [FunctionDefinition][wake.ir.declarations.function_definition.FunctionDefinition] or [ModifierDefinition][wake.ir.declarations.modifier_definition.ModifierDefinition] that contains the statement.\n        \"\"\"\n        from ..declarations.function_definition import FunctionDefinition\n        from ..declarations.modifier_definition import ModifierDefinition\n\n        node = self\n        while node is not None:\n            if isinstance(node, (FunctionDefinition, ModifierDefinition)):\n                return node\n            node = node.parent\n        assert False, f\"Statement {self.source} is not part of a function or modifier\"\n</code></pre>"},{"location":"api-reference/ir/statements/abc/#wake.ir.statements.abc.StatementAbc.declaration","title":"<code>declaration: Union[FunctionDefinition, ModifierDefinition]</code>  <code>cached</code> <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[FunctionDefinition, ModifierDefinition]</code> <p>FunctionDefinition or ModifierDefinition that contains the statement.</p>"},{"location":"api-reference/ir/statements/abc/#wake.ir.statements.abc.StatementAbc.documentation","title":"<code>documentation: Optional[str]</code>  <code>property</code>","text":"<p>Statement documentation strings should be placed above the statement.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>NatSpec documentation string, if any.</p>"},{"location":"api-reference/ir/statements/abc/#wake.ir.statements.abc.StatementAbc.parent","title":"<code>parent: Union[Block, DoWhileStatement, ForStatement, IfStatement, UncheckedBlock, WhileStatement, FunctionDefinition, ModifierDefinition, TryCatchClause]</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[Block, DoWhileStatement, ForStatement, IfStatement, UncheckedBlock, WhileStatement, FunctionDefinition, ModifierDefinition, TryCatchClause]</code> <p>Parent node of the statement.</p>"},{"location":"api-reference/ir/statements/abc/#wake.ir.statements.abc.StatementAbc.statements_iter","title":"<code>statements_iter()</code>","text":"<p>Yields:</p> Type Description <code>StatementAbc</code> <p>Child statements of the statement (recursively) including <code>self</code>.</p> Source code in <code>wake/ir/statements/abc.py</code> <pre><code>def statements_iter(self) -&gt; Iterator[StatementAbc]:\n    \"\"\"\n    Yields:\n        Child statements of the statement (recursively) including `self`.\n    \"\"\"\n    yield self\n</code></pre>"},{"location":"api-reference/ir/statements/block/","title":"block","text":""},{"location":"api-reference/ir/statements/block/#wake.ir.statements.block","title":"<code>wake.ir.statements.block</code>  <code>module</code>","text":""},{"location":"api-reference/ir/statements/block/#wake.ir.statements.block.Block","title":"<code>Block</code>  <code>class</code>","text":"<p>         Bases: <code>StatementAbc</code></p> <p>Block statements group multiple statements into a single block.</p> <p>Example</p> <p>Lines 3-5 in the following code: <pre><code>contract Foo {\n    function bar(uint a, uint b) public pure returns(uint)\n    {\n        return a + b;\n    }\n}\n</code></pre></p> Source code in <code>wake/ir/statements/block.py</code> <pre><code>class Block(StatementAbc):\n    \"\"\"\n    Block statements group multiple statements into a single block.\n\n    !!! example\n        Lines 3-5 in the following code:\n        ```solidity linenums=\"1\"\n        contract Foo {\n            function bar(uint a, uint b) public pure returns(uint)\n            {\n                return a + b;\n            }\n        }\n        ```\n    \"\"\"\n\n    _ast_node: SolcBlock\n    _parent: Union[\n        Block,\n        DoWhileStatement,\n        ForStatement,\n        IfStatement,\n        UncheckedBlock,\n        WhileStatement,  # statements\n        FunctionDefinition,\n        ModifierDefinition,  # declarations\n        TryCatchClause,  # meta\n    ]\n\n    _statements: List[StatementAbc]\n\n    def __init__(self, init: IrInitTuple, block: SolcBlock, parent: SolidityAbc):\n        super().__init__(init, block, parent)\n        self._statements = [\n            StatementAbc.from_ast(init, statement, self)\n            for statement in block.statements\n        ]\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        if self._statements is not None:\n            for statement in self._statements:\n                yield from statement\n\n    @property\n    def parent(\n        self,\n    ) -&gt; Union[\n        Block,\n        DoWhileStatement,\n        ForStatement,\n        IfStatement,\n        UncheckedBlock,\n        WhileStatement,\n        FunctionDefinition,\n        ModifierDefinition,\n        TryCatchClause,\n    ]:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def statements(self) -&gt; Tuple[StatementAbc, ...]:\n        \"\"\"\n        Can be empty.\n\n        Returns:\n            Statements in the block.\n        \"\"\"\n        return tuple(self._statements)\n\n    @property\n    @lru_cache(maxsize=2048)\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        if self.statements is None:\n            return set()\n        return reduce(\n            or_,\n            (statement.modifies_state for statement in self.statements),\n            set(),\n        )\n\n    def statements_iter(self) -&gt; Iterator[StatementAbc]:\n        yield self\n        if self._statements is not None:\n            for statement in self._statements:\n                yield from statement.statements_iter()\n</code></pre>"},{"location":"api-reference/ir/statements/block/#wake.ir.statements.block.Block.parent","title":"<code>parent: Union[Block, DoWhileStatement, ForStatement, IfStatement, UncheckedBlock, WhileStatement, FunctionDefinition, ModifierDefinition, TryCatchClause]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[Block, DoWhileStatement, ForStatement, IfStatement, UncheckedBlock, WhileStatement, FunctionDefinition, ModifierDefinition, TryCatchClause]</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/statements/block/#wake.ir.statements.block.Block.statements","title":"<code>statements: Tuple[StatementAbc, ...]</code>  <code>property</code>","text":"<p>Can be empty.</p> <p>Returns:</p> Type Description <code>Tuple[StatementAbc, ...]</code> <p>Statements in the block.</p>"},{"location":"api-reference/ir/statements/break-statement/","title":"break_statement","text":""},{"location":"api-reference/ir/statements/break-statement/#wake.ir.statements.break_statement","title":"<code>wake.ir.statements.break_statement</code>  <code>module</code>","text":""},{"location":"api-reference/ir/statements/break-statement/#wake.ir.statements.break_statement.Break","title":"<code>Break</code>  <code>class</code>","text":"<p>         Bases: <code>StatementAbc</code></p> <p>Example</p> <p><code>break</code> in the following code: <pre><code>function foo() public {\n    for (uint i = 0; i &lt; 10; i++) {\n        if (i == 5)\n            break;\n    }\n}\n</code></pre></p> Source code in <code>wake/ir/statements/break_statement.py</code> <pre><code>class Break(StatementAbc):\n    \"\"\"\n    !!! example\n        `:::solidity break` in the following code:\n        ```solidity\n        function foo() public {\n            for (uint i = 0; i &lt; 10; i++) {\n                if (i == 5)\n                    break;\n            }\n        }\n        ```\n    \"\"\"\n\n    _ast_node: SolcBreak\n    _parent: Union[\n        Block,\n        DoWhileStatement,\n        ForStatement,\n        IfStatement,\n        UncheckedBlock,\n        WhileStatement,\n    ]\n\n    def __init__(self, init: IrInitTuple, break_: SolcBreak, parent: SolidityAbc):\n        super().__init__(init, break_, parent)\n\n    @property\n    def parent(\n        self,\n    ) -&gt; Union[\n        Block,\n        DoWhileStatement,\n        ForStatement,\n        IfStatement,\n        UncheckedBlock,\n        WhileStatement,\n    ]:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        return set()\n</code></pre>"},{"location":"api-reference/ir/statements/break-statement/#wake.ir.statements.break_statement.Break.parent","title":"<code>parent: Union[Block, DoWhileStatement, ForStatement, IfStatement, UncheckedBlock, WhileStatement]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[Block, DoWhileStatement, ForStatement, IfStatement, UncheckedBlock, WhileStatement]</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/statements/continue-statement/","title":"continue_statement","text":""},{"location":"api-reference/ir/statements/continue-statement/#wake.ir.statements.continue_statement","title":"<code>wake.ir.statements.continue_statement</code>  <code>module</code>","text":""},{"location":"api-reference/ir/statements/continue-statement/#wake.ir.statements.continue_statement.Continue","title":"<code>Continue</code>  <code>class</code>","text":"<p>         Bases: <code>StatementAbc</code></p> <p>Example</p> <p><code>continue</code> in the following code: <pre><code>function foo() public {\n    for (uint i = 0; i &lt; 10; i++) {\n        if (i == 5)\n            continue;\n    }\n}\n</code></pre></p> Source code in <code>wake/ir/statements/continue_statement.py</code> <pre><code>class Continue(StatementAbc):\n    \"\"\"\n    !!! example\n        `:::solidity continue` in the following code:\n        ```solidity\n        function foo() public {\n            for (uint i = 0; i &lt; 10; i++) {\n                if (i == 5)\n                    continue;\n            }\n        }\n        ```\n    \"\"\"\n\n    _ast_node: SolcContinue\n    _parent: Union[\n        Block,\n        DoWhileStatement,\n        ForStatement,\n        IfStatement,\n        UncheckedBlock,\n        WhileStatement,\n    ]\n\n    def __init__(self, init: IrInitTuple, continue_: SolcContinue, parent: SolidityAbc):\n        super().__init__(init, continue_, parent)\n\n    @property\n    def parent(\n        self,\n    ) -&gt; Union[\n        Block,\n        DoWhileStatement,\n        ForStatement,\n        IfStatement,\n        UncheckedBlock,\n        WhileStatement,\n    ]:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        return set()\n</code></pre>"},{"location":"api-reference/ir/statements/continue-statement/#wake.ir.statements.continue_statement.Continue.parent","title":"<code>parent: Union[Block, DoWhileStatement, ForStatement, IfStatement, UncheckedBlock, WhileStatement]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[Block, DoWhileStatement, ForStatement, IfStatement, UncheckedBlock, WhileStatement]</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/statements/do-while-statement/","title":"do_while_statement","text":""},{"location":"api-reference/ir/statements/do-while-statement/#wake.ir.statements.do_while_statement","title":"<code>wake.ir.statements.do_while_statement</code>  <code>module</code>","text":""},{"location":"api-reference/ir/statements/do-while-statement/#wake.ir.statements.do_while_statement.DoWhileStatement","title":"<code>DoWhileStatement</code>  <code>class</code>","text":"<p>         Bases: <code>StatementAbc</code></p> <p>Example</p> <p>Lines 2-4 in the following code: <pre><code>function foo(uint x) public {\n    do {\n        x += 1;\n    } while (x &lt; 10);\n}\n</code></pre></p> Source code in <code>wake/ir/statements/do_while_statement.py</code> <pre><code>class DoWhileStatement(StatementAbc):\n    \"\"\"\n    !!! example\n        Lines 2-4 in the following code:\n        ```solidity linenums=\"1\"\n        function foo(uint x) public {\n            do {\n                x += 1;\n            } while (x &lt; 10);\n        }\n        ```\n    \"\"\"\n\n    _ast_node: SolcDoWhileStatement\n    _parent: Union[\n        Block,\n        DoWhileStatement,\n        ForStatement,\n        IfStatement,\n        UncheckedBlock,\n        WhileStatement,\n    ]\n\n    _body: StatementAbc\n    _condition: ExpressionAbc\n\n    def __init__(\n        self, init: IrInitTuple, do_while: SolcDoWhileStatement, parent: SolidityAbc\n    ):\n        super().__init__(init, do_while, parent)\n        self._body = StatementAbc.from_ast(init, do_while.body, self)\n        self._condition = ExpressionAbc.from_ast(init, do_while.condition, self)\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        yield from self._body\n        yield from self._condition\n\n    @property\n    def parent(\n        self,\n    ) -&gt; Union[\n        Block,\n        DoWhileStatement,\n        ForStatement,\n        IfStatement,\n        UncheckedBlock,\n        WhileStatement,\n    ]:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def body(self) -&gt; StatementAbc:\n        \"\"\"\n        Returns:\n            Body of the do-while statement.\n        \"\"\"\n        return self._body\n\n    @property\n    def condition(self) -&gt; ExpressionAbc:\n        \"\"\"\n        Returns:\n            Condition of the do-while statement.\n        \"\"\"\n        return self._condition\n\n    @property\n    @lru_cache(maxsize=2048)\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        return self.condition.modifies_state | self.body.modifies_state\n\n    def statements_iter(self) -&gt; Iterator[StatementAbc]:\n        yield self\n        yield from self._body.statements_iter()\n</code></pre>"},{"location":"api-reference/ir/statements/do-while-statement/#wake.ir.statements.do_while_statement.DoWhileStatement.body","title":"<code>body: StatementAbc</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>StatementAbc</code> <p>Body of the do-while statement.</p>"},{"location":"api-reference/ir/statements/do-while-statement/#wake.ir.statements.do_while_statement.DoWhileStatement.condition","title":"<code>condition: ExpressionAbc</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>ExpressionAbc</code> <p>Condition of the do-while statement.</p>"},{"location":"api-reference/ir/statements/do-while-statement/#wake.ir.statements.do_while_statement.DoWhileStatement.parent","title":"<code>parent: Union[Block, DoWhileStatement, ForStatement, IfStatement, UncheckedBlock, WhileStatement]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[Block, DoWhileStatement, ForStatement, IfStatement, UncheckedBlock, WhileStatement]</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/statements/emit-statement/","title":"emit_statement","text":""},{"location":"api-reference/ir/statements/emit-statement/#wake.ir.statements.emit_statement","title":"<code>wake.ir.statements.emit_statement</code>  <code>module</code>","text":""},{"location":"api-reference/ir/statements/emit-statement/#wake.ir.statements.emit_statement.EmitStatement","title":"<code>EmitStatement</code>  <code>class</code>","text":"<p>         Bases: <code>StatementAbc</code></p> <p>Example</p> <p><code>emit Transfer(msg.sender, to, amount)</code> in the following code: <pre><code>function transfer(address to, uint amount) public {\n    emit Transfer(msg.sender, to, amount);\n}\n</code></pre></p> Source code in <code>wake/ir/statements/emit_statement.py</code> <pre><code>class EmitStatement(StatementAbc):\n    \"\"\"\n    !!! example\n        `:::solidity emit Transfer(msg.sender, to, amount)` in the following code:\n        ```solidity\n        function transfer(address to, uint amount) public {\n            emit Transfer(msg.sender, to, amount);\n        }\n        ```\n    \"\"\"\n\n    _ast_node: SolcEmitStatement\n    _parent: Union[\n        Block,\n        DoWhileStatement,\n        ForStatement,\n        IfStatement,\n        UncheckedBlock,\n        WhileStatement,\n    ]\n\n    _event_call: FunctionCall\n\n    def __init__(self, init: IrInitTuple, emit: SolcEmitStatement, parent: SolidityAbc):\n        super().__init__(init, emit, parent)\n        self._event_call = FunctionCall(init, emit.event_call, self)\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        yield from self._event_call\n\n    @property\n    def parent(\n        self,\n    ) -&gt; Union[\n        Block,\n        DoWhileStatement,\n        ForStatement,\n        IfStatement,\n        UncheckedBlock,\n        WhileStatement,\n    ]:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def event_call(self) -&gt; FunctionCall:\n        \"\"\"\n        !!! example\n            ```solidity\n            Transfer(msg.sender, to, amount)\n            ```\n            in the following emit statement:\n            ```solidity\n            emit Transfer(msg.sender, to, amount)\n            ```\n\n        Returns:\n            Expression representing the event call.\n        \"\"\"\n        return self._event_call\n\n    @property\n    @lru_cache(maxsize=2048)\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        return {(self, ModifiesStateFlag.EMITS)} | self.event_call.modifies_state\n</code></pre>"},{"location":"api-reference/ir/statements/emit-statement/#wake.ir.statements.emit_statement.EmitStatement.event_call","title":"<code>event_call: FunctionCall</code>  <code>property</code>","text":"<p>Example</p> <p><pre><code>Transfer(msg.sender, to, amount)\n</code></pre> in the following emit statement: <pre><code>emit Transfer(msg.sender, to, amount)\n</code></pre></p> <p>Returns:</p> Type Description <code>FunctionCall</code> <p>Expression representing the event call.</p>"},{"location":"api-reference/ir/statements/emit-statement/#wake.ir.statements.emit_statement.EmitStatement.parent","title":"<code>parent: Union[Block, DoWhileStatement, ForStatement, IfStatement, UncheckedBlock, WhileStatement]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[Block, DoWhileStatement, ForStatement, IfStatement, UncheckedBlock, WhileStatement]</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/statements/expression-statement/","title":"expression_statement","text":""},{"location":"api-reference/ir/statements/expression-statement/#wake.ir.statements.expression_statement","title":"<code>wake.ir.statements.expression_statement</code>  <code>module</code>","text":""},{"location":"api-reference/ir/statements/expression-statement/#wake.ir.statements.expression_statement.ExpressionStatement","title":"<code>ExpressionStatement</code>  <code>class</code>","text":"<p>         Bases: <code>StatementAbc</code></p> <p>Example</p> <p>The underlying expression can be any expression (ExpressionAbc):</p> <ul> <li>an Assignment:<ul> <li><code>i = 1</code> on line 6,</li> </ul> </li> <li>a BinaryOperation:<ul> <li><code>arr[0] + arr[1]</code> on line 11,</li> </ul> </li> <li>a Conditional:<ul> <li><code>arr[i] &gt;= arr[i - 1] ? x++ : x--</code> on line 7,</li> </ul> </li> <li>an ElementaryTypeNameExpression:<ul> <li><code>int</code> on line 18,</li> </ul> </li> <li>a FunctionCall:<ul> <li><code>require(arr.length &gt; 1)</code> on line 3,</li> </ul> </li> <li>a FunctionCallOptions:<ul> <li><code>payable(msg.sender).call{value: 1}</code> on line 17,</li> </ul> </li> <li>an Identifier:<ul> <li><code>this</code> on line 16,</li> </ul> </li> <li>an IndexAccess:<ul> <li><code>arr[0]</code> on line 9,</li> </ul> </li> <li>an IndexRangeAccess:<ul> <li><code>arr[0:1]</code> on line 10,</li> </ul> </li> <li>a Literal:<ul> <li><code>10</code> on line 12,</li> </ul> </li> <li>a MemberAccess:<ul> <li><code>arr.length</code> on line 13,</li> </ul> </li> <li>a NewExpression:<ul> <li><code>new uint[]</code> on line 14,</li> </ul> </li> <li>a TupleExpression:<ul> <li><code>(arr)</code> on line 15,</li> </ul> </li> <li>an UnaryOperation:<ul> <li><code>i++</code> on line 6.</li> </ul> </li> </ul> <pre><code>contract C {\n    function foo(uint[] calldata arr) external view {\n        require(arr.length &gt; 1);\n        uint i;\n        int x = 0;\n        for (i = 1; i &lt; arr.length; i++)\n            arr[i] &gt;= arr[i - 1] ? x++ : x--;\n\n        arr[0];\n        arr[0:1];\n        arr[0] + arr[1];\n        10;\n        arr.length;\n        new uint[];\n        (arr);\n        this; // silence state mutability warning without generating bytecode\n        payable(msg.sender).call{value: 1};\n        int;\n    }\n}\n</code></pre> Source code in <code>wake/ir/statements/expression_statement.py</code> <pre><code>class ExpressionStatement(StatementAbc):\n    \"\"\"\n    !!! example\n        The underlying expression can be any expression ([ExpressionAbc][wake.ir.expressions.abc.ExpressionAbc]):\n\n        - an [Assignment][wake.ir.expressions.assignment.Assignment]:\n            - `:::solidity i = 1` on line 6,\n        - a [BinaryOperation][wake.ir.expressions.binary_operation.BinaryOperation]:\n            - `:::solidity arr[0] + arr[1]` on line 11,\n        - a [Conditional][wake.ir.expressions.conditional.Conditional]:\n            - `:::solidity arr[i] &gt;= arr[i - 1] ? x++ : x--` on line 7,\n        - an [ElementaryTypeNameExpression][wake.ir.expressions.elementary_type_name_expression.ElementaryTypeNameExpression]:\n            - `:::solidity int` on line 18,\n        - a [FunctionCall][wake.ir.expressions.function_call.FunctionCall]:\n            - `:::solidity require(arr.length &gt; 1)` on line 3,\n        - a [FunctionCallOptions][wake.ir.expressions.function_call_options.FunctionCallOptions]:\n            - `:::solidity payable(msg.sender).call{value: 1}` on line 17,\n        - an [Identifier][wake.ir.expressions.identifier.Identifier]:\n            - `:::solidity this` on line 16,\n        - an [IndexAccess][wake.ir.expressions.index_access.IndexAccess]:\n            - `:::solidity arr[0]` on line 9,\n        - an [IndexRangeAccess][wake.ir.expressions.index_range_access.IndexRangeAccess]:\n            - `:::solidity arr[0:1]` on line 10,\n        - a [Literal][wake.ir.expressions.literal.Literal]:\n            - `:::solidity 10` on line 12,\n        - a [MemberAccess][wake.ir.expressions.member_access.MemberAccess]:\n            - `:::solidity arr.length` on line 13,\n        - a [NewExpression][wake.ir.expressions.new_expression.NewExpression]:\n            - `:::solidity new uint[]` on line 14,\n        - a [TupleExpression][wake.ir.expressions.tuple_expression.TupleExpression]:\n            - `:::solidity (arr)` on line 15,\n        - an [UnaryOperation][wake.ir.expressions.unary_operation.UnaryOperation]:\n            - `:::solidity i++` on line 6.\n\n        ```solidity linenums=\"1\"\n        contract C {\n            function foo(uint[] calldata arr) external view {\n                require(arr.length &gt; 1);\n                uint i;\n                int x = 0;\n                for (i = 1; i &lt; arr.length; i++)\n                    arr[i] &gt;= arr[i - 1] ? x++ : x--;\n\n                arr[0];\n                arr[0:1];\n                arr[0] + arr[1];\n                10;\n                arr.length;\n                new uint[];\n                (arr);\n                this; // silence state mutability warning without generating bytecode\n                payable(msg.sender).call{value: 1};\n                int;\n            }\n        }\n        ```\n    \"\"\"\n\n    _ast_node: SolcExpressionStatement\n    _parent: Union[\n        Block,\n        DoWhileStatement,\n        ForStatement,\n        IfStatement,\n        UncheckedBlock,\n        WhileStatement,\n    ]\n\n    __expression: ExpressionAbc\n\n    def __init__(\n        self,\n        init: IrInitTuple,\n        expression_statement: SolcExpressionStatement,\n        parent: SolidityAbc,\n    ):\n        super().__init__(init, expression_statement, parent)\n        expr = ExpressionAbc.from_ast(init, expression_statement.expression, self)\n        self._expression = expr\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        yield from self._expression\n\n    @property\n    def parent(\n        self,\n    ) -&gt; Union[\n        Block,\n        DoWhileStatement,\n        ForStatement,\n        IfStatement,\n        UncheckedBlock,\n        WhileStatement,\n    ]:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def expression(\n        self,\n    ) -&gt; ExpressionAbc:\n        \"\"\"\n        Returns:\n            Expression of the expression statement.\n        \"\"\"\n        return self._expression\n\n    @property\n    @lru_cache(maxsize=2048)\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        return self.expression.modifies_state\n</code></pre>"},{"location":"api-reference/ir/statements/expression-statement/#wake.ir.statements.expression_statement.ExpressionStatement.expression","title":"<code>expression: ExpressionAbc</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>ExpressionAbc</code> <p>Expression of the expression statement.</p>"},{"location":"api-reference/ir/statements/expression-statement/#wake.ir.statements.expression_statement.ExpressionStatement.parent","title":"<code>parent: Union[Block, DoWhileStatement, ForStatement, IfStatement, UncheckedBlock, WhileStatement]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[Block, DoWhileStatement, ForStatement, IfStatement, UncheckedBlock, WhileStatement]</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/statements/for-statement/","title":"for_statement","text":""},{"location":"api-reference/ir/statements/for-statement/#wake.ir.statements.for_statement","title":"<code>wake.ir.statements.for_statement</code>  <code>module</code>","text":""},{"location":"api-reference/ir/statements/for-statement/#wake.ir.statements.for_statement.ForStatement","title":"<code>ForStatement</code>  <code>class</code>","text":"<p>         Bases: <code>StatementAbc</code></p> <p>Example</p> <p>Lines 2-4 in the following code: <pre><code>function foo(uint x) public pure {\n    for (uint i = 0; i &lt; 10; i++) {\n        x += 1;\n    }\n}\n</code></pre></p> Source code in <code>wake/ir/statements/for_statement.py</code> <pre><code>class ForStatement(StatementAbc):\n    \"\"\"\n    !!! example\n        Lines 2-4 in the following code:\n        ```solidity linenums=\"1\"\n        function foo(uint x) public pure {\n            for (uint i = 0; i &lt; 10; i++) {\n                x += 1;\n            }\n        }\n        ```\n    \"\"\"\n\n    _ast_node: SolcForStatement\n    _parent: Union[\n        Block,\n        DoWhileStatement,\n        ForStatement,\n        IfStatement,\n        UncheckedBlock,\n        WhileStatement,\n    ]\n\n    _body: StatementAbc\n    _condition: Optional[ExpressionAbc]\n    _initialization_expression: Optional[\n        Union[ExpressionStatement, VariableDeclarationStatement]\n    ]\n    _loop_expression: Optional[ExpressionStatement]\n\n    def __init__(self, init: IrInitTuple, for_: SolcForStatement, parent: SolidityAbc):\n        super().__init__(init, for_, parent)\n        self._body = StatementAbc.from_ast(init, for_.body, self)\n\n        self._condition = (\n            ExpressionAbc.from_ast(init, for_.condition, self)\n            if for_.condition\n            else None\n        )\n\n        if for_.initialization_expression is None:\n            self._initialization_expression = None\n        else:\n            if isinstance(for_.initialization_expression, SolcExpressionStatement):\n                self._initialization_expression = ExpressionStatement(\n                    init, for_.initialization_expression, self\n                )\n            elif isinstance(\n                for_.initialization_expression, SolcVariableDeclarationStatement\n            ):\n                self._initialization_expression = VariableDeclarationStatement(\n                    init, for_.initialization_expression, self\n                )\n\n        self._loop_expression = (\n            ExpressionStatement(init, for_.loop_expression, self)\n            if for_.loop_expression\n            else None\n        )\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        yield from self._body\n        if self._condition is not None:\n            yield from self._condition\n        if self._initialization_expression is not None:\n            yield from self._initialization_expression\n        if self._loop_expression is not None:\n            yield from self._loop_expression\n\n    @property\n    def parent(\n        self,\n    ) -&gt; Union[\n        Block,\n        DoWhileStatement,\n        ForStatement,\n        IfStatement,\n        UncheckedBlock,\n        WhileStatement,\n    ]:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def body(self) -&gt; StatementAbc:\n        \"\"\"\n        Returns:\n            Body of the for loop.\n        \"\"\"\n        return self._body\n\n    @property\n    def condition(self) -&gt; Optional[ExpressionAbc]:\n        \"\"\"\n        !!! example\n            ```solidity\n            i &lt; 10\n            ```\n            in the following for loop:\n            ```solidity\n            for (uint i = 0; i &lt; 10; i++) {}\n            ```\n\n        Returns:\n            Condition of the for loop, if any.\n        \"\"\"\n        return self._condition\n\n    @property\n    def initialization_expression(\n        self,\n    ) -&gt; Optional[Union[ExpressionStatement, VariableDeclarationStatement]]:\n        \"\"\"\n        !!! example\n            ```solidity\n            uint i = 0\n            ```\n            in the following for loop:\n            ```solidity\n            for (uint i = 0; i &lt; 10; i++) {}\n            ```\n\n        Returns:\n            Initialization expression of the for loop, if any.\n        \"\"\"\n        return self._initialization_expression\n\n    @property\n    def loop_expression(self) -&gt; Optional[ExpressionStatement]:\n        \"\"\"\n        !!! example\n            ```solidity\n            i++\n            ```\n            in the following for loop:\n            ```solidity\n            for (uint i = 0; i &lt; 10; i++) {}\n            ```\n\n        Returns:\n            Loop expression of the for loop, if any.\n        \"\"\"\n        return self._loop_expression\n\n    @property\n    @lru_cache(maxsize=2048)\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        ret = set()\n        if self.initialization_expression is not None:\n            ret |= self.initialization_expression.modifies_state\n        if self.condition is not None:\n            ret |= self.condition.modifies_state\n        if self.loop_expression is not None:\n            ret |= self.loop_expression.modifies_state\n        return ret\n\n    def statements_iter(self) -&gt; Iterator[StatementAbc]:\n        yield self\n        yield from self._body.statements_iter()\n        if self._initialization_expression is not None:\n            yield from self._initialization_expression.statements_iter()\n        if self._loop_expression is not None:\n            yield from self._loop_expression.statements_iter()\n</code></pre>"},{"location":"api-reference/ir/statements/for-statement/#wake.ir.statements.for_statement.ForStatement.body","title":"<code>body: StatementAbc</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>StatementAbc</code> <p>Body of the for loop.</p>"},{"location":"api-reference/ir/statements/for-statement/#wake.ir.statements.for_statement.ForStatement.condition","title":"<code>condition: Optional[ExpressionAbc]</code>  <code>property</code>","text":"<p>Example</p> <p><pre><code>i &lt; 10\n</code></pre> in the following for loop: <pre><code>for (uint i = 0; i &lt; 10; i++) {}\n</code></pre></p> <p>Returns:</p> Type Description <code>Optional[ExpressionAbc]</code> <p>Condition of the for loop, if any.</p>"},{"location":"api-reference/ir/statements/for-statement/#wake.ir.statements.for_statement.ForStatement.initialization_expression","title":"<code>initialization_expression: Optional[Union[ExpressionStatement, VariableDeclarationStatement]]</code>  <code>property</code>","text":"<p>Example</p> <p><pre><code>uint i = 0\n</code></pre> in the following for loop: <pre><code>for (uint i = 0; i &lt; 10; i++) {}\n</code></pre></p> <p>Returns:</p> Type Description <code>Optional[Union[ExpressionStatement, VariableDeclarationStatement]]</code> <p>Initialization expression of the for loop, if any.</p>"},{"location":"api-reference/ir/statements/for-statement/#wake.ir.statements.for_statement.ForStatement.loop_expression","title":"<code>loop_expression: Optional[ExpressionStatement]</code>  <code>property</code>","text":"<p>Example</p> <p><pre><code>i++\n</code></pre> in the following for loop: <pre><code>for (uint i = 0; i &lt; 10; i++) {}\n</code></pre></p> <p>Returns:</p> Type Description <code>Optional[ExpressionStatement]</code> <p>Loop expression of the for loop, if any.</p>"},{"location":"api-reference/ir/statements/for-statement/#wake.ir.statements.for_statement.ForStatement.parent","title":"<code>parent: Union[Block, DoWhileStatement, ForStatement, IfStatement, UncheckedBlock, WhileStatement]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[Block, DoWhileStatement, ForStatement, IfStatement, UncheckedBlock, WhileStatement]</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/statements/if-statement/","title":"if_statement","text":""},{"location":"api-reference/ir/statements/if-statement/#wake.ir.statements.if_statement","title":"<code>wake.ir.statements.if_statement</code>  <code>module</code>","text":""},{"location":"api-reference/ir/statements/if-statement/#wake.ir.statements.if_statement.IfStatement","title":"<code>IfStatement</code>  <code>class</code>","text":"<p>         Bases: <code>StatementAbc</code></p> <p>Example</p> <p>Lines 2-6 in the following code: <pre><code>function foo(int x) public pure returns(uint) {\n    if (x &lt; 0) {\n        return 0;\n    } else {\n        return uint(x);\n    }\n}\n</code></pre></p> Source code in <code>wake/ir/statements/if_statement.py</code> <pre><code>class IfStatement(StatementAbc):\n    \"\"\"\n    !!! example\n        Lines 2-6 in the following code:\n        ```solidity linenums=\"1\"\n        function foo(int x) public pure returns(uint) {\n            if (x &lt; 0) {\n                return 0;\n            } else {\n                return uint(x);\n            }\n        }\n        ```\n    \"\"\"\n\n    _ast_node: SolcIfStatement\n    _parent: Union[\n        Block,\n        DoWhileStatement,\n        ForStatement,\n        IfStatement,\n        UncheckedBlock,\n        WhileStatement,\n    ]\n\n    _condition: ExpressionAbc\n    _true_body: StatementAbc\n    _false_body: Optional[StatementAbc]\n\n    def __init__(\n        self, init: IrInitTuple, if_statement: SolcIfStatement, parent: SolidityAbc\n    ):\n        super().__init__(init, if_statement, parent)\n        self._condition = ExpressionAbc.from_ast(init, if_statement.condition, self)\n        self._true_body = StatementAbc.from_ast(init, if_statement.true_body, self)\n        self._false_body = (\n            None\n            if if_statement.false_body is None\n            else StatementAbc.from_ast(init, if_statement.false_body, self)\n        )\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        yield from self._condition\n        yield from self._true_body\n        if self._false_body is not None:\n            yield from self._false_body\n\n    @property\n    def parent(\n        self,\n    ) -&gt; Union[\n        Block,\n        DoWhileStatement,\n        ForStatement,\n        IfStatement,\n        UncheckedBlock,\n        WhileStatement,\n    ]:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def condition(self) -&gt; ExpressionAbc:\n        \"\"\"\n        Returns:\n            Condition of the if statement.\n        \"\"\"\n        return self._condition\n\n    @property\n    def true_body(self) -&gt; StatementAbc:\n        \"\"\"\n        Returns:\n            Statement executed if the condition is true.\n        \"\"\"\n        return self._true_body\n\n    @property\n    def false_body(self) -&gt; Optional[StatementAbc]:\n        \"\"\"\n        Returns:\n            Statement executed if the condition is false (if any).\n        \"\"\"\n        return self._false_body\n\n    @property\n    @lru_cache(maxsize=2048)\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        return (\n            self.condition.modifies_state\n            | self.true_body.modifies_state\n            | (self.false_body.modifies_state if self.false_body is not None else set())\n        )\n\n    def statements_iter(self) -&gt; Iterator[StatementAbc]:\n        yield self\n        yield from self._true_body.statements_iter()\n        if self._false_body is not None:\n            yield from self._false_body.statements_iter()\n</code></pre>"},{"location":"api-reference/ir/statements/if-statement/#wake.ir.statements.if_statement.IfStatement.condition","title":"<code>condition: ExpressionAbc</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>ExpressionAbc</code> <p>Condition of the if statement.</p>"},{"location":"api-reference/ir/statements/if-statement/#wake.ir.statements.if_statement.IfStatement.false_body","title":"<code>false_body: Optional[StatementAbc]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Optional[StatementAbc]</code> <p>Statement executed if the condition is false (if any).</p>"},{"location":"api-reference/ir/statements/if-statement/#wake.ir.statements.if_statement.IfStatement.parent","title":"<code>parent: Union[Block, DoWhileStatement, ForStatement, IfStatement, UncheckedBlock, WhileStatement]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[Block, DoWhileStatement, ForStatement, IfStatement, UncheckedBlock, WhileStatement]</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/statements/if-statement/#wake.ir.statements.if_statement.IfStatement.true_body","title":"<code>true_body: StatementAbc</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>StatementAbc</code> <p>Statement executed if the condition is true.</p>"},{"location":"api-reference/ir/statements/inline-assembly/","title":"inline_assembly","text":""},{"location":"api-reference/ir/statements/inline-assembly/#wake.ir.statements.inline_assembly","title":"<code>wake.ir.statements.inline_assembly</code>  <code>module</code>","text":""},{"location":"api-reference/ir/statements/inline-assembly/#wake.ir.statements.inline_assembly.ExternalReference","title":"<code>ExternalReference</code>  <code>class</code>","text":"<p>Reference from an inline assembly block to a Solidity declaration.</p> <p>Warning</p> <p>This is not an IR node, but a helper class for InlineAssembly. Since this is not an IR node, there must still be a Yul IR node (YulIdentifier) in the source code that represents the identifier.</p> Source code in <code>wake/ir/statements/inline_assembly.py</code> <pre><code>class ExternalReference:\n    \"\"\"\n    Reference from an inline assembly block to a Solidity declaration.\n    !!! warning\n        This is not an IR node, but a helper class for [InlineAssembly][wake.ir.statements.inline_assembly.InlineAssembly].\n        Since this is not an IR node, there must still be a Yul IR node ([YulIdentifier][wake.ir.yul.identifier.YulIdentifier]) in the source code that represents the identifier.\n    \"\"\"\n\n    _inline_assembly: InlineAssembly\n    _external_reference_model: ExternalReferenceModel\n    _reference_resolver: ReferenceResolver\n    _source: bytes\n    _source_unit: SourceUnit\n\n    _referenced_declaration_id: AstNodeId\n    _value_size: int\n    _suffix: Optional[InlineAssemblySuffix]\n    _yul_identifier: Optional[YulIdentifier]\n\n    def __init__(\n        self,\n        inline_assembly: InlineAssembly,\n        init: IrInitTuple,\n        external_reference_model: ExternalReferenceModel,\n    ):\n        self._inline_assembly = inline_assembly\n        self._external_reference_model = external_reference_model\n        self._reference_resolver = init.reference_resolver\n        self._source = init.source[self.byte_location[0] : self.byte_location[1]]\n        assert init.source_unit is not None\n        self._source_unit = init.source_unit\n\n        self._referenced_declaration_id = external_reference_model.declaration\n        assert self._referenced_declaration_id &gt;= 0\n        self._value_size = external_reference_model.value_size\n        self._suffix = external_reference_model.suffix\n        self._yul_identifier = None\n\n        if external_reference_model.is_offset:\n            self._suffix = InlineAssemblySuffix.OFFSET\n        elif external_reference_model.is_slot:\n            self._suffix = InlineAssemblySuffix.SLOT\n\n        self._reference_resolver.register_post_process_callback(self._post_process)\n\n    def _post_process(self, callback_params: CallbackParams):\n        referenced_declaration = self.referenced_declaration\n        referenced_declaration.register_reference(self)\n        self._reference_resolver.register_destroy_callback(\n            self._source_unit.file, partial(self._destroy, referenced_declaration)\n        )\n        interval_tree = callback_params.interval_trees[self._source_unit.file]\n        start, end = self.byte_location\n        nodes = interval_tree[start:end]\n        node = next(node for node in nodes if node.begin == start and node.end == end)\n        assert isinstance(\n            node.data, YulIdentifier\n        ), f\"Expected Identifier, got {type(node.data)}\"\n        self._yul_identifier = node.data\n        self._yul_identifier._external_reference = self\n\n    def _destroy(self, referenced_declaration: VariableDeclaration) -&gt; None:\n        referenced_declaration.unregister_reference(self)\n\n    @property\n    def source_unit(self) -&gt; SourceUnit:\n        \"\"\"\n        Returns:\n            Source unit that contains this node.\n        \"\"\"\n        return self._source_unit\n\n    @property\n    def byte_location(self) -&gt; Tuple[int, int]:\n        \"\"\"\n        Returns:\n            Byte offsets (start and end) of the external reference in the source file.\n        \"\"\"\n        return (\n            self._external_reference_model.src.byte_offset,\n            self._external_reference_model.src.byte_offset\n            + self._external_reference_model.src.byte_length,\n        )\n\n    @property\n    @lru_cache(maxsize=2048)\n    def identifier_location(self) -&gt; Tuple[int, int]:\n        \"\"\"\n        !!! example\n            Returns the byte location of `stateVar` on line 6, not `stateVar.slot`:\n            ```solidity linenums=\"1\"\n            contract Foo {\n                uint stateVar;\n\n                function f() public pure {\n                    assembly {\n                        let x := stateVar.slot\n                    }\n                }\n            }\n            ```\n\n        Returns:\n            Byte offsets (start and end) of the identifier representing the external reference in the source file.\n        \"\"\"\n        source = bytearray(self._source)\n        _, stripped_sums = SoliditySourceParser.strip_comments(source)\n\n        match = IDENTIFIER_RE.match(source)\n        assert match\n\n        if len(stripped_sums) == 0:\n            stripped = 0\n        else:\n            index = bisect([s[0] for s in stripped_sums], match.start())\n            if index == 0:\n                stripped = 0\n            else:\n                stripped = stripped_sums[index - 1][1]\n\n        start = self.byte_location[0] + match.start() + stripped\n        end = self.byte_location[0] + match.end() + stripped\n        return start, end\n\n    @property\n    def referenced_declaration(self) -&gt; VariableDeclaration:\n        \"\"\"\n        Returns:\n            Solidity variable declaration referenced by this external reference.\n        \"\"\"\n        node = self._reference_resolver.resolve_node(\n            self._referenced_declaration_id, self._source_unit.cu_hash\n        )\n        assert isinstance(node, VariableDeclaration)\n        return node\n\n    @property\n    def inline_assembly(self) -&gt; InlineAssembly:\n        \"\"\"\n        Returns:\n            Inline assembly block this external references belongs to.\n        \"\"\"\n        return self._inline_assembly\n\n    @property\n    def yul_identifier(self) -&gt; YulIdentifier:\n        \"\"\"\n        Returns:\n            Yul Identifier node representing this external reference.\n        \"\"\"\n        assert isinstance(self._yul_identifier, YulIdentifier)\n        return self._yul_identifier\n\n    @property\n    def value_size(self) -&gt; int:\n        # TODO document this?\n        return self._value_size\n\n    @property\n    def suffix(self) -&gt; Optional[InlineAssemblySuffix]:\n        \"\"\"\n        - `.slot` and `.offset` suffixes may be applied to storage variables.\n        - `.length` suffix may be applied to dynamically-sized `calldata` arrays, `calldata` bytes and `calldata` strings.\n        - `.address` amd `.selector` suffixes may be applied to variables holding a reference to an external function (the variable has the [FunctionTypeName][wake.ir.type_names.function_type_name.FunctionTypeName] type name).\n\n        Returns:\n            Suffix of the external reference, if any.\n        \"\"\"\n        return self._suffix\n</code></pre>"},{"location":"api-reference/ir/statements/inline-assembly/#wake.ir.statements.inline_assembly.ExternalReference.byte_location","title":"<code>byte_location: Tuple[int, int]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[int, int]</code> <p>Byte offsets (start and end) of the external reference in the source file.</p>"},{"location":"api-reference/ir/statements/inline-assembly/#wake.ir.statements.inline_assembly.ExternalReference.identifier_location","title":"<code>identifier_location: Tuple[int, int]</code>  <code>cached</code> <code>property</code>","text":"<p>Example</p> <p>Returns the byte location of <code>stateVar</code> on line 6, not <code>stateVar.slot</code>: <pre><code>contract Foo {\n    uint stateVar;\n\n    function f() public pure {\n        assembly {\n            let x := stateVar.slot\n        }\n    }\n}\n</code></pre></p> <p>Returns:</p> Type Description <code>Tuple[int, int]</code> <p>Byte offsets (start and end) of the identifier representing the external reference in the source file.</p>"},{"location":"api-reference/ir/statements/inline-assembly/#wake.ir.statements.inline_assembly.ExternalReference.inline_assembly","title":"<code>inline_assembly: InlineAssembly</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>InlineAssembly</code> <p>Inline assembly block this external references belongs to.</p>"},{"location":"api-reference/ir/statements/inline-assembly/#wake.ir.statements.inline_assembly.ExternalReference.referenced_declaration","title":"<code>referenced_declaration: VariableDeclaration</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>VariableDeclaration</code> <p>Solidity variable declaration referenced by this external reference.</p>"},{"location":"api-reference/ir/statements/inline-assembly/#wake.ir.statements.inline_assembly.ExternalReference.source_unit","title":"<code>source_unit: SourceUnit</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>SourceUnit</code> <p>Source unit that contains this node.</p>"},{"location":"api-reference/ir/statements/inline-assembly/#wake.ir.statements.inline_assembly.ExternalReference.suffix","title":"<code>suffix: Optional[InlineAssemblySuffix]</code>  <code>property</code>","text":"<ul> <li><code>.slot</code> and <code>.offset</code> suffixes may be applied to storage variables.</li> <li><code>.length</code> suffix may be applied to dynamically-sized <code>calldata</code> arrays, <code>calldata</code> bytes and <code>calldata</code> strings.</li> <li><code>.address</code> amd <code>.selector</code> suffixes may be applied to variables holding a reference to an external function (the variable has the FunctionTypeName type name).</li> </ul> <p>Returns:</p> Type Description <code>Optional[InlineAssemblySuffix]</code> <p>Suffix of the external reference, if any.</p>"},{"location":"api-reference/ir/statements/inline-assembly/#wake.ir.statements.inline_assembly.ExternalReference.yul_identifier","title":"<code>yul_identifier: YulIdentifier</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>YulIdentifier</code> <p>Yul Identifier node representing this external reference.</p>"},{"location":"api-reference/ir/statements/inline-assembly/#wake.ir.statements.inline_assembly.InlineAssembly","title":"<code>InlineAssembly</code>  <code>class</code>","text":"<p>         Bases: <code>StatementAbc</code></p> <p>Inline assembly block in Solidity.</p> <p>Example</p> <pre><code>function f() public pure {\n    assembly {\n        let x := 1\n        let y := 2\n        let z := add(x, y)\n    }\n}\n</code></pre> Source code in <code>wake/ir/statements/inline_assembly.py</code> <pre><code>class InlineAssembly(StatementAbc):\n    \"\"\"\n    Inline assembly block in Solidity.\n    !!! example\n        ```solidity\n        function f() public pure {\n            assembly {\n                let x := 1\n                let y := 2\n                let z := add(x, y)\n            }\n        }\n        ```\n    \"\"\"\n\n    _ast_node: SolcInlineAssembly\n    _parent: Union[\n        Block,\n        DoWhileStatement,\n        ForStatement,\n        IfStatement,\n        UncheckedBlock,\n        WhileStatement,\n    ]\n\n    _yul_block: YulBlock\n    _evm_version: InlineAssemblyEvmVersion\n    _external_references: IntervalTree\n    _flags: Set[InlineAssemblyFlag]\n\n    def __init__(\n        self,\n        init: IrInitTuple,\n        inline_assembly: SolcInlineAssembly,\n        parent: SolidityAbc,\n    ):\n        super().__init__(init, inline_assembly, parent)\n        init.inline_assembly = self\n\n        self._yul_block = YulBlock(init, inline_assembly.ast, self)\n        self._evm_version = inline_assembly.evm_version\n        self._external_references = IntervalTree()\n        self._flags = set()\n        if inline_assembly.flags is not None:\n            for flag in inline_assembly.flags:\n                self._flags.add(InlineAssemblyFlag(flag))\n        for external_reference in inline_assembly.external_references:\n            start = external_reference.src.byte_offset\n            end = start + external_reference.src.byte_length\n            self._external_references[start:end] = ExternalReference(\n                self, init, external_reference\n            )\n\n        init.inline_assembly = None\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        yield from self._yul_block\n\n    @property\n    def parent(\n        self,\n    ) -&gt; Union[\n        Block,\n        DoWhileStatement,\n        ForStatement,\n        IfStatement,\n        UncheckedBlock,\n        WhileStatement,\n    ]:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def yul_block(self) -&gt; YulBlock:\n        \"\"\"\n        Returns:\n            Yul block containing Yul IR nodes ([YulAbc][wake.ir.yul.abc.YulAbc]).\n        \"\"\"\n        return self._yul_block\n\n    @property\n    def evm_version(self) -&gt; InlineAssemblyEvmVersion:\n        \"\"\"\n        Depends on the version of the `solc` compiler used to compile the contract and settings passed to the compiler.\n\n        Returns:\n            EVM version used for the inline assembly block.\n        \"\"\"\n        return self._evm_version\n\n    @property\n    def flags(self) -&gt; FrozenSet[InlineAssemblyFlag]:\n        \"\"\"\n        !!! example\n            ```solidity\n            function f() public pure {\n                assembly (\"memory-safe\") {\n                    let x := 1\n                    let y := 2\n                    let z := add(x, y)\n                }\n            }\n            ```\n\n        Returns:\n            Flags decorating the inline assembly block.\n        \"\"\"\n        return frozenset(self._flags)\n\n    @property\n    def external_references(self) -&gt; Tuple[ExternalReference, ...]:\n        \"\"\"\n        Returns:\n            External references in the inline assembly block.\n        \"\"\"\n        return tuple(interval.data for interval in self._external_references)\n\n    def external_reference_at(self, byte_offset: int) -&gt; Optional[ExternalReference]:\n        \"\"\"\n        Args:\n            byte_offset: Byte offset in the source file.\n\n        Returns:\n            External reference at the given byte offset, if any.\n        \"\"\"\n        intervals = self._external_references.at(byte_offset)\n        assert len(intervals) &lt;= 1\n        if len(intervals) == 0:\n            return None\n        return intervals.pop().data\n\n    @property\n    @lru_cache(maxsize=2048)\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        return self.yul_block.modifies_state\n</code></pre>"},{"location":"api-reference/ir/statements/inline-assembly/#wake.ir.statements.inline_assembly.InlineAssembly.evm_version","title":"<code>evm_version: InlineAssemblyEvmVersion</code>  <code>property</code>","text":"<p>Depends on the version of the <code>solc</code> compiler used to compile the contract and settings passed to the compiler.</p> <p>Returns:</p> Type Description <code>InlineAssemblyEvmVersion</code> <p>EVM version used for the inline assembly block.</p>"},{"location":"api-reference/ir/statements/inline-assembly/#wake.ir.statements.inline_assembly.InlineAssembly.external_references","title":"<code>external_references: Tuple[ExternalReference, ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[ExternalReference, ...]</code> <p>External references in the inline assembly block.</p>"},{"location":"api-reference/ir/statements/inline-assembly/#wake.ir.statements.inline_assembly.InlineAssembly.flags","title":"<code>flags: FrozenSet[InlineAssemblyFlag]</code>  <code>property</code>","text":"<p>Example</p> <pre><code>function f() public pure {\n    assembly (\"memory-safe\") {\n        let x := 1\n        let y := 2\n        let z := add(x, y)\n    }\n}\n</code></pre> <p>Returns:</p> Type Description <code>FrozenSet[InlineAssemblyFlag]</code> <p>Flags decorating the inline assembly block.</p>"},{"location":"api-reference/ir/statements/inline-assembly/#wake.ir.statements.inline_assembly.InlineAssembly.parent","title":"<code>parent: Union[Block, DoWhileStatement, ForStatement, IfStatement, UncheckedBlock, WhileStatement]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[Block, DoWhileStatement, ForStatement, IfStatement, UncheckedBlock, WhileStatement]</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/statements/inline-assembly/#wake.ir.statements.inline_assembly.InlineAssembly.yul_block","title":"<code>yul_block: YulBlock</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>YulBlock</code> <p>Yul block containing Yul IR nodes (YulAbc).</p>"},{"location":"api-reference/ir/statements/inline-assembly/#wake.ir.statements.inline_assembly.InlineAssembly.external_reference_at","title":"<code>external_reference_at(byte_offset)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>byte_offset</code> <code>int</code> <p>Byte offset in the source file.</p> required <p>Returns:</p> Type Description <code>Optional[ExternalReference]</code> <p>External reference at the given byte offset, if any.</p> Source code in <code>wake/ir/statements/inline_assembly.py</code> <pre><code>def external_reference_at(self, byte_offset: int) -&gt; Optional[ExternalReference]:\n    \"\"\"\n    Args:\n        byte_offset: Byte offset in the source file.\n\n    Returns:\n        External reference at the given byte offset, if any.\n    \"\"\"\n    intervals = self._external_references.at(byte_offset)\n    assert len(intervals) &lt;= 1\n    if len(intervals) == 0:\n        return None\n    return intervals.pop().data\n</code></pre>"},{"location":"api-reference/ir/statements/placeholder-statement/","title":"placeholder_statement","text":""},{"location":"api-reference/ir/statements/placeholder-statement/#wake.ir.statements.placeholder_statement","title":"<code>wake.ir.statements.placeholder_statement</code>  <code>module</code>","text":""},{"location":"api-reference/ir/statements/placeholder-statement/#wake.ir.statements.placeholder_statement.PlaceholderStatement","title":"<code>PlaceholderStatement</code>  <code>class</code>","text":"<p>         Bases: <code>StatementAbc</code></p> <p>Placeholder statements represent <code>_</code> (underscore) in a modifier body.</p> <p>Example</p> <p><code>_</code> in the following code: <pre><code>modifier foo() {\n    require(msg.sender == owner, \"Not owner\");\n    _;\n}\n</code></pre></p> Source code in <code>wake/ir/statements/placeholder_statement.py</code> <pre><code>class PlaceholderStatement(StatementAbc):\n    \"\"\"\n    Placeholder statements represent `_` (underscore) in a modifier body.\n    !!! example\n        `:::solidity _` in the following code:\n        ```solidity linenums=\"1\"\n        modifier foo() {\n            require(msg.sender == owner, \"Not owner\");\n            _;\n        }\n        ```\n    \"\"\"\n\n    _ast_node: SolcPlaceholderStatement\n    _parent: Union[Block, DoWhileStatement, ForStatement, IfStatement, WhileStatement]\n\n    def __init__(\n        self,\n        init: IrInitTuple,\n        placeholder_statement: SolcPlaceholderStatement,\n        parent: SolidityAbc,\n    ):\n        super().__init__(init, placeholder_statement, parent)\n\n    @property\n    def parent(\n        self,\n    ) -&gt; Union[Block, DoWhileStatement, ForStatement, IfStatement, WhileStatement]:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        return set()\n</code></pre>"},{"location":"api-reference/ir/statements/placeholder-statement/#wake.ir.statements.placeholder_statement.PlaceholderStatement.parent","title":"<code>parent: Union[Block, DoWhileStatement, ForStatement, IfStatement, WhileStatement]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[Block, DoWhileStatement, ForStatement, IfStatement, WhileStatement]</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/statements/return-statement/","title":"return_statement","text":""},{"location":"api-reference/ir/statements/return-statement/#wake.ir.statements.return_statement","title":"<code>wake.ir.statements.return_statement</code>  <code>module</code>","text":""},{"location":"api-reference/ir/statements/return-statement/#wake.ir.statements.return_statement.Return","title":"<code>Return</code>  <code>class</code>","text":"<p>         Bases: <code>StatementAbc</code></p> <p>Example</p> <p><code>return 1</code> in the following code: <pre><code>function f() public pure returns(uint) {\n    return 1;\n}\n</code></pre></p> Source code in <code>wake/ir/statements/return_statement.py</code> <pre><code>class Return(StatementAbc):\n    \"\"\"\n    !!! example\n        `:::solidity return 1` in the following code:\n        ```solidity\n        function f() public pure returns(uint) {\n            return 1;\n        }\n        ```\n    \"\"\"\n\n    _ast_node: SolcReturn\n    _parent: Union[\n        Block,\n        DoWhileStatement,\n        ForStatement,\n        IfStatement,\n        UncheckedBlock,\n        WhileStatement,\n    ]\n\n    _function_return_parameters: Optional[AstNodeId]\n    _expression: Optional[ExpressionAbc]\n\n    def __init__(self, init: IrInitTuple, return_: SolcReturn, parent: SolidityAbc):\n        super().__init__(init, return_, parent)\n        self._function_return_parameters = return_.function_return_parameters\n        self._expression = (\n            ExpressionAbc.from_ast(init, return_.expression, self)\n            if return_.expression\n            else None\n        )\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        if self._expression is not None:\n            yield from self._expression\n\n    @property\n    def parent(\n        self,\n    ) -&gt; Union[\n        Block,\n        DoWhileStatement,\n        ForStatement,\n        IfStatement,\n        UncheckedBlock,\n        WhileStatement,\n    ]:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def function_return_parameters(self) -&gt; Optional[ParameterList]:\n        \"\"\"\n        !!! example\n            Can be `None` if the function does not return anything.\n            ```solidity\n            function f(uint x) public {\n                if (x &gt; 0) {\n                    return;\n                }\n                doSomething(x);\n            }\n            ```\n\n        Returns:\n            Parameter list describing the return parameters of the function (if any).\n        \"\"\"\n        from ..meta.parameter_list import ParameterList\n\n        if self._function_return_parameters is None:\n            return None\n        node = self._reference_resolver.resolve_node(\n            self._function_return_parameters, self.source_unit.cu_hash\n        )\n        assert isinstance(node, ParameterList)\n        return node\n\n    @property\n    def expression(self) -&gt; Optional[ExpressionAbc]:\n        \"\"\"\n        Returns:\n            Expression returned by the return statement, if any.\n        \"\"\"\n        return self._expression\n\n    @property\n    @lru_cache(maxsize=2048)\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        if self._expression is None:\n            return set()\n        return self._expression.modifies_state\n</code></pre>"},{"location":"api-reference/ir/statements/return-statement/#wake.ir.statements.return_statement.Return.expression","title":"<code>expression: Optional[ExpressionAbc]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Optional[ExpressionAbc]</code> <p>Expression returned by the return statement, if any.</p>"},{"location":"api-reference/ir/statements/return-statement/#wake.ir.statements.return_statement.Return.function_return_parameters","title":"<code>function_return_parameters: Optional[ParameterList]</code>  <code>property</code>","text":"<p>Example</p> <p>Can be <code>None</code> if the function does not return anything. <pre><code>function f(uint x) public {\n    if (x &gt; 0) {\n        return;\n    }\n    doSomething(x);\n}\n</code></pre></p> <p>Returns:</p> Type Description <code>Optional[ParameterList]</code> <p>Parameter list describing the return parameters of the function (if any).</p>"},{"location":"api-reference/ir/statements/return-statement/#wake.ir.statements.return_statement.Return.parent","title":"<code>parent: Union[Block, DoWhileStatement, ForStatement, IfStatement, UncheckedBlock, WhileStatement]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[Block, DoWhileStatement, ForStatement, IfStatement, UncheckedBlock, WhileStatement]</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/statements/revert-statement/","title":"revert_statement","text":""},{"location":"api-reference/ir/statements/revert-statement/#wake.ir.statements.revert_statement","title":"<code>wake.ir.statements.revert_statement</code>  <code>module</code>","text":""},{"location":"api-reference/ir/statements/revert-statement/#wake.ir.statements.revert_statement.RevertStatement","title":"<code>RevertStatement</code>  <code>class</code>","text":"<p>         Bases: <code>StatementAbc</code></p> <p>Warning</p> <p>Only matches reverts with user-defined errors: <pre><code>revert InsufficientBalance(want, have);\n</code></pre> This is an ExpressionStatement with a FunctionCall expression: <pre><code>revert(\"Insufficient balance\");\n</code></pre></p> Source code in <code>wake/ir/statements/revert_statement.py</code> <pre><code>class RevertStatement(StatementAbc):\n    \"\"\"\n    !!! warning\n        Only matches reverts with user-defined errors:\n        ```solidity\n        revert InsufficientBalance(want, have);\n        ```\n        This is an [ExpressionStatement][wake.ir.statements.expression_statement.ExpressionStatement] with a [FunctionCall][wake.ir.expressions.function_call.FunctionCall] expression:\n        ```solidity\n        revert(\"Insufficient balance\");\n        ```\n    \"\"\"\n\n    _ast_node: SolcRevertStatement\n    _parent: Union[\n        Block,\n        DoWhileStatement,\n        ForStatement,\n        IfStatement,\n        UncheckedBlock,\n        WhileStatement,\n    ]\n\n    _error_call: FunctionCall\n\n    def __init__(\n        self, init: IrInitTuple, revert: SolcRevertStatement, parent: SolidityAbc\n    ):\n        super().__init__(init, revert, parent)\n        self._error_call = FunctionCall(init, revert.error_call, self)\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        yield from self._error_call\n\n    @property\n    def parent(\n        self,\n    ) -&gt; Union[\n        Block,\n        DoWhileStatement,\n        ForStatement,\n        IfStatement,\n        UncheckedBlock,\n        WhileStatement,\n    ]:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def error_call(self) -&gt; FunctionCall:\n        \"\"\"\n        !!! example\n            ```solidity\n            InsufficientBalance(want, have)\n            ```\n            in the following revert statement:\n            ```solidity\n            revert InsufficientBalance(want, have)\n            ```\n\n        Returns:\n            Expression representing the error call.\n        \"\"\"\n        return self._error_call\n\n    @property\n    @lru_cache(maxsize=2048)\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        return self.error_call.modifies_state\n</code></pre>"},{"location":"api-reference/ir/statements/revert-statement/#wake.ir.statements.revert_statement.RevertStatement.error_call","title":"<code>error_call: FunctionCall</code>  <code>property</code>","text":"<p>Example</p> <p><pre><code>InsufficientBalance(want, have)\n</code></pre> in the following revert statement: <pre><code>revert InsufficientBalance(want, have)\n</code></pre></p> <p>Returns:</p> Type Description <code>FunctionCall</code> <p>Expression representing the error call.</p>"},{"location":"api-reference/ir/statements/revert-statement/#wake.ir.statements.revert_statement.RevertStatement.parent","title":"<code>parent: Union[Block, DoWhileStatement, ForStatement, IfStatement, UncheckedBlock, WhileStatement]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[Block, DoWhileStatement, ForStatement, IfStatement, UncheckedBlock, WhileStatement]</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/statements/try-statement/","title":"try_statement","text":""},{"location":"api-reference/ir/statements/try-statement/#wake.ir.statements.try_statement","title":"<code>wake.ir.statements.try_statement</code>  <code>module</code>","text":""},{"location":"api-reference/ir/statements/try-statement/#wake.ir.statements.try_statement.TryStatement","title":"<code>TryStatement</code>  <code>class</code>","text":"<p>         Bases: <code>StatementAbc</code></p> <p>Example</p> <pre><code>try this.f() returns (uint256) {\n    // ...\n} catch Error(string memory reason) {\n    // ...\n} catch Panic(uint errorCode) {\n    // ...\n} catch (bytes memory lowLevelData) {\n    // ...\n}\n</code></pre> Source code in <code>wake/ir/statements/try_statement.py</code> <pre><code>class TryStatement(StatementAbc):\n    \"\"\"\n    !!! example\n        ```solidity\n        try this.f() returns (uint256) {\n            // ...\n        } catch Error(string memory reason) {\n            // ...\n        } catch Panic(uint errorCode) {\n            // ...\n        } catch (bytes memory lowLevelData) {\n            // ...\n        }\n        ```\n    \"\"\"\n\n    _ast_node: SolcTryStatement\n    _parent: Union[\n        Block,\n        DoWhileStatement,\n        ForStatement,\n        IfStatement,\n        UncheckedBlock,\n        WhileStatement,\n    ]\n\n    _clauses: List[TryCatchClause]\n    _external_call: FunctionCall\n\n    def __init__(\n        self, init: IrInitTuple, try_statement: SolcTryStatement, parent: SolidityAbc\n    ):\n        super().__init__(init, try_statement, parent)\n        self._clauses = [\n            TryCatchClause(init, clause, self) for clause in try_statement.clauses\n        ]\n        self._external_call = FunctionCall(init, try_statement.external_call, self)\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        for clause in self._clauses:\n            yield from clause\n        yield from self._external_call\n\n    @property\n    def parent(\n        self,\n    ) -&gt; Union[\n        Block,\n        DoWhileStatement,\n        ForStatement,\n        IfStatement,\n        UncheckedBlock,\n        WhileStatement,\n    ]:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def clauses(self) -&gt; Tuple[TryCatchClause, ...]:\n        \"\"\"\n        Returns:\n            Try/catch clauses.\n        \"\"\"\n        return tuple(self._clauses)\n\n    @property\n    def external_call(self) -&gt; FunctionCall:\n        \"\"\"\n        Returns:\n            External call executed in the try statement.\n        \"\"\"\n        return self._external_call\n\n    @property\n    @lru_cache(maxsize=2048)\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        return (\n            reduce(\n                or_,\n                (clause.modifies_state for clause in self._clauses),\n                set(),\n            )\n            | self.external_call.modifies_state\n        )\n\n    def statements_iter(self) -&gt; Iterator[StatementAbc]:\n        yield self\n        for clause in self._clauses:\n            yield from clause.block.statements_iter()\n</code></pre>"},{"location":"api-reference/ir/statements/try-statement/#wake.ir.statements.try_statement.TryStatement.clauses","title":"<code>clauses: Tuple[TryCatchClause, ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[TryCatchClause, ...]</code> <p>Try/catch clauses.</p>"},{"location":"api-reference/ir/statements/try-statement/#wake.ir.statements.try_statement.TryStatement.external_call","title":"<code>external_call: FunctionCall</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>FunctionCall</code> <p>External call executed in the try statement.</p>"},{"location":"api-reference/ir/statements/try-statement/#wake.ir.statements.try_statement.TryStatement.parent","title":"<code>parent: Union[Block, DoWhileStatement, ForStatement, IfStatement, UncheckedBlock, WhileStatement]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[Block, DoWhileStatement, ForStatement, IfStatement, UncheckedBlock, WhileStatement]</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/statements/unchecked-block/","title":"unchecked_block","text":""},{"location":"api-reference/ir/statements/unchecked-block/#wake.ir.statements.unchecked_block","title":"<code>wake.ir.statements.unchecked_block</code>  <code>module</code>","text":""},{"location":"api-reference/ir/statements/unchecked-block/#wake.ir.statements.unchecked_block.UncheckedBlock","title":"<code>UncheckedBlock</code>  <code>class</code>","text":"<p>         Bases: <code>StatementAbc</code></p> <p>Example</p> <p>Lines 2-4 in the following code: <pre><code>function inc(uint x) public pure returns(uint) {\n    unchecked {\n        x += 1;\n    }\n    return x;\n}\n</code></pre></p> Source code in <code>wake/ir/statements/unchecked_block.py</code> <pre><code>class UncheckedBlock(StatementAbc):\n    \"\"\"\n    !!! example\n        Lines 2-4 in the following code:\n        ```solidity linenums=\"1\"\n        function inc(uint x) public pure returns(uint) {\n            unchecked {\n                x += 1;\n            }\n            return x;\n        }\n        ```\n    \"\"\"\n\n    _ast_node: SolcUncheckedBlock\n    _parent: Union[Block, DoWhileStatement, ForStatement, IfStatement, WhileStatement]\n\n    _statements: List[StatementAbc]\n\n    def __init__(\n        self,\n        init: IrInitTuple,\n        unchecked_block: SolcUncheckedBlock,\n        parent: SolidityAbc,\n    ):\n        super().__init__(init, unchecked_block, parent)\n        self._statements = [\n            StatementAbc.from_ast(init, statement, self)\n            for statement in unchecked_block.statements\n        ]\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        for statement in self._statements:\n            yield from statement\n\n    @property\n    def parent(\n        self,\n    ) -&gt; Union[Block, DoWhileStatement, ForStatement, IfStatement, WhileStatement]:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def statements(self) -&gt; Tuple[StatementAbc, ...]:\n        \"\"\"\n        Can be empty.\n\n        Returns:\n            Statements in the block.\n        \"\"\"\n        return tuple(self._statements)\n\n    @property\n    @lru_cache(maxsize=2048)\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        return reduce(\n            or_,\n            (statement.modifies_state for statement in self._statements),\n            set(),\n        )\n\n    def statements_iter(self) -&gt; Iterator[StatementAbc]:\n        yield self\n        for statement in self._statements:\n            yield from statement.statements_iter()\n</code></pre>"},{"location":"api-reference/ir/statements/unchecked-block/#wake.ir.statements.unchecked_block.UncheckedBlock.parent","title":"<code>parent: Union[Block, DoWhileStatement, ForStatement, IfStatement, WhileStatement]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[Block, DoWhileStatement, ForStatement, IfStatement, WhileStatement]</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/statements/unchecked-block/#wake.ir.statements.unchecked_block.UncheckedBlock.statements","title":"<code>statements: Tuple[StatementAbc, ...]</code>  <code>property</code>","text":"<p>Can be empty.</p> <p>Returns:</p> Type Description <code>Tuple[StatementAbc, ...]</code> <p>Statements in the block.</p>"},{"location":"api-reference/ir/statements/variable-declaration-statement/","title":"variable_declaration_statement","text":""},{"location":"api-reference/ir/statements/variable-declaration-statement/#wake.ir.statements.variable_declaration_statement","title":"<code>wake.ir.statements.variable_declaration_statement</code>  <code>module</code>","text":""},{"location":"api-reference/ir/statements/variable-declaration-statement/#wake.ir.statements.variable_declaration_statement.VariableDeclarationStatement","title":"<code>VariableDeclarationStatement</code>  <code>class</code>","text":"<p>         Bases: <code>StatementAbc</code></p> <p>Example</p> <p><code>(uint a, uint b) = (1, 2)</code> in the following code: <pre><code>contract C {\n    function f() public {\n        (uint a, uint b) = (1, 2);\n    }\n}\n</code></pre></p> Source code in <code>wake/ir/statements/variable_declaration_statement.py</code> <pre><code>class VariableDeclarationStatement(StatementAbc):\n    \"\"\"\n    !!! example\n        `:::solidity (uint a, uint b) = (1, 2)` in the following code:\n        ```solidity\n        contract C {\n            function f() public {\n                (uint a, uint b) = (1, 2);\n            }\n        }\n        ```\n    \"\"\"\n\n    _ast_node: SolcVariableDeclarationStatement\n    _parent: Union[\n        Block,\n        DoWhileStatement,\n        ForStatement,\n        IfStatement,\n        UncheckedBlock,\n        WhileStatement,\n    ]\n\n    _assignments: List[Optional[AstNodeId]]\n    _declarations: List[Optional[VariableDeclaration]]\n    _initial_value: Optional[ExpressionAbc]\n\n    def __init__(\n        self,\n        init: IrInitTuple,\n        variable_declaration_statement: SolcVariableDeclarationStatement,\n        parent: SolidityAbc,\n    ):\n        super().__init__(init, variable_declaration_statement, parent)\n        self._assignments = list(variable_declaration_statement.assignments)\n\n        self._declarations = []\n        for declaration in variable_declaration_statement.declarations:\n            if declaration is None:\n                self._declarations.append(None)\n            else:\n                self._declarations.append(VariableDeclaration(init, declaration, self))\n\n        if variable_declaration_statement.initial_value is None:\n            self._initial_value = None\n        else:\n            self._initial_value = ExpressionAbc.from_ast(\n                init, variable_declaration_statement.initial_value, self\n            )\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        for declaration in self._declarations:\n            if declaration is not None:\n                yield from declaration\n        if self._initial_value is not None:\n            yield from self._initial_value\n\n    @property\n    def parent(\n        self,\n    ) -&gt; Union[\n        Block,\n        DoWhileStatement,\n        ForStatement,\n        IfStatement,\n        UncheckedBlock,\n        WhileStatement,\n    ]:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def declarations(self) -&gt; Tuple[Optional[VariableDeclaration], ...]:\n        \"\"\"\n        !!! example\n            Some declarations may be `None`, e.g. in the following code:\n            ```solidity\n            (bool success, ) = address(this).call{value: 1}(\"\");\n            ```\n\n        Returns:\n            Tuple of variable declarations in this statement.\n        \"\"\"\n        return tuple(self._declarations)\n\n    @property\n    def initial_value(self) -&gt; Optional[ExpressionAbc]:\n        \"\"\"\n        Does not need to be a [TupleExpression][wake.ir.expressions.tuple_expression.TupleExpression] when there is more than one variable declared.\n        Can also be a [FunctionCall][wake.ir.expressions.function_call.FunctionCall] returning a tuple.\n\n        Returns:\n            Initial value assigned to the declared variables (if any).\n        \"\"\"\n        return self._initial_value\n\n    @property\n    @lru_cache(maxsize=2048)\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        ret = set()\n        if self.initial_value is not None:\n            ret |= self.initial_value.modifies_state\n            if any(\n                declaration.is_state_variable\n                for declaration in self.declarations\n                if declaration is not None\n            ):\n                ret |= {(self, ModifiesStateFlag.MODIFIES_STATE_VAR)}\n        return ret\n</code></pre>"},{"location":"api-reference/ir/statements/variable-declaration-statement/#wake.ir.statements.variable_declaration_statement.VariableDeclarationStatement.declarations","title":"<code>declarations: Tuple[Optional[VariableDeclaration], ...]</code>  <code>property</code>","text":"<p>Example</p> <p>Some declarations may be <code>None</code>, e.g. in the following code: <pre><code>(bool success, ) = address(this).call{value: 1}(\"\");\n</code></pre></p> <p>Returns:</p> Type Description <code>Tuple[Optional[VariableDeclaration], ...]</code> <p>Tuple of variable declarations in this statement.</p>"},{"location":"api-reference/ir/statements/variable-declaration-statement/#wake.ir.statements.variable_declaration_statement.VariableDeclarationStatement.initial_value","title":"<code>initial_value: Optional[ExpressionAbc]</code>  <code>property</code>","text":"<p>Does not need to be a TupleExpression when there is more than one variable declared. Can also be a FunctionCall returning a tuple.</p> <p>Returns:</p> Type Description <code>Optional[ExpressionAbc]</code> <p>Initial value assigned to the declared variables (if any).</p>"},{"location":"api-reference/ir/statements/variable-declaration-statement/#wake.ir.statements.variable_declaration_statement.VariableDeclarationStatement.parent","title":"<code>parent: Union[Block, DoWhileStatement, ForStatement, IfStatement, UncheckedBlock, WhileStatement]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[Block, DoWhileStatement, ForStatement, IfStatement, UncheckedBlock, WhileStatement]</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/statements/while-statement/","title":"while_statement","text":""},{"location":"api-reference/ir/statements/while-statement/#wake.ir.statements.while_statement","title":"<code>wake.ir.statements.while_statement</code>  <code>module</code>","text":""},{"location":"api-reference/ir/statements/while-statement/#wake.ir.statements.while_statement.WhileStatement","title":"<code>WhileStatement</code>  <code>class</code>","text":"<p>         Bases: <code>StatementAbc</code></p> <p>Example</p> <p>Lines 2-3 in the following code: <pre><code>function foo(uint x) public pure {\n    while (x % 2 == 0)\n        x /= 2;\n}\n</code></pre></p> Source code in <code>wake/ir/statements/while_statement.py</code> <pre><code>class WhileStatement(StatementAbc):\n    \"\"\"\n    !!! example\n        Lines 2-3 in the following code:\n        ```solidity linenums=\"1\"\n        function foo(uint x) public pure {\n            while (x % 2 == 0)\n                x /= 2;\n        }\n        ```\n    \"\"\"\n\n    _ast_node: SolcWhileStatement\n    _parent: Union[\n        Block,\n        DoWhileStatement,\n        ForStatement,\n        IfStatement,\n        UncheckedBlock,\n        WhileStatement,\n    ]\n\n    _body: StatementAbc\n    _condition: ExpressionAbc\n\n    def __init__(\n        self,\n        init: IrInitTuple,\n        while_statement: SolcWhileStatement,\n        parent: SolidityAbc,\n    ):\n        super().__init__(init, while_statement, parent)\n        self._body = StatementAbc.from_ast(init, while_statement.body, self)\n        self._condition = ExpressionAbc.from_ast(init, while_statement.condition, self)\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        yield from self._body\n        yield from self._condition\n\n    @property\n    def parent(\n        self,\n    ) -&gt; Union[\n        Block,\n        DoWhileStatement,\n        ForStatement,\n        IfStatement,\n        UncheckedBlock,\n        WhileStatement,\n    ]:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def body(self) -&gt; StatementAbc:\n        \"\"\"\n        Returns:\n            Body of the while statement.\n        \"\"\"\n        return self._body\n\n    @property\n    def condition(self) -&gt; ExpressionAbc:\n        \"\"\"\n        Returns:\n            Condition of the while statement.\n        \"\"\"\n        return self._condition\n\n    @property\n    @lru_cache(maxsize=2048)\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        return self.body.modifies_state | self.condition.modifies_state\n\n    def statements_iter(self) -&gt; Iterator[StatementAbc]:\n        yield self\n        yield from self._body.statements_iter()\n</code></pre>"},{"location":"api-reference/ir/statements/while-statement/#wake.ir.statements.while_statement.WhileStatement.body","title":"<code>body: StatementAbc</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>StatementAbc</code> <p>Body of the while statement.</p>"},{"location":"api-reference/ir/statements/while-statement/#wake.ir.statements.while_statement.WhileStatement.condition","title":"<code>condition: ExpressionAbc</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>ExpressionAbc</code> <p>Condition of the while statement.</p>"},{"location":"api-reference/ir/statements/while-statement/#wake.ir.statements.while_statement.WhileStatement.parent","title":"<code>parent: Union[Block, DoWhileStatement, ForStatement, IfStatement, UncheckedBlock, WhileStatement]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[Block, DoWhileStatement, ForStatement, IfStatement, UncheckedBlock, WhileStatement]</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/type-names/abc/","title":"abc","text":""},{"location":"api-reference/ir/type-names/abc/#wake.ir.type_names.abc","title":"<code>wake.ir.type_names.abc</code>  <code>module</code>","text":""},{"location":"api-reference/ir/type-names/abc/#wake.ir.type_names.abc.TypeNameAbc","title":"<code>TypeNameAbc</code>  <code>class</code>","text":"<p>         Bases: <code>SolidityAbc</code>, <code>ABC</code></p> <p>Abstract base class for all IR type name nodes.</p> Source code in <code>wake/ir/type_names/abc.py</code> <pre><code>class TypeNameAbc(SolidityAbc, ABC):\n    \"\"\"\n    Abstract base class for all IR type name nodes.\n    \"\"\"\n\n    _type_descriptions: TypeDescriptionsModel\n\n    def __init__(\n        self, init: IrInitTuple, type_name: SolcTypeNameUnion, parent: SolidityAbc\n    ):\n        super().__init__(init, type_name, parent)\n        self._type_descriptions = type_name.type_descriptions\n\n    @staticmethod\n    def from_ast(\n        init: IrInitTuple, type_name: SolcTypeNameUnion, parent: SolidityAbc\n    ) -&gt; TypeNameAbc:\n        from .array_type_name import ArrayTypeName\n        from .elementary_type_name import ElementaryTypeName\n        from .function_type_name import FunctionTypeName\n        from .mapping import Mapping\n        from .user_defined_type_name import UserDefinedTypeName\n\n        if isinstance(type_name, SolcArrayTypeName):\n            return ArrayTypeName(init, type_name, parent)\n        elif isinstance(type_name, SolcElementaryTypeName):\n            return ElementaryTypeName(init, type_name, parent)\n        elif isinstance(type_name, SolcFunctionTypeName):\n            return FunctionTypeName(init, type_name, parent)\n        elif isinstance(type_name, SolcMapping):\n            return Mapping(init, type_name, parent)\n        elif isinstance(type_name, SolcUserDefinedTypeName):\n            return UserDefinedTypeName(init, type_name, parent)\n\n    @property\n    @abstractmethod\n    def parent(\n        self,\n    ) -&gt; Union[\n        VariableDeclaration,\n        UserDefinedValueTypeDefinition,\n        ElementaryTypeNameExpression,\n        NewExpression,\n        UsingForDirective,\n        ArrayTypeName,\n        Mapping,\n    ]:\n        \"\"\"\n        Returns:\n            Parent node of the type name.\n        \"\"\"\n        ...\n\n    @property\n    @lru_cache(maxsize=2048)\n    def type(\n        self,\n    ) -&gt; Union[\n        Array,\n        Address,\n        Bool,\n        Int,\n        UInt,\n        Fixed,\n        UFixed,\n        String,\n        Bytes,\n        FixedBytes,\n        Type,\n        Function,\n        Mapping,\n        Struct,\n        Enum,\n        Contract,\n        UserDefinedValueType,\n    ]:\n        \"\"\"\n        Returns:\n            Type of the type name.\n        \"\"\"\n        assert self._type_descriptions.type_identifier is not None\n\n        type_identifier = StringReader(self._type_descriptions.type_identifier)\n        ret = TypeAbc.from_type_identifier(\n            type_identifier, self._reference_resolver, self.source_unit.cu_hash\n        )\n        assert (\n            len(type_identifier) == 0 and ret is not None\n        ), f\"Failed to parse type identifier: {self._type_descriptions.type_identifier}\"\n        assert isinstance(\n            ret,\n            (\n                Array,\n                Address,\n                Bool,\n                Int,\n                UInt,\n                Fixed,\n                UFixed,\n                String,\n                Bytes,\n                FixedBytes,\n                Type,\n                Function,\n                Mapping,\n                Struct,\n                Enum,\n                Contract,\n                UserDefinedValueType,\n            ),\n        )\n        return ret\n\n    @property\n    def type_identifier(self) -&gt; str:\n        assert self._type_descriptions.type_identifier is not None\n        return self._type_descriptions.type_identifier\n\n    @property\n    def type_string(self) -&gt; str:\n        \"\"\"\n        !!! example\n            `:::solidity mapping(uint256 =&gt; int24[])` in the case of the `:::solidity mapping(uint =&gt; int24[])` type name in the following declaration:\n            ```solidity\n            mapping(uint =&gt; int24[]) map;\n            ```\n\n        Returns:\n            User-friendly string describing the type name type.\n        \"\"\"\n        assert self._type_descriptions.type_string is not None\n        return self._type_descriptions.type_string\n</code></pre>"},{"location":"api-reference/ir/type-names/abc/#wake.ir.type_names.abc.TypeNameAbc.parent","title":"<code>parent: Union[VariableDeclaration, UserDefinedValueTypeDefinition, ElementaryTypeNameExpression, NewExpression, UsingForDirective, ArrayTypeName, Mapping]</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[VariableDeclaration, UserDefinedValueTypeDefinition, ElementaryTypeNameExpression, NewExpression, UsingForDirective, ArrayTypeName, Mapping]</code> <p>Parent node of the type name.</p>"},{"location":"api-reference/ir/type-names/abc/#wake.ir.type_names.abc.TypeNameAbc.type","title":"<code>type: Union[Array, Address, Bool, Int, UInt, Fixed, UFixed, String, Bytes, FixedBytes, Type, Function, Mapping, Struct, Enum, Contract, UserDefinedValueType]</code>  <code>cached</code> <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[Array, Address, Bool, Int, UInt, Fixed, UFixed, String, Bytes, FixedBytes, Type, Function, Mapping, Struct, Enum, Contract, UserDefinedValueType]</code> <p>Type of the type name.</p>"},{"location":"api-reference/ir/type-names/abc/#wake.ir.type_names.abc.TypeNameAbc.type_string","title":"<code>type_string: str</code>  <code>property</code>","text":"<p>Example</p> <p><code>mapping(uint256 =&gt; int24[])</code> in the case of the <code>mapping(uint =&gt; int24[])</code> type name in the following declaration: <pre><code>mapping(uint =&gt; int24[]) map;\n</code></pre></p> <p>Returns:</p> Type Description <code>str</code> <p>User-friendly string describing the type name type.</p>"},{"location":"api-reference/ir/type-names/array-type-name/","title":"array_type_name","text":""},{"location":"api-reference/ir/type-names/array-type-name/#wake.ir.type_names.array_type_name","title":"<code>wake.ir.type_names.array_type_name</code>  <code>module</code>","text":""},{"location":"api-reference/ir/type-names/array-type-name/#wake.ir.type_names.array_type_name.ArrayTypeName","title":"<code>ArrayTypeName</code>  <code>class</code>","text":"<p>         Bases: <code>TypeNameAbc</code></p> <p>Array type name.</p> <p>Example</p> <p>An array type name can be used:</p> <ul> <li>inside a VariableDeclaration:<ul> <li><code>bool[]</code> on line 1,</li> <li><code>int[10][20]</code> on line 11,</li> <li><code>string[10]</code> on line 12,</li> <li><code>address[]</code> on line 16,</li> </ul> </li> <li>inside a NewExpression:<ul> <li><code>address[]</code> on line 16,</li> </ul> </li> <li>inside a UsingForDirective:<ul> <li><code>bool[]</code> on line 8,</li> </ul> </li> <li>inside an ArrayTypeName:<ul> <li><code>int[10]</code> on line 11,</li> </ul> </li> <li>inside a Mapping:<ul> <li><code>C[]</code> on line 13.</li> </ul> </li> </ul> <pre><code>function or(bool[] memory arr) pure returns(bool) {\n    for (uint i = 0; i &lt; arr.length; i++)\n        if (arr[i])\n            return true;\n    return false;\n}\n\nusing {or} for bool[];\n\ncontract C {\n    int[10][20] arr;\n    string[10] names;\n    mapping(address =&gt; C[]) map;\n\n    function foo() public pure {\n        address[] memory addresses = new address[](5);\n    }\n}\n</code></pre> Source code in <code>wake/ir/type_names/array_type_name.py</code> <pre><code>class ArrayTypeName(TypeNameAbc):\n    \"\"\"\n    Array type name.\n\n    !!! example\n        An array type name can be used:\n\n        - inside a [VariableDeclaration][wake.ir.declarations.variable_declaration.VariableDeclaration]:\n            - `:::solidity bool[]` on line 1,\n            - `:::solidity int[10][20]` on line 11,\n            - `:::solidity string[10]` on line 12,\n            - `:::solidity address[]` on line 16,\n        - inside a [NewExpression][wake.ir.expressions.new_expression.NewExpression]:\n            - `:::solidity address[]` on line 16,\n        - inside a [UsingForDirective][wake.ir.meta.using_for_directive.UsingForDirective]:\n            - `:::solidity bool[]` on line 8,\n        - inside an [ArrayTypeName][wake.ir.type_names.array_type_name.ArrayTypeName]:\n            - `:::solidity int[10]` on line 11,\n        - inside a [Mapping][wake.ir.type_names.mapping.Mapping]:\n            - `:::solidity C[]` on line 13.\n\n        ```solidity linenums=\"1\"\n        function or(bool[] memory arr) pure returns(bool) {\n            for (uint i = 0; i &lt; arr.length; i++)\n                if (arr[i])\n                    return true;\n            return false;\n        }\n\n        using {or} for bool[];\n\n        contract C {\n            int[10][20] arr;\n            string[10] names;\n            mapping(address =&gt; C[]) map;\n\n            function foo() public pure {\n                address[] memory addresses = new address[](5);\n            }\n        }\n        ```\n    \"\"\"\n\n    _ast_node: SolcArrayTypeName\n    _parent: Union[\n        VariableDeclaration, NewExpression, UsingForDirective, ArrayTypeName, Mapping\n    ]\n\n    _base_type: TypeNameAbc\n    _length: Optional[ExpressionAbc]\n\n    def __init__(\n        self, init: IrInitTuple, array_type_name: SolcArrayTypeName, parent: SolidityAbc\n    ):\n        super().__init__(init, array_type_name, parent)\n        self._base_type = TypeNameAbc.from_ast(init, array_type_name.base_type, self)\n        self._length = (\n            ExpressionAbc.from_ast(init, array_type_name.length, self)\n            if array_type_name.length is not None\n            else None\n        )\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        yield from self._base_type\n        if self._length is not None:\n            yield from self._length\n\n    @property\n    def parent(\n        self,\n    ) -&gt; Union[\n        VariableDeclaration, NewExpression, UsingForDirective, ArrayTypeName, Mapping\n    ]:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def type(self) -&gt; Array:\n        \"\"\"\n        Returns:\n            Type description.\n        \"\"\"\n        t = super().type\n        assert isinstance(t, Array)\n        return t\n\n    @property\n    def base_type(self) -&gt; TypeNameAbc:\n        \"\"\"\n        !!! example\n            `uint8[2]` has `uint8` ([ElementaryTypeName][wake.ir.type_names.elementary_type_name.ElementaryTypeName]) as a base type.\n\n            `uint8[2][3]` has `uint8[2]` ([ArrayTypeName][wake.ir.type_names.array_type_name.ArrayTypeName]) as a base type.\n\n        Returns:\n            Type name IR node describing the base type.\n        \"\"\"\n        return self._base_type\n\n    @property\n    def length(self) -&gt; Optional[ExpressionAbc]:\n        \"\"\"\n        Returns an expression as present in the source code.\n\n        Returns:\n            Expression defining the length of the array.\n        \"\"\"\n        return self._length\n</code></pre>"},{"location":"api-reference/ir/type-names/array-type-name/#wake.ir.type_names.array_type_name.ArrayTypeName.base_type","title":"<code>base_type: TypeNameAbc</code>  <code>property</code>","text":"<p>Example</p> <p><code>uint8[2]</code> has <code>uint8</code> (ElementaryTypeName) as a base type.</p> <p><code>uint8[2][3]</code> has <code>uint8[2]</code> (ArrayTypeName) as a base type.</p> <p>Returns:</p> Type Description <code>TypeNameAbc</code> <p>Type name IR node describing the base type.</p>"},{"location":"api-reference/ir/type-names/array-type-name/#wake.ir.type_names.array_type_name.ArrayTypeName.length","title":"<code>length: Optional[ExpressionAbc]</code>  <code>property</code>","text":"<p>Returns an expression as present in the source code.</p> <p>Returns:</p> Type Description <code>Optional[ExpressionAbc]</code> <p>Expression defining the length of the array.</p>"},{"location":"api-reference/ir/type-names/array-type-name/#wake.ir.type_names.array_type_name.ArrayTypeName.parent","title":"<code>parent: Union[VariableDeclaration, NewExpression, UsingForDirective, ArrayTypeName, Mapping]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[VariableDeclaration, NewExpression, UsingForDirective, ArrayTypeName, Mapping]</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/type-names/array-type-name/#wake.ir.type_names.array_type_name.ArrayTypeName.type","title":"<code>type: Array</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Array</code> <p>Type description.</p>"},{"location":"api-reference/ir/type-names/elementary-type-name/","title":"elementary_type_name","text":""},{"location":"api-reference/ir/type-names/elementary-type-name/#wake.ir.type_names.elementary_type_name","title":"<code>wake.ir.type_names.elementary_type_name</code>  <code>module</code>","text":""},{"location":"api-reference/ir/type-names/elementary-type-name/#wake.ir.type_names.elementary_type_name.ElementaryTypeName","title":"<code>ElementaryTypeName</code>  <code>class</code>","text":"<p>         Bases: <code>TypeNameAbc</code></p> <p>Elementary type name.</p> <p>Example</p> <p>An elementary type name can be used:</p> <ul> <li>inside a VariableDeclaration:<ul> <li>both occurrences of <code>uint</code> on line 1,</li> <li><code>int</code> on line 1,</li> <li><code>string</code> on line 10,</li> <li>the first occurrence of <code>bytes</code> on line 15,</li> </ul> </li> <li>inside a UserDefinedValueTypeDefinition:<ul> <li><code>int</code> on line 7,</li> </ul> </li> <li>inside an ElementaryTypeNameExpression:<ul> <li><code>int</code> on line 2,</li> </ul> </li> <li>inside a NewExpression:<ul> <li>the second occurrence of <code>bytes</code> on line 15,</li> </ul> </li> <li>inside a UsingForDirective:<ul> <li><code>uint</code> on line 5,</li> </ul> </li> <li>inside an ArrayTypeName:<ul> <li><code>uint</code> on line 11,</li> </ul> </li> <li>inside a Mapping:<ul> <li><code>address</code> on line 12.</li> </ul> </li> </ul> <pre><code>function add(uint a, uint b) pure returns(int) {\n    return int(a + b);\n}\n\nusing {add} for uint;\n\ntype MyInt is int;\n\ncontract C {\n    string public str;\n    uint[10] arr;\n    mapping(address =&gt; MyInt) map;\n\n    function foo() public pure {\n        bytes memory b = new bytes(10);\n    }\n}\n</code></pre> Source code in <code>wake/ir/type_names/elementary_type_name.py</code> <pre><code>class ElementaryTypeName(TypeNameAbc):\n    \"\"\"\n    Elementary type name.\n\n    !!! example\n        An elementary type name can be used:\n\n        - inside a [VariableDeclaration][wake.ir.declarations.variable_declaration.VariableDeclaration]:\n            - both occurrences of `:::solidity uint` on line 1,\n            - `:::solidity int` on line 1,\n            - `:::solidity string` on line 10,\n            - the first occurrence of `:::solidity bytes` on line 15,\n        - inside a [UserDefinedValueTypeDefinition][wake.ir.declarations.user_defined_value_type_definition.UserDefinedValueTypeDefinition]:\n            - `:::solidity int` on line 7,\n        - inside an [ElementaryTypeNameExpression][wake.ir.expressions.elementary_type_name_expression.ElementaryTypeNameExpression]:\n            - `:::solidity int` on line 2,\n        - inside a [NewExpression][wake.ir.expressions.new_expression.NewExpression]:\n            - the second occurrence of `:::solidity bytes` on line 15,\n        - inside a [UsingForDirective][wake.ir.meta.using_for_directive.UsingForDirective]:\n            - `:::solidity uint` on line 5,\n        - inside an [ArrayTypeName][wake.ir.type_names.array_type_name.ArrayTypeName]:\n            - `:::solidity uint` on line 11,\n        - inside a [Mapping][wake.ir.type_names.mapping.Mapping]:\n            - `:::solidity address` on line 12.\n\n        ```solidity linenums=\"1\"\n        function add(uint a, uint b) pure returns(int) {\n            return int(a + b);\n        }\n\n        using {add} for uint;\n\n        type MyInt is int;\n\n        contract C {\n            string public str;\n            uint[10] arr;\n            mapping(address =&gt; MyInt) map;\n\n            function foo() public pure {\n                bytes memory b = new bytes(10);\n            }\n        }\n        ```\n    \"\"\"\n\n    _ast_node: SolcElementaryTypeName\n    _parent: Union[\n        VariableDeclaration,\n        UserDefinedValueTypeDefinition,\n        ElementaryTypeNameExpression,\n        NewExpression,\n        UsingForDirective,\n        ArrayTypeName,\n        Mapping,\n    ]\n\n    _name: str\n    _state_mutability: Optional[StateMutability]\n\n    def __init__(\n        self,\n        init: IrInitTuple,\n        elementary_type_name: SolcElementaryTypeName,\n        parent: SolidityAbc,\n    ):\n        super().__init__(init, elementary_type_name, parent)\n        self._name = elementary_type_name.name\n        self._state_mutability = elementary_type_name.state_mutability\n\n        from wake.ir.expressions.elementary_type_name_expression import (\n            ElementaryTypeNameExpression,\n        )\n\n        # fix missing type descriptions in AST\n        if self._type_descriptions.type_identifier is None and isinstance(\n            parent, ElementaryTypeNameExpression\n        ):\n            self._type_descriptions = parent._type_descriptions\n\n    @property\n    def parent(\n        self,\n    ) -&gt; Union[\n        VariableDeclaration,\n        UserDefinedValueTypeDefinition,\n        ElementaryTypeNameExpression,\n        NewExpression,\n        UsingForDirective,\n        ArrayTypeName,\n        Mapping,\n    ]:\n        \"\"\"\n        When the parent is a [NewExpression][wake.ir.expressions.new_expression.NewExpression], this can only be `bytes` or `string`.\n\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def type(\n        self,\n    ) -&gt; Union[\n        Address, Bool, Int, UInt, Fixed, UFixed, String, Bytes, FixedBytes, Type\n    ]:\n        \"\"\"\n        Returns either the generic [Type][wake.ir.types.Type] expression type (this is the case of a type conversion, for example `:::solidity address(0)`) or directly one of the elementary expression types.\n\n        Returns:\n            Type description.\n        \"\"\"\n        t = super().type\n        if not isinstance(\n            t,\n            (Address, Bool, Int, UInt, Fixed, UFixed, String, Bytes, FixedBytes, Type),\n        ):\n            raise TypeError(f\"Unexpected type {t} {self.source}\")\n        assert isinstance(\n            t,\n            (Address, Bool, Int, UInt, Fixed, UFixed, String, Bytes, FixedBytes, Type),\n        )\n        return t\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"\n        !!! example\n            For example `uint256`, `bool`, `string`, `bytes1` or `address`.\n\n        !!! tip\n            Instead of working with the name, it may be better to use the [type][wake.ir.type_names.elementary_type_name.ElementaryTypeName.type] property.\n\n        Returns:\n            Name of the elementary type.\n        \"\"\"\n        return self._name\n\n    @property\n    def state_mutability(self) -&gt; Optional[StateMutability]:\n        \"\"\"\n        Is only set for `address` as either [StateMutability.PAYABLE][wake.ir.enums.StateMutability.PAYABLE] or [StateMutability.NONPAYABLE][wake.ir.enums.StateMutability.NONPAYABLE].\n\n        Returns:\n            State mutability of the `address` type.\n        \"\"\"\n        return self._state_mutability\n</code></pre>"},{"location":"api-reference/ir/type-names/elementary-type-name/#wake.ir.type_names.elementary_type_name.ElementaryTypeName.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Example</p> <p>For example <code>uint256</code>, <code>bool</code>, <code>string</code>, <code>bytes1</code> or <code>address</code>.</p> <p>Tip</p> <p>Instead of working with the name, it may be better to use the type property.</p> <p>Returns:</p> Type Description <code>str</code> <p>Name of the elementary type.</p>"},{"location":"api-reference/ir/type-names/elementary-type-name/#wake.ir.type_names.elementary_type_name.ElementaryTypeName.parent","title":"<code>parent: Union[VariableDeclaration, UserDefinedValueTypeDefinition, ElementaryTypeNameExpression, NewExpression, UsingForDirective, ArrayTypeName, Mapping]</code>  <code>property</code>","text":"<p>When the parent is a NewExpression, this can only be <code>bytes</code> or <code>string</code>.</p> <p>Returns:</p> Type Description <code>Union[VariableDeclaration, UserDefinedValueTypeDefinition, ElementaryTypeNameExpression, NewExpression, UsingForDirective, ArrayTypeName, Mapping]</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/type-names/elementary-type-name/#wake.ir.type_names.elementary_type_name.ElementaryTypeName.state_mutability","title":"<code>state_mutability: Optional[StateMutability]</code>  <code>property</code>","text":"<p>Is only set for <code>address</code> as either StateMutability.PAYABLE or StateMutability.NONPAYABLE.</p> <p>Returns:</p> Type Description <code>Optional[StateMutability]</code> <p>State mutability of the <code>address</code> type.</p>"},{"location":"api-reference/ir/type-names/elementary-type-name/#wake.ir.type_names.elementary_type_name.ElementaryTypeName.type","title":"<code>type: Union[Address, Bool, Int, UInt, Fixed, UFixed, String, Bytes, FixedBytes, Type]</code>  <code>property</code>","text":"<p>Returns either the generic Type expression type (this is the case of a type conversion, for example <code>address(0)</code>) or directly one of the elementary expression types.</p> <p>Returns:</p> Type Description <code>Union[Address, Bool, Int, UInt, Fixed, UFixed, String, Bytes, FixedBytes, Type]</code> <p>Type description.</p>"},{"location":"api-reference/ir/type-names/function-type-name/","title":"function_type_name","text":""},{"location":"api-reference/ir/type-names/function-type-name/#wake.ir.type_names.function_type_name","title":"<code>wake.ir.type_names.function_type_name</code>  <code>module</code>","text":""},{"location":"api-reference/ir/type-names/function-type-name/#wake.ir.type_names.function_type_name.FunctionTypeName","title":"<code>FunctionTypeName</code>  <code>class</code>","text":"<p>         Bases: <code>TypeNameAbc</code></p> <p>Function type name.</p> <p>Example</p> <p>A function type name (<code>function (uint) returns(uint)</code>) can be used:</p> <ul> <li>inside a VariableDeclaration (lines 1 and 8),</li> <li>inside a UsingForDirective (line 5),</li> <li>inside a ArrayTypeName (line 9),</li> <li>inside a Mapping (line 11).</li> </ul> <pre><code>function test(function (uint) returns(uint) f) {\n    f(10);\n}\n\nusing {test} for function (uint) returns(uint);\n\ncontract X {\n    function (uint) returns(uint) x;\n    function (uint) returns(uint)[] y;\n\n    mapping(uint =&gt; function (uint) returns(uint)) map;\n\n    function foo(uint a) public returns(uint){\n        x = foo;\n        y.push(foo);\n    }\n}\n</code></pre> Source code in <code>wake/ir/type_names/function_type_name.py</code> <pre><code>class FunctionTypeName(TypeNameAbc):\n    \"\"\"\n    Function type name.\n\n    !!! example\n        A function type name (`:::solidity function (uint) returns(uint)`) can be used:\n\n        - inside a [VariableDeclaration][wake.ir.declarations.variable_declaration.VariableDeclaration] (lines 1 and 8),\n        - inside a [UsingForDirective][wake.ir.meta.using_for_directive.UsingForDirective] (line 5),\n        - inside a [ArrayTypeName][wake.ir.type_names.array_type_name.ArrayTypeName] (line 9),\n        - inside a [Mapping][wake.ir.type_names.mapping.Mapping] (line 11).\n\n        ```solidity linenums=\"1\"\n        function test(function (uint) returns(uint) f) {\n            f(10);\n        }\n\n        using {test} for function (uint) returns(uint);\n\n        contract X {\n            function (uint) returns(uint) x;\n            function (uint) returns(uint)[] y;\n\n            mapping(uint =&gt; function (uint) returns(uint)) map;\n\n            function foo(uint a) public returns(uint){\n                x = foo;\n                y.push(foo);\n            }\n        }\n        ```\n    \"\"\"\n\n    _ast_node: SolcFunctionTypeName\n    _parent: Union[VariableDeclaration, UsingForDirective, ArrayTypeName, Mapping]\n\n    _parameter_types: ParameterList\n    _return_parameter_types: ParameterList\n    _state_mutability: StateMutability\n    _visibility: Visibility\n\n    def __init__(\n        self,\n        init: IrInitTuple,\n        function_type_name: SolcFunctionTypeName,\n        parent: SolidityAbc,\n    ):\n        super().__init__(init, function_type_name, parent)\n        self._parameter_types = ParameterList(\n            init, function_type_name.parameter_types, self\n        )\n        self._return_parameter_types = ParameterList(\n            init, function_type_name.return_parameter_types, self\n        )\n        self._state_mutability = function_type_name.state_mutability\n        self._visibility = function_type_name.visibility\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        yield from self._parameter_types\n        yield from self._return_parameter_types\n\n    @property\n    def parent(\n        self,\n    ) -&gt; Union[VariableDeclaration, UsingForDirective, ArrayTypeName, Mapping]:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def type(self) -&gt; Function:\n        \"\"\"\n        Returns:\n            Type description.\n        \"\"\"\n        t = super().type\n        assert isinstance(t, Function)\n        return t\n\n    @property\n    def parameter_types(self) -&gt; ParameterList:\n        \"\"\"\n        Returns:\n            Parameter list describing the function type name parameters.\n        \"\"\"\n        return self._parameter_types\n\n    @property\n    def return_parameter_types(self) -&gt; ParameterList:\n        \"\"\"\n        Returns:\n            Parameter list describing the function type name return parameters.\n        \"\"\"\n        return self._return_parameter_types\n\n    @property\n    def state_mutability(self) -&gt; StateMutability:\n        \"\"\"\n        Returns:\n            State mutability of the function type name.\n        \"\"\"\n        return self._state_mutability\n\n    @property\n    def visibility(self) -&gt; Visibility:\n        \"\"\"\n        Returns:\n            Visibility of the function type name.\n        \"\"\"\n        return self._visibility\n</code></pre>"},{"location":"api-reference/ir/type-names/function-type-name/#wake.ir.type_names.function_type_name.FunctionTypeName.parameter_types","title":"<code>parameter_types: ParameterList</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>ParameterList</code> <p>Parameter list describing the function type name parameters.</p>"},{"location":"api-reference/ir/type-names/function-type-name/#wake.ir.type_names.function_type_name.FunctionTypeName.parent","title":"<code>parent: Union[VariableDeclaration, UsingForDirective, ArrayTypeName, Mapping]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[VariableDeclaration, UsingForDirective, ArrayTypeName, Mapping]</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/type-names/function-type-name/#wake.ir.type_names.function_type_name.FunctionTypeName.return_parameter_types","title":"<code>return_parameter_types: ParameterList</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>ParameterList</code> <p>Parameter list describing the function type name return parameters.</p>"},{"location":"api-reference/ir/type-names/function-type-name/#wake.ir.type_names.function_type_name.FunctionTypeName.state_mutability","title":"<code>state_mutability: StateMutability</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>StateMutability</code> <p>State mutability of the function type name.</p>"},{"location":"api-reference/ir/type-names/function-type-name/#wake.ir.type_names.function_type_name.FunctionTypeName.type","title":"<code>type: Function</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Function</code> <p>Type description.</p>"},{"location":"api-reference/ir/type-names/function-type-name/#wake.ir.type_names.function_type_name.FunctionTypeName.visibility","title":"<code>visibility: Visibility</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Visibility</code> <p>Visibility of the function type name.</p>"},{"location":"api-reference/ir/type-names/mapping/","title":"mapping","text":""},{"location":"api-reference/ir/type-names/mapping/#wake.ir.type_names.mapping","title":"<code>wake.ir.type_names.mapping</code>  <code>module</code>","text":""},{"location":"api-reference/ir/type-names/mapping/#wake.ir.type_names.mapping.Mapping","title":"<code>Mapping</code>  <code>class</code>","text":"<p>         Bases: <code>TypeNameAbc</code></p> <p>Mapping type name.</p> <p>Example</p> <p>A mapping type name can be used:</p> <ul> <li>inside a VariableDeclaration:<ul> <li><code>mapping(address =&gt; uint)</code> on line 1,</li> <li><code>mapping(address =&gt; mapping(address =&gt; uint))</code> on line 8,</li> </ul> </li> <li>inside a UsingForDirective:<ul> <li><code>mapping(address =&gt; uint)</code> on line 5,</li> </ul> </li> <li>inside an ArrayTypeName:<ul> <li><code>mapping(address =&gt; uint)</code> on line 9,</li> </ul> </li> <li>inside a Mapping:<ul> <li><code>mapping(address =&gt; uint)</code> on line 8.</li> </ul> </li> </ul> <pre><code>function remove(mapping(address =&gt; uint) storage balances, address account) {\n    delete balances[account];\n}\n\nusing {remove} for mapping(address =&gt; uint);\n\ncontract C {\n    mapping(address =&gt; mapping(address =&gt; uint)) public allowances;\n    mapping(address =&gt; uint)[2] public balances;\n}\n</code></pre> Source code in <code>wake/ir/type_names/mapping.py</code> <pre><code>class Mapping(TypeNameAbc):\n    \"\"\"\n    Mapping type name.\n\n    !!! example\n        A mapping type name can be used:\n\n        - inside a [VariableDeclaration][wake.ir.declarations.variable_declaration.VariableDeclaration]:\n            - `:::solidity mapping(address =&gt; uint)` on line 1,\n            - `:::solidity mapping(address =&gt; mapping(address =&gt; uint))` on line 8,\n        - inside a [UsingForDirective][wake.ir.meta.using_for_directive.UsingForDirective]:\n            - `:::solidity mapping(address =&gt; uint)` on line 5,\n        - inside an [ArrayTypeName][wake.ir.type_names.array_type_name.ArrayTypeName]:\n            - `:::solidity mapping(address =&gt; uint)` on line 9,\n        - inside a [Mapping][wake.ir.type_names.mapping.Mapping]:\n            - `:::solidity mapping(address =&gt; uint)` on line 8.\n\n        ```solidity linenums=\"1\"\n        function remove(mapping(address =&gt; uint) storage balances, address account) {\n            delete balances[account];\n        }\n\n        using {remove} for mapping(address =&gt; uint);\n\n        contract C {\n            mapping(address =&gt; mapping(address =&gt; uint)) public allowances;\n            mapping(address =&gt; uint)[2] public balances;\n        }\n        ```\n    \"\"\"\n\n    _ast_node: SolcMapping\n    _parent: Union[VariableDeclaration, UsingForDirective, ArrayTypeName, Mapping]\n\n    _key_type: Union[ElementaryTypeName, UserDefinedTypeName]\n    _value_type: TypeNameAbc\n    _key_name: Optional[str]\n    _key_name_location: Optional[Tuple[int, int]]\n    _value_name: Optional[str]\n    _value_name_location: Optional[Tuple[int, int]]\n\n    def __init__(self, init: IrInitTuple, mapping: SolcMapping, parent: SolidityAbc):\n        super().__init__(init, mapping, parent)\n        key_type = TypeNameAbc.from_ast(init, mapping.key_type, self)\n        assert isinstance(key_type, (ElementaryTypeName, UserDefinedTypeName))\n        self._key_type = key_type\n        self._value_type = TypeNameAbc.from_ast(init, mapping.value_type, self)\n\n        self._key_name = mapping.key_name\n        if mapping.key_name_location is not None:\n            self._key_name_location = (\n                mapping.key_name_location.byte_offset,\n                mapping.key_name_location.byte_offset\n                + mapping.key_name_location.byte_length,\n            )\n        else:\n            self._key_name_location = None\n\n        self._value_name = mapping.value_name\n        if mapping.value_name_location is not None:\n            self._value_name_location = (\n                mapping.value_name_location.byte_offset,\n                mapping.value_name_location.byte_offset\n                + mapping.value_name_location.byte_length,\n            )\n        else:\n            self._value_name_location = None\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        yield from self._key_type\n        yield from self._value_type\n\n    @property\n    def parent(\n        self,\n    ) -&gt; Union[VariableDeclaration, UsingForDirective, ArrayTypeName, Mapping]:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def type(self) -&gt; types.Mapping:\n        \"\"\"\n        Returns:\n            Type description.\n        \"\"\"\n        t = super().type\n        assert isinstance(t, types.Mapping)\n        return t\n\n    @property\n    def key_type(self) -&gt; Union[ElementaryTypeName, UserDefinedTypeName]:\n        \"\"\"\n        Can only be:\n\n        - an [ElementaryTypeName][wake.ir.type_names.elementary_type_name.ElementaryTypeName],\n        - a [UserDefinedTypeName][wake.ir.type_names.user_defined_type_name.UserDefinedTypeName] of a [Contract][wake.ir.types.Contract] type,\n        - a [UserDefinedTypeName][wake.ir.type_names.user_defined_type_name.UserDefinedTypeName] of an [Enum][wake.ir.types.Enum] type,\n        - a [UserDefinedTypeName][wake.ir.type_names.user_defined_type_name.UserDefinedTypeName] of a [UserDefinedValueType][wake.ir.types.UserDefinedValueType] type.\n\n        Returns:\n            Mapping key type name.\n        \"\"\"\n        return self._key_type\n\n    @property\n    def value_type(self) -&gt; TypeNameAbc:\n        \"\"\"\n        Returns:\n            Mapping value type name.\n        \"\"\"\n        return self._value_type\n\n    @property\n    def key_name(self) -&gt; Optional[str]:\n        \"\"\"\n        !!! note\n            Mapping key names were introduced in Solidity 0.8.18.\n\n        !!! example\n            Returns `account` in the following code:\n\n            ```solidity\n            mapping(address account =&gt; uint balance) public balances;\n            ```\n\n        Returns:\n            Mapping key name, if present.\n        \"\"\"\n        return self._key_name\n\n    @property\n    def key_name_location(self) -&gt; Optional[Tuple[int, int]]:\n        \"\"\"\n        !!! note\n            Mapping key names were introduced in Solidity 0.8.18.\n\n        Returns:\n            Tuple of the start and end byte offsets of the [key_name][wake.ir.type_names.mapping.Mapping.key_name] in the source code, if present.\n        \"\"\"\n        return self._key_name_location\n\n    @property\n    def value_name(self) -&gt; Optional[str]:\n        \"\"\"\n        !!! note\n            Mapping value names were introduced in Solidity 0.8.18.\n\n        !!! example\n            Returns `balance` in the following code:\n\n            ```solidity\n            mapping(address account =&gt; uint balance) public balances;\n            ```\n\n        Returns:\n            Mapping value name, if present.\n        \"\"\"\n        return self._value_name\n\n    @property\n    def value_name_location(self) -&gt; Optional[Tuple[int, int]]:\n        \"\"\"\n        !!! note\n            Mapping value names were introduced in Solidity 0.8.18.\n\n        Returns:\n            Tuple of the start and end byte offsets of the [value_name][wake.ir.type_names.mapping.Mapping.value_name] in the source code, if present.\n        \"\"\"\n        return self._value_name_location\n</code></pre>"},{"location":"api-reference/ir/type-names/mapping/#wake.ir.type_names.mapping.Mapping.key_name","title":"<code>key_name: Optional[str]</code>  <code>property</code>","text":"<p>Note</p> <p>Mapping key names were introduced in Solidity 0.8.18.</p> <p>Example</p> <p>Returns <code>account</code> in the following code:</p> <pre><code>mapping(address account =&gt; uint balance) public balances;\n</code></pre> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Mapping key name, if present.</p>"},{"location":"api-reference/ir/type-names/mapping/#wake.ir.type_names.mapping.Mapping.key_name_location","title":"<code>key_name_location: Optional[Tuple[int, int]]</code>  <code>property</code>","text":"<p>Note</p> <p>Mapping key names were introduced in Solidity 0.8.18.</p> <p>Returns:</p> Type Description <code>Optional[Tuple[int, int]]</code> <p>Tuple of the start and end byte offsets of the key_name in the source code, if present.</p>"},{"location":"api-reference/ir/type-names/mapping/#wake.ir.type_names.mapping.Mapping.key_type","title":"<code>key_type: Union[ElementaryTypeName, UserDefinedTypeName]</code>  <code>property</code>","text":"<p>Can only be:</p> <ul> <li>an ElementaryTypeName,</li> <li>a UserDefinedTypeName of a Contract type,</li> <li>a UserDefinedTypeName of an Enum type,</li> <li>a UserDefinedTypeName of a UserDefinedValueType type.</li> </ul> <p>Returns:</p> Type Description <code>Union[ElementaryTypeName, UserDefinedTypeName]</code> <p>Mapping key type name.</p>"},{"location":"api-reference/ir/type-names/mapping/#wake.ir.type_names.mapping.Mapping.parent","title":"<code>parent: Union[VariableDeclaration, UsingForDirective, ArrayTypeName, Mapping]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[VariableDeclaration, UsingForDirective, ArrayTypeName, Mapping]</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/type-names/mapping/#wake.ir.type_names.mapping.Mapping.type","title":"<code>type: types.Mapping</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Mapping</code> <p>Type description.</p>"},{"location":"api-reference/ir/type-names/mapping/#wake.ir.type_names.mapping.Mapping.value_name","title":"<code>value_name: Optional[str]</code>  <code>property</code>","text":"<p>Note</p> <p>Mapping value names were introduced in Solidity 0.8.18.</p> <p>Example</p> <p>Returns <code>balance</code> in the following code:</p> <pre><code>mapping(address account =&gt; uint balance) public balances;\n</code></pre> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Mapping value name, if present.</p>"},{"location":"api-reference/ir/type-names/mapping/#wake.ir.type_names.mapping.Mapping.value_name_location","title":"<code>value_name_location: Optional[Tuple[int, int]]</code>  <code>property</code>","text":"<p>Note</p> <p>Mapping value names were introduced in Solidity 0.8.18.</p> <p>Returns:</p> Type Description <code>Optional[Tuple[int, int]]</code> <p>Tuple of the start and end byte offsets of the value_name in the source code, if present.</p>"},{"location":"api-reference/ir/type-names/mapping/#wake.ir.type_names.mapping.Mapping.value_type","title":"<code>value_type: TypeNameAbc</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>TypeNameAbc</code> <p>Mapping value type name.</p>"},{"location":"api-reference/ir/type-names/user-defined-type-name/","title":"user_defined_type_name","text":""},{"location":"api-reference/ir/type-names/user-defined-type-name/#wake.ir.type_names.user_defined_type_name","title":"<code>wake.ir.type_names.user_defined_type_name</code>  <code>module</code>","text":""},{"location":"api-reference/ir/type-names/user-defined-type-name/#wake.ir.type_names.user_defined_type_name.UserDefinedTypeName","title":"<code>UserDefinedTypeName</code>  <code>class</code>","text":"<p>         Bases: <code>TypeNameAbc</code></p> <p>User defined type name represents a name path to a user defined type. Path parts are separated by dots. In Solidity 0.8.0 a new IR node (IdentifierPath) was introduced to replace UserDefinedTypeName in some cases.</p> <p>Example</p> <p>A user defined type name can be used:</p> <ul> <li>inside a VariableDeclaration:<ul> <li><code>Interface.Struct</code> on line 18,</li> <li><code>Interface.Enum</code> on line 26,</li> </ul> </li> <li>inside a NewExpression:<ul> <li><code>Contract</code> on line 20,</li> </ul> </li> <li>inside an InheritanceSpecifier:<ul> <li><code>Interface</code> on line 23,</li> </ul> </li> <li>inside an OverrideSpecifier:<ul> <li><code>Interface</code> on line 30,</li> </ul> </li> <li>inside a UsingForDirective:<ul> <li><code>Lib</code> on line 24,</li> <li><code>Interface.Struct</code> on line 24,</li> </ul> </li> <li>inside an ArrayTypeName:<ul> <li><code>Interface.Enum</code> on line 27,</li> </ul> </li> <li>inside a Mapping:<ul> <li>both occurrences of <code>Interface.Enum</code> on line 28.</li> </ul> </li> </ul> <pre><code>pragma solidity 0.7;\n\ninterface Interface {\n    enum Enum {\n        READY,\n        WAITING\n    }\n\n    struct Struct {\n        uint a;\n    }\n\n    function foo() external;\n}\n\nlibrary Lib {}\n\nfunction tmp(Interface.Struct memory s) {\n    s.a = 5;\n    new Contract();\n}\n\ncontract Contract is Interface {\n    using Lib for Interface.Struct;\n\n    Interface.Enum state;\n    Interface.Enum[] states;\n    mapping(Interface.Enum =&gt; Interface.Enum) map;\n\n    function foo() external override(Interface) {\n    }\n}\n</code></pre> Source code in <code>wake/ir/type_names/user_defined_type_name.py</code> <pre><code>class UserDefinedTypeName(TypeNameAbc):\n    \"\"\"\n    User defined type name represents a name path to a user defined type. Path parts are separated by dots.\n    In Solidity 0.8.0 a new IR node ([IdentifierPath][wake.ir.meta.identifier_path.IdentifierPath]) was introduced to replace [UserDefinedTypeName][wake.ir.type_names.user_defined_type_name.UserDefinedTypeName] in some cases.\n\n    !!! example\n        A user defined type name can be used:\n\n        - inside a [VariableDeclaration][wake.ir.declarations.variable_declaration.VariableDeclaration]:\n            - `:::solidity Interface.Struct` on line 18,\n            - `:::solidity Interface.Enum` on line 26,\n        - inside a [NewExpression][wake.ir.expressions.new_expression.NewExpression]:\n            - `:::solidity Contract` on line 20,\n        - inside an [InheritanceSpecifier][wake.ir.meta.inheritance_specifier.InheritanceSpecifier]:\n            - `:::solidity Interface` on line 23,\n        - inside an [OverrideSpecifier][wake.ir.meta.override_specifier.OverrideSpecifier]:\n            - `:::solidity Interface` on line 30,\n        - inside a [UsingForDirective][wake.ir.meta.using_for_directive.UsingForDirective]:\n            - `:::solidity Lib` on line 24,\n            - `:::solidity Interface.Struct` on line 24,\n        - inside an [ArrayTypeName][wake.ir.type_names.array_type_name.ArrayTypeName]:\n            - `:::solidity Interface.Enum` on line 27,\n        - inside a [Mapping][wake.ir.type_names.mapping.Mapping]:\n            - both occurrences of `:::solidity Interface.Enum` on line 28.\n\n        ```solidity linenums=\"1\"\n        pragma solidity 0.7;\n\n        interface Interface {\n            enum Enum {\n                READY,\n                WAITING\n            }\n\n            struct Struct {\n                uint a;\n            }\n\n            function foo() external;\n        }\n\n        library Lib {}\n\n        function tmp(Interface.Struct memory s) {\n            s.a = 5;\n            new Contract();\n        }\n\n        contract Contract is Interface {\n            using Lib for Interface.Struct;\n\n            Interface.Enum state;\n            Interface.Enum[] states;\n            mapping(Interface.Enum =&gt; Interface.Enum) map;\n\n            function foo() external override(Interface) {\n            }\n        }\n        ```\n    \"\"\"\n\n    _ast_node: SolcUserDefinedTypeName\n    _parent: Union[\n        VariableDeclaration,\n        NewExpression,\n        InheritanceSpecifier,\n        OverrideSpecifier,\n        UsingForDirective,\n        ArrayTypeName,\n        Mapping,\n    ]\n\n    _referenced_declaration_id: AstNodeId\n    _contract_scope_id: Optional[AstNodeId]\n    _name: Optional[str]\n    _path_node: Optional[IdentifierPath]\n    _parts: Optional[IntervalTree]\n\n    def __init__(\n        self,\n        init: IrInitTuple,\n        user_defined_type_name: SolcUserDefinedTypeName,\n        parent: SolidityAbc,\n    ):\n        super().__init__(init, user_defined_type_name, parent)\n        self._name = user_defined_type_name.name\n        self._referenced_declaration_id = user_defined_type_name.referenced_declaration\n        assert self._referenced_declaration_id &gt;= 0\n        self._contract_scope_id = user_defined_type_name.contract_scope\n\n        if user_defined_type_name.path_node is None:\n            self._path_node = None\n            self._reference_resolver.register_post_process_callback(self._post_process)\n        else:\n            self._path_node = IdentifierPath(\n                init, user_defined_type_name.path_node, self\n            )\n            self._parts = None\n\n    def _post_process(self, callback_params: CallbackParams):\n        def find_referenced_source_unit(\n            searched_name: str, start_source_unit: SourceUnit\n        ) -&gt; SourceUnit:\n            source_units_queue: Deque[SourceUnit] = deque([start_source_unit])\n            processed_source_units: Set[Path] = {start_source_unit.file}\n            referenced_declaration = None\n\n            while source_units_queue and referenced_declaration is None:\n                source_unit = source_units_queue.popleft()\n\n                for import_ in source_unit.imports:\n                    if import_.unit_alias == searched_name:\n                        referenced_declaration = callback_params.source_units[\n                            import_.imported_file\n                        ]\n                        break\n                    for symbol_alias in import_.symbol_aliases:\n                        if symbol_alias.local == searched_name:\n                            ref = symbol_alias.foreign.referenced_declaration\n                            assert isinstance(ref, SourceUnit)\n                            referenced_declaration = ref\n\n                    if referenced_declaration is not None:\n                        break\n\n                    if import_.imported_file not in processed_source_units:\n                        source_units_queue.append(\n                            callback_params.source_units[import_.imported_file]\n                        )\n                        processed_source_units.add(import_.imported_file)\n\n            assert referenced_declaration is not None\n            return referenced_declaration\n\n        from ..meta.source_unit import SourceUnit\n\n        source = bytearray(self._source)\n        _, stripped_sums = SoliditySourceParser.strip_comments(source)\n\n        matches = list(IDENTIFIER_RE.finditer(source))\n        groups_count = len(matches)\n        assert groups_count &gt; 0\n\n        self._parts = IntervalTree()\n        start_source_unit = callback_params.source_units[self.source_unit.file]\n\n        ref = self.referenced_declaration\n        refs = []\n        for _ in range(groups_count):\n            refs.append(ref)\n            if ref is not None:\n                ref = ref.parent\n\n        for match, ref in zip(matches, reversed(refs)):\n            name = match.group(0).decode(\"utf-8\")\n\n            if ref is None:\n                start_source_unit = find_referenced_source_unit(name, start_source_unit)\n                referenced_node = start_source_unit\n            elif isinstance(ref, (DeclarationAbc, SourceUnit)):\n                referenced_node = ref\n            else:\n                raise TypeError(\n                    f\"Unexpected type of referenced declaration: {type(ref)}\"\n                )\n\n            node_path_order = self._reference_resolver.get_node_path_order(\n                AstNodeId(referenced_node.ast_node_id),\n                referenced_node.source_unit.cu_hash,\n            )\n            referenced_node_id = (\n                self._reference_resolver.get_ast_id_from_cu_node_path_order(\n                    node_path_order, self.source_unit.cu_hash\n                )\n            )\n\n            if len(stripped_sums) == 0:\n                stripped = 0\n            else:\n                index = bisect([s[0] for s in stripped_sums], match.start())\n                if index == 0:\n                    stripped = 0\n                else:\n                    stripped = stripped_sums[index - 1][1]\n\n            start = self.byte_location[0] + match.start() + stripped\n            end = self.byte_location[0] + match.end() + stripped\n            self._parts[start:end] = IdentifierPathPart(\n                self,\n                (start, end),\n                name,\n                referenced_node_id,\n                self._reference_resolver,\n                self.source_unit,\n            )\n\n    def __iter__(self) -&gt; Iterator[IrAbc]:\n        yield self\n        if self._path_node is not None:\n            yield from self._path_node\n\n    @property\n    def parent(\n        self,\n    ) -&gt; Union[\n        VariableDeclaration,\n        NewExpression,\n        InheritanceSpecifier,\n        OverrideSpecifier,\n        UsingForDirective,\n        ArrayTypeName,\n        Mapping,\n    ]:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def type(self) -&gt; Union[Contract, Struct, Enum, UserDefinedValueType]:\n        \"\"\"\n        Returns:\n            Type description.\n        \"\"\"\n        t = super().type\n        assert isinstance(t, (Contract, Struct, Enum, UserDefinedValueType))\n        return t\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"\n        !!! note\n            Should be the same as [source][wake.ir.abc.IrAbc.source] and is the same as [path_node.name][wake.ir.meta.identifier_path.IdentifierPath.name] if [path_node][wake.ir.type_names.user_defined_type_name.UserDefinedTypeName.path_node] is not `None`.\n\n        Returns:\n            Name of the user defined type as it appears in the source code.\n        \"\"\"\n        if self._name is None:\n            assert self._path_node is not None\n            self._name = self._path_node.name\n        return self._name\n\n    @property\n    def identifier_path_parts(self) -&gt; Tuple[IdentifierPathPart, ...]:\n        \"\"\"\n        Returns:\n            Parts of the user defined type name.\n        \"\"\"\n        if self._path_node is not None:\n            return self._path_node.identifier_path_parts\n\n        assert self._parts is not None\n        return tuple(\n            interval.data  # pyright: ignore reportGeneralTypeIssues\n            for interval in sorted(self._parts)\n        )\n\n    def identifier_path_part_at(self, byte_offset: int) -&gt; Optional[IdentifierPathPart]:\n        \"\"\"\n        Args:\n            byte_offset: Byte offset in the source file.\n\n        Returns:\n            Identifier path part at the given byte offset, if any.\n        \"\"\"\n        if self._path_node is not None:\n            return self._path_node.identifier_path_part_at(byte_offset)\n\n        assert self._parts is not None\n        intervals = self._parts.at(byte_offset)\n        assert len(intervals) &lt;= 1\n        if len(intervals) == 0:\n            return None\n        return intervals.pop().data\n\n    @property\n    def referenced_declaration(self) -&gt; DeclarationAbc:\n        \"\"\"\n        Returns:\n            Declaration IR node referenced by this user defined type name.\n        \"\"\"\n        node = self._reference_resolver.resolve_node(\n            self._referenced_declaration_id, self.source_unit.cu_hash\n        )\n        assert isinstance(node, DeclarationAbc)\n        return node\n\n    @property\n    def path_node(self) -&gt; Optional[IdentifierPath]:\n        \"\"\"\n        Always present since Solidity 0.8.0. If not `None`, it represents the same source code as this node ([byte_location][wake.ir.abc.IrAbc.byte_location] properties are the same) and references the same declaration.\n\n        Returns:\n            Identifier path IR node.\n        \"\"\"\n        return self._path_node\n</code></pre>"},{"location":"api-reference/ir/type-names/user-defined-type-name/#wake.ir.type_names.user_defined_type_name.UserDefinedTypeName.identifier_path_parts","title":"<code>identifier_path_parts: Tuple[IdentifierPathPart, ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[IdentifierPathPart, ...]</code> <p>Parts of the user defined type name.</p>"},{"location":"api-reference/ir/type-names/user-defined-type-name/#wake.ir.type_names.user_defined_type_name.UserDefinedTypeName.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Note</p> <p>Should be the same as source and is the same as path_node.name if path_node is not <code>None</code>.</p> <p>Returns:</p> Type Description <code>str</code> <p>Name of the user defined type as it appears in the source code.</p>"},{"location":"api-reference/ir/type-names/user-defined-type-name/#wake.ir.type_names.user_defined_type_name.UserDefinedTypeName.parent","title":"<code>parent: Union[VariableDeclaration, NewExpression, InheritanceSpecifier, OverrideSpecifier, UsingForDirective, ArrayTypeName, Mapping]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[VariableDeclaration, NewExpression, InheritanceSpecifier, OverrideSpecifier, UsingForDirective, ArrayTypeName, Mapping]</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/type-names/user-defined-type-name/#wake.ir.type_names.user_defined_type_name.UserDefinedTypeName.path_node","title":"<code>path_node: Optional[IdentifierPath]</code>  <code>property</code>","text":"<p>Always present since Solidity 0.8.0. If not <code>None</code>, it represents the same source code as this node (byte_location properties are the same) and references the same declaration.</p> <p>Returns:</p> Type Description <code>Optional[IdentifierPath]</code> <p>Identifier path IR node.</p>"},{"location":"api-reference/ir/type-names/user-defined-type-name/#wake.ir.type_names.user_defined_type_name.UserDefinedTypeName.referenced_declaration","title":"<code>referenced_declaration: DeclarationAbc</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>DeclarationAbc</code> <p>Declaration IR node referenced by this user defined type name.</p>"},{"location":"api-reference/ir/type-names/user-defined-type-name/#wake.ir.type_names.user_defined_type_name.UserDefinedTypeName.type","title":"<code>type: Union[Contract, Struct, Enum, UserDefinedValueType]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[Contract, Struct, Enum, UserDefinedValueType]</code> <p>Type description.</p>"},{"location":"api-reference/ir/type-names/user-defined-type-name/#wake.ir.type_names.user_defined_type_name.UserDefinedTypeName.identifier_path_part_at","title":"<code>identifier_path_part_at(byte_offset)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>byte_offset</code> <code>int</code> <p>Byte offset in the source file.</p> required <p>Returns:</p> Type Description <code>Optional[IdentifierPathPart]</code> <p>Identifier path part at the given byte offset, if any.</p> Source code in <code>wake/ir/type_names/user_defined_type_name.py</code> <pre><code>def identifier_path_part_at(self, byte_offset: int) -&gt; Optional[IdentifierPathPart]:\n    \"\"\"\n    Args:\n        byte_offset: Byte offset in the source file.\n\n    Returns:\n        Identifier path part at the given byte offset, if any.\n    \"\"\"\n    if self._path_node is not None:\n        return self._path_node.identifier_path_part_at(byte_offset)\n\n    assert self._parts is not None\n    intervals = self._parts.at(byte_offset)\n    assert len(intervals) &lt;= 1\n    if len(intervals) == 0:\n        return None\n    return intervals.pop().data\n</code></pre>"},{"location":"api-reference/ir/yul/abc/","title":"abc","text":""},{"location":"api-reference/ir/yul/abc/#wake.ir.yul.abc","title":"<code>wake.ir.yul.abc</code>  <code>module</code>","text":""},{"location":"api-reference/ir/yul/abc/#wake.ir.yul.abc.YulAbc","title":"<code>YulAbc</code>  <code>class</code>","text":"<p>         Bases: <code>IrAbc</code>, <code>ABC</code></p> <p>Abstract base class for all Yul IR nodes.</p> Source code in <code>wake/ir/yul/abc.py</code> <pre><code>class YulAbc(IrAbc, ABC):\n    \"\"\"\n    Abstract base class for all Yul IR nodes.\n    \"\"\"\n\n    _ast_node: YulNode\n    _inline_assembly: InlineAssembly\n\n    def __init__(self, init: IrInitTuple, yul: YulNode, parent: IrAbc):\n        super().__init__(init, yul, parent)\n        assert init.inline_assembly is not None\n        self._inline_assembly = init.inline_assembly\n\n    def __iter__(self) -&gt; Iterator[YulAbc]:\n        yield self\n\n    @property\n    def ast_node(self) -&gt; YulNode:\n        return self._ast_node\n\n    @property\n    @abstractmethod\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        \"\"\"\n        WARNING:\n            Is not considered stable and so is not exported in the documentation.\n\n        Returns:\n            Set of child IR nodes (including `self`) that modify the blockchain state and flags describing how the state is modified.\n        \"\"\"\n        ...\n\n    @property\n    def inline_assembly(self) -&gt; InlineAssembly:\n        \"\"\"\n        Returns:\n            Inline assembly statement that contains this Yul node.\n        \"\"\"\n        return self._inline_assembly\n</code></pre>"},{"location":"api-reference/ir/yul/abc/#wake.ir.yul.abc.YulAbc.inline_assembly","title":"<code>inline_assembly: InlineAssembly</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>InlineAssembly</code> <p>Inline assembly statement that contains this Yul node.</p>"},{"location":"api-reference/ir/yul/abc/#wake.ir.yul.abc.YulAbc.modifies_state","title":"<code>modifies_state: Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]</code>  <code>abstractmethod</code> <code>property</code>","text":"WARNING <p>Is not considered stable and so is not exported in the documentation.</p> <p>Returns:</p> Type Description <code>Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]</code> <p>Set of child IR nodes (including <code>self</code>) that modify the blockchain state and flags describing how the state is modified.</p>"},{"location":"api-reference/ir/yul/abc/#wake.ir.yul.abc.YulStatementAbc","title":"<code>YulStatementAbc</code>  <code>class</code>","text":"<p>         Bases: <code>YulAbc</code>, <code>ABC</code></p> <p>Abstract base class for all Yul IR statements.</p> Source code in <code>wake/ir/yul/abc.py</code> <pre><code>class YulStatementAbc(YulAbc, ABC):\n    \"\"\"\n    Abstract base class for all Yul IR statements.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/ir/yul/assignment/","title":"assignment","text":""},{"location":"api-reference/ir/yul/assignment/#wake.ir.yul.assignment","title":"<code>wake.ir.yul.assignment</code>  <code>module</code>","text":""},{"location":"api-reference/ir/yul/assignment/#wake.ir.yul.assignment.YulAssignment","title":"<code>YulAssignment</code>  <code>class</code>","text":"<p>         Bases: <code>YulStatementAbc</code></p> <p>Important</p> <p>Should not be confused with <code>let a, b := foo()</code> which is a YulVariableDeclaration.</p> <p>Example</p> <p><code>a, b := foo()</code> in the following example:</p> <pre><code>uint a;\nuint b;\nassembly {\n    function foo() -&gt; x, y {\n        x := 1\n        y := 2\n    }\n    a, b := foo()\n}\n</code></pre> Source code in <code>wake/ir/yul/assignment.py</code> <pre><code>class YulAssignment(YulStatementAbc):\n    \"\"\"\n    !!! important\n        Should not be confused with `:::solidity let a, b := foo()` which is a [YulVariableDeclaration][wake.ir.yul.variable_declaration.YulVariableDeclaration].\n\n    !!! example\n        `:::solidity a, b := foo()` in the following example:\n\n        ```solidity\n        uint a;\n        uint b;\n        assembly {\n            function foo() -&gt; x, y {\n                x := 1\n                y := 2\n            }\n            a, b := foo()\n        }\n        ```\n    \"\"\"\n\n    _parent: YulBlock\n    _value: Union[YulFunctionCall, YulIdentifier, YulLiteral]\n    _variable_names: List[YulIdentifier]\n\n    def __init__(\n        self, init: IrInitTuple, assignment: SolcYulAssignment, parent: YulAbc\n    ):\n        super().__init__(init, assignment, parent)\n        if isinstance(assignment.value, SolcYulFunctionCall):\n            self._value = YulFunctionCall(init, assignment.value, self)\n        elif isinstance(assignment.value, SolcYulIdentifier):\n            self._value = YulIdentifier(init, assignment.value, self)\n        elif isinstance(assignment.value, SolcYulLiteral):\n            self._value = YulLiteral(init, assignment.value, self)\n        else:\n            assert False, f\"Unexpected type: {type(assignment.value)}\"\n        self._variable_names = [\n            YulIdentifier(init, variable_name, self)\n            for variable_name in assignment.variable_names\n        ]\n\n    def __iter__(self) -&gt; Iterator[YulAbc]:\n        yield self\n        yield from self._value\n        for variable_name in self._variable_names:\n            yield from variable_name\n\n    @property\n    def parent(self) -&gt; YulBlock:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def value(self) -&gt; Union[YulFunctionCall, YulIdentifier, YulLiteral]:\n        \"\"\"\n        Returns:\n            Value that is assigned to the variables.\n        \"\"\"\n        return self._value\n\n    @property\n    def variable_names(self) -&gt; Tuple[YulIdentifier, ...]:\n        \"\"\"\n        Returns:\n            Identifiers of variables that are assigned to in the order they appear in the source code.\n        \"\"\"\n        return tuple(self._variable_names)\n\n    @property\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        return self._value.modifies_state\n</code></pre>"},{"location":"api-reference/ir/yul/assignment/#wake.ir.yul.assignment.YulAssignment.parent","title":"<code>parent: YulBlock</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>YulBlock</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/yul/assignment/#wake.ir.yul.assignment.YulAssignment.value","title":"<code>value: Union[YulFunctionCall, YulIdentifier, YulLiteral]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[YulFunctionCall, YulIdentifier, YulLiteral]</code> <p>Value that is assigned to the variables.</p>"},{"location":"api-reference/ir/yul/assignment/#wake.ir.yul.assignment.YulAssignment.variable_names","title":"<code>variable_names: Tuple[YulIdentifier, ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[YulIdentifier, ...]</code> <p>Identifiers of variables that are assigned to in the order they appear in the source code.</p>"},{"location":"api-reference/ir/yul/block/","title":"block","text":""},{"location":"api-reference/ir/yul/block/#wake.ir.yul.block","title":"<code>wake.ir.yul.block</code>  <code>module</code>","text":""},{"location":"api-reference/ir/yul/block/#wake.ir.yul.block.YulBlock","title":"<code>YulBlock</code>  <code>class</code>","text":"<p>         Bases: <code>YulStatementAbc</code></p> <p>Block statements group multiple statements into a single block.</p> Source code in <code>wake/ir/yul/block.py</code> <pre><code>class YulBlock(YulStatementAbc):\n    \"\"\"\n    Block statements group multiple statements into a single block.\n    \"\"\"\n\n    _parent: Union[\n        InlineAssembly, YulBlock, YulForLoop, YulFunctionDefinition, YulIf, YulCase\n    ]\n    _statements: List[YulStatementAbc]\n\n    def __init__(\n        self,\n        init: IrInitTuple,\n        block: SolcYulBlock,\n        parent: Union[InlineAssembly, YulAbc],\n    ):\n        from .assignment import YulAssignment\n        from .break_statement import YulBreak\n        from .continue_statement import YulContinue\n        from .expression_statement import YulExpressionStatement\n        from .for_loop import YulForLoop\n        from .function_definition import YulFunctionDefinition\n        from .if_statement import YulIf\n        from .leave import YulLeave\n        from .switch import YulSwitch\n        from .variable_declaration import YulVariableDeclaration\n\n        super().__init__(init, block, parent)\n        self._statements = []\n        for statement in block.statements:\n            if isinstance(statement, SolcYulAssignment):\n                self._statements.append(YulAssignment(init, statement, self))\n            elif isinstance(statement, SolcYulBlock):\n                self._statements.append(YulBlock(init, statement, self))\n            elif isinstance(statement, SolcYulBreak):\n                self._statements.append(YulBreak(init, statement, self))\n            elif isinstance(statement, SolcYulContinue):\n                self._statements.append(YulContinue(init, statement, self))\n            elif isinstance(statement, SolcYulExpressionStatement):\n                self._statements.append(YulExpressionStatement(init, statement, self))\n            elif isinstance(statement, SolcYulLeave):\n                self._statements.append(YulLeave(init, statement, self))\n            elif isinstance(statement, SolcYulForLoop):\n                self._statements.append(YulForLoop(init, statement, self))\n            elif isinstance(statement, SolcYulFunctionDefinition):\n                self._statements.append(YulFunctionDefinition(init, statement, self))\n            elif isinstance(statement, SolcYulIf):\n                self._statements.append(YulIf(init, statement, self))\n            elif isinstance(statement, SolcYulSwitch):\n                self._statements.append(YulSwitch(init, statement, self))\n            elif isinstance(statement, SolcYulVariableDeclaration):\n                self._statements.append(YulVariableDeclaration(init, statement, self))\n            else:\n                assert False, f\"Unexpected type: {type(statement)}\"\n\n    def __iter__(self) -&gt; Iterator[YulAbc]:\n        yield self\n        for statement in self._statements:\n            yield from statement\n\n    @property\n    def parent(\n        self,\n    ) -&gt; Union[\n        InlineAssembly, YulBlock, YulForLoop, YulFunctionDefinition, YulIf, YulCase\n    ]:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def statements(\n        self,\n    ) -&gt; Tuple[YulStatementAbc, ...]:\n        \"\"\"\n        Returns:\n            Statements contained in this block.\n        \"\"\"\n        return tuple(self._statements)\n\n    @property\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        return reduce(\n            or_,\n            (statement.modifies_state for statement in self.statements),\n            set(),\n        )\n</code></pre>"},{"location":"api-reference/ir/yul/block/#wake.ir.yul.block.YulBlock.parent","title":"<code>parent: Union[InlineAssembly, YulBlock, YulForLoop, YulFunctionDefinition, YulIf, YulCase]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[InlineAssembly, YulBlock, YulForLoop, YulFunctionDefinition, YulIf, YulCase]</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/yul/block/#wake.ir.yul.block.YulBlock.statements","title":"<code>statements: Tuple[YulStatementAbc, ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[YulStatementAbc, ...]</code> <p>Statements contained in this block.</p>"},{"location":"api-reference/ir/yul/break-statement/","title":"break_statement","text":""},{"location":"api-reference/ir/yul/break-statement/#wake.ir.yul.break_statement","title":"<code>wake.ir.yul.break_statement</code>  <code>module</code>","text":""},{"location":"api-reference/ir/yul/break-statement/#wake.ir.yul.break_statement.YulBreak","title":"<code>YulBreak</code>  <code>class</code>","text":"<p>         Bases: <code>YulStatementAbc</code></p> <p>Break statement can be used in a body of a YulForLoop to exit the loop early.</p> <p>Example</p> <pre><code>assembly {\n    for { let i := 0 } lt(i, 10) { i := add(i, 1) } {\n        // ...\n        break\n    }\n}\n</code></pre> Source code in <code>wake/ir/yul/break_statement.py</code> <pre><code>class YulBreak(YulStatementAbc):\n    \"\"\"\n    Break statement can be used in a body of a [YulForLoop][wake.ir.yul.for_loop.YulForLoop] to exit the loop early.\n\n    !!! example\n        ```solidity\n        assembly {\n            for { let i := 0 } lt(i, 10) { i := add(i, 1) } {\n                // ...\n                break\n            }\n        }\n        ```\n    \"\"\"\n\n    _parent: YulBlock\n\n    @property\n    def parent(self) -&gt; YulBlock:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        return set()\n</code></pre>"},{"location":"api-reference/ir/yul/break-statement/#wake.ir.yul.break_statement.YulBreak.parent","title":"<code>parent: YulBlock</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>YulBlock</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/yul/case/","title":"case","text":""},{"location":"api-reference/ir/yul/case/#wake.ir.yul.case_","title":"<code>wake.ir.yul.case_</code>  <code>module</code>","text":""},{"location":"api-reference/ir/yul/case/#wake.ir.yul.case_.YulCase","title":"<code>YulCase</code>  <code>class</code>","text":"<p>         Bases: <code>YulAbc</code></p> <p>Represents a single case in a YulSwitch statement.</p> <p>Example</p> <p>Lines 4-6, 7-9, and 10-12 in the following example:</p> <pre><code>uint x = foo();\nassembly {\n    switch x\n    case 0 {\n        // ...\n    }\n    case 1 {\n        // ...\n    }\n    default {\n        // ...\n    }\n}\n</code></pre> Source code in <code>wake/ir/yul/case_.py</code> <pre><code>class YulCase(YulAbc):\n    \"\"\"\n    Represents a single case in a [YulSwitch][wake.ir.yul.switch.YulSwitch] statement.\n\n    !!! example\n        Lines 4-6, 7-9, and 10-12 in the following example:\n\n        ```solidity linenums=\"1\"\n        uint x = foo();\n        assembly {\n            switch x\n            case 0 {\n                // ...\n            }\n            case 1 {\n                // ...\n            }\n            default {\n                // ...\n            }\n        }\n        ```\n    \"\"\"\n\n    _parent: YulSwitch\n    _body: YulBlock\n    _value: Union[Literal[\"default\"], YulLiteral]\n\n    def __init__(self, init: IrInitTuple, case_: SolcYulCase, parent: YulAbc):\n        super().__init__(init, case_, parent)\n        self._body = YulBlock(init, case_.body, self)\n        if case_.value == \"default\":\n            self._value = \"default\"\n        else:\n            self._value = YulLiteral(init, case_.value, self)\n\n    def __iter__(self) -&gt; Iterator[YulAbc]:\n        yield self\n        yield from self._body\n        if self._value != \"default\":\n            yield from self._value\n\n    @property\n    def parent(self) -&gt; YulSwitch:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def body(self) -&gt; YulBlock:\n        \"\"\"\n        Returns:\n            Body of the case.\n        \"\"\"\n        return self._body\n\n    @property\n    def value(self) -&gt; Union[Literal[\"default\"], YulLiteral]:\n        \"\"\"\n        May be either a [YulLiteral][wake.ir.yul.literal.YulLiteral] or the string `default`.\n        `default` is used for the default case when neither of the cases match. The default case\n        is optional.\n\n        Returns:\n            Value that is compared to the switch expression.\n        \"\"\"\n        return self._value\n\n    @property\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        return self._body.modifies_state\n</code></pre>"},{"location":"api-reference/ir/yul/case/#wake.ir.yul.case_.YulCase.body","title":"<code>body: YulBlock</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>YulBlock</code> <p>Body of the case.</p>"},{"location":"api-reference/ir/yul/case/#wake.ir.yul.case_.YulCase.parent","title":"<code>parent: YulSwitch</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>YulSwitch</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/yul/case/#wake.ir.yul.case_.YulCase.value","title":"<code>value: Union[Literal['default'], YulLiteral]</code>  <code>property</code>","text":"<p>May be either a YulLiteral or the string <code>default</code>. <code>default</code> is used for the default case when neither of the cases match. The default case is optional.</p> <p>Returns:</p> Type Description <code>Union[Literal['default'], YulLiteral]</code> <p>Value that is compared to the switch expression.</p>"},{"location":"api-reference/ir/yul/continue-statement/","title":"continue_statement","text":""},{"location":"api-reference/ir/yul/continue-statement/#wake.ir.yul.continue_statement","title":"<code>wake.ir.yul.continue_statement</code>  <code>module</code>","text":""},{"location":"api-reference/ir/yul/continue-statement/#wake.ir.yul.continue_statement.YulContinue","title":"<code>YulContinue</code>  <code>class</code>","text":"<p>         Bases: <code>YulStatementAbc</code></p> <p>Continue statement can be used in a body of a YulForLoop to skip the rest of the loop body and continue with the next iteration.</p> <p>Example</p> <pre><code>assembly {\n    for { let i := 0 } lt(i, 10) { i := add(i, 1) } {\n        // ...\n        continue\n    }\n}\n</code></pre> Source code in <code>wake/ir/yul/continue_statement.py</code> <pre><code>class YulContinue(YulStatementAbc):\n    \"\"\"\n    Continue statement can be used in a body of a [YulForLoop][wake.ir.yul.for_loop.YulForLoop] to skip the rest of the loop body and continue with the next iteration.\n\n    !!! example\n        ```solidity\n        assembly {\n            for { let i := 0 } lt(i, 10) { i := add(i, 1) } {\n                // ...\n                continue\n            }\n        }\n        ```\n    \"\"\"\n\n    _parent: YulBlock\n\n    @property\n    def parent(self) -&gt; YulBlock:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        return set()\n</code></pre>"},{"location":"api-reference/ir/yul/continue-statement/#wake.ir.yul.continue_statement.YulContinue.parent","title":"<code>parent: YulBlock</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>YulBlock</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/yul/expression-statement/","title":"expression_statement","text":""},{"location":"api-reference/ir/yul/expression-statement/#wake.ir.yul.expression_statement","title":"<code>wake.ir.yul.expression_statement</code>  <code>module</code>","text":""},{"location":"api-reference/ir/yul/expression-statement/#wake.ir.yul.expression_statement.YulExpressionStatement","title":"<code>YulExpressionStatement</code>  <code>class</code>","text":"<p>         Bases: <code>YulStatementAbc</code></p> <p>The underlying expression can only be a YulFunctionCall.</p> <p>Example</p> <pre><code>assembly {\n    stop()\n}\n</code></pre> Source code in <code>wake/ir/yul/expression_statement.py</code> <pre><code>class YulExpressionStatement(YulStatementAbc):\n    \"\"\"\n    The underlying expression can only be a [YulFunctionCall][wake.ir.yul.function_call.YulFunctionCall].\n\n    !!! example\n        ```solidity\n        assembly {\n            stop()\n        }\n        ```\n    \"\"\"\n\n    _parent: YulBlock\n    _expression: YulFunctionCall\n\n    def __init__(\n        self,\n        init: IrInitTuple,\n        expression_statement: SolcYulExpressionStatement,\n        parent: YulAbc,\n    ):\n        super().__init__(init, expression_statement, parent)\n        assert isinstance(\n            expression_statement.expression, SolcYulFunctionCall\n        ), f\"Unexpected type: {type(expression_statement.expression)}\"\n        self._expression = YulFunctionCall(init, expression_statement.expression, self)\n\n    def __iter__(self) -&gt; Iterator[YulAbc]:\n        yield self\n        yield from self._expression\n\n    @property\n    def parent(self) -&gt; YulBlock:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def expression(self) -&gt; YulFunctionCall:\n        \"\"\"\n        Returns:\n            Underlying expression.\n        \"\"\"\n        return self._expression\n\n    @property\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        return self._expression.modifies_state\n</code></pre>"},{"location":"api-reference/ir/yul/expression-statement/#wake.ir.yul.expression_statement.YulExpressionStatement.expression","title":"<code>expression: YulFunctionCall</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>YulFunctionCall</code> <p>Underlying expression.</p>"},{"location":"api-reference/ir/yul/expression-statement/#wake.ir.yul.expression_statement.YulExpressionStatement.parent","title":"<code>parent: YulBlock</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>YulBlock</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/yul/for-loop/","title":"for_loop","text":""},{"location":"api-reference/ir/yul/for-loop/#wake.ir.yul.for_loop","title":"<code>wake.ir.yul.for_loop</code>  <code>module</code>","text":""},{"location":"api-reference/ir/yul/for-loop/#wake.ir.yul.for_loop.YulForLoop","title":"<code>YulForLoop</code>  <code>class</code>","text":"<p>         Bases: <code>YulStatementAbc</code></p> <p>Represents a for loop with the following structure:</p> <pre><code>for &lt;pre&gt; &lt;condition&gt; &lt;post&gt; {\n    &lt;body&gt;\n}\n</code></pre> <p>Example</p> <pre><code>assembly {\n    for { let i := 0 } lt(i, 10) { i := add(i, 1) } {\n        // ...\n    }\n}\n</code></pre> Source code in <code>wake/ir/yul/for_loop.py</code> <pre><code>class YulForLoop(YulStatementAbc):\n    \"\"\"\n    Represents a for loop with the following structure:\n\n    ```solidity\n    for &lt;pre&gt; &lt;condition&gt; &lt;post&gt; {\n        &lt;body&gt;\n    }\n    ```\n\n    !!! example\n        ```solidity\n        assembly {\n            for { let i := 0 } lt(i, 10) { i := add(i, 1) } {\n                // ...\n            }\n        }\n        ```\n    \"\"\"\n\n    _parent: YulBlock\n    _body: YulBlock\n    _condition: Union[YulFunctionCall, YulIdentifier, YulLiteral]\n    _post: YulBlock\n    _pre: YulBlock\n\n    def __init__(self, init: IrInitTuple, for_loop: SolcYulForLoop, parent: YulAbc):\n        super().__init__(init, for_loop, parent)\n        self._body = YulBlock(init, for_loop.body, self)\n        if isinstance(for_loop.condition, SolcYulFunctionCall):\n            self._condition = YulFunctionCall(init, for_loop.condition, self)\n        elif isinstance(for_loop.condition, SolcYulIdentifier):\n            self._condition = YulIdentifier(init, for_loop.condition, self)\n        elif isinstance(for_loop.condition, SolcYulLiteral):\n            self._condition = YulLiteral(init, for_loop.condition, self)\n        else:\n            assert False, f\"Unexpected type: {type(for_loop.condition)}\"\n        self._post = YulBlock(init, for_loop.post, self)\n        self._pre = YulBlock(init, for_loop.pre, self)\n\n    def __iter__(self) -&gt; Iterator[YulAbc]:\n        yield self\n        yield from self._pre\n        yield from self._condition\n        yield from self._body\n        yield from self._post\n\n    @property\n    def parent(self) -&gt; YulBlock:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def body(self) -&gt; YulBlock:\n        return self._body\n\n    @property\n    def condition(self) -&gt; Union[YulFunctionCall, YulIdentifier, YulLiteral]:\n        \"\"\"\n        Returns:\n            Condition expression that is evaluated before each iteration.\n        \"\"\"\n        return self._condition\n\n    @property\n    def post(self) -&gt; YulBlock:\n        \"\"\"\n        Returns:\n            Block of statements that are executed after each iteration.\n        \"\"\"\n        return self._post\n\n    @property\n    def pre(self) -&gt; YulBlock:\n        \"\"\"\n        Returns:\n            Block of statements that are executed once before the first iteration.\n        \"\"\"\n        return self._pre\n\n    @property\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        return (\n            self._pre.modifies_state\n            | self._condition.modifies_state\n            | self._post.modifies_state\n            | self._body.modifies_state\n        )\n</code></pre>"},{"location":"api-reference/ir/yul/for-loop/#wake.ir.yul.for_loop.YulForLoop.condition","title":"<code>condition: Union[YulFunctionCall, YulIdentifier, YulLiteral]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[YulFunctionCall, YulIdentifier, YulLiteral]</code> <p>Condition expression that is evaluated before each iteration.</p>"},{"location":"api-reference/ir/yul/for-loop/#wake.ir.yul.for_loop.YulForLoop.parent","title":"<code>parent: YulBlock</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>YulBlock</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/yul/for-loop/#wake.ir.yul.for_loop.YulForLoop.post","title":"<code>post: YulBlock</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>YulBlock</code> <p>Block of statements that are executed after each iteration.</p>"},{"location":"api-reference/ir/yul/for-loop/#wake.ir.yul.for_loop.YulForLoop.pre","title":"<code>pre: YulBlock</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>YulBlock</code> <p>Block of statements that are executed once before the first iteration.</p>"},{"location":"api-reference/ir/yul/function-call/","title":"function_call","text":""},{"location":"api-reference/ir/yul/function-call/#wake.ir.yul.function_call","title":"<code>wake.ir.yul.function_call</code>  <code>module</code>","text":""},{"location":"api-reference/ir/yul/function-call/#wake.ir.yul.function_call.YulFunctionCall","title":"<code>YulFunctionCall</code>  <code>class</code>","text":"<p>         Bases: <code>YulAbc</code></p> <p>Represents a call to a \"builtin\" function/instruction (see Solidity docs) or a user-defined YulFunctionDefinition.</p> <p>Example</p> <p><code>foo</code> and <code>stop()</code> in the following example:</p> <pre><code>assembly {\n    function foo() -&gt; x, y {\n        x := 1\n        y := 2\n    }\n    foo()\n    stop()\n}\n</code></pre> Source code in <code>wake/ir/yul/function_call.py</code> <pre><code>class YulFunctionCall(YulAbc):\n    \"\"\"\n    Represents a call to a \"builtin\" function/instruction (see [Solidity docs](https://docs.soliditylang.org/en/latest/yul.html#evm-dialect)) or a user-defined [YulFunctionDefinition][wake.ir.yul.function_definition.YulFunctionDefinition].\n\n    !!! example\n        `foo` and `stop()` in the following example:\n\n        ```solidity\n        assembly {\n            function foo() -&gt; x, y {\n                x := 1\n                y := 2\n            }\n            foo()\n            stop()\n        }\n        ```\n    \"\"\"\n\n    _parent: Union[\n        YulAssignment,\n        YulExpressionStatement,\n        YulForLoop,\n        YulIf,\n        YulSwitch,\n        YulVariableDeclaration,\n        YulFunctionCall,\n    ]\n    _arguments: List[Union[YulFunctionCall, YulIdentifier, YulLiteral]]\n    _function_name: YulIdentifier\n\n    def __init__(\n        self, init: IrInitTuple, function_call: SolcYulFunctionCall, parent: YulAbc\n    ):\n        super().__init__(init, function_call, parent)\n        self._function_name = YulIdentifier(init, function_call.function_name, self)\n        self._arguments = []\n        for argument in function_call.arguments:\n            if isinstance(argument, SolcYulFunctionCall):\n                self._arguments.append(\n                    YulFunctionCall(\n                        init, argument, self  # pyright: ignore reportGeneralTypeIssues\n                    )\n                )\n            elif isinstance(argument, SolcYulIdentifier):\n                self._arguments.append(\n                    YulIdentifier(\n                        init, argument, self  # pyright: ignore reportGeneralTypeIssues\n                    )\n                )\n            elif isinstance(argument, SolcYulLiteral):\n                self._arguments.append(\n                    YulLiteral(\n                        init, argument, self  # pyright: ignore reportGeneralTypeIssues\n                    )\n                )\n            else:\n                assert False, f\"Unexpected type: {type(argument)}\"\n\n    def __iter__(self) -&gt; Iterator[YulAbc]:\n        yield self\n        yield from self._function_name\n        for argument in self._arguments:\n            yield from argument\n\n    @property\n    def parent(\n        self,\n    ) -&gt; Union[\n        YulAssignment,\n        YulExpressionStatement,\n        YulForLoop,\n        YulIf,\n        YulSwitch,\n        YulVariableDeclaration,\n        YulFunctionCall,\n    ]:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def arguments(\n        self,\n    ) -&gt; Tuple[Union[YulFunctionCall, YulIdentifier, YulLiteral], ...]:\n        \"\"\"\n        Returns:\n            Arguments of the function call in the order they appear in the source code.\n        \"\"\"\n        return tuple(self._arguments)\n\n    @property\n    def function_name(self) -&gt; YulIdentifier:\n        \"\"\"\n        Returns:\n            Name of the function that is called.\n        \"\"\"\n        return self._function_name\n\n    @property\n    @cached_return_on_recursion(frozenset())\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        ret = set()\n\n        if self._function_name.name == \"sstore\":\n            ret.add((self, ModifiesStateFlag.MODIFIES_STATE_VAR))\n        elif self._function_name.name in {\"create\", \"create2\"}:\n            ret.add((self, ModifiesStateFlag.DEPLOYS_CONTRACT))\n        elif self._function_name.name in {\"call\", \"callcode\"}:\n            arg2 = self._arguments[2]\n            if (\n                isinstance(arg2, YulLiteral)\n                and arg2.kind == YulLiteralKind.NUMBER\n                and arg2.value is not None\n                and (\n                    int(arg2.value, 16)\n                    if arg2.value.startswith(\"0x\")\n                    else int(arg2.value)\n                )\n                == 0\n            ):\n                # value is 0\n                pass\n            else:\n                ret.add((self, ModifiesStateFlag.SENDS_ETHER))\n            ret.add((self, ModifiesStateFlag.PERFORMS_CALL))\n        elif self._function_name.name == \"delegatecall\":\n            ret.add((self, ModifiesStateFlag.PERFORMS_DELEGATECALL))\n        elif self._function_name.name == \"selfdestruct\":\n            ret.add((self, ModifiesStateFlag.SELFDESTRUCTS))\n        elif self._function_name.name in {\n            \"log0\",\n            \"log1\",\n            \"log2\",\n            \"log3\",\n            \"log4\",\n        }:\n            ret.add((self, ModifiesStateFlag.EMITS))\n        else:\n            # try to find YulFunctionDefinition in parents\n            parent = self.parent\n            while parent != self.inline_assembly:\n                if isinstance(parent, YulBlock):\n                    try:\n                        func = next(\n                            s\n                            for s in parent.statements\n                            if isinstance(s, YulFunctionDefinition)\n                            and s.name == self._function_name.name\n                        )\n                        ret |= func.body.modifies_state\n                        break\n                    except StopIteration:\n                        pass\n                parent = parent.parent\n\n        ret |= reduce(\n            or_,\n            (argument.modifies_state for argument in self.arguments),\n            set(),\n        )\n\n        return ret\n</code></pre>"},{"location":"api-reference/ir/yul/function-call/#wake.ir.yul.function_call.YulFunctionCall.arguments","title":"<code>arguments: Tuple[Union[YulFunctionCall, YulIdentifier, YulLiteral], ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[Union[YulFunctionCall, YulIdentifier, YulLiteral], ...]</code> <p>Arguments of the function call in the order they appear in the source code.</p>"},{"location":"api-reference/ir/yul/function-call/#wake.ir.yul.function_call.YulFunctionCall.function_name","title":"<code>function_name: YulIdentifier</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>YulIdentifier</code> <p>Name of the function that is called.</p>"},{"location":"api-reference/ir/yul/function-call/#wake.ir.yul.function_call.YulFunctionCall.parent","title":"<code>parent: Union[YulAssignment, YulExpressionStatement, YulForLoop, YulIf, YulSwitch, YulVariableDeclaration, YulFunctionCall]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[YulAssignment, YulExpressionStatement, YulForLoop, YulIf, YulSwitch, YulVariableDeclaration, YulFunctionCall]</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/yul/function-definition/","title":"function_definition","text":""},{"location":"api-reference/ir/yul/function-definition/#wake.ir.yul.function_definition","title":"<code>wake.ir.yul.function_definition</code>  <code>module</code>","text":""},{"location":"api-reference/ir/yul/function-definition/#wake.ir.yul.function_definition.YulFunctionDefinition","title":"<code>YulFunctionDefinition</code>  <code>class</code>","text":"<p>         Bases: <code>YulStatementAbc</code></p> <p>Represents a Yul function definition.</p> <p>Example</p> <pre><code>assembly {\n    function foo() -&gt; x, y {\n        x := 1\n        y := 2\n    }\n}\n</code></pre> Source code in <code>wake/ir/yul/function_definition.py</code> <pre><code>class YulFunctionDefinition(YulStatementAbc):\n    \"\"\"\n    Represents a Yul function definition.\n\n    !!! example\n        ```solidity\n        assembly {\n            function foo() -&gt; x, y {\n                x := 1\n                y := 2\n            }\n        }\n        ```\n    \"\"\"\n\n    _parent: YulBlock\n    _body: YulBlock\n    _name: str\n    _parameters: List[YulTypedName]\n    _return_variables: List[YulTypedName]\n\n    def __init__(\n        self,\n        init: IrInitTuple,\n        function_definition: SolcYulFunctionDefinition,\n        parent: YulAbc,\n    ):\n        super().__init__(init, function_definition, parent)\n        self._body = YulBlock(init, function_definition.body, self)\n        self._name = function_definition.name\n        if function_definition.parameters is None:\n            self._parameters = []\n        else:\n            self._parameters = [\n                YulTypedName(init, parameter, self)\n                for parameter in function_definition.parameters\n            ]\n        if function_definition.return_variables is None:\n            self._return_variables = []\n        else:\n            self._return_variables = [\n                YulTypedName(init, return_variable, self)\n                for return_variable in function_definition.return_variables\n            ]\n\n    def __iter__(self) -&gt; Iterator[YulAbc]:\n        yield self\n        yield from self._body\n        if self._parameters is not None:\n            for parameter in self._parameters:\n                yield from parameter\n        if self._return_variables is not None:\n            for return_variable in self._return_variables:\n                yield from return_variable\n\n    @property\n    def parent(self) -&gt; YulBlock:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def body(self) -&gt; YulBlock:\n        \"\"\"\n        Returns:\n            Body of the function.\n        \"\"\"\n        return self._body\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"\n        Returns:\n            Name of the function.\n        \"\"\"\n        return self._name\n\n    @property\n    def parameters(self) -&gt; Tuple[YulTypedName, ...]:\n        \"\"\"\n        Returns:\n            Parameters of the function.\n        \"\"\"\n        return tuple(self._parameters)\n\n    @property\n    def return_variables(self) -&gt; Optional[Tuple[YulTypedName, ...]]:\n        \"\"\"\n        Returns:\n            Return variables of the function.\n        \"\"\"\n        return tuple(self._return_variables)\n\n    @property\n    @lru_cache(maxsize=64)\n    def cfg(self) -&gt; ControlFlowGraph:\n        \"\"\"\n        Returns:\n            Control flow graph of the function.\n        \"\"\"\n        from wake.analysis.cfg import ControlFlowGraph\n\n        return ControlFlowGraph(self)\n\n    @property\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        # the declaration itself does nothing\n        return set()\n</code></pre>"},{"location":"api-reference/ir/yul/function-definition/#wake.ir.yul.function_definition.YulFunctionDefinition.body","title":"<code>body: YulBlock</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>YulBlock</code> <p>Body of the function.</p>"},{"location":"api-reference/ir/yul/function-definition/#wake.ir.yul.function_definition.YulFunctionDefinition.cfg","title":"<code>cfg: ControlFlowGraph</code>  <code>cached</code> <code>property</code>","text":"<p>Returns:</p> Type Description <code>ControlFlowGraph</code> <p>Control flow graph of the function.</p>"},{"location":"api-reference/ir/yul/function-definition/#wake.ir.yul.function_definition.YulFunctionDefinition.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>Name of the function.</p>"},{"location":"api-reference/ir/yul/function-definition/#wake.ir.yul.function_definition.YulFunctionDefinition.parameters","title":"<code>parameters: Tuple[YulTypedName, ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[YulTypedName, ...]</code> <p>Parameters of the function.</p>"},{"location":"api-reference/ir/yul/function-definition/#wake.ir.yul.function_definition.YulFunctionDefinition.parent","title":"<code>parent: YulBlock</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>YulBlock</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/yul/function-definition/#wake.ir.yul.function_definition.YulFunctionDefinition.return_variables","title":"<code>return_variables: Optional[Tuple[YulTypedName, ...]]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Optional[Tuple[YulTypedName, ...]]</code> <p>Return variables of the function.</p>"},{"location":"api-reference/ir/yul/identifier/","title":"identifier","text":""},{"location":"api-reference/ir/yul/identifier/#wake.ir.yul.identifier","title":"<code>wake.ir.yul.identifier</code>  <code>module</code>","text":""},{"location":"api-reference/ir/yul/identifier/#wake.ir.yul.identifier.YulIdentifier","title":"<code>YulIdentifier</code>  <code>class</code>","text":"<p>         Bases: <code>YulAbc</code></p> <p>Represents an identifier referencing a YulFunctionDefinition, a YulVariableDeclaration, or a Solidity VariableDeclaration through an ExternalReference.</p> Source code in <code>wake/ir/yul/identifier.py</code> <pre><code>class YulIdentifier(YulAbc):\n    \"\"\"\n    Represents an identifier referencing a [YulFunctionDefinition][wake.ir.yul.function_definition.YulFunctionDefinition], a [YulVariableDeclaration][wake.ir.yul.variable_declaration.YulVariableDeclaration], or a Solidity [VariableDeclaration][wake.ir.declarations.variable_declaration.VariableDeclaration] through an [ExternalReference][wake.ir.statements.inline_assembly.ExternalReference].\n    \"\"\"\n\n    _parent: Union[\n        YulAssignment,\n        YulExpressionStatement,\n        YulForLoop,\n        YulIf,\n        YulSwitch,\n        YulVariableDeclaration,\n        YulFunctionCall,\n    ]\n    _name: str\n    _external_reference: Optional[ExternalReference]\n\n    def __init__(\n        self, init: IrInitTuple, identifier: SolcYulIdentifier, parent: YulAbc\n    ):\n        super().__init__(init, identifier, parent)\n        self._name = identifier.name\n        self._external_reference = None\n\n    @property\n    def parent(\n        self,\n    ) -&gt; Union[\n        YulAssignment,\n        YulExpressionStatement,\n        YulForLoop,\n        YulIf,\n        YulSwitch,\n        YulVariableDeclaration,\n        YulFunctionCall,\n    ]:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"\n        Returns:\n            Name of the identifier.\n        \"\"\"\n        return self._name\n\n    @property\n    def external_reference(self) -&gt; Optional[ExternalReference]:\n        \"\"\"\n        Is not `None` if the identifier is an external reference to a Solidity variable.\n\n        !!! example\n            `:::solidity foo` in the following example:\n\n            ```solidity\n            uint foo;\n            assembly {\n                foo := 1\n            }\n            ```\n\n        Returns:\n            Object describing the external reference to a Solidity variable.\n        \"\"\"\n        return self._external_reference\n\n    @property\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        return set()\n</code></pre>"},{"location":"api-reference/ir/yul/identifier/#wake.ir.yul.identifier.YulIdentifier.external_reference","title":"<code>external_reference: Optional[ExternalReference]</code>  <code>property</code>","text":"<p>Is not <code>None</code> if the identifier is an external reference to a Solidity variable.</p> <p>Example</p> <p><code>foo</code> in the following example:</p> <pre><code>uint foo;\nassembly {\n    foo := 1\n}\n</code></pre> <p>Returns:</p> Type Description <code>Optional[ExternalReference]</code> <p>Object describing the external reference to a Solidity variable.</p>"},{"location":"api-reference/ir/yul/identifier/#wake.ir.yul.identifier.YulIdentifier.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>Name of the identifier.</p>"},{"location":"api-reference/ir/yul/identifier/#wake.ir.yul.identifier.YulIdentifier.parent","title":"<code>parent: Union[YulAssignment, YulExpressionStatement, YulForLoop, YulIf, YulSwitch, YulVariableDeclaration, YulFunctionCall]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[YulAssignment, YulExpressionStatement, YulForLoop, YulIf, YulSwitch, YulVariableDeclaration, YulFunctionCall]</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/yul/if-statement/","title":"if_statement","text":""},{"location":"api-reference/ir/yul/if-statement/#wake.ir.yul.if_statement","title":"<code>wake.ir.yul.if_statement</code>  <code>module</code>","text":""},{"location":"api-reference/ir/yul/if-statement/#wake.ir.yul.if_statement.YulIf","title":"<code>YulIf</code>  <code>class</code>","text":"<p>         Bases: <code>YulStatementAbc</code></p> <p>Represents an if statement with the following structure:</p> <pre><code>if &lt;condition&gt; {\n    &lt;body&gt;\n}\n</code></pre> <p>Example</p> <pre><code>assembly {\n    if lt(i, 10) {\n        // ...\n    }\n}\n</code></pre> <p>Note</p> <p>There is no <code>else</code> branch in Yul. It must be implemented using a second <code>if</code> statement when needed.</p> Source code in <code>wake/ir/yul/if_statement.py</code> <pre><code>class YulIf(YulStatementAbc):\n    \"\"\"\n    Represents an if statement with the following structure:\n\n    ```solidity\n    if &lt;condition&gt; {\n        &lt;body&gt;\n    }\n    ```\n\n    !!! example\n        ```solidity\n        assembly {\n            if lt(i, 10) {\n                // ...\n            }\n        }\n        ```\n\n    !!! note\n        There is no `else` branch in Yul. It must be implemented using a second `if` statement when needed.\n    \"\"\"\n\n    _parent: YulBlock\n    _body: YulBlock\n    _condition: Union[YulFunctionCall, YulIdentifier, YulLiteral]\n\n    def __init__(self, init: IrInitTuple, if_statement: SolcYulIf, parent: YulAbc):\n        super().__init__(init, if_statement, parent)\n        self._body = YulBlock(init, if_statement.body, self)\n        if isinstance(if_statement.condition, SolcYulFunctionCall):\n            self._condition = YulFunctionCall(init, if_statement.condition, self)\n        elif isinstance(if_statement.condition, SolcYulIdentifier):\n            self._condition = YulIdentifier(init, if_statement.condition, self)\n        elif isinstance(if_statement.condition, SolcYulLiteral):\n            self._condition = YulLiteral(init, if_statement.condition, self)\n        else:\n            assert False, f\"Unexpected type: {type(if_statement.condition)}\"\n\n    def __iter__(self) -&gt; Iterator[YulAbc]:\n        yield self\n        yield from self._condition\n        yield from self._body\n\n    @property\n    def parent(self) -&gt; YulBlock:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def body(self) -&gt; YulBlock:\n        \"\"\"\n        Returns:\n            Body of the function executed if the condition is true.\n        \"\"\"\n        return self._body\n\n    @property\n    def condition(self) -&gt; Union[YulFunctionCall, YulIdentifier, YulLiteral]:\n        \"\"\"\n        Returns:\n            Condition of the if statement.\n        \"\"\"\n        return self._condition\n\n    @property\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        return self._condition.modifies_state | self._body.modifies_state\n</code></pre>"},{"location":"api-reference/ir/yul/if-statement/#wake.ir.yul.if_statement.YulIf.body","title":"<code>body: YulBlock</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>YulBlock</code> <p>Body of the function executed if the condition is true.</p>"},{"location":"api-reference/ir/yul/if-statement/#wake.ir.yul.if_statement.YulIf.condition","title":"<code>condition: Union[YulFunctionCall, YulIdentifier, YulLiteral]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[YulFunctionCall, YulIdentifier, YulLiteral]</code> <p>Condition of the if statement.</p>"},{"location":"api-reference/ir/yul/if-statement/#wake.ir.yul.if_statement.YulIf.parent","title":"<code>parent: YulBlock</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>YulBlock</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/yul/leave/","title":"leave","text":""},{"location":"api-reference/ir/yul/leave/#wake.ir.yul.leave","title":"<code>wake.ir.yul.leave</code>  <code>module</code>","text":""},{"location":"api-reference/ir/yul/leave/#wake.ir.yul.leave.YulLeave","title":"<code>YulLeave</code>  <code>class</code>","text":"<p>         Bases: <code>YulStatementAbc</code></p> <p>Leave statement exits the execution of the current function. It is analogous to the <code>return</code> statement in Solidity, except that it does not accept any arguments to be returned as a return value. Instead, it returns the last-assigned values to the return variables of the function (or default values if none were assigned).</p> <p>Example</p> <pre><code>assembly {\n    function foo() {\n        leave\n        // execution stops here\n    }\n    foo()\n    // execution continue here\n}\n</code></pre> Source code in <code>wake/ir/yul/leave.py</code> <pre><code>class YulLeave(YulStatementAbc):\n    \"\"\"\n    Leave statement exits the execution of the current function.\n    It is analogous to the `return` statement in Solidity, except that it does not accept any arguments to be returned as a return value.\n    Instead, it returns the last-assigned values to the return variables of the function (or default values if none were assigned).\n\n    !!! example\n        ```solidity\n        assembly {\n            function foo() {\n                leave\n                // execution stops here\n            }\n            foo()\n            // execution continue here\n        }\n        ```\n    \"\"\"\n\n    _parent: YulBlock\n\n    @property\n    def parent(self) -&gt; YulBlock:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        return set()\n</code></pre>"},{"location":"api-reference/ir/yul/leave/#wake.ir.yul.leave.YulLeave.parent","title":"<code>parent: YulBlock</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>YulBlock</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/yul/literal/","title":"literal","text":""},{"location":"api-reference/ir/yul/literal/#wake.ir.yul.literal","title":"<code>wake.ir.yul.literal</code>  <code>module</code>","text":""},{"location":"api-reference/ir/yul/literal/#wake.ir.yul.literal.YulLiteral","title":"<code>YulLiteral</code>  <code>class</code>","text":"<p>         Bases: <code>YulAbc</code></p> <p>String literals may have up to 32 bytes.</p> <p>Example</p> <p><code>10</code>, <code>0x1234</code>, <code>true</code>, <code>\"abcdef\"</code> and <code>\"\\x01\\x02\\x03\"</code> in the following example are all literals:</p> <pre><code>assembly {\n    let x := 10\n    x := 0x1234\n    x := true\n    x := \"abcdef\"\n    x := \"\\x01\\x02\\x03\"\n}\n</code></pre> Source code in <code>wake/ir/yul/literal.py</code> <pre><code>class YulLiteral(YulAbc):\n    \"\"\"\n    String literals may have up to 32 bytes.\n\n    !!! example\n        `:::solidity 10`, `:::solidity 0x1234`, `:::solidity true`, `:::solidity \"abcdef\"` and `:::solidity \"\\\\x01\\\\x02\\\\x03\"` in the following example are all literals:\n\n        ```solidity\n        assembly {\n            let x := 10\n            x := 0x1234\n            x := true\n            x := \"abcdef\"\n            x := \"\\\\x01\\\\x02\\\\x03\"\n        }\n        ```\n    \"\"\"\n\n    _parent: Union[\n        YulAssignment,\n        YulExpressionStatement,\n        YulForLoop,\n        YulIf,\n        YulSwitch,\n        YulVariableDeclaration,\n        YulFunctionCall,\n        YulCase,\n    ]\n    _kind: YulLiteralKind\n    _type: str\n    _value: Optional[str]\n    _hex_value: Optional[bytes]\n\n    def __init__(self, init: IrInitTuple, literal: SolcYulLiteral, parent: YulAbc):\n        super().__init__(init, literal, parent)\n        self._kind = literal.kind\n        self._type = literal.type\n        assert (\n            literal.type == \"\"\n        ), f\"Expected YulLiteral type to be empty, got {literal.type}\"\n        self._value = literal.value\n        self._hex_value = (\n            bytes.fromhex(literal.hex_value) if literal.hex_value is not None else None\n        )\n\n    @property\n    def parent(\n        self,\n    ) -&gt; Union[\n        YulAssignment,\n        YulExpressionStatement,\n        YulForLoop,\n        YulIf,\n        YulSwitch,\n        YulVariableDeclaration,\n        YulFunctionCall,\n        YulCase,\n    ]:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def kind(self) -&gt; YulLiteralKind:\n        \"\"\"\n        Returns:\n            Kind of the literal.\n        \"\"\"\n        return self._kind\n\n    # type seems to be always empty\n    # @property\n    # def type(self) -&gt; str:\n    # return self._type\n\n    @property\n    def value(self) -&gt; Optional[str]:\n        \"\"\"\n        Is `None` for hex-escaped strings that are not valid UTF-8 sequences, e.g. `:::solidity \"\\\\xaa\\\\xbb\"`.\n\n        Returns:\n            Value of the literal as it appears in the Yul source code, except for hex-escape sequences that are\n                replaced with their corresponding bytes.\n        \"\"\"\n        return self._value\n\n    @property\n    def hex_value(self) -&gt; Optional[bytes]:\n        \"\"\"\n        !!! note\n            Only set for [YulLiteralKind.STRING][wake.ir.enums.YulLiteralKind.STRING] literals in Solidity &gt;= 0.8.5.\n\n        Returns:\n            Byte representation of the literal.\n        \"\"\"\n        return self._hex_value\n\n    @property\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        return set()\n</code></pre>"},{"location":"api-reference/ir/yul/literal/#wake.ir.yul.literal.YulLiteral.hex_value","title":"<code>hex_value: Optional[bytes]</code>  <code>property</code>","text":"<p>Note</p> <p>Only set for YulLiteralKind.STRING literals in Solidity &gt;= 0.8.5.</p> <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Byte representation of the literal.</p>"},{"location":"api-reference/ir/yul/literal/#wake.ir.yul.literal.YulLiteral.kind","title":"<code>kind: YulLiteralKind</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>YulLiteralKind</code> <p>Kind of the literal.</p>"},{"location":"api-reference/ir/yul/literal/#wake.ir.yul.literal.YulLiteral.parent","title":"<code>parent: Union[YulAssignment, YulExpressionStatement, YulForLoop, YulIf, YulSwitch, YulVariableDeclaration, YulFunctionCall, YulCase]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[YulAssignment, YulExpressionStatement, YulForLoop, YulIf, YulSwitch, YulVariableDeclaration, YulFunctionCall, YulCase]</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/yul/literal/#wake.ir.yul.literal.YulLiteral.value","title":"<code>value: Optional[str]</code>  <code>property</code>","text":"<p>Is <code>None</code> for hex-escaped strings that are not valid UTF-8 sequences, e.g. <code>\"\\xaa\\xbb\"</code>.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Value of the literal as it appears in the Yul source code, except for hex-escape sequences that are replaced with their corresponding bytes.</p>"},{"location":"api-reference/ir/yul/switch/","title":"switch","text":""},{"location":"api-reference/ir/yul/switch/#wake.ir.yul.switch","title":"<code>wake.ir.yul.switch</code>  <code>module</code>","text":""},{"location":"api-reference/ir/yul/switch/#wake.ir.yul.switch.YulSwitch","title":"<code>YulSwitch</code>  <code>class</code>","text":"<p>         Bases: <code>YulStatementAbc</code></p> <p>Represents a switch statement with the following structure:</p> <pre><code>switch &lt;expression&gt; {\n    &lt;cases&gt;\n}\n</code></pre> <p>Example</p> <pre><code>assembly {\n    switch lt(i, 10)\n    case 1 {\n        // ...\n    }\n    case 2 {\n        // ...\n    }\n    default {\n        // ...\n    }\n}\n</code></pre> Source code in <code>wake/ir/yul/switch.py</code> <pre><code>class YulSwitch(YulStatementAbc):\n    \"\"\"\n    Represents a switch statement with the following structure:\n\n    ```solidity\n    switch &lt;expression&gt; {\n        &lt;cases&gt;\n    }\n    ```\n\n    !!! example\n        ```solidity\n        assembly {\n            switch lt(i, 10)\n            case 1 {\n                // ...\n            }\n            case 2 {\n                // ...\n            }\n            default {\n                // ...\n            }\n        }\n        ```\n    \"\"\"\n\n    _parent: YulBlock\n    _cases: List[YulCase]\n    _expression: Union[YulFunctionCall, YulIdentifier, YulLiteral]\n\n    def __init__(self, init: IrInitTuple, switch: SolcYulSwitch, parent: YulAbc):\n        super().__init__(init, switch, parent)\n        if isinstance(switch.expression, SolcYulFunctionCall):\n            self._expression = YulFunctionCall(init, switch.expression, self)\n        elif isinstance(switch.expression, SolcYulIdentifier):\n            self._expression = YulIdentifier(init, switch.expression, self)\n        elif isinstance(switch.expression, SolcYulLiteral):\n            self._expression = YulLiteral(init, switch.expression, self)\n        else:\n            assert False, f\"Unexpected type: {type(switch.expression)}\"\n        self._cases = [YulCase(init, case, self) for case in switch.cases]\n\n    def __iter__(self) -&gt; Iterator[YulAbc]:\n        yield self\n        yield from self._expression\n        for case_ in self._cases:\n            yield from case_\n\n    @property\n    def parent(self) -&gt; YulBlock:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def cases(self) -&gt; Tuple[YulCase, ...]:\n        \"\"\"\n        The `default` case is optional.\n\n        Returns:\n            Tuple of cases of this switch statement in the order they appear in the source code.\n        \"\"\"\n        return tuple(self._cases)\n\n    @property\n    def expression(self) -&gt; Union[YulFunctionCall, YulIdentifier, YulLiteral]:\n        \"\"\"\n        Returns:\n            Expression that is evaluated to determine which case to execute.\n        \"\"\"\n        return self._expression\n\n    @property\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        return self._expression.modifies_state | reduce(\n            or_,\n            (case.modifies_state for case in self._cases),\n            set(),\n        )\n</code></pre>"},{"location":"api-reference/ir/yul/switch/#wake.ir.yul.switch.YulSwitch.cases","title":"<code>cases: Tuple[YulCase, ...]</code>  <code>property</code>","text":"<p>The <code>default</code> case is optional.</p> <p>Returns:</p> Type Description <code>Tuple[YulCase, ...]</code> <p>Tuple of cases of this switch statement in the order they appear in the source code.</p>"},{"location":"api-reference/ir/yul/switch/#wake.ir.yul.switch.YulSwitch.expression","title":"<code>expression: Union[YulFunctionCall, YulIdentifier, YulLiteral]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Union[YulFunctionCall, YulIdentifier, YulLiteral]</code> <p>Expression that is evaluated to determine which case to execute.</p>"},{"location":"api-reference/ir/yul/switch/#wake.ir.yul.switch.YulSwitch.parent","title":"<code>parent: YulBlock</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>YulBlock</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/yul/typed-name/","title":"typed_name","text":""},{"location":"api-reference/ir/yul/typed-name/#wake.ir.yul.typed_name","title":"<code>wake.ir.yul.typed_name</code>  <code>module</code>","text":""},{"location":"api-reference/ir/yul/typed-name/#wake.ir.yul.typed_name.YulTypedName","title":"<code>YulTypedName</code>  <code>class</code>","text":"<p>         Bases: <code>YulAbc</code></p> <p>As opposed to YulIdentifier that serves as a reference to a variable and is evaluated to its value, <code>YulTypedName</code> is a declaration of a variable (an intention to use the given name for a variable).</p> <p>The difference from YulVariableDeclaration is that the variable declaration is used to declare a new unique name and contains <code>YulTypedName</code> as a child.</p> <p>Example</p> <p><code>x</code>, <code>y</code>, <code>z</code> and <code>w</code> in the following example are all typed names:</p> <pre><code>assembly {\n    function foo(x, y) -&gt; z {\n        z := add(x, y)\n    }\n    let w := foo(1, 2)\n}\n</code></pre> Source code in <code>wake/ir/yul/typed_name.py</code> <pre><code>class YulTypedName(YulAbc):\n    \"\"\"\n    As opposed to [YulIdentifier][wake.ir.yul.identifier.YulIdentifier] that serves as a reference to a variable and is evaluated to its value, `YulTypedName` is a declaration of a variable (an intention to use the given name for a variable).\n\n    The difference from [YulVariableDeclaration][wake.ir.yul.variable_declaration.YulVariableDeclaration] is that the variable declaration is used to declare a new unique name and contains `YulTypedName` as a child.\n\n    !!! example\n        `x`, `y`, `z` and `w` in the following example are all typed names:\n\n        ```solidity\n        assembly {\n            function foo(x, y) -&gt; z {\n                z := add(x, y)\n            }\n            let w := foo(1, 2)\n        }\n        ```\n    \"\"\"\n\n    _parent: Union[YulFunctionDefinition, YulVariableDeclaration]\n    _name: str\n    _type: str\n\n    def __init__(self, init: IrInitTuple, typed_name: SolcYulTypedName, parent: YulAbc):\n        super().__init__(init, typed_name, parent)\n        self._name = typed_name.name\n        self._type = typed_name.type\n        assert (\n            self._type == \"\"\n        ), f\"Expected YulTypedName type to be empty, got {self._type}\"\n\n    @property\n    def parent(self) -&gt; Union[YulFunctionDefinition, YulVariableDeclaration]:\n        return self._parent\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"\n        Returns:\n            Name of the typed name.\n        \"\"\"\n        return self._name\n\n    # type seems to be always empty\n    # @property\n    # def type(self) -&gt; str:\n    # return self._type\n\n    @property\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        return set()\n</code></pre>"},{"location":"api-reference/ir/yul/typed-name/#wake.ir.yul.typed_name.YulTypedName.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>Name of the typed name.</p>"},{"location":"api-reference/ir/yul/variable-declaration/","title":"variable_declaration","text":""},{"location":"api-reference/ir/yul/variable-declaration/#wake.ir.yul.variable_declaration","title":"<code>wake.ir.yul.variable_declaration</code>  <code>module</code>","text":""},{"location":"api-reference/ir/yul/variable-declaration/#wake.ir.yul.variable_declaration.YulVariableDeclaration","title":"<code>YulVariableDeclaration</code>  <code>class</code>","text":"<p>         Bases: <code>YulStatementAbc</code></p> <p>Represents a new variable declaration with the following structure:</p> <pre><code>let &lt;variables&gt; := &lt;value&gt;\n</code></pre> <p>Example</p> <p><code>let a, b := foo()</code> in the following example:</p> <pre><code>assembly {\n    function foo() -&gt; x, y {\n        x := 1\n        y := 2\n    }\n\n    let a, b := foo()\n}\n</code></pre> Source code in <code>wake/ir/yul/variable_declaration.py</code> <pre><code>class YulVariableDeclaration(YulStatementAbc):\n    \"\"\"\n    Represents a new variable declaration with the following structure:\n\n    ```solidity\n    let &lt;variables&gt; := &lt;value&gt;\n    ```\n\n    !!! example\n        `:::solidity let a, b := foo()` in the following example:\n\n        ```solidity\n        assembly {\n            function foo() -&gt; x, y {\n                x := 1\n                y := 2\n            }\n\n            let a, b := foo()\n        }\n        ```\n    \"\"\"\n\n    _parent: YulBlock\n    _variables: List[YulTypedName]\n    _value: Optional[Union[YulFunctionCall, YulIdentifier, YulLiteral]]\n\n    def __init__(\n        self,\n        init: IrInitTuple,\n        variable_declaration: SolcYulVariableDeclaration,\n        parent: YulAbc,\n    ):\n        super().__init__(init, variable_declaration, parent)\n        self._variables = [\n            YulTypedName(init, variable, self)\n            for variable in variable_declaration.variables\n        ]\n        if variable_declaration.value is None:\n            self._value = None\n        elif isinstance(variable_declaration.value, SolcYulFunctionCall):\n            self._value = YulFunctionCall(init, variable_declaration.value, self)\n        elif isinstance(variable_declaration.value, SolcYulIdentifier):\n            self._value = YulIdentifier(init, variable_declaration.value, self)\n        elif isinstance(variable_declaration.value, SolcYulLiteral):\n            self._value = YulLiteral(init, variable_declaration.value, self)\n        else:\n            assert False, f\"Unexpected type: {type(variable_declaration.value)}\"\n\n    def __iter__(self) -&gt; Iterator[YulAbc]:\n        yield self\n        for variable in self._variables:\n            yield from variable\n        if self._value is not None:\n            yield from self._value\n\n    @property\n    def parent(self) -&gt; YulBlock:\n        \"\"\"\n        Returns:\n            Parent IR node.\n        \"\"\"\n        return self._parent\n\n    @property\n    def variables(self) -&gt; Tuple[YulTypedName, ...]:\n        \"\"\"\n        Returns:\n            Tuple of variables declared in this statement.\n        \"\"\"\n        return tuple(self._variables)\n\n    @property\n    def value(self) -&gt; Optional[Union[YulFunctionCall, YulIdentifier, YulLiteral]]:\n        \"\"\"\n        Returns:\n            Value assigned to the variables.\n        \"\"\"\n        return self._value\n\n    @property\n    def modifies_state(\n        self,\n    ) -&gt; Set[Tuple[Union[ExpressionAbc, StatementAbc, YulAbc], ModifiesStateFlag]]:\n        if self._value is None:\n            return set()\n        return self._value.modifies_state\n</code></pre>"},{"location":"api-reference/ir/yul/variable-declaration/#wake.ir.yul.variable_declaration.YulVariableDeclaration.parent","title":"<code>parent: YulBlock</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>YulBlock</code> <p>Parent IR node.</p>"},{"location":"api-reference/ir/yul/variable-declaration/#wake.ir.yul.variable_declaration.YulVariableDeclaration.value","title":"<code>value: Optional[Union[YulFunctionCall, YulIdentifier, YulLiteral]]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Optional[Union[YulFunctionCall, YulIdentifier, YulLiteral]]</code> <p>Value assigned to the variables.</p>"},{"location":"api-reference/ir/yul/variable-declaration/#wake.ir.yul.variable_declaration.YulVariableDeclaration.variables","title":"<code>variables: Tuple[YulTypedName, ...]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Tuple[YulTypedName, ...]</code> <p>Tuple of variables declared in this statement.</p>"},{"location":"api-reference/printers/api/","title":"api","text":""},{"location":"api-reference/printers/api/#wake.printers.api","title":"<code>wake.printers.api</code>  <code>module</code>","text":""},{"location":"api-reference/printers/api/#wake.printers.api.Printer","title":"<code>Printer</code>  <code>class</code>","text":"<p>         Bases: <code>Visitor</code></p> <p>Base class for printers.</p> <p>Attributes:</p> Name Type Description <code>paths</code> <code>List[Path]</code> <p>Paths the printer should operate on. May be empty if a user did not specify any paths, e.g. when running <code>wake print printer-name</code>. In this case, the printer should operate on all paths. May be ignored unless visit_mode is <code>all</code>.</p> <code>extra</code> <code>Dict[Any, Any]</code> <p>Extra data set by the execution engine.</p> Source code in <code>wake/printers/api.py</code> <pre><code>class Printer(Visitor, metaclass=ABCMeta):\n    \"\"\"\n    Base class for printers.\n\n    Attributes:\n        paths: Paths the printer should operate on. May be empty if a user did not specify any paths, e.g. when running `wake print printer-name`.\n            In this case, the printer should operate on all paths. May be ignored unless [visit_mode][wake.printers.api.Printer.visit_mode] is `all`.\n        extra: Extra data set by the execution engine.\n    \"\"\"\n\n    console: Console\n    paths: List[Path]\n    extra: Dict[Any, Any]\n    lsp_provider: Optional[LspProvider]\n    execution_mode: Literal[\"cli\", \"lsp\", \"both\"] = \"cli\"  # TODO remove both?\n\n    @property\n    def visit_mode(self) -&gt; Literal[\"paths\", \"all\"]:\n        \"\"\"\n        Configurable visit mode of the printer. If set to `paths`, the printer `visit_` methods will be called only for the paths specified by the user.\n        If set to `all`, the printer `visit_` methods will be called for all paths. In this case, the printer should use the `paths` attribute to decide what to print.\n\n        Returns:\n            Visit mode of the printer.\n        \"\"\"\n        return \"paths\"\n\n    @abstractmethod\n    def print(self) -&gt; None:\n        \"\"\"\n        Abstract method that must be implemented in every printer. This method is called after all `visit_` methods have been called.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api-reference/printers/api/#wake.printers.api.Printer.visit_mode","title":"<code>visit_mode: Literal['paths', 'all']</code>  <code>property</code>","text":"<p>Configurable visit mode of the printer. If set to <code>paths</code>, the printer <code>visit_</code> methods will be called only for the paths specified by the user. If set to <code>all</code>, the printer <code>visit_</code> methods will be called for all paths. In this case, the printer should use the <code>paths</code> attribute to decide what to print.</p> <p>Returns:</p> Type Description <code>Literal['paths', 'all']</code> <p>Visit mode of the printer.</p>"},{"location":"api-reference/printers/api/#wake.printers.api.Printer.print","title":"<code>print()</code>  <code>abstractmethod</code>","text":"<p>Abstract method that must be implemented in every printer. This method is called after all <code>visit_</code> methods have been called.</p> Source code in <code>wake/printers/api.py</code> <pre><code>@abstractmethod\ndef print(self) -&gt; None:\n    \"\"\"\n    Abstract method that must be implemented in every printer. This method is called after all `visit_` methods have been called.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"static-analysis/command-line-interface/","title":"Command-line interface","text":"<p>Detectors and printers provide a command-line interface through the Click library. It is recommended to read the Click documentation for information about how to use it. This section provides additional tips how to make command-line interactions with detectors and printers more user-friendly.</p>"},{"location":"static-analysis/command-line-interface/#name-completions","title":"Name completions","text":"<p>Wake offers a custom <code>SolidityName</code> click type that can be used with Click options and arguments to provide name completions for Solidity functions, modifiers, etc.</p> <p>Info</p> <p>Refer to the Installation section for how to enable shell completions.</p> <p>Warning</p> <p><code>SolidityName</code> completions are only available after the project has been compiled.</p> <p>The <code>SolidityName</code> type accepts one or multiple types of auto-completed names represented by the following constants:</p> <ul> <li><code>\"contract\"</code>,</li> <li><code>\"enum\"</code>,</li> <li><code>\"error\"</code>,</li> <li><code>\"event\"</code>,</li> <li><code>\"function\"</code>,</li> <li><code>\"modifier\"</code>,</li> <li><code>\"struct\"</code>,</li> <li><code>\"user_defined_value_type</code>,</li> <li><code>\"variable\"</code>.</li> </ul> <p>Additionally, the <code>SolidityName</code> type accepts the following boolean keyword arguments:</p> <ul> <li><code>case_sensitive</code> - whether the completions should be case-sensitive,</li> <li><code>canonical</code> - whether canonical names should be auto-completed, e.g. <code>ContractName.functionName</code>,</li> <li><code>non_canonical</code> - whether non-canonical (local) names should be auto-completed, e.g. <code>functionName</code>.</li> </ul> <p>Example</p> <p>In the following example, both canonical and non-canonical function and modifier names are auto-completed case-insensitively: <pre><code>@click.option(\n    \"--name\",\n    \"-n\",\n    \"names\",\n    type=SolidityName(\"function\", \"modifier\", case_sensitive=False),\n    multiple=True,\n    help=\"Function and modifier names\",\n)\n</code></pre></p>"},{"location":"static-analysis/command-line-interface/#imports","title":"Imports","text":"<p>In order to have the shell completions as quick as possible, all unnecessary imports should be avoided or delayed for the time when the command is actually run. To achieve this, it is the best to follow these recommendations:</p> <ul> <li>It is strongly recommended to start with the templates provided by the <code>wake up</code> command.</li> <li>Any additionally needed imports should be placed inside functions and methods, not at the top of the file.</li> <li><code>networkx</code>, <code>wake.ir</code> and <code>wake.ir.types</code> modules are lazy-loaded, their members should not be accessed at the top level of the file or at the top level of the detector/printer class.<ul> <li>This is not necessary for type annotations as long as <code>from __future__ import annotations</code> is used.</li> </ul> </li> </ul> <p>The following example shows common patterns that lead to additional delays in shell completions:</p> <pre><code>from __future__ import annotations\n\nfrom pathlib import Path  # (1)!\nfrom typing import Set, Tuple, Union\n\nimport graphviz  # (2)!\nimport networkx as nx\nimport rich_click as click\nfrom rich import print\n\nimport wake.ir as ir\nimport wake.ir.types as types\nfrom wake.cli import SolidityName\nfrom wake.printers import Printer, printer\n\n\nclass MyPrinter(Printer):\n    restricted_nodes = (  # (3)!\n        ir.Identifier,\n        ir.IndexAccess,\n        ir.IndexRangeAccess,\n        ir.Literal,\n        ir.MemberAccess,\n    )\n\n    ...\n</code></pre> <ol> <li>Both <code>pathlib</code> and <code>typing</code> modules may be imported at the top level of the file as they are imported by the Wake runtime anyway.</li> <li><code>graphviz</code> module is not lazy-loaded, it should be imported inside a function or a method that uses it.</li> <li><code>wake.ir</code> members accessed at the top level of the class. This will case the module to be loaded. Instead, a property or a helper function should be used:</li> </ol>"},{"location":"static-analysis/getting-started/","title":"Getting started","text":"<p>Implementing a custom detector or printer is a very efficient way to extend Wake's detection and analysis capabilities.</p> <p>Both detectors and printers may be implemented as project-specific or global.</p> <p>Tip</p> <p>Built-in detectors and printers may serve as a good starting point for implementing custom detectors and printers.</p>"},{"location":"static-analysis/getting-started/#using-a-template","title":"Using a template","text":"<p>The best way to get started is to use</p> <pre><code>wake up detector detector-name\n</code></pre> <p>or</p> <pre><code>wake up printer printer-name\n</code></pre> <p>commands, which will create a template detector or printer in <code>./detectors</code> or <code>./printers</code> respectively. By supplying the <code>--global</code> flag, the template will be created in <code>$XDG_DATA_HOME/wake/global-detectors</code> or <code>$XDG_DATA_HOME/wake/global-printers</code> instead.</p> <p>Tip</p> <p>If working in VS Code with the Tools for Solidity extension installed, the same can be achieved by running the following commands in the command palette:</p> <ul> <li><code>Tools for Solidity: New Detector</code>,</li> <li><code>Tools for Solidity: New Global Detector</code>,</li> <li><code>Tools for Solidity: New Printer</code>,</li> <li><code>Tools for Solidity: New Global Printer</code>.</li> </ul>"},{"location":"static-analysis/getting-started/#detector-printer-structure","title":"Detector &amp; printer structure","text":"<p>Both template detectors and printers are implemented as a minimal Python class:</p> Detector Printer <pre><code>class MyDetectorDetector(Detector):\n    _detections: List[DetectorResult]\n\n    def __init__(self) -&gt; None:\n        self._detections = []\n\n    def detect(self) -&gt; List[DetectorResult]:\n        return self._detections\n\n    @detector.command(name=\"my-detector\")\n    def cli(self) -&gt; None:\n        pass\n</code></pre> <pre><code>class MyPrinterPrinter(Printer):\n    def print(self) -&gt; None:\n        pass\n\n    @printer.command(name=\"my-printer\")\n    def cli(self) -&gt; None:\n        pass\n</code></pre> <p>Detectors define the <code>detect</code> method, which returns a list of detections. Printers define the <code>print</code> method, which prints the results of the analysis.</p> <p>Tip</p> <p>Printers may print information from any method (even from <code>__init__</code> and <code>cli</code>), not just from <code>print</code>.</p> <p>On the contrary, printers do not need to print anything at all. For example, a printer may be used to generate a file with the results of the analysis.</p>"},{"location":"static-analysis/getting-started/#command-line-interface","title":"Command-line interface","text":"<p>Detector and Printer subclasses should implement a command-line interface (CLI) method using the Click library. The name of the Click command determines the name of the detector or printer. Both detectors and printers may accept additional arguments and options, for example:</p> <pre><code>@printer.command(name=\"my-printer\")\n@click.argument(\n    \"modifier\",\n    type=str,\n    required=True,\n    help=\"Name of the modifier to analyze.\",\n)\n@click.option(\n    \"--follow-function-calls/--no-follow-function-calls\",\n    is_flag=True,\n    default=False,\n    help=\"Follow function calls in the modifier.\",\n)\n</code></pre> <p>See the Detector configuration and Printer configuration sections for how to set the values of arguments and options when running detectors and printers.</p> <p>Default values for detectors</p> <p>Detectors must always provide default values for all arguments and options.</p> <p>This is because detectors may be run with <code>wake detect all</code>, where passing detector-specific arguments and options is not possible. The same is true for the LSP server, which runs detectors in the background.</p>"},{"location":"static-analysis/getting-started/#inherited-attributes-and-methods","title":"Inherited attributes and methods","text":"<p>Both Detector and Printer classes inherit from the Visitor class, which provides <code>visit_</code> methods for all types of Solidity abstract syntax tree (AST) nodes.</p> <p>Wake builds on the AST and provides an intermediate representation (IR) model, which is an extension of the AST with additional information and fixes for incorrect or missing information. Refer to the <code>wake.ir</code> API reference for more information.</p> <p>The <code>visit_</code> methods accept a single argument, which is the IR node to be visited, for example:</p> <pre><code>def visit_function_definition(self, node: ir.FunctionDefinition) -&gt; None:\n    pass\n</code></pre> <p>Visit functions are automatically called by the execution engine when running the detector or printer.</p> <p>Additionally, there are two methods for generating links from an IR node or from a source code location:</p> <pre><code>def generate_link(self, node: ir.IrAbc) -&gt; str:\n    ...\n\ndef generate_link_from_line_col(self, path: Union[str, Path], line: int, col: int) -&gt; str:\n    ...\n</code></pre> <p>Example</p> <p>The methods may be used in the following way:</p> <pre><code>def visit_function_definition(self, node: ir.FunctionDefinition) -&gt; None:\n    link = f\"[link={self.generate_link(node)}]{node.canonical_name}[/link]\"\n</code></pre> <p>Refer to the Rich documentation for more information about the syntax of console links.</p>"},{"location":"static-analysis/getting-started/#visit-modes","title":"Visit modes","text":"<p>All detectors and printers accept unlimited number of paths to Solidity source code files and directories. The paths are passed as command-line arguments, for example:</p> <pre><code>wake detect my-detector contracts/utils\n</code></pre> <p>When there are any paths specified, the <code>visit_</code> functions are called only for IR nodes in Solidity files in the specified paths. However, some detectors and printers may need to visit all IR nodes in the project, to perform the analysis correctly. In such cases, the detector or printer should override the <code>visit_mode</code> property and return <code>\"all\"</code> instead of the default <code>\"paths\"</code>.</p> <pre><code>class MyDetectorDetector(Detector):\n    ...\n\n    @property\n    def visit_mode(self) -&gt; str:\n        return \"all\"\n</code></pre> <p>When the <code>visit_mode</code> is set to <code>\"all\"</code>, the detector or printer is responsible for filtering out the detections or printed information that are not relevant to the specified paths. For example:</p> <pre><code>class MyPrinterPrinter(Printer):\n    ...\n\n    @property\n    def visit_mode(self):\n        return \"all\"\n\n    def visit_contract_definition(self, node: ir.ContractDefinition) -&gt; None:\n        from wake.utils import is_relative_to\n\n        if not any(is_relative_to(node.source_unit.file, p) for p in self.paths):\n            return\n        ...\n</code></pre>"},{"location":"static-analysis/getting-started/#execution-order","title":"Execution order","text":"<p>The methods of detectors and printers are executed in the following order:</p> <ol> <li><code>__init__</code>,</li> <li>Click command-line entry point (<code>cli</code> or any other method decorated with <code>@detector.command()</code> or <code>@printer.command()</code>),</li> <li><code>visit_mode</code>,</li> <li><code>visit_</code> methods in an unspecified order,</li> <li><code>detect</code> for detectors or <code>print</code> for printers.</li> </ol>"},{"location":"static-analysis/using-detectors/","title":"Using detectors","text":"<p>Wake comes with the built-in wake_detectors module, which provides a set of detectors for common vulnerabilities and code quality issues in Solidity smart contracts.</p> <p>The first label in each detection message describes the impact of the issue, the second label describes the confidence of the detection.</p>"},{"location":"static-analysis/using-detectors/#basic-usage","title":"Basic usage","text":"<p>To list all available detectors, run:</p> <pre><code>wake detect --help\n</code></pre> <p>Use</p> <pre><code>wake detect all\n</code></pre> <p>to run all detectors on all contracts in the project or</p> <pre><code>wake detect detector-name\n</code></pre> <p>to run a specific detector only.</p> <p>In both cases, it is possible to specify paths to contracts to be analyzed, <code>--min-impact</code> and <code>--min-confidence</code>:</p> <pre><code>wake detect all contracts/utils --min-impact medium --min-confidence high\n</code></pre> <p>Tip</p> <p>The Tools for Solidity VS Code extension comes with a custom UI for viewing and filtering detector results and compiler warnings and errors.</p> <p></p>"},{"location":"static-analysis/using-detectors/#ignoring-detections","title":"Ignoring detections","text":"<p>Reported detections may be ignored by adding a comment to the detection location in the source code. Both single-line (<code>// ...</code>) and multi-line (<code>/* ... */</code>) comments are supported.</p> <p>There are 4 types of comments:</p> <ul> <li><code>// wake-disable-line</code> disables detections on the current line,</li> <li><code>// wake-disable-next-line</code> disables detections on the next line,</li> <li><code>// wake-disable</code> disables detections on the current line and all following lines,</li> <li><code>// wake-enable</code> re-enables detections after <code>// wake-disable</code>.</li> </ul> <p>All comments may be followed by a list of detector names and compiler warning codes separated by commas. Whitespace is ignored. For example:</p> <pre><code>// wake-disable unused-import, unused-contract, 1234\n</code></pre> <p>Compiler errors cannot be ignored. If no detector names or compiler warning codes are specified, all detections are ignored (or re-enabled in case of <code>// wake-enable</code>).</p>"},{"location":"static-analysis/using-detectors/#detector-configuration","title":"Detector configuration","text":"<p>Detectors may accept additional arguments and options. To list them, run:</p> <pre><code>wake detect detector-name --help\n</code></pre> <p>The output also describes environment variables that can be used to configure given arguments and options.</p> <p>Additionally, detector configuration can be specified in the project-specific and global configuration TOML file, for example:</p> wake.toml<pre><code>[detector.\"detector-name\"]\nmin_impact = \"medium\"\nmin_confidence = \"high\"\ncustom_option = \"value\"\n</code></pre> <p>See Configuration for more information.</p>"},{"location":"static-analysis/using-detectors/#changing-detector-loading-priorities","title":"Changing detector loading priorities","text":"<p>Detectors may be loaded from local directories:</p> <ul> <li><code>./detectors</code> (project-specific)</li> <li><code>$XDG_DATA_HOME/wake/global-detectors</code> (global)</li> </ul> <p>and from detector packages (plugins), for example <code>wake_detectors</code>.</p> <p>A detector of the same name may be present in multiple packages (plugins). To see the list of available sources for each detector, run:</p> <pre><code>wake detect list\n</code></pre> <p>Project-specific and global detectors take precedence over detectors from packages, with project-specific detectors having the highest priority.</p> <p>After that, detectors are loaded from packages in the alphabetical order of package module names, making the first package the lowest priority.</p> <p>The loading priorities can be changed in the global <code>plugins.toml</code> configuration file. See Configuration for more information.</p>"},{"location":"static-analysis/using-printers/","title":"Using printers","text":"<p>Printers are Python scripts used to extract useful information from Solidity smart contracts. Wake is installed together with the wake_printers module, which provides a set of printers for common use cases.</p>"},{"location":"static-analysis/using-printers/#basic-usage","title":"Basic usage","text":"<p>To list all available printers, run:</p> <pre><code>wake print --help\n</code></pre> <p>To run a printer, use:</p> <pre><code>wake print printer-name\n</code></pre> <p>A printer accepts a list of paths to contracts to be analyzed as arguments. For example:</p> <pre><code>wake print inheritance-graph contracts/utils\n</code></pre>"},{"location":"static-analysis/using-printers/#printer-configuration","title":"Printer configuration","text":"<p>Printers may accept additional arguments and options. To list them, run:</p> <pre><code>wake print printer-name --help\n</code></pre> <p>The output also describes environment variables that can be used to configure given arguments and options.</p> <p>Additionally, printer configuration can be specified in the project-specific and global configuration TOML file, for example:</p> wake.toml<pre><code>[printer.\"printer-name\"]\ncustom_option = \"value\"\n</code></pre> <p>See Configuration for more information.</p>"},{"location":"static-analysis/using-printers/#changing-printer-loading-priorities","title":"Changing printer loading priorities","text":"<p>Printers may be loaded from local directories:</p> <ul> <li><code>./printers</code> (project-specific)</li> <li><code>$XDG_DATA_HOME/wake/global-printers</code> (global)</li> </ul> <p>and from printer packages (plugins), for example <code>wake_printers</code>.</p> <p>A printer of the same name may be present in multiple packages (plugins). To see the list of available sources for each printer, run:</p> <pre><code>wake print list\n</code></pre> <p>Project-specific and global printers take precedence over printers from packages, with project-specific printers having the highest priority.</p> <p>After that, printers are loaded from packages in the alphabetical order of package module names, making the first package the lowest priority.</p> <p>The loading priorities can be changed in the global <code>plugins.toml</code> configuration file. See Configuration for more information.</p>"},{"location":"static-analysis/working-with-ir/","title":"Working with IR","text":"<p>Wake IR (intermediate representation) model builds on top of the AST (abstract syntax tree) produced by the Solidity compiler. It is a tree representation of the source code holding additional information.</p> <p>The IR tree nodes can be divided into a few categories:</p> <ul> <li>Declarations - nodes that represent declarations of variables, functions, structs, etc.,</li> <li>Statements - nodes that control the execution flow (if, for, while, etc.) and nodes that represent a single operation ending with a semicolon (assignment, function call, etc.),</li> <li>Expressions - nodes that typically have a value (literals, identifiers, function calls, etc.),</li> <li>Type names - nodes that represent a name of a type (uint, address, etc.), usually used in a VariableDeclaration,</li> <li>Meta - nodes typically used as helpers that do not belong to any of the above categories.</li> </ul> <p>All expressions, type names and a VariableDeclaration have a type information attached to them. See <code>wake.ir.types</code> API reference for more information.</p>"},{"location":"static-analysis/working-with-ir/#nodes-structure","title":"Nodes structure","text":"<p>The IR tree can have a very complex structure. However, there are a few rules that make it easier to understand:</p> <ul> <li>SourceUnit is the root node of the IR tree,</li> <li>FunctionDefinitions and ModifierDefinitions hold statements,</li> <li>statements may hold other statements and expressions,</li> <li>there are only a few cases when expressions may be used without a parental statement (i.e. outside of a function/modifier body):<ul> <li>in an InheritanceSpecifier argument list,<ul> <li>e.g. <code>contract A is B(1, 2) {}</code>,</li> </ul> </li> <li>in a ModifierInvocation argument list,<ul> <li>e.g. <code>function foo() public onlyOwner(1, 2) {}</code>,</li> </ul> </li> <li>in a VariableDeclaration initial value,<ul> <li>e.g. <code>uint a = 1;</code>,</li> </ul> </li> <li>in an ArrayTypeName fixed length value,<ul> <li>e.g. <code>uint[2] a;</code>,</li> </ul> </li> </ul> </li> <li>only a few nodes may reference other nodes (declarations specifically):<ul> <li>Identifier as a simple name reference,<ul> <li>e.g. <code>owner</code> referencing a variable declaration,</li> </ul> </li> <li>MemberAccess as a member access reference,<ul> <li>e.g. <code>owner.balance</code> referencing a global symbol ADDRESS_BALANCE,</li> </ul> </li> <li>IdentifierPathPart a helper structure used in IdentifierPath to describe a part of a path separated by dots,<ul> <li>e.g. <code>Utils.IERC20</code> in <code>contract A is Utils.IERC20 {}</code>,</li> </ul> </li> <li>UserDefinedTypeName as a reference to a user defined type,<ul> <li>e.g. <code>MyContract</code> in <code>new MyContract()</code>,</li> </ul> </li> <li>ExternalReference a helper structure describing a YulIdentifier referencing a Solidity VariableDeclaration,<ul> <li>e.g. <code>assembly { mstore(0, owner) }</code>.</li> </ul> </li> </ul> </li> </ul> <p>The following example shows the whole IR tree for a simple Solidity code snippet:</p> <pre><code>pragma solidity ^0.8;\n\nlibrary Math{\n    function fib(uint n) public pure returns (uint) {\n        if (n &lt; 2)\n            return n;\n        return fib(n - 1) + fib(n - 2);\n    }\n}\n</code></pre> <p>Nodes of the same category are colored the same. Both nodes and labels of edges are clickable and lead to the corresponding API documentation. Dash edges represent a reference to another node.</p> eyJ2ZXJzaW9uIjoiMSIsImVuY29kaW5nIjoiYnN0cmluZyIsImNvbXByZXNzZWQiOnRydWUsImVuY29kZWQiOiJ4nO19aVNcItuy9vfzKzr2/XqpvebhfsNcdTAwMDFcdTAwMTVFQFGEN25cdTAwMTDMXCKTMqo3zn9/M7G3XHUwMDE01CosbbSxT9XZp0NcdTAwMTnKqlWZ+TyZK4f/+9ePXHUwMDFmf02e7pt//c+Pv5qP9Wqv01x1MDAxOFXnf/03vj5rjsad4Vx1MDAwMN5ii9/Hw+movvjk7WRyP/6fv/9efsOrXHUwMDBm+y/favaa/eZgMobP/T/4/ceP/1v8XHUwMDBi73RcdTAwMWH43buL0fNcdTAwMWTtJVx1MDAwZmX+unJQSM6MfDaLry4+9M/FjJr1SXXQ7jWXbz3C64bK19+f8MpcdTAwMDR7/X3eaUxu4TXKzOtrt81O+3ZcdTAwMDIvSv762stp/+dcdTAwMDd5fWU8XHUwMDE5XHK7zf1hbzjCv/1ftIn/W/7lWrXebY+G00Fj+ZlWq1m3dvmZVqfXu5w8Lc5cZktcdTAwMDXL8tfa+Ys/r4+tvVx1MDAxZfYt+IPt20FzjEtJX19cdTAwMWTeV+udXHTeOyXLO8Cruz9pLFb9f5fXNKr2mye47INpr+c/8aDx88T/PJ3l0vOfr/x7eZnNJp6DXHUwMDFhrS0jjOjXd3xcImLF+qvnw8FCXFy45dpcdTAwMWEmlvfQXHUwMDE5XHUwMDFmgJhMXHUwMDE2Z21Ve+PmcqXx0lx1MDAwZddFyC9GK1IyaT5OXlx1MDAxN8wnZMlWsvFoXHUwMDFlXHUwMDA3e2dcdTAwMTf7yVx1MDAxM5qenFx1MDAxY1xyXHUwMDFif71+7t//7T7ty5fF3vRcIpG7bmYnLN+tNcfNqWGD1b/yz9+vjkbDedTzjkslKvdnpVIvVapcdTAwMWSlkrzKuyfRzvvzp+WTnd43qi/rRzUhnGluXHUwMDE49a1wrzPorj/23rDeXS75v3xcdTAwMTe8pqLu1Vx1MDAwYqjoyuK/aCfTXHUwMDFlk4ZzSSmXTIpVXZUqqKuEe1x1MDAwMr7ArNYgQpaxoOoyuV3VnYyqg/F9dVx1MDAwNFwi9u3Vd+WNf/RUUyOZYdw69JRKXHUwMDEzpqdUSU1cdTAwMTkzin9AUVcu5NelcylsKGSwuJdcdTAwMGLwuVx1MDAxYXT8z2w4mFxcdp7x2lx1MDAxOVl5NVXtd3pPK1x1MDAwYo8nSvY6bVxchL/qcNXN0V/+lZh0XHUwMDAwy14/0O80XHUwMDFhvVx1MDAxNTFcdTAwMWE34apcdTAwMTfLtFxcwDr8qSq8OjqJXHUwMDAybcNRp91cdTAwMTlUe4VccreEf+P4XHUwMDFmwaegTFx1MDAxYtS0f5mtXHUwMDE0SsV64WrWy9SSsnLczJxFRlIphGe0tUJcdTAwMWJDtLLLu8J1g1x1MDAxNzxquFx1MDAxNpwqXHUwMDBivyxF6Vx1MDAxZs1lhHjWfyxR4VVz1fKpbFx1MDAwN3SrsmFarW+vte9cdTAwMDBdrbmgmlx0ly5cdTAwMWJK1l991WWiraRW04/o8lx1MDAwN0G3UalcdTAwMGVcdTAwMDf6udZJXHUwMDFh2birJsVF5WRcdTAwMTBcdTAwMTVcdTAwMWNHXHUwMDBmxdThwaw5Lp5cdTAwMWb37puHqYPKLd9cdTAwMDLo6oPbfbGXzl3PL1NV0nssPT2cXHUwMDE3d1x1MDAxMXTdq1x1MDAxN1x1MDAwMXSlJJ5cIsJcbsWlMJbYVUU2ylNcdTAwMWJcdTAwMTWZXHUwMDFh68E54IaIpFpqXHUwMDA3eY5cdTAwMTH4vVxirFxmM1ZcdFx1MDAxN1NcdTAwMDaFXHUwMDBl01pDJFx1MDAxN1qSXVx1MDAwNODr6qhTrfWaXHUwMDA3zXqvOqpO8GZ2XHUwMDE2id+AxnUk3nhv74FknqvKWcaS28ZtUpdcdTAwMDYyI/ab48iQrHVcZsnfXHUwMDAwklx1MDAwNZHEgkJJv9D+XHUwMDAzyb54xDokU1x1MDAwM5pIXHUwMDE5XT6VT4fk20Kl2j147Ndrs6ubxs3RY6szKEWFzsmQ5Eg+czdJ6pPSfH90fDo5fthcdTAwMDIkz6dFm0yWXHUwMDA3V2eJZPaItY+O9q+qu1xiye7Vi1x1MDAwMMnaxJC8a5AshFx1MDAxNJRK7tJaeFxiYVrLrTKEaGo/oLQxJPsg+VxyaPw0SLZcdTAwMTdnLb5XnOjmXHUwMDE5n19cdTAwMWRdSV67SkeGZEoonN/A81ffXGKTa6zFarVvr8fviU1TLjmzlPql9qd2W1x1MDAxYYrJUlx1MDAxMVx1MDAwM3SbfyEk31x1MDAxZujTfLp5fjtcdTAwMTHy4nB+cXB3XetHhc78Q6crW1x1MDAxN73LPqF79YPJcXXeIVuA5Jw9vFx1MDAxYdOL8XltfjW43L+eXlx1MDAxZl3Wt3BeebvfK81p86qbq5+KZKl5N2O9XYR691OJXHUwMDAw9Vx1MDAxNGDeM0JKTlx1MDAxOVx1MDAwNyGUa1x1MDAwNuJtrGfcM4Zz+L414DXSOFx1MDAwMv7LYM8oVVx1MDAxY1Sbc4c5MGJDXHUwMDA0nGlwv1x1MDAxNd9FtD9pXU7gnP3Vh7ZjKP9cdTAwMDbarqO8857eg+6zSm6QXHUwMDE5ntynXHUwMDFivfvrs1l/r65Tl9HRnYHHbbUmSirKOfHtbOLKXHUwMDE5XHLKa+HxWWngP7OUplx1MDAxON2/XHUwMDE23S08XHUwMDA1QkE3XHUwMDFk+lxmXHUwMDE2ONznJtQuNG/5xU9cdTAwMDf4+WRwPnnknaScXHUwMDBlzdFe8rGfoV9cdTAwMDGYXHUwMDFiz5suiVx1MDAwN0Myqj191N3iSbY8rnafd1x1MDAxMYjdq1x1MDAxN1x1MDAwNYi5YJ5loMuKa8VcdTAwMDRhq7pshUc36rKSXHUwMDFlQVx1MDAxNTZCXHUwMDBiynxMMobhj8KwXHUwMDExijE/u/aRclx1MDAxM1x1MDAxYVx1MDAwNaecMGWF0lx1MDAxZklcdTAwMTj5bFx1MDAxNL5oTqajXHUwMDFkdrPfXHUwMDAwxHVcdTAwMDBev533YO/eYVGN2cNl4eCp227dVi4qR7byjmD3KlNcdTAwMTY6mMlcdTAwMTVcdTAwMDe0v1x1MDAwNl45MUpcdTAwMTM/SvroMlx1MDAwYvjUr4pqidRKafmFm8yFbKfA5ml2Os+Z5Pih3chcXDxXoqIg0zfsUZVKJtlpNIuZXHUwMDE5r1x0k9pcdTAwMDK6XHUwMDFlnoyKZp6SpdNytt7Sp6fNdPpiXHUwMDBi501cdTAwMWXfXHUwMDFjn2cy45K8nt7oWz3an9D2XHUwMDE2zvs0TN3djKfTZDdTouNCt55cdTAwMTSVvV1kXHUwMDAz7qdcdTAwMWSBXHJohHuqlDIg19RcdTAwMWa+XdhcdTAwMWGMr1x1MDAwN6xcclXGXHUwMDAzcVaKSXDVpfLBfUxcdTAwMDE+SFx1MDAwMVx1MDAwNNdSW82cXHUwMDFi4TLcskigYkTA09tBXG6Qmlx1MDAwZepcdTAwMTiPPmi2OoPObkfd38DodTqw6dbeQ1xyntXNsNjLXHUwMDFlXGaub/vdcb52NN/vpFwiU1x1MDAwMym0Z6Smgr38u6q8ilx1MDAwYs/3pk9Efitt+Fx1MDAwZsxcdTAwMDe3xFx1MDAxMHC3tDPoXHUwMDFlzFx1MDAxMl9uhCv8nyZf6JTT9vA4z47IXHUwMDAzf6LXp4Vxo3rZuY5cbpf11MNjPVXe66fu55RmXHUwMDFm96Yn7Z3MIXPfZVx1MDAwNLiUWnuKw4VcYm7A+6Kr1FxcSeaRjVx1MDAxYVx1MDAwN3fgXHRcdTAwMDGaXHUwMDA2fpthXCLO4t7ChjWlnFx1MDAxMUFdyGmUXG5VLkWopdpcdTAwMWYq21x1MDAxZOTMVXEtXHUwMDAw5s4641x1MDAxZFx1MDAwZWK/gV7roFx1MDAxOXJX78HLYqc+bDeGXHUwMDAz3qWl56lcdTAwMTnuV4f32Xe40iTGy2+Al5xcYi5Aj1xccGnDN6U0s4xw8Fm+XHUwMDBlLnX+QFx1MDAwZlx1MDAwYq3yZa2Tejg+OyeFbLX+XHUwMDA13vDXwqX7LiPAJdCeXHUwMDE4LndcZi4tXHUwMDA1yYBcdTAwMDV1xbCsXGbHS2s0NcBFY7z8MF6+gV6fgJeV+vCucGrH/Xy12mfX/c7sTJPIeFx0Qsg8yVxiXHUwMDAz7fs+gPmft+3LXHUwMDAw9LhccuZm/vWSTFx1MDAxZKrSRoJJVeorXHUwMDAxs9uqdFx1MDAwYrf7if6eaTT2r0+GudTp/Vx1MDAxN4R5v1x1MDAxNjDdd1x1MDAxOVx1MDAwMTApQVx1MDAwN9NK0DhiXHUwMDA1sFx1MDAxOb6qcW9cIibWOGFCNJVMXHUwMDFhbSxRQY2LIfOdkFx0sKeNpMRFSClcdTAwMTWhXG4mXHUwMDAwLflKUHd3IHNcdTAwMGbf312ofFx1MDAwM7jWoXLtbt5cdTAwMDORpzp1nJw+nJUzj1x1MDAxN0+n2fRz4uIkXHUwMDExPVx1MDAwNMvphlIkY+hbac+Ufj1CNpu1Zqv67XX1PdXBxHCDNtWhwYZcdTAwMDSo8CtCMspB94X8wrxnlVx1MDAxMX2Zzd6yh8pNu5yc1vOFvchcdTAwMTHYb1PF677LXGJcYim59lx1MDAxOKOKSlwiXHUwMDE1UWxN4ax5I42YXHUwMDEx6nHc8JRKWFx1MDAwMcY7XHUwMDA2yC3kL3HChXaXXGbJXHUwMDAwai7zlzRlUmq5i1nEP/9UdfRUXHUwMDAwWTyHddldsHxcdTAwMDPC1sFy0629a/Ny+nTAyjVaIVx1MDAxN7R4fVtrXff65+9cbsZqTSV1XHUwMDE2XGbFyLkjyEnBhzDgkFx1MDAxMNfmpTGh9YCYS6yF8Hswn1x1MDAwZZ2zXppcdTAwMWV08925PZO3Z7WTcTGfv/njqm3dd1x1MDAxOVx1MDAwMTq1Vlx1MDAxZaWcXHUwMDFhXHUwMDExQ+euQKclQktw6527l0FAXUZjmeKWsJ2Mxn4n6HxcdTAwMDPDPlx1MDAwYjrLuT4zZjpcdTAwMWU+0vv6s7pJ3c87o8jQ6Su2lcJcdTAwMTJlVvvHvWInU4ZcdTAwMTFiXHUwMDFj+cK/XHUwMDAzO1utuq3/Z21kSlh9olx1MDAxOXXutehQ7JRWXHUwMDAwLSZf6XXa4/ORuZvUs3ud8mD8mNjvXHUwMDE178q/vSp28CDnl4XrSsVcdTAwMTYrh41Rd1ivbiNccvk6XUo/pmZi/tBcdTAwMTmePVxyT6fH5drVLkK9+6lEgHpKXHUwMDA08VxmmFx1MDAxOMB5zVx1MDAxNOFrXHUwMDA1e/9gfaiFoJJ5lmLOmpbMMpeBiKH+nWFkXCJcdTAwMTix1jiNQXhcdTAwMTDZWMaYkjuZp7RcdTAwMDfYOHrK3jd3vanGXHUwMDFieFx1MDAxYlxiJ4fd13swnsmMllVyd9XIyba6S2dbWkbP7Vx1MDAwNcdcdTAwMTh0XHUwMDE02Lg1Lv9cdTAwMTgg26NEMsqsZVLzXHUwMDFk8Y//XHUwMDAzMZ4yqoRwM3hKwndfjVx1MDAxMUJQar4wubc9vEpz02+dJC7Ojsb9ZDJ/f9mJXG6aXHUwMDBmucF9tVfv16aPpfPi4PHsNj252Vx1MDAwMlx1MDAxOOfGnfunMyOHs7bOXHSePa1lXHUwMDFh91s47/lZWVx1MDAxZFxcnuSnrGmLx6mLJ11sZXdcdTAwMTHk3U8lXG7IS2E8kD6iOCGCk9WO7+AkXGJPbTRcdTAwMTExyP/YNshLsFx1MDAwNMxcbuGKllHCQ9OrjJFg8I2NUf5cdTAwMTdQ/lxyxP1cdTAwMTSUf6RcdTAwMDfZXFyjPpHqKtso66vh6ez0KHpcdTAwMTBcXDGPWyWwXHUwMDA1i8aa/FVcdTAwMTVmmnogUFx1MDAwNiSDSuDxMcj/vsJfwzRz9qlFXHUwMDAyXHUwMDEwptaUK0Mk2Wrl739cdTAwMWNcdTAwMWOHnPcttnNZqndN8mBwYcr9Yucoafv32YvIy5At5U9cdTAwMGJTXU5cdTAwMWTeN9PHrfHkblbewjJ0+qlecy877jVcdTAwMGK0P1MkWehUz3eRlbhXL1x1MDAwMivRXHUwMDE2TFx1MDAxMsewl1BAf9f6fFFwwzy7yaTFpOTHtklcdCy0kdZcbmcnXkqDhVx1MDAxNq+beETCM2JkJyddfFx1MDAxYlryXHUwMDA2RfhcdTAwMTRaspdcdTAwMWM8n2ZcdTAwMWXSV42bQbpcXJ6ZvcbeQ2RaQpmyXHUwMDFlyFxmsYpoYk0oLeGYV1x1MDAxNfOS38VLLFPgaihn+z7Kg13AXr1cclx1MDAwZaZVsW0mfsesZPXjYazk+amrb1x1MDAwNz1KXHUwMDA3U6Hqd7OjgWpMol7ucbp8UbnR8/JzvmO7z6OLYeYuv4vswX2XXHUwMDEx2Fx1MDAwM1x1MDAwNis8zpTG8lxcsDHL61ljXHUwMDBmYZYnplx1MDAwZj+2Tlx1MDAxZohcdTAwMTJcdTAwMTKYnHVcdTAwMDY1OFx1MDAwZi8wkYYqLelONlx1MDAwNf829OFccij/XHUwMDE0+tCSVM1cdTAwMWZrXHUwMDA3SfpUus+Peo/5wakjJlx1MDAxOb53oT3JmORGWdDDtd3H12bgzHDKmc9D+K304T+vblxmXHUwMDFik1x1MDAxOFxyf9VdOVx1MDAxNpyLt1xma1x1MDAxOCqMkF85Nevm1k6L6dqDXHUwMDFkKXr+nKC1xkUvsjv/WbykY++fpv2neqmTKpayJF996Gcqu1xiyO7Vi1x1MDAwMsjSXHUwMDEyz2rQZYBjoexqQdpr2+5QVY67hW5cdTAwMWaOOT5cdTAwMTRcdTAwMWRSjrahmsVqLPbkO1mPtuv9Qt9AxG32XHUwMDBirWYu92wzcZipXFzXjtvDq9zD0fP+O7ZcdTAwMTSAQPsq0laxdz1vIHbdf9uWgrRaW+VcdTAwMWNYuVmLmVx1MDAwMGPM2Vx1MDAxN1Zt34qjweBycNdJylZmry/b5u4kctX2L2TxfS1Guu8yXHUwMDAyRlx1MDAxYWY9IZTC2SpcdTAwMDSY7VrIe30jPqhzlnpGLZtwmniO1S+jpIGFXikt8+/Dh0fGqFx1MDAwMCrD6G5i5ElcdTAwMDP+UKfV8aPbruHkXHUwMDFi4Fx1MDAxNVx1MDAxOGzhuKV3Jdmlr2q5h8azLlx1MDAxZT+Ou9XbXFzuvmgjYyXoJNBXSVxmXHUwMDA16iqsWCW34OVcdTAwMTCPcWGllaCehsRg+ZvAUkkjhXVUmy00NrxcYlxynqBcIkZ/KVamak836f2jXHUwMDBlb89LJ5XH68fE/eXsj9tcdTAwMWV232VcdTAwMDSslIZ6WlJccq4k0ZaYdZVcdTAwMDN+qjeqXFyMlT+2jZXUoJJcYsacXHUwMDFlpZChY2NcZiOWXHUwMDAxnO7iXHUwMDAwiu9cdTAwMDCWb6DXtsGyR09cdTAwMGKj8/PLfGlQT5+VL/ePj/KO0enhm8LKk7jbSFx1MDAwNVx1MDAwMN16uulcdTAwMTIslWJkWZFcdTAwMTZD5ZdCJZhMJaVw9pqmakN/P45DviT/ylx0UOXyXlxuRO04s5dcdTAwMDJAOOtcdTAwMWOMz65bUaHy6mAvc97PTWdnLZa8LOh8htzaXYRK911GgErwQkDhwLm0XHUwMDFhNI5Su7ZcdTAwMTm6xEq3xsVI+WPbSFx0y4xtTFx1MDAxZE1NXHUwMDE26sXC1UtzguHznex18lx1MDAxZKDyXHLs2jZUXlx1MDAxNlx1MDAxZtqJhKwm9tK5oy4565xcdTAwMWVfOSovNzXONExcdEVB+ySlq1x1MDAwNdq+XHUwMDA0KsWt9SfqxGj5pWgpXHUwMDA15t1b5URLqUJ7TTPwSLn40nnI/cHz9HqSu9k7mFdcdTAwMTh95Oliqp2MXG6W6mEqSD2fzmd6qpKajtJHT/2d3Kd032VcdTAwMTSwJFxuVM5cIovhXFxZf2eMtcyhMJWL4fLHtuFcdTAwMTKHilxuokVwxslCv3ioflx1MDAxOS0wvyCOwn5cdTAwMTAt34CvbaMlPZnreXdIiolxs389OHuiV6N3OJaSSk9Trlx1MDAxNFx1MDAwN1x1MDAxZWuJWFfdV7SUTFjQ7Vx1MDAxOC1/V76QUIYywZ1wqX2SXHUwMDFmnFQqcCzxV8ZhSe+yWinMzisknb19YJ2RbLPIXHUwMDAzXHUwMDEw9/Kz6em+6pBcdTAwMWOtT++veSGdylx1MDAxNbaQL/RtXHUwMDA2XG66Vy9cblx1MDAwZUtccsps4HpwxjCngdqBV1x1MDAxY1x1MDAwZVPmXHUwMDE4h39sXHUwMDFih5U12Ew8OKFcdTAwMTT/qDLhI1W4UFx1MDAxModBx1x1MDAwMd6P4fBcdTAwMWLAuG1cdTAwMWNcdTAwMWX0T+tPdyd9dvV8flxc6t2RXFzm4J1VP0JroqTm2lK2OXXIMe4hhuEvqkaWxFx1MDAxYcBTlzpTXHUwMDExPjBcdTAwMWOeXHUwMDFkZ0Z/pdtaSmVV4YzP705v6o3DnKxOXHUwMDFln/tR4TJdXHUwMDEyXHUwMDBmhmRUe/qou8WTbHlcXO0+71wiXFy67zJcblxcXHUwMDAyTnpScM0px41qtapzgdyhoNLFcPlj23BJrVx1MDAwMp6ijXErXHUwMDE43dDR2tJFyWzst35cZi/fXHUwMDAwsG3jZe0kV0hlj2/64qCZSFx1MDAxY42HldGMvyPK+9qGXHUwMDEzU21jtPxHuXZcbi1cdTAwMTlcdTAwMTFAfDVcdCl+XHUwMDBmj0GBaVx1MDAwNlx1MDAxZoZvs3XHmzUuV0+3XCIxe8i1LjPtOZs+XFydlrJ/XFxXS/ddRlx1MDAwMUtihMdR4SSXwqzvh76NlUp6hsBcdTAwMDFcdTAwMDSKaqlNXFyN8uuupdCSMlx1MDAxMmxm+1x1MDAwMpVcdTAwMWJcdTAwMTJtqWRG0Z3cXHUwMDEwPetcdTAwMDC2VXu7i5NvXHUwMDAw1zpOXHUwMDA27uc9INkot2/Hh6KTPO1cdTAwMWRcdTAwMWU89Fx1MDAxZlx1MDAxYolcdTAwMDJVkUFSK+1cdTAwMTlKQNcso8bqtZ3QZdaQYMT4y7VjmPxip1x1MDAxMlx1MDAxY0ezkv/jj1x1MDAxMW1oRVx1MDAwZmrMNbFfWVx1MDAwYlq4LdxV985ujnI3o8v0Zbf73EnnouJkdjpcdTAwMTml95vNTvcxdzLf77ZcdTAwMDZ3T1x1MDAxMWO7X4uT7ruMgJNGXHUwMDEwz6LOXHUwMDExblx1MDAxNfG3XHUwMDE4XctcdTAwMWJcbtO5XHUwMDE4J39sXHUwMDFiJ6lcdTAwMDVcbsqEcvuU4G+G01BuiTW7XHUwMDE5g915oHxcdTAwMDO8tlxulDeNbH92e508rlx1MDAxNDqTXHUwMDBinuV0f3r3nl1Q4yGplUJYYYhcci1GWWT7kXhcdTAwMTf0dyHlYrgqXHR2R3hRrFCg5OCHXG60x1+Hk0/5x5p6MHfXjaPu5W2vPZu1hYiKk3x/0kmWa7X8TX1fqVx1MDAxYVx1MDAxZFx1MDAxY1TOM7uIk+67jOJPSks9iSrHLFx1MDAxNsaTdXK6mmDrULlcdTAwMTgof2xcdTAwMWQopVx1MDAxNlx1MDAxYSilO8PWXHUwMDA0tjBfcZIqSYWUMsbJXHUwMDBm4ORcdTAwMWLYtVWcPOjXjyaNk95TsTs9nlx1MDAxNGvF6n798lx1MDAxZFx1MDAwZeXPlslaXHUwMDE5riRfyy9cdTAwMDAvxlt0U+bUXHUwMDFh8FviQpTfNvxIXHUwMDEznC7jTlx1MDAxNuJcdTAwMWI2UYSgXHUwMDE4UvpCnGyby9P5TbVBR73SdFooXGZcdTAwMGUnj3df0Jvwa3HSfZdR/ElKPKM40cJcdTAwMDBaXG61rnJcblF0k8pRKj2i4smBW8VJXHUwMDAxosGkdueuM1x1MDAxYrqvgVx1MDAwM1x1MDAwN4G97iROpqaDOnat26/2dlx1MDAxOCzfXHUwMDAwsHWwdN/Ue1x1MDAxMFOM23uTXFyzPW7lctmb8nH7op2M3lx1MDAxMWiZXyuYlMSwpWy/6C/XnrA42ZNIyYlPoGLI/FLIXHUwMDE0nFLCQ9p0i2CnoGVeXHUwMDBmeFx1MDAxZThcYuZcdTAwMGIhM1vLNfrnXHJ+9nS3nz+apFVfn3d/X9vdX07b/Voodq9eJJdVXHSPXHUwMDFhgkXYnHAt13VZXG7Q1E26XHUwMDFjY/Hi1e1ugoIvoi2RbsXl4Vx0eTghVFx1MDAxYqF3cVx1MDAxM/R7YPFcdTAwMWLQuH0sTraPb6+L9/lh62xef749K1lSc4zfXHUwMDBlnXpvPC0toUCUiZVyNcjLJfU4aiVcdTAwMGX0MlY6mLQlXHUwMDFl8Vx1MDAxZstcdTAwMTN8XHUwMDFlXHUwMDEyV2XDtFrfXnPfNdXPXHUwMDAyv9YkOFx1MDAxYVx1MDAwM9dXhY/x4qDMkqsvXHUwMDA04sFNopc5OEmdTFx1MDAxZSrDxK3pNa50MypgjkslKvdnpVIvVapcdTAwMWSlkrzKuye7XGKY7ruMXHUwMDAwmGBdPUWIMpJzxcRavyGujGc2K1x1MDAxYyhsPPR+u3DJlVx1MDAxNFx1MDAwMlx1MDAxNty1XHUwMDE1qmhohFdQa7iyOzlcdHdcdTAwMWZQaVStT1x1MDAwZZqtzqCz21xy5d9AsHXI3HRr71x1MDAwMc5xKnU1zKRaRbp/2lx1MDAxZVx1MDAxZCVcdTAwMGKPR2eJyMApJfOoYEbqn/9cdTAwMDaAU/vf3lxy4Gy1mnX7XHUwMDFm5cJiS1vFjbOjvFLhXHUwMDFlrNBAk4n4wvrQajrJh6fq9vj+VFxcp9t76XJj3Ppt+Oa+mlxi+CZcdTAwMDHBXHUwMDE4irxUXHUwMDE0bKNZ9Vx1MDAwN8FcXHpss15IvbqFXHUwMDE5w9uvwlx1MDAxYvp0lrtcdTAwMTNcdTAwMDRUcDvktadcYrhcdTAwMDTWkF0sXHUwMDFkyY2q7X71oIO2uTNr7i60vYEx69BcdTAwMTZ6X+/Btc2zJdb484rugu5xjzKqXHUwMDE1XHUwMDAzSiSpXFwtITGcvDEnhXhSMaLAV9FwXHUwMDAyK5RcdTAwMDPUqOKeXHUwMDE0cHpurOaW2iWBjbX5TaBjYUBHwWAqsjK/fanljk2Z5UhFS1x1MDAxOJH+mW3vgLptotHry/fDzjqSLn/6sZSOxS+vP//vfzs/nVxil0k8gtK4PGFcdTAwMDBxe9XxZH/Y73cmcKc5vMqAxZ1UR5O9zqDRXHUwMDE5tFefX/Nl1V7MwubhXHJcdTAwMGKLVZ+OXHUwMDE3XG5cdTAwMDVEhGDxXHUwMDFm+PDwoKzwfahdvcflXHUwMDBlSERz0Hj7XHUwMDEyNs+m9l1cdTAwMDIsoLCMYS6LwVx1MDAxZbjct9/6elx1MDAxMdxcdTAwMDOzYLHhXHUwMDFjN1JcdTAwMTFJVFBOcWmSaHRum9WA1MM1+9/ze/duK7d5l3uzlVx1MDAxM1x1MDAxNJxsrlxygFx1MDAxZjXrXHUwMDA1rtKs1MlcdTAwMDWNXHUwMDFjXHUwMDEwXHUwMDFiXHUwMDBmPHPBqDRcdTAwMDJcdTAwMTbFsfdEifLAQDJjsf5SML60KrGN+7iN04bgeEnXXHUwMDA2s1xmxrqXPFx1MDAwNifGKvZJbvpyMX+biVx1MDAwYpVIPIKy+Fx1MDAxNVx1MDAxNu495oVcdTAwMTMjubVSabDUhinp+9gv2bjN++IrZpaBM2LB33uZMOtrbfp6XHJcdTAwMTLNoJWagOWQWslPt3CbNyU3WziuPFxyMiqskYxcdTAwMDfqXHUwMDEywcRJhd1cdTAwMDJcdTAwMDU1XHUwMDE4WHbwOIazmaxcdTAwMDDUgf/jjlDQyGnlMU40rFx1MDAxNyiXNjrmcduwceKlw1xydcVcIo0vILRm5CzRXGYsI/1IoP9bXHUwMDE4uVxyXCKJR0BcdTAwMTh3yshcdTAwMTFcdTAwMGZ8J2GUXHUwMDEwRCyMnMPEeUJaysCIgzXXwEw+ZvI2bz+u2l2c9oSsXHUwMDEyXHUwMDFijlpjgtSSeVx1MDAxOFx1MDAwMIC11sRwaY34dJtXTz081lPlvX7qfk5p9nFvetIuRrJ5wFxyPCmBLDMgblxc+Tq7oVx1MDAxNlx1MDAwM/x5QO5cdTAwMDWwfOxcXO3bRnuNO3HhXHUwMDExJcGvpUDOKfH1pvLROsRZyVx1MDAwMKgk55juXHUwMDEwm7xtuK5SKc1cdTAwMTl3uq6bpn6ix8aV+nOJXbhQ4lx1MDAxMVx1MDAxNMdtXHUwMDFhvXVFftv2PKubYbGXPVx1MDAxOFxc3/a743ztaL7fXHTlfFx1MDAwYi3VXHUwMDFhm5fD8/fZ8lePUlmlkblcdTAwMWKwQdbYzzY91fHsrnLEqpVCrXgoXHUwMDA24/P9+omjZ6gj4m25p1x0zmuiXHUwMDAy7PZqcSs8XHUwMDE5T1xiTTH3XFxcdTAwMTLhsDtUe7idq1x1MDAwNMXeXHUwMDFl8JiDdoctXHUwMDE5WmxnfrxcdTAwMWTwXHUwMDE2jGmqmDNvMZxCXHUwMDE5ZlxmXHUwMDBlN9g+hVLYbzRcdTAwMTBcbvvL8/6G/6r3ncSo2WrC06g3/+6M/m40673qy7Ds8d+tn/lBicbrbuff/zWvdpteZ+T5P+n988nK8pPeP9lFy61SXHUwMDBmXHUwMDFlO6zpXHUwMDA0bt1cdTAwMTdd3lx1MDAxY213fSVCoJ2vnOg1jt5rtnxSXHUwMDE3XGKzT4b3ftl9jbH7/spqjH1l6ddcdTAwMDPqzrtdi6VvsFx0yeOb4/NMZlxcktfTXHUwMDFifatH+1x1MDAxM9qOREfAZq1cdTAwMTFcdTAwMTDkW8ziqJpFYZiDgFx1MDAxOOwqrMCUWJxcdTAwMTLmQ8MlXHUwMDAxoczjXHUwMDE4gMO2pZipXHUwMDE374RthYAgy2XaMbhccsVYhFx1MDAwZtHAeVxunPhcdTAwMWJcdTAwMWb+YVxmJFxcKFx1MDAxN+9cdTAwMDbEcZtcdTAwMDQkjGbsXHUwMDFkXHUwMDE21Zg9XFxcdTAwMTZcdTAwMGWeuu3WbeWicmQrITRcdTAwMDOYXHUwMDA1o1x1MDAxNKBcdTAwMTdugFC+tchSpT68K5zacT9frfbZdb8zO9PE7flxK6g0imtNNLXWQXXA9Vx1MDAwM8dEguNcdTAwMDKOXHUwMDFmfFo7XHUwMDA0dbtcXKcyPVx1MDAxZObOhzVxmL9szp/koHG0d1x1MDAxZYXr4Gw1XHUwMDBmvHCQUWU052vTnKVC2sZcdTAwMTU3XHUwMDFjXHUwMDA3XHUwMDFi2GDwXFyol+6QwoA3rIVyeFkx23lv4Vx1MDAxNcftXHUwMDE55VxmXHUwMDE5idA+XHUwMDFlXHUwMDFhPH6hP6PsSmlcdTAwMTDngO36PXSnNmw8RSY6q1x1MDAxZv4mXHUwMDE0Z+1cdTAwMGWjk1x1MDAxYrE3vUjkrpvZXHTLd2vNcXNqmMPhcZBcdTAwMWJDwS0lXHUwMDEyXHUwMDFjUkVcdTAwMDGn6GqsXHUwMDA1xyMoXHUwMDFjVmM47lx1MDAxOTJcdTAwMTacmUk194yUXHUwMDE23pNcdTAwMTZcdTAwMTTDYVx1MDAwNbC7iIBTS6K54P5+brFR+Fx1MDAwNaaj0J9cdTAwMTbKPVx1MDAwMMWG+kaMXGLDpZJcdTAwMWaaxvctmE5cIlQm8VxiSONXXHUwMDEwnbuL0fNcdTAwMWTtJVx1MDAwZmX+unJQSM6MfDZhWVx1MDAwMlYv0lx1MDAwNDCtXFzQd2dcdFx1MDAwNC9ve2SDJU6vJ5c2/VBp3Fx1MDAxYz/og/n0LGeikFxyhUm0glx1MDAxMHDMXHUwMDE32YCrY+xcdTAwMDFnPFx1MDAwYlx1MDAxZlx1MDAwMVpHrdA6mEpomEeoUtjnXG7pnzOVMOZcdTAwMWHv4lx1MDAxYdpwwiRxT/NcZlxy1Fxu4Iv6g9PJ3jBcdTAwMWXglfg2XHUwMDFl36BcdTAwMWH95qT693g4XHUwMDFk1ZuJKVx1MDAxMIQltcB3vJd3KviOd7n4+Vxuf7xfJOW9I1xcsv75b0IkgvdcdTAwMTmdS2yu29nIJUCNwUFcdTAwMTJcZmTEKGlW96qZNVx1MDAxZVx1MDAwN9dcdTAwMWPj21x1MDAxNnzQYMej5a2+KrWwXHUwMDFluCfMSDCHjGifsMY6/nHqIDBcdFxy1tWZRbyhXHUwMDFiJ5VEXHUwMDEw+6FJS9+COKx8OiB6O8ZcdTAwMTPgUYBvblx1MDAxOZBcdTAwMWSrqda+XFzIZSafX9+YXGbIQ6RcdTAwMDDJ5pqe1Wti2irGXHUwMDAwxFx1MDAwNfAr5ksk8V1cdTAwMTS8wzXHjX1mXHUwMDA0SFRQSre8XHUwMDFiVExcdTAwMWOlpszOXHUwMDFmJlx1MDAwNXZSTLL5cWNcdTAwMWOFtFx1MDAxOIv9hTkxXHUwMDE0boVxu9qbhlx1MDAxM1x1MDAxMFx1MDAxMHCOtOVcdTAwMDL8b2tcdTAwMWRcdTAwMWJCRHqwXHUwMDEy1iorXGZcdTAwMTPMXHUwMDA3qzFt+XBcdTAwMDWElNRcdTAwMWbqWJouXHUwMDE22veJXHUwMDAx9+TcXHUwMDE3NNya5Vx1MDAxMmyln9ynsJb6zyq56LzF8Y1vwlxcXFz3XHUwMDFhnbswfcNcdTAwMWVVqWSSnUazmJnxmjCpLXBcdTAwMTdBiYc5eExcdEGNYkFVZ57SXHUwMDAyx1tcdTAwMTEmhPY3qnrVdIn1wFxcgs8pOdhcdTAwMGJcdTAwMTYn2W0p41x1MDAwNPxcdTAwMDZcZlA5LEJwjNWrRaBESCn+5FTiUJHEIyCM22Q37883ec9GXHUwMDEwgC7GsIBpwELzZcepXHUwMDFmy1xcN4FtyFxicFx1MDAwYmbwLj+bYZy2r/L5YSplXHUwMDA2VTvsX1x1MDAxY5G72qVj1k+QYVx1MDAwMC/zXGbXjMBTkHKtgVx1MDAwMFxcvCc5NuShTFx1MDAxOKFigvE1XHJ34GFo6e9cdTAwMTHpY1x1MDAxOKFRVVx0XHUwMDBmkVx1MDAwMqHdvm9cdTAwMDT+h3+47Xu2YP5cdTAwMDHTt7dg/vmkf1x1MDAwYiZYnP+6U1x1MDAxM52JOL7xTZiI616jM5HDk1HRzFOydFrO1lv69LSZTl9EY1wiRHtaXHUwMDAxMsFzt1StTTWRXHUwMDFjrJsxIFx1MDAxMcBDlNCOKIqHXadxy0ZQMOyUOqiIlVx1MDAxZTiNwHOYXHUwMDA0t0b7wqmxifg4XHUwMDE1XHUwMDAxP1BwXHUwMDE2XGag4KXYTZMzlVlJKvvDiEi4QOJcdTAwMTFcdTAwMTDFbVx1MDAxMpFfplx1MDAxYkj7gUNxQ1x1MDAxOFx1MDAwMcZhSLCY6INpJ8VOfdhuXGZcdTAwMDe8S0vPUzPcr1x1MDAwZe+zIYxHUVx1MDAwM4jEXHKVVitDg6kvylNG4PpisIIrXHUwMDFklNDtXHUwMDEynpLNmptki4xm7Ta7S2aql1x0WopcdTAwMTRSYdSjcCNA4SxcdTAwMTVEroZUpGJcdTAwMWWutLJSYD5x0LhRa7FunXNgdURcdTAwMWFpXHUwMDFkxi0mPO8jPDhhzYJwc9dGslxm3Vx00spayej2/ScwXHUwMDA1jEVcdTAwMGWpfG7Oyag5mY5cdTAwMDaVXHUwMDBmZNpu+OY3IUCb7j06XHUwMDExXHUwMDFhPVx1MDAxNFOHXHUwMDA3s+a4eH7cu29cdTAwMWWmXHUwMDBlKrdcdTAwMGXfyEGEXHUwMDE01Vx1MDAxZVx1MDAwMXRcXOSW4YCjXHUwMDE1W1x1MDAwMVx1MDAxZY8n0DlcdTAwMDI7wrHBRZBcYlx1MDAwNU2DpuBuXHUwMDE5i9NSNCXGxJko2+A9XHUwMDA2XGZcdTAwMDEl1j3ejYU2XHUwMDBiR69XWfNcdTAwMDeHYFY+XHUwMDFkkL1tXHUwMDEynfdHXFz6l9lKoVSsXHUwMDE3rma9TC0pK8fNzFlcYv/AsnuF2Vx1MDAxN8hvpVx1MDAxNsFdXHUwMDFk5lmmsGRcdTAwMTNcXFx1MDAxNpBcdTAwMDTz6dWFj+knboyUrXaaq/lcdTAwMDW7vC/lXHUwMDBmI2WicOBTQlx1MDAwMouSmGq55l7Bk/GU5lx1MDAxMlxcK1x1MDAwMU6YL55cdTAwMTJcdTAwMTf5fGLTRlx1MDAwNv6uUc7ObuE1g4oqqSlcdTAwMTPbT0VZVMi+b1PnXHUwMDE1JVx1MDAxM73OeH1f5/XNXG6+6eX++fVcZn+Lq3jeXHUwMDEzVlx1MDAxOVx1MDAxZV3mTlx1MDAwN7XTTN6k1ek1uSql91wiOVx1MDAxZZx5XHUwMDA0N3hcYuNcdTAwMTT8zNVcdTAwMDQ0TcCt4Fx1MDAwMFx1MDAxYlKD/8FYrPZf4nhYhnlcdTAwMDDOUlx1MDAxZErDS3WkXHUwMDA1w82s2OJU2Fx1MDAxN+maXGZJjuQzd5OkPinN90fHp5PjXHUwMDA3XHUwMDFmJlx1MDAwNvjq6ztcdTAwMTFaOlx1MDAxYcGsJH6hj43KP6L/e43K5se+OXveeMZKTjCYYSRfLaFZd1GCyfPMU4xcdTAwMWGQZ8EkONO+nLily8I8rjinklipmNaxjdnKrjGCgMTxNFx1MDAwZduzIVx1MDAwNVx1MDAwZfdcdTAwMTMpKPOf6rGEXG4kXHUwMDFlXHUwMDAxUdymXHUwMDA3XHUwMDEz5qdsRnyfn0I9ao3FUiiutMBAfMBLocLT1GKVI1x1MDAwN2+GMlx1MDAxZHRTXCL5TjxXlbOMJbeN26QuXHJkRuw3xyG+k6RGgZtcdTAwMGLOXG74T4o4d6uBk1x1MDAxOJxcdTAwMTEqLabGf7rv9JTPzvbFdO+60Mjf3uVcdTAwMTInXe3K4l+Y5Fx1MDAxNXNHwWX3KLh4mlx1MDAwYmL9Y9lcdTAwMTfmzmhPY/hOKKwppMGKQSqUJ1x1MDAxNYg6tqzSTDnMXHUwMDFkg0eEm1x1MDAwMZZzZVx1MDAxNrNkYnu3XHUwMDA1e8eA+3IppHCOPrXhfVmMXHUwMDA2kSTkj035XHJcdTAwMTVJPILCuE2LXHUwMDE3XHUwMDFls/l4XHRcdTAwMGa+t0Hz81x1MDAwZp2ubF30LvuE7tVcdTAwMGYmx9V5h0RiOpRcdTAwMGKBaTVAYilhilx1MDAwNOIm3JNcdTAwMTaRXHUwMDAz51x1MDAwNjLXsFx1MDAwYq49TjV2XCLmOElXO3pcIkjhXHUwMDAx79eLZFqQOkPinlxiW0n315wwI5mzUHBcdTAwMDPZXHUwMDAxn9da+1x1MDAxOVx1MDAwMZZcdTAwMWRR/kS4UOJcdTAwMTFcdTAwMTTHryA8+dJ5Roz3S+Obk1S32mtcdTAwMTZ7fHpcdTAwMWJCLjhn2L5bYG83KWiwXHUwMDA0gFx1MDAxMk9gXHUwMDE3X0U4lvFcdTAwMTNcdTAwMTHMto/EeOzFWYvvXHUwMDE1J7p5xudXR1eS167SITVcdTAwMDBGK62VXHUwMDEwimpYV+a4KE9o4JBAdlxiTs4x0lx1MDAwNCV3u4ynY++fpv2neqmTKpayJF996Gcq0e2ehFtcdTAwMTJYnYZJXG5rdo9cdTAwMDHDXHUwMDAzJ49brqkyrvpo5Vx0JizgKFx1MDAwN05tXHUwMDFkXHUwMDE5elJ5XGZ7RVx1MDAxMCpcciZrxkNcdTAwMTG24+NcdTAwMTlFkXdcdTAwMDfnui+MW2hqMEivXHUwMDA0XHUwMDAxtn+s2Vx1MDAwYlx1MDAxNUk8gsK4U0aPeDhcdTAwMDeaKiuxwbuU2nfxP82LXHUwMDA1h1xuh2RcdTAwMTjsdkOB0n3M5EVu7I4pyVx1MDAxY3w8cIkttu+Aa4pStL1lXHUwMDEzt3lcdTAwMDU39YFcdTAwMDFcdTAwMDRcdTAwMDEgkYuJ6oZrvZqTo7T1KFFsXHUwMDEx5LLE1W4zXHUwMDBljf/4XHUwMDE1k+ZuXHUwMDA0XHUwMDAzeGNxLpzDdoVnIXNrNXz1Y1x1MDAwMyBeRdZcdTAwMTFcdTAwMTnf7DisSNi7pupuXHUwMDA25o3nXHJcdTAwMTijgLm1QHts5Ig76OPkZTH+rqFcdTAwMTVehtuX73iLd7y9xb/LlyPH2F1f+SYxdufdRo+x64PbfbGXzl3PL1NV0nssPT2cR+tcdTAwMDYsccpcIrVcZrgkdjmWq1x1MDAxZGpwkFxyvqvB2FvlyFx1MDAxOHRcdTAwMTWVa1x1MDAwZlx1MDAwME5cdTAwMTNcdTAwMDPfXHUwMDAwbq9kbJy2klx1MDAwNiSNXHUwMDExjDrdTFx1MDAxM5pcdTAwMDVEpeBcdTAwMTR4xodcdTAwMDaMf1x1MDAwYrq1WlVcdTAwMWWQva+gV5GTfUCZiFx1MDAwMI1cdTAwMDMgIUCzpFx00ivw3sBXxmJai4+bfpRfnerUcXL6cFbOPF48nWbTz4mLk0RcYr9CXCIqrcYoXHUwMDFjJ1JcdTAwMDWD6NyjXHUwMDAy84+4XHUwMDAwJmZcdTAwMTgw2M/mW/Np0SaT5cHVWVwimT1i7aOj/atqxE1D6lx1MDAxMWIk8mu4arXKt9CgWYXjP3BcdTAwMTODyiDfXCJcdTAwMWWlXHUwMDA0nlx1MDAxMJaMac2wL6LDxlx1MDAxOY8wXHUwMDAy1Fxmu9RLXHUwMDEyXHUwMDE3eGwnilx1MDAwZfxKrGQn+5uLhlx1MDAwZeZcdTAwMDJcdTAwMWTBvuj6XHUwMDEz+lx1MDAxMe+IjUtsXHUwMDEwSjzWxfErjF7kXTowetxyIbHKXHUwMDAyeITmLqOntVx1MDAxMVx1MDAxNKdcdTAwMTLgLspcdTAwMDdN3vP06YCVa7RCLmjx+rbWuu71z0NMXHUwMDFlmFx1MDAwMC0oZWD6KLjqrolcdTAwMGVcZs2HXHUwMDA2j81cdTAwMTKuzad3XHUwMDFh7aamlcmzvTtU1yeNTP/koTkx+1E8TFx1MDAwMFxuXHUwMDBmhYJcdTAwMTBsXCLIfeK6MHiCeeA2XHUwMDEygEVcdTAwMDPOJneE0OIq11x1MDAxZlt3MIlcdTAwMTZWXG7rZGs8lK1cdE2pJFx1MDAxZnEvN5sxXHUwMDBipsM3fe09NVx1MDAxZrPqqFOt9ZpcdN+rIUVcdTAwMWb/fLTie9W7/vnige81lOXKXHUwMDAwXHUwMDE2NrJn5/jGN3HsXFz3XHUwMDFh3a87vcjx+cEsMT/IVFMk3Zf51P1dtIRM6mH9lrKWMkrMmlsnqMdxXHUwMDFhXHUwMDA2plx1MDAwNVx1MDAxM+XYToxtwo+t21x1MDAwNFx1MDAwM9pcclx1MDAxOFx1MDAxZOya8deiNXGYUVx1MDAwMFx1MDAxNcZm2Fx1MDAxZmo/vDHqtJljr1xi2Fx1MDAwN6JDXHUwMDEyM1wiYpPz7UxOzlx1MDAxZV6N6cX4vDa/XHUwMDFhXFzuX0+vjy7r0TbziFx1MDAwNKNDuFJcdTAwMDa4XHUwMDA2YWszkZld9ENcdTAwMDepXHUwMDAww2JYsKJcZihcdTAwMTfQLVx1MDAwZaKO+WWcXHUwMDEx1Uz4kqD8XVx1MDAwYrGbMlBzTZjhsVx1MDAxZNpOeb3CgV86WJGKXHUwMDE0M7y8nlx1MDAwM39cdTAwMTaC/blVZonNYolHQCCX51xmXHUwMDE4yq35X+/IXHUwMDE5kFZcdTAwMTlJXHSTZlHcvbXZXHUwMDBl5Vxcn1x1MDAxOTNcdTAwMWRcdTAwMGZcdTAwMWbpff1Z3aTu551RmMNFcdOXMmtcdTAwMDTBzU+HXHUwMDBmaKxcdTAwMTLgkMEnXHUwMDA1XHUwMDEz/NNDTInjbunu8up03t/vtGZqUlx1MDAxYT3tO6a/O0c7SHAgXHUwMDE5UCNYWWrXSmeRXFxcdTAwMDFpQt4lNfW7XHUwMDAwMbv6RHbFiCCYXHUwMDE44/S4wtu1a1xmxZJPaCyEnE1HJkC+7bFOK/H6m3OXrNOqvP7mnbQuX39cdTAwMDaO0FhcdTAwMTTWRyY5jm98XHUwMDEzkuO61+gkR97u90pz2rzq5uqnXCJZat7NWC9cdTAwMWHJXHUwMDAxUPKwSMFyMKdKkNVSNyxZgdeFwIhcZlMkXHUwMDE4btHWM0py+CZcdTAwMDNEIcaxnS8lxsPAUqKpNJrJOGNpK1x1MDAxOUtcdTAwMTS8XHUwMDEyq5hzpEP4VHRBMNuF/Lk7aKFcdTAwMTKJR1BcdTAwMTZ3itzg7lx1MDAxNdAus0hcdTAwMGVcdTAwMDIu6lx1MDAxYmf7Y1x1MDAxOcqloIlgjlx0QVx1MDAxN9xo/jG6M6vkXHUwMDA2meHJfbrRu78+m/X36jrlXHUwMDFjko41/YJzQTigP1x1MDAxMELpjC+DXHSBq1x1MDAxMlRTQVx1MDAwNP/0+LJq5fnd3XRcXDjoqafjh0HqZnbUj0R34JlcdTAwMDN9XHUwMDAzXHUwMDAyjI2kgN2u0Vx1MDAxZMxNx1x1MDAxNKZFa1dnXHUwMDA2U0x3fmyb7mjJwVljzlx1MDAwNCa+IedcXGn4XHUwMDE2t1unO4ZQ5W/h/Vx1MDAxNXRnMpo2K+9cdTAwMWFb5fjGN6E7rnuNTnfSJfFgSEa1p4+6WzzJlsfV7nPEXHUwMDA0bcYx4Vx1MDAxM2wrOLaSqtWgjuXaXHUwMDAzUFx1MDAxMDhbRoNn7Fxu6lx1MDAxMCo0WDolXGZcdTAwMTZcdTAwMTC6OjdrjylcdTAwMGVvS1x0n1x1MDAxNL5IaGxcbn6F7SiL4+qtazddhW+mM3Dp8XH9sVx1MDAwMZ1QicQjIItfwXZcIlx1MDAxM1x1MDAwYiQ7XFwyXHUwMDA112Y0XHUwMDBlfHJVf1DDuCbwXHUwMDExjEk5wiiRuM6gf1p/ujvps6vn8+NS747kMlx1MDAwN1x1MDAwZiFcXEfgzFAhwFx1MDAwMeeY4ewoXGb2QFx1MDAwZTnlXHUwMDFje//i6K1PJzvXo6f708vbXqnfuUhcdTAwMWXnRlbdZSaRyFx1MDAwZVx1MDAxN9QzVEtcdTAwMDXrh/2YVs2dXHUwMDE0njVKIIxcbmDMjtBOnK39Y9tcXFx1MDAwN3vJoz9cdTAwMWRSXVx1MDAxYmbJQP5x7OL2R1x1MDAwZVx1MDAxYlx1MDAwMuLBP8J1Xnr+vcF3fjZcdTAwMDZcXHKei8VcdTAwMGJe8/F+XHUwMDA0i/Se8I7rK9+E8DjvNjrjyd5cdTAwMWRnXHUwMDA3qbvUaXV/sD8uXefTV3flSFx1MDAwNkBcdTAwMWHrXHTM/SFgPZm/LfzC27HYr01oTsGhZNZViVx1MDAxYluAXHUwMDFm27ZcdTAwMDBAMHFcdTAwMDaQy9dcdJ3aS1x1MDAwMZVcdTAwMDR4m3rrcVx1MDAxYkNcZnBh41x1MDAxN8tY/3dM/y9nXHUwMDBmZZV+bp3z+zmpPJXOk8OSjlx1MDAxNu0g3Fx1MDAwM2g3XG5cdTAwMDe56/X4LqVMeVx1MDAxY+veXHUwMDE09mpUxGFcdTAwMDC09Fxc5fex0r+7SMtSoYRzVETQq3kt0jKA+pqwrWfRXHUwMDE5Kri2kbPollx1MDAwMjz+u1x1MDAwNpI9ekpcZu+b69ksvk95L5+qvH7K21u8kH39XHUwMDFkXHUwMDE1sPJcdTAwMDEzXHUwMDEw+r1vYlx1MDAwYsLvO7pByHTO9lPnw+nRsVx1MDAxY5/dlvnxfZZFXHUwMDBif1x1MDAwMtfzsCO6XCKWW8P0KiGgRHNcdTAwMGZlQ1JcIpWxjsGb1GhcdTAwMGZcdTAwMGJcdTAwMTEk0Fx1MDAwNblcYqXHxuGXXHUwMDE5XHUwMDAxIVx1MDAxYSiWXHSZI7NpMJXFTHq29Wy687OyOrg8yU9Z01x1MDAxNo9TXHUwMDE3T7rY8k9cdTAwMWP4sVx1MDAxZWd7feftbDpDwen0hXW/3vSMUE4/YnvCv/hNjM+GO49ufY7T5YvKjZ6Xn/NcdTAwMWTbfVx1MDAxZV1cZjN3+WhcdTAwMDFYXHT+hMJuylahM7FcdTAwMTSCXHUwMDE3OmKZZ60hTDJh0WtcdFhcdTAwMWawXlx1MDAxNFxcXHUwMDE1bYxijFx1MDAwYqtcdTAwMWT+iEZOI+Agmlx1MDAwMfHx1XnGxujHx+uZqII/Kd2N28P3m1x1MDAxNeaQaf5cdTAwMDdXM4WLJFx1MDAxZVx1MDAwMWFcXJ4vYCi/YnZecvB8mnlIXzVuXHUwMDA26XJ5ZvZcdTAwMWF7zkgo8YBcdTAwMWXwReNDI7SQxFx1MDAwNqOzzCOWYHhcdTAwMTk3Uik8k09cdTAwMWael+1272utnr5Oneebt8mzXirRSUaLhCrhMUmAhcOT4HJ141x1MDAwN9wk8HKIopSDbVwiNk5y+5LpvCBdVPs34ZZcdTAwMTYlaGZeIyFcdTAwMDTTXHUwMDEwQZO2XHUwMDFmXHRl4Fx1MDAwMavIkVx1MDAxMD8veZ0lXHUwMDAzyN1zk5LXITL4kdfxMfv4S3XUnr6vN4TjXHUwMDFi34SAuO41OvPYy8+mp/uqQ3K0Pr2/5oV0KleIyDwkWGLwpjlcdTAwMTadXHUwMDAycqxWUlNcdTAwMWNcdTAwMTbFJY6TXHUwMDEyWENcdTAwMTRs6s7AbVKSSmZccjZcdTAwMTR3hEQ08Sw1aEsoXHUwMDBlhFCxOdjOzF5sLVx1MDAwNXbC2ZkrfORcdTAwMTT4RWBfXGL9c5lHmETiXHUwMDExkMVt0o4wciHG7b1JrtlcdTAwMWW3crnsTfm4fdFO7rvJhWLweFx1MDAxOFeUXHUwMDEzXHUwMDA2XHUwMDFh5yqiNtJcdTAwMDC74EJywSzjwb5/kVxiXHUwMDBmPZnreXdIiolxs389OHuiV6OB65ow905boDFcdTAwMDSgRVx1MDAwYuyR6LgoaphCXHUwMDFlZ3FUMFx1MDAxMZ/ejHCYp+ThQFx1MDAxY9T2m7J21Js9zFLJ68g7P1x1MDAwYvFQwoC9W1x1MDAwZvRcdTAwMDCd9zAkXGaIp4C5xjs/XzMu2HL0b117Pya0KsngV7DBytZcdFx1MDAwZrZcdTAwMDT1XcyXXHUwMDExnnjz5z0ljNlS/rQw1eXU4X0zfdxcdTAwMWFP7maOzV9cdTAwMDfn0ZYvUmxwtDk4cqvZXHUwMDFmgFxyzMOUXVx1MDAwMsbOYHuZoFx08DR4d2BJXHUwMDE2TemtP/ng1Vx1MDAwNCg0I4xjfYAh3Lc9XHUwMDE5XHUwMDFihF/hPJJcdO5cdTAwMWWySWn4JjE4RlJcdTAwMTC1/d2iXaE8iXCRxGNdXHUwMDE4t0l63lx1MDAxZmt5pFx1MDAwN9lcXKM+keoq2yjrq+Hp7PQohHpohlx1MDAwMzSsXHUwMDAxMiQodVBcdTAwMGbmMVx0zlx1MDAwYlAlYzhOef/0WIt6mFxuUs+n85meqqSmo/TRUz9aXHUwMDFmZKuBKCktMVx1MDAxZlx1MDAxMchcdTAwMDNcdTAwMGZcdTAwMDRbsImOlNhcdTAwMTFMYFx1MDAwM66A4Vx1MDAxMVx1MDAxY3vOUty95sZyw1x1MDAxZHtMynjEKlx1MDAwYvRRMSZ8U7hiw/NcdTAwMGKGx1x1MDAxMKHhXGJm1G5kKMCKLahcdTAwMWO1f6zhXHSXSDzWZfH32p3L4kM7kZDVxF46d9QlZ53T46tymMtjXHUwMDE0eFhESku0lsv8I5/d0XjPVChcdTAwMGV3L+inXHUwMDBmnCk+lbrDW3WUtI1aq3p7IHpcdTAwMTfP00hcdTAwMWVcdTAwMGb4+kB3XHUwMDE0U4vew1av81x1MDAxZCo9XHUwMDAwVSbBelLpXHUwMDFmSFx1MDAxM7s8n5j3XHUwMDAynqeF/5jLomzogqetsPBcdTAwMDD49vPdOFx1MDAxMzZ6vmvs9PxcdTAwMTanJ90t317nes+jh3H2nGX2XHUwMDBi/V7WscXsaFx1MDAxNVx1MDAwNUaAXHUwMDFh7GthwFx1MDAxNlx1MDAxMLGW8MZcdTAwMTjxcHYnNoXXTDl2mOOdnsWrW25ngI1cdJR2bvWEN5B7aen1XHRcdTAwMTFcXMNcdTAwMTRuSn+9XHKId3qiXHUwMDFhgE4/1WvuZce9ZoH2Z4okXHUwMDBinep5JO9cdTAwMDP8XHUwMDBlXHUwMDBmW8RcdTAwMTCjmJBKr3lcdTAwMWacXHUwMDAyWdOGYPMmLlx1MDAxOVx1MDAwYk6eM9JcdTAwMDOp48B2OFHgT7uK/IzHmMZ5X1x1MDAxNrfAadwydyveh8DRXHUwMDExhlhnjkmw++RrgJRhQc1cdTAwMWZb4pdcYlx1MDAxNUg8XHUwMDAyorhN5+OXQ1x1MDAxYuBhSCM5JsBgSEZcdFdkQzBtcFx1MDAxOFx1MDAwNdPgQTHxwYZcdTAwMDYsfVXLPTSedfH4cdyt3uZy90VcdTAwMWLi9mBcdTAwMGb5xZBcdTAwMDCpuCW++T6vV8U9i9PrOHp0Uij46Gc7Pro6nz3avr1cdTAwMTD9SZ3eXHUwMDE1+62b8klcdTAwMTTKXHUwMDAzK+wpjqusXHUwMDA0LN/apE1cbjLjgTtDXHUwMDE5uK3a+lO14lx1MDAxY/9t+zqWg9A4WY5cZo3aXG5cbiDFPzSg/I1cZn+mXHUwMDA1/dDuTpzh/9sz/LPTySi932x2uo+5k/l+tzW4e4qW6aJccvdcdTAwMDAlXpRd+1tTvphcdTAwMDOcXHUwMDE5QLRlgFx1MDAxNYopXHUwMDExjL7i2CxlKTjfXHUwMDFhPlxydtlhXHUwMDFhXHUwMDA0JtNcYiPASZLMSlx1MDAxOefYbmX45qLmXHUwMDAy3FeHXHUwMDAx0aFcdTAwMDbEXG5O/+hEl0S4ROJcdTAwMTGQxW0yoPeHX1x1MDAxYuX27fhQdJKnvcODh/5jI1GgKoSHXHUwMDE4rL0zmKiEOWky2GyAeVx1MDAxNkNcdTAwMTDwnlx1MDAwNXZEiKPb05ZpyOGdXHUwMDE5XHUwMDBm95tHrctcIjktdi5cdTAwMGX7rH5cdTAwMTaFhlx1MDAxOFwiPK6t5FxmXHUwMDFmgpXrdkdcYk8zXHUwMDAxjvdcIu3HOsKvcWXRj61TXHUwMDEycHK1NNplUUT4RjLXXG6+KT9UV/RcdTAwMDYpscb6bjau/flmtT9y8CDnl4XrSsVcdTAwMTYrh41Rd1ivpqJl4Fx1MDAxMmKBmICpQylcdTAwMTC+aZw/my9hr0lcdTAwMWMsXHTePJiIoJtcIqlcdTAwMDcwXHUwMDA3QIdcdTAwMWI02JY7aFx1MDAxZaT0uJWKSFxu3pCVNqYlWyn9XHUwMDAxm62Eck4y2tB7yVx1MDAxOEYkp9tvz7YzvCRUXCLxXGLI4jZpyS83scZcdTAwMWXW0uJoXFxAa4BtXHUwMDEyXGaBUE9xQlx1MDAwNNc4LJFcYsU/XHUwMDE4mKlmLvdsM3GYqVxc147bw6vcw9FzSFow0Fx1MDAwMvhTyIhcdTAwMTjDelxmV1xchjJjXHUwMDE5XHUwMDEwXGbgfJTyz9+Qrlx1MDAwZY5zR9n8bdJcdTAwMWXkXHUwMDFmXHUwMDA3vFkq85JjhECQXHUwMDEwaWU97CDFhLW4v1x1MDAxZey+tFx1MDAxOFx1MDAxZFx1MDAwMMRcdTAwMWQwWjj4UFx1MDAxY5bZXHUwMDBlXHUwMDA3XHUwMDEyWlONJNthv3w7wYGWK1x1MDAxMjue6k9ouYRtW+nvLICOIzO/XHUwMDEwmbktlbtEmFx1MDAwMzq7vn5O8lx1MDAxYlx1MDAwNVpcdTAwMWMtMlx1MDAwM1x1MDAxZZLGuWboqVx1MDAxMuWDzlx1MDAxN/lcdTAwMDd7gTF8XHUwMDFjbMB8kXKfg2SwXHUwMDE1L/j7ilx1MDAxYXCknOkp0iNcdTAwMDZ8RsmNUdrfkHunbUWjOr5t7jBcdTAwMDVcdTAwMDJvXGJcdTAwMWJoXHUwMDEx7ZyxLcM78iM/UNLwP5dcdTAwMDRRTT2JJcJcdTAwMDJcdTAwMWNNXGZSrFx1MDAwNGdcdTAwMTLYbpkwbinItcXiWvH2XHUwMDE5w+T89V3DpcDW51xmnFQj3z6hVFx1MDAxZWhcdTAwMWTHTvdwupWhIThcdTAwMTMloDTbpGrhXHUwMDExpOC3tsdacqdGl1x1MDAxZlx1MDAwN9djbY5cbons3tXgIOGwUlx1MDAwYmv6XHUwMDBl1oI80Fx1MDAxM9pi30hcXDBcdTAwMTPcPsd6ePBcdTAwMTVcdTAwMDSgLnh7nLjNlKc0XHUwMDBlXbfwPIQx36RJ7s5bKU20oowyZ3O5cE+Ng9xr4m9cdTAwMDb0p1x1MDAxOalwocQjII67rv/43lx1MDAwNuU/6er2XHSdXHUwMDFlXU+S8+ZcdTAwMTPnyXKu3Y6i/JRh6j5cYlx1MDAwM8cwrJVyvT2UZJ5YMFx1MDAxOFx1MDAwZVx1MDAwZlix4EBcdTAwMTCpXHUwMDAwXHIkw2g2s8yfXHUwMDExvlR+QFx1MDAwNGlB3qSSwmBaQKz9W9k9XHUwMDAyh5iATXZWXHKRUIqCpTSgo3+u7nPlSYpKj9OapU9o8VxiXG7jm+dcdTAwMGJcdTAwMTVxPKj2NHB3oDlcbuNcdTAwMTPku5uS871cdTAwMDdzdDx/aKZcdTAwMWJPl3elq/a88OzouOIyJUp72EtcdTAwMWbza6igdj1cdTAwMGZPXHUwMDEz3LbjRmJxqz/N9tWUSFxy1FHi8GGMXHUwMDBiu3hcdTAwMDQnmMtDcb/CYJXzd+m5sOumXHUwMDA0ebXCgW+ukC9cdTAwMGJvV0klPC4p/mgmQXCWOnZcdTAwMDBQXHUwMDEyu1KsjK5PUG6w9E0xS63Bglx1MDAxYf3mXHTBYHvoIGKclVpFzcpcdFx1MDAxOfw9KVx1MDAwNNBcdTAwMTMsw1H87fNJSj348KJcdTAwMDRcdTAwMTJcdTAwMWNcdTAwMWG9dj6DlYRwOoMnXHUwMDA03/Tt84Wp4eLdoFx1MDAwNn5zg3d1sJc57+ems7NcdTAwMTZLXlx1MDAxNnQ+Q25tpPBcdTAwMGVcdTAwMTVa4Vx1MDAwNjZcdTAwMDe9MVx1MDAxY9vur1k8Tjxcclx1MDAxNIpra4BjOppMcc/4hUc7yJMwXHUwMDFluLzYXHUwMDEyllrs21x1MDAxZdc9bsVxgqfGweA5M29kaIHCXHUwMDAytyz3j2n808xduEziXHUwMDExkMavUf6wnaab/EXp7u6u1ty/vynu5apH7GroTEtcdTAwMDYnR2iLq0y0xW5ijimyoKx421aAMlNl1acnXHUwMDAwb776jV2+wfBQxnGGK7hmTK7FbLiQwIBcdTAwMDWjXGZcdTAwMTNrhHI09Y23mt5tXpyNfLG2XHUwMDE0NMHZ0i7cXHUwMDAzXHUwMDEzdJFcdTAwMTjzkVxuho1dfDdj2YpUfaCLL3aRjjxcdTAwMTI23sRaqsVcdTAwMGVsYvH9SSdZrtXyN/V9pWp0cFA5z0RkOYZ4guK4Js2xTHqtkVx1MDAxZWdcZlx1MDAxMEMyIYylXHUwMDFhOHLA2IRTXHUwMDE4f1x1MDAxZVx1MDAwZriPXHUwMDA0J7RZSaiIWc52WI7A3Vx1MDAwZuFcdTAwMWNcdTAwMTm7IUJEXHQnL9UwfyrNXHRcdTAwMTVJPFx1MDAwMsL4e0nO7Z3K1HRheFdcdTAwMWXNJ9m0afOKajnzizE7iVx1MDAxYjDUinEuXHUwMDA18XO3nyxHelx1MDAxNnthWrNwXHUwMDE3XHUwMDE1oUHZ2S7J2Xz1XHUwMDFiXHUwMDFi2nHhKWBjgmstNFvbPOfwXGJcdTAwMDW4qLhcdTAwMTGpmTDx4IIvSa3hcGqs2nRVbIZPbtWGXHUwMDEz9sGSzY2EZzOsrUjY+1x0XHUwMDBmI8o/aSFOXf5mqctPw9TdzXg6TXYzJToudOtJUdmLxnk001x1MDAxZcawKSdcdTAwMTQ8KLre0UpcdE9cdTAwMWGwPCDXWHZcdTAwMWU0PtpgNqUgVGFcdTAwMTd965vD5Fx1MDAxYlvA0YJcdTAwMTlcdTAwMDHWS2Gb0e9hinY9lG21xlx1MDAxOajO5D9mw0sgXGJSpT+2pGrjnlhcdTAwMDLE3GOaYUhcZiTWUP32plx1MDAxOLcgvErgJppcdTAwMDQqRVenICSUNFx1MDAxZSpcdTAwMDYxQKFcdTAwMTSc+81cdTAwMTOCNnmUXHUwMDFhbLaL9UJi9XxcdTAwMDFl2SYn++VewsQzXHUwMDFjr51cdTAwMTBqXHUwMDA0XHUwMDA3T4j6PvRCvFx1MDAxNCxcdTAwMDf4ToThXHUwMDE2XHUwMDE5iIZcdTAwMGX284s20OGwqMbs4bJw8NRtt24rXHUwMDE3lSNbcbJB4i1cIpxSSWJhQVxyXHUwMDBiXFxcdTAwMTP3XGLj2D9LW03052dWz2dlTvcy5Pxcbp7h6VP3+i6V6EbZW5SceoRIsLWGWGF9XHUwMDFkOn5uLSpgvjjXcjEy2lx1MDAwNl1QarhcdTAwMDdcdTAwMGIhXHUwMDE15mFarEhcdNpjTjj2XHUwMDEx0SBjXFxcdTAwMDNbWZKV2Fx1MDAxZf/4uD2WUoMpZMHWX4vHXHUwMDEy2mJQK7PoXCLxx+ZRWs9f4rpq7Vx1MDAxOGZcdTAwMWNw3J4wglxiq8Wb9jhcXMBcdTAwMTcnXGbI9jbN52/YtEufqXrrcp+p4uyU8XZm+lRJJVwi9c5QgFtcdTAwMTaD5tjig4q1LTuwLp5cdTAwMTDcWIbZq8oxXHUwMDE1QmK+XHUwMDA3XHUwMDFjTFqtMPb+fZ3K32I5XFxeJVx1MDAwZVx1MDAxNbJMK1dcdTAwMTYj3VCwoTA6wyn/hMkwXHUwMDFjO8F9xPXrNOBcdTAwMGZ0Wp3myO30Ld/3TpY/vp6uUWk0673qi1x1MDAwM1x1MDAxON3fe+Pr38Xre2tcdTAwMTWi+36lg4m4Tzxnh91296ZcXKpcdTAwMTRcdTAwMWVcdTAwMGV0pFwiLjDG1OMokUoyiUlNK1x1MDAxNlx1MDAwMsdpXHUwMDAyXHShVlpcdTAwMGVm1NFcXCe2XHUwMDEwL69uN+6EOUY4+tLJXCJI+ChcdTAwMDWNimy3X9KlkdKIXHUwMDBmdVx1MDAxNY0txE5YiLtCgfaeupe1+rWtnFx1MDAxN2S3Xs2xSImOwFx1MDAxYTxcdTAwMDNOXHUwMDE1RoCwaGV9930t7SfojSiqPFx1MDAwYsZBXHUwMDFinMXiXHUwMDBmSvgshMHSMVx1MDAxMF+56FpcdTAwMTY7I1vqOGg4wXE+LjNcdTAwMTI+1JLCg2aGiD83PqSkpzAugU35JFx1MDAxMXI1x1x1MDAxOSBcdTAwMTHQjFx0rXF7Sb6ZkyiV8Vxm9tHDSSOgXHUwMDAybNPZ7JvOTai+4JHALt5cdTAwMDLjQsJQY1x1MDAwNZE7X831hnNznS6lXHUwMDFmUzMxf+hcZs+ehqfT43LtKmLLXHKmPUlxdlx1MDAxMFXMrm3Vg9vjcTBMXHUwMDE2PE5GJVx0VqAzjOlcdTAwMDFnMfB4XHUwMDE4yryrXHUwMDEzmPEw74hcdTAwMTgtheWMkW9imnZ9r1x1MDAxZcyLXHUwMDAwwulcIjjhvVx1MDAwNDWQXHUwMDFiru32+/bsil1cbpdIPIKyuE3V30LPXHIjKUF1XHUwMDEzmmC/Vl9Q5mdcYlZ42Fx1MDAxMFxmXGYlurKMklx1MDAwZkaFaye5Qip7fNNcdTAwMTdcdTAwMDfNROJoPKyMZjwkKqwthutxZ9xcYmzPXHUwMDE1uCa+6FNBkMNcYktd/Vm3XHUwMDFjXHUwMDE3XHUwMDE294/7N3VhylmSKtdcdTAwMGb5tHJ6XHUwMDExbcovsCxcdTAwMGbHilNGwfyz1eo1K5XHiMbqtlx1MDAwNarFKVx1MDAwMl/T+91IhV19nVx1MDAxYnDhOUdCwpPQfPtD76iWVsXb+N9hXHUwMDFi/18/7fVf1fv7y1x0PMZXk/fXrNOc71x1MDAwNbXpv1qLXHUwMDAzrcvCtqAmNVx1MDAxN9D773/9+/9cdTAwMDNcdTAwMTY1R1oifQ== SourceUnitVariableDeclarationVariableDeclarationIfStatementReturnFunctionDefinitionParameterListParameterListBlockElementaryTypeNameElementaryTypeNameBinaryOperationBinaryOperationBinaryOperationBinaryOperationReturnIdentifierIdentifierIdentifierIdentifierIdentifierIdentifierLiteralLiteralLiteralFunctionCallFunctionCallContractDefinitionPragmaDirectiveparametersbodypragmascontractsfunctionsreturn_parametersparametersparametersstatementstype_nametype_nameconditiontrue_bodyexpressionexpressionleft_expressionright_expressionargumentsexpressionexpressionargumentsleft_expressionright_expressionleft_expressionleft_expressionright_expressionreferenced_declarationreferenced_declarationright_expression <p>Tip</p> <p>Since all IR nodes are iterable, it is very easy to create a simple printer to explore what parts of the source code correspond to which nodes.</p> <pre><code>from __future__ import annotations\n\nimport networkx as nx\nimport rich_click as click\nimport wake.ir as ir\nimport wake.ir.types as types\nfrom rich import print\nfrom wake.printers import Printer, printer\n\n\nclass StructurePrinter(Printer):\n    def print(self) -&gt; None:\n        pass\n\n    def visit_source_unit(self, node: ir.SourceUnit):\n        for n in node:\n            print(f\"{n}\\n{n.source}\\n====================\")\n\n    @printer.command(name=\"structure\")\n    def cli(self) -&gt; None:\n        pass\n</code></pre>"},{"location":"static-analysis/detectors/abi-encode-with-signature/","title":"<code>abi.encodeWithSignature</code> detector","text":"<p>Name: <code>abi-encode-with-signature</code></p> <p>The detector checks for incorrect ABI signatures in <code>ABI.encodeWithSignature</code> calls. The most common mistake is the use of <code>uint</code> instead of <code>uint256</code> or <code>int</code> instead of <code>int256</code>.</p>"},{"location":"static-analysis/detectors/abi-encode-with-signature/#examples","title":"Examples","text":"<pre><code>import \"@openzeppelin/contracts/interfaces/IERC20.sol\";\n\ncontract Example {\n    function transfer(IERC20 token, uint amount) external {\n        bytes memory data = abi.encodeWithSignature(\n            \"transfer(address,uint)\", // (1)!\n            msg.sender,\n            amount\n        );\n        (bool success, ) = address(token).call(data);\n        require(success, \"Transfer failed\");\n    }\n}\n</code></pre> <ol> <li><code>uint256</code> must be used instead of <code>uint</code> to generate the correct function selector.</li> </ol>"},{"location":"static-analysis/detectors/abi-encode-with-signature/#parameters","title":"Parameters","text":"<p>The detector does not accept any additional parameters.</p>"},{"location":"static-analysis/detectors/axelar-proxy-contract-id/","title":"Axelar proxy <code>contractId</code> detector","text":"<p>Name: <code>axelar-proxy-contract-id</code></p> <p>The detector detects Axelar proxy and implementation contracts that use the <code>contractId</code> method as an additional check for deploying the contracts and when performing an upgrade.</p>"},{"location":"static-analysis/detectors/axelar-proxy-contract-id/#proxy-contractid-shared-between-multiple-contracts","title":"Proxy <code>contractId</code> shared between multiple contracts","text":"<p>Two different proxy contracts should not share the same <code>contractId</code>.</p> <pre><code>pragma solidity ^0.8.0;\n\nimport { Proxy } from '@axelar-network/axelar-gmp-sdk-solidity/contracts/upgradable/Proxy.sol';\n\ncontract MyProxy is Proxy {\n    constructor(\n        address implementationAddress,\n        address owner,\n        bytes memory setupParams\n    ) Proxy(implementationAddress, owner, setupParams) {}\n\n    function contractId() internal pure virtual override returns (bytes32) {\n        return keccak256('my-proxy');\n    }\n}\n\ncontract AnotherProxy is Proxy {\n    constructor(\n        address implementationAddress,\n        address owner,\n        bytes memory setupParams\n    ) Proxy(implementationAddress, owner, setupParams) {}\n\n    function contractId() internal pure virtual override returns (bytes32) {\n        return keccak256('my-proxy');\n    }\n}\n</code></pre>"},{"location":"static-analysis/detectors/axelar-proxy-contract-id/#proxy-contract-without-upgradeable-contract-with-the-same-contractid","title":"Proxy contract without upgradeable contract with the same <code>contractId</code>","text":"<p>It is expected that a project will have at least one implementation contract with the same <code>contractId</code> as the proxy contract. Proxy contracts without an implementation contract with the same <code>contractId</code> are reported.</p>"},{"location":"static-analysis/detectors/axelar-proxy-contract-id/#implementation-contract-without-proxy-contract-with-the-same-contractid","title":"Implementation contract without proxy contract with the same <code>contractId</code>","text":"<p>It is expected that a project will have exactly one proxy contract with the same <code>contractId</code> as the implementation contract. Implementation contracts without a proxy contract with the same <code>contractId</code> are reported.</p>"},{"location":"static-analysis/detectors/axelar-proxy-contract-id/#proxy-contract-and-upgradeable-contract-with-function-selector-collision","title":"Proxy contract and upgradeable contract with function selector collision","text":"<p>An implementation contract and a corresponding proxy contract should not define functions with the same function selector. It wouldn't be possible to call the implementation contract function in this case, as the proxy contract function would be called instead.</p> <p>The <code>implementation()</code> and <code>setup(bytes calldata params)</code> functions are an exception to this rule and are not reported.</p> <pre><code>pragma solidity ^0.8.0;\n\nimport { Proxy } from '@axelar-network/axelar-gmp-sdk-solidity/contracts/upgradable/Proxy.sol';\nimport { Upgradable } from '@axelar-network/axelar-gmp-sdk-solidity/contracts/upgradable/Upgradable.sol';\n\ncontract MyProxy is Proxy {\n    constructor(address implementationAddress, address owner, bytes memory setupParams) Proxy(implementationAddress, owner, setupParams) {}\n\n    function kind() external pure returns (string memory) {\n        return 'proxy';\n    }\n\n    function contractId() internal pure virtual override returns (bytes32) {\n        return keccak256('test');\n    }\n}\n\ncontract MyImplementation is Upgradable {\n    constructor() Upgradable() {}\n\n    function kind() external pure returns (string memory) {  // (1)!\n        return 'implementation';\n    }\n\n    function contractId() external pure returns (bytes32) {\n        return keccak256('test');\n    }\n}\n</code></pre> <ol> <li>It will never be possible to call the <code>kind</code> function of the implementation contract, as the proxy contract function will be called instead.</li> </ol>"},{"location":"static-analysis/detectors/axelar-proxy-contract-id/#parameters","title":"Parameters","text":"<p>The detector does not accept any additional parameters.</p>"},{"location":"static-analysis/detectors/balance-relied-on/","title":"Balance relied on detector","text":"<p>Name: <code>balance-relied-on</code></p> <p>Reports uses of <code>address.balance</code> in strict equality comparisons and in state variable assignments.</p> <p>A contract may forcefully receive Ether without a single <code>payable</code> function implemented. This is possible by selfdestructing another contract and sending the Ether to the address of the contract that relies on <code>address.balance</code>.</p>"},{"location":"static-analysis/detectors/balance-relied-on/#example","title":"Example","text":"<pre><code>pragma solidity ^0.8;\n\ncontract Auction {\n    address owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    receive() external payable {\n        // only the owner can start the auction with initial bid\n        require(msg.sender == owner);\n    }\n\n    function bid() external payable {\n        require(\n            address(this).balance != 0, // (1)!\n            \"Cannot bid on an auction that has not started\"\n        );\n        // ...\n    }\n}\n</code></pre> <ol> <li>The contract relies on <code>address(this).balance</code> to check if the auction has started.     An attacker can selfdestruct another contract and send the Ether to the address of the auction contract.     This will make the auction start and allow the attacker to bid on it.</li> </ol>"},{"location":"static-analysis/detectors/balance-relied-on/#parameters","title":"Parameters","text":"<p>The detector does not accept any additional parameters.</p>"},{"location":"static-analysis/detectors/call-options-not-called/","title":"Call options not called detector","text":"<p>Name: <code>call-options-not-called</code></p> <p>Reports when a function call option (<code>gas</code>, <code>salt</code> or <code>value</code>) is used but the corresponding function is not called. Both old-style syntax <code>.value(...)</code> and new-style syntax <code>{value: ...}</code> are supported.</p>"},{"location":"static-analysis/detectors/call-options-not-called/#example","title":"Example","text":"<pre><code>pragma solidity ^0.6.0;\n\ncontract Example {\n    function withdraw() external {\n        msg.sender.call{value: address(this).balance}; // (1)!\n    }\n\n    function withdraw2() external {\n        msg.sender.call.value(address(this).balance); // (2)!\n    }\n}\n</code></pre> <ol> <li>The <code>value</code> call option is used but the low-level <code>call</code> function is not called.</li> <li>The <code>value</code> call option is used but the low-level <code>call</code> function is not called.</li> </ol>"},{"location":"static-analysis/detectors/call-options-not-called/#parameters","title":"Parameters","text":"<p>The detector does not accept any additional parameters.</p>"},{"location":"static-analysis/detectors/calldata-tuple-reencoding-head-overflow-bug/","title":"Calldata tuple reencoding head overflow bug detector","text":"<p>Name: <code>calldata-tuple-reencoding-head-overflow-bug</code></p> <p>Reports a possibility of triggering a compiler bug when ABI-encoding a tuple with at least one dynamic component and the last component as a statically-sized <code>calldata</code> array.</p> <p>The bug would cause malformed output of the ABI encoder caused by overwriting some of the encoded values. The detector reports concerned ABI-encoding expressions if a fault compiler version may be used. Functions that when externally called may trigger the bug are also reported. In such cases, the compiler version is not checked since the bug is triggered by the caller.</p> <p>See the bug announcement for more details. The bug was fixed in Solidity 0.8.16.</p>"},{"location":"static-analysis/detectors/calldata-tuple-reencoding-head-overflow-bug/#example","title":"Example","text":"<pre><code>pragma solidity 0.8.0;\n\nstruct T {\n    bytes x; // (1)!\n    uint[3] y;\n}\n\ncontract C {\n    function f(bool a, T memory b, bytes32[2] memory c) public {} // (2)!\n\n    function vulnerable(bytes32[2] calldata data) external {\n        this.f(true, T(\"abcd\", [uint(11), 12, 13]), data); // (3)!\n    }\n}\n</code></pre> <ol> <li>An encoded tuple must have at least one dynamic component. In this example, the dynamic component is <code>x</code>.</li> <li>ABI encoding may be explicit (i.e. <code>abi.encode(...)</code>) or implicit when doing an external call.     In this example, the function <code>f</code> is called externally. To call the function, its parameters must be ABI-encoded.     <code>c</code> is the last component of the tuple, complying with the condition of statically-sized array.     <code>x</code> in the <code>T</code> struct is the dynamic component also needed to trigger the bug.</li> <li>Call to the bug-affected function <code>f</code> performs an implicit ABI encoding and triggers the bug.     <code>data</code> must be stored in <code>calldata</code> to trigger the bug.</li> </ol>"},{"location":"static-analysis/detectors/calldata-tuple-reencoding-head-overflow-bug/#parameters","title":"Parameters","text":"<p>The detector does not accept any additional parameters.</p>"},{"location":"static-analysis/detectors/complex-struct-getter/","title":"Complex struct getter detector","text":"<p>Name: <code>complex-struct-getter</code></p> <p>Solidity-generated getters for public state variables do not return array and mapping members of (possible nested) structs. See the Solidity docs for more details.</p>"},{"location":"static-analysis/detectors/complex-struct-getter/#example","title":"Example","text":"<pre><code>pragma solidity 0.8.0;\n\ncontract C {\n    struct ComplexStruct {\n        uint a;\n        address[] b;  // (2)!\n        string c;\n        mapping(uint =&gt; uint) d;  // (3)!\n    }\n\n    ComplexStruct public s; // (1)!\n\n    /* the generated getter for `s` looks like this: */\n    function s1() public view returns (uint, string memory) {\n        return (s.a, s.c);\n    }\n}\n</code></pre> <ol> <li>Getter for <code>s</code> is generated. Since the <code>ComplexStruct</code> contains an array and a mapping, the getter returns only the non-complex members <code>a</code> and <code>c</code> (as a tuple).</li> <li>The array member <code>b</code> is not returned by the <code>s</code> getter.</li> <li>The mapping member <code>d</code> is not returned by the <code>s</code> getter.</li> </ol>"},{"location":"static-analysis/detectors/complex-struct-getter/#parameters","title":"Parameters","text":"<p>The detector does not accept any additional parameters.</p>"},{"location":"static-analysis/detectors/empty-byte-array-copy-bug/","title":"Empty byte array copy bug detector","text":"<p>Name: <code>empty-byte-array-copy-bug</code></p> <p>Reports a possibility of triggering a compiler bug when copying empty <code>calldata</code> or <code>memory</code> bytes to <code>storage</code> bytes and then extending the <code>storage</code> bytes using <code>.push()</code>. See the bug announcement for more details. The bug was fixed in Solidity 0.7.4.</p>"},{"location":"static-analysis/detectors/empty-byte-array-copy-bug/#example","title":"Example","text":"<pre><code>pragma solidity ^0.7;\n\ncontract Example {\n    bytes public data;\n\n    function foo() external {\n        bytes memory empty;\n        uint[2] memory arr;\n        arr[0] = type(uint).max;\n        data = empty; // (1)!\n        data.push(); // (2)!\n    }\n}\n</code></pre> <ol> <li>Empty <code>memory</code> bytes are copied to <code>storage</code> bytes.</li> <li>The <code>storage</code> bytes are extended using <code>.push()</code>. Because of the compiler bug, a non-zero byte is possibly appended to the <code>storage</code> bytes.</li> </ol>"},{"location":"static-analysis/detectors/empty-byte-array-copy-bug/#parameters","title":"Parameters","text":"<p>The detector does not accept any additional parameters.</p>"},{"location":"static-analysis/detectors/incorrect-interface/","title":"Incorrect interface detector","text":"<p>Name: <code>incorrect-interface</code></p> <p>Reports multiple different issues when implementing ERC-20/ERC-721/ERC-1155 interfaces.</p>"},{"location":"static-analysis/detectors/incorrect-interface/#missing-functions-events","title":"Missing functions &amp; events","text":"<p>One or more functions or events are missing from the contract. The recognition is based on the function/event selectors.</p>"},{"location":"static-analysis/detectors/incorrect-interface/#example","title":"Example","text":"<pre><code>pragma solidity ^0.8;\n\ncontract MyToken { // (1)!\n    uint256 public totalSupply;\n    mapping(address =&gt; uint256) public balanceOf;\n    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function approve(address spender, uint256 value) external returns (bool) {\n        // ...\n    }\n\n    function transfer(address to, uint256 value) external returns (bool) {\n        // ...\n    }\n}\n</code></pre> <ol> <li>The contract does not implement the <code>transferFrom</code> function and the <code>Approval</code> event defined in the ERC20 standard.</li> </ol>"},{"location":"static-analysis/detectors/incorrect-interface/#incorrect-state-mutability","title":"Incorrect state mutability","text":"<p>Some functions are marked as <code>view</code> in the token standards as they are not supposed to modify the state. The detector reports functions that should be marked as <code>view</code> but are not.</p>"},{"location":"static-analysis/detectors/incorrect-interface/#example_1","title":"Example","text":"<pre><code>pragma solidity ^0.8;\n\ncontract MyToken {\n    mapping(address =&gt; uint256) public balanceOf;\n    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner, address indexed spender, uint256 value\n    );\n\n    function totalSupply() external returns (uint256) { // (1)!\n        // ...\n    }\n\n    function approve(address spender, uint256 value) external returns (bool) {\n        // ...\n    }\n\n    function transfer(address to, uint256 value) external returns (bool) {\n        // ...\n    }\n\n    function transferFrom(\n        address from, address to, uint256 value\n    ) external returns (bool) {\n        // ...\n    }\n}\n</code></pre> <ol> <li>The <code>totalSupply</code> function should be marked as <code>pure</code> or <code>view</code>, but it is not.</li> </ol>"},{"location":"static-analysis/detectors/incorrect-interface/#incorrect-return-type","title":"Incorrect return type","text":"<p>Return types do not affect the function selectors. Still, tokens implemented according to the standard should return values as specified in the standard.</p>"},{"location":"static-analysis/detectors/incorrect-interface/#example_2","title":"Example","text":"<pre><code>pragma solidity ^0.8;\n\ncontract MyToken {\n    uint256 public totalSupply;\n    mapping(address =&gt; uint256) public balanceOf;\n    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner, address indexed spender, uint256 value\n    );\n\n    function approve(address spender, uint256 value) external { // (1)!\n        // ...\n    }\n\n    function transfer(address to, uint256 value) external { // (2)!\n        // ...\n    }\n\n    function transferFrom(\n        address from, address to, uint256 value\n    ) external { // (3)!\n        // ...\n    }\n}\n</code></pre> <ol> <li>The <code>approve</code> function should return a <code>bool</code> value, but it does not.</li> <li>The <code>transfer</code> function should return a <code>bool</code> value, but it does not.</li> <li>The <code>transferFrom</code> function should return a <code>bool</code> value, but it does not.</li> </ol>"},{"location":"static-analysis/detectors/incorrect-interface/#indexed-event-parameters","title":"Indexed event parameters","text":"<p>Indexed event parameters do not affect the event selectors, but they still should be used according to the standard.</p>"},{"location":"static-analysis/detectors/incorrect-interface/#example_3","title":"Example","text":"<pre><code>pragma solidity ^0.8;\n\ncontract MyToken {\n    uint256 public totalSupply;\n    mapping(address =&gt; uint256) public balanceOf;\n    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;\n\n    event Transfer(address indexed from, address to, uint256 value); // (1)!\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 indexed value // (2)!\n    );\n\n    function approve(address spender, uint256 value) external returns (bool) {\n        // ...\n    }\n\n    function transfer(address to, uint256 value) external returns (bool) {\n        // ...\n    }\n\n    function transferFrom(\n        address from, address to, uint256 value\n    ) external returns (bool) {\n        // ...\n    }\n}\n</code></pre> <ol> <li>The <code>to</code> parameter of the <code>Transfer</code> event should be indexed, but it is not.</li> <li>The <code>value</code> parameter of the <code>Approval</code> event should not be indexed, but it is.</li> </ol>"},{"location":"static-analysis/detectors/incorrect-interface/#anonymous-events","title":"Anonymous events","text":"<p>Events defined in the token standards should not be anonymous.</p>"},{"location":"static-analysis/detectors/incorrect-interface/#example_4","title":"Example","text":"<pre><code>pragma solidity ^0.8;\n\ncontract MyToken {\n    uint256 public totalSupply;\n    mapping(address =&gt; uint256) public balanceOf;\n    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;\n\n    event Transfer(\n        address indexed from, address indexed to, uint256 value\n    ) anonymous; // (1)!\n    event Approval(\n        address indexed owner, address indexed spender, uint256 value\n    );\n\n    function approve(address spender, uint256 value) external returns (bool) {\n        // ...\n    }\n\n    function transfer(address to, uint256 value) external returns (bool) {\n        // ...\n    }\n\n    function transferFrom(\n        address from, address to, uint256 value\n    ) external returns (bool) {\n        // ...\n    }\n}\n</code></pre> <ol> <li>The <code>Transfer</code> event should not be anonymous, but it is.</li> </ol>"},{"location":"static-analysis/detectors/incorrect-interface/#parameters","title":"Parameters","text":"Command-line name TOML name Type Default value Description <code>--erc20-threshold</code> <code>erc20_threshold</code> <code>int</code> <code>4</code> Number of ERC-20 functions/events required to consider a contract an ERC-20 token. <code>--erc721-threshold</code> <code>erc721_threshold</code> <code>int</code> <code>6</code> Number of ERC-721 functions/events required to consider a contract an ERC-721 token. <code>--erc1155-threshold</code> <code>erc1155_threshold</code> <code>int</code> <code>4</code> Number of ERC-1155 functions/events required to consider a contract an ERC-1155 token."},{"location":"static-analysis/detectors/missing-return/","title":"Missing return detector","text":"<p>Name: <code>missing-return</code></p> <p>Reports functions that contain at least one execution path that does not set all return variables.</p>"},{"location":"static-analysis/detectors/missing-return/#example","title":"Example","text":"<pre><code>pragma solidity ^0.8;\n\ncontract C {\n    function sqrt(uint x) public returns (uint) { // (1)!\n        if (x &gt;= 2) {\n            uint z = (x + 1) / 2;\n            uint y = x;\n            while (z &lt; y) {\n                y = z;\n                z = (x / z + z) / 2;\n            }\n            return y;\n        }\n    }\n}\n</code></pre> <ol> <li>The function does not set the return value if <code>x &lt; 2</code>. This is a problem since <code>sqrt(1)</code> will return <code>0</code> instead of <code>1</code>.</li> </ol>"},{"location":"static-analysis/detectors/missing-return/#parameters","title":"Parameters","text":"<p>The detector does not accept any additional parameters.</p>"},{"location":"static-analysis/detectors/msg-value-nonpayable-function/","title":"<code>msg.value</code> non-payable function","text":"<p>Name: <code>msg-value-nonpayable-function</code></p> <p>Reports uses of <code>msg.value</code> in functions that are never called from a payable function. The value of <code>msg.value</code> is always zero in such functions.</p>"},{"location":"static-analysis/detectors/msg-value-nonpayable-function/#example","title":"Example","text":"<pre><code>pragma solidity ^0.8;\n\ncontract C {\n    function f() public {\n        g();\n    }\n\n    function g() private {\n        require(msg.value &gt; 0); // (1)!\n        // ...\n    }\n}\n</code></pre> <ol> <li>The function <code>g</code> is never called from a payable function in this example.    The value of <code>msg.value</code> will always be zero.</li> </ol>"},{"location":"static-analysis/detectors/msg-value-nonpayable-function/#parameters","title":"Parameters","text":"<p>The detector does not accept any additional parameters.</p>"},{"location":"static-analysis/detectors/reentrancy/","title":"Reentrancy detector","text":"<p>Name: <code>reentrancy</code></p> <p>Reports calls to external contracts that may allow reentrancy attacks. The vulnerability is only reported if there is at least one public/external function in the contract that can be called by anyone, serving as an entry point for the reentrancy attack. The entry points are reported as subdetections.</p> <p>A function is considered to be an entry point if it does not have any access control checks in a form of <code>msg.sender == trustedAddress</code>, where <code>trustedAddress</code> is an address set only in the constructor of the contract or in a function protected by the same access control check.</p> <p>A reentrancy detection is not reported if an externally called contract is considered to be trusted. The same rules apply here - the external call address must only be assigned to by the deployer of the contract in the constructor or an access control protected function.</p> <p>The impact of a detection depends on the EVM global state changes that are performed after the external call. For example, if the external call is only followed by an event emission, the impact is evaluated as warning. Still, it may be an issue if there is any backend logic that relies on the correct order of events.</p>"},{"location":"static-analysis/detectors/reentrancy/#example","title":"Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Reentrancy {\n    mapping(address =&gt; uint256) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint256 amount) public {\n        require(balances[msg.sender] &gt;= amount, \"Insufficient balance\");\n        (bool success, ) = msg.sender.call{value: amount}(\"\"); // (1)!\n        require(success, \"Transfer failed\");\n        balances[msg.sender] -= amount;\n    }\n}\n</code></pre> <ol> <li>The contract calls <code>msg.sender.call</code> before updating the balance of the user.    This allows the user to call <code>withdraw</code> again before the balance is updated,    withdrawing more funds than they have deposited.</li> </ol>"},{"location":"static-analysis/detectors/reentrancy/#parameters","title":"Parameters","text":"<p>The detector does not accept any additional parameters.</p>"},{"location":"static-analysis/detectors/struct-mapping-deletion/","title":"Struct mapping deletion detector","text":"<p>Name: <code>struct-mapping-deletion</code></p> <p>Using <code>delete</code> on a (possibly nested) struct containing a mapping member does not delete the mapping.</p>"},{"location":"static-analysis/detectors/struct-mapping-deletion/#example","title":"Example","text":"<pre><code>pragma solidity 0.8.0;\n\ncontract C {\n    struct Account {\n        string name;\n        mapping(uint =&gt; uint) balances;  // (2)!\n    }\n\n    mapping(uint =&gt; Account) accounts;\n\n    function clearAccount(uint id) internal {\n        delete accounts[id];  // (1)!\n    }\n}\n</code></pre> <ol> <li>The <code>delete</code> statement does not delete the <code>Account</code> struct mapping member <code>balances</code>.</li> <li>The <code>balances</code> member is not deleted.</li> </ol>"},{"location":"static-analysis/detectors/struct-mapping-deletion/#parameters","title":"Parameters","text":"<p>The detector does not accept any additional parameters.</p>"},{"location":"static-analysis/detectors/tx-origin/","title":"<code>tx.origin</code> detector","text":"<p>Name: <code>tx-origin</code></p>"},{"location":"static-analysis/detectors/tx-origin/#phishing-attacks","title":"Phishing attacks","text":"<p>Access controls based on <code>tx.origin</code> are vulnerable to phishing attacks. The attacker may convince the user to send a transaction to an attacker's contract. The attacker's contract may then call the victim's contract with <code>tx.origin</code> set to the victim's address.</p>"},{"location":"static-analysis/detectors/tx-origin/#example","title":"Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Victim {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function withdraw() {\n        require(tx.origin == owner, \"Not owner\"); // (1)!\n        tx.origin.call{value: this.balance}(\"\");\n    }\n}\n</code></pre> <ol> <li>An attacker may convince <code>owner</code> to send a transaction to the attacker's    contract. <code>tx.origin</code> will be set to <code>owner</code>. Attacker's contract calls     <code>withdraw</code> on the victim's contract, withdrawing the victim's funds.</li> </ol>"},{"location":"static-analysis/detectors/tx-origin/#account-abstraction","title":"Account abstraction","text":"<p>Use of <code>tx.origin</code> may prevent users using ERC-4337 account abstraction from interacting with a contract. In this case, <code>tx.origin</code> will not be set to the address of the user operation sender.</p>"},{"location":"static-analysis/detectors/tx-origin/#example_1","title":"Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Treasury {\n    mapping(address =&gt; uint256) public deposits;\n\n    function deposit() public payable {\n        require(tx.origin == msg.sender, \"Only EOAs can deposit\"); // (1)!\n        deposits[msg.sender] += msg.value;\n    }\n}\n</code></pre> <ol> <li>Users using account abstraction will not be able to deposit funds into the    contract.</li> </ol>"},{"location":"static-analysis/detectors/tx-origin/#parameters","title":"Parameters","text":"Command-line name TOML name Type Default value Description <code>--account-abstraction/</code><code>--no-account-abstraction</code> <code>account_abstraction</code> <code>bool</code> <code>true</code> Report ERC-4337 account abstraction related issues."},{"location":"static-analysis/detectors/unchecked-return-value/","title":"Unchecked return value detector","text":"<p>Name: <code>unchecked-return-value</code></p> <p>Reports when a function call return value is unused.</p>"},{"location":"static-analysis/detectors/unchecked-return-value/#example","title":"Example","text":"<pre><code>import \"@openzeppelin/contracts/interfaces/IERC20.sol\";\n\ncontract Treasury {\n    function deposit(IERC20 token, uint256 amount) external {\n        token.transferFrom(msg.sender, address(this), amount); // (1)!\n    }\n\n    function withdrawNative(address to, uint256 amount) external {\n        to.call{value: amount}(\"\"); // (2)!\n    }\n\n    function withdraw(IERC20 token, address to, uint256 amount) external {\n        token.transfer(to, amount);  // (3)!\n    }\n}\n</code></pre> <ol> <li>The return value of <code>transferFrom</code> is unused, possibly causing logic errors since the transfer may fail.</li> <li>The return value of <code>call</code> is unused, silently discarding the boolean indicating whether the call succeeded.</li> <li>The return value of <code>transfer</code> is unused, possibly causing logic errors since the transfer may fail.</li> </ol>"},{"location":"static-analysis/detectors/unchecked-return-value/#parameters","title":"Parameters","text":"<p>The detector does not accept any additional parameters.</p>"},{"location":"static-analysis/detectors/unprotected-selfdestruct/","title":"Unprotected selfdestruct detector","text":"<p>Name: <code>unprotected-selfdestruct</code></p> <p>Reports selfdestruct calls that are not protected by an <code>onlyOwner</code> modifier or similar logic.</p> <p>More precisely, access controls based on <code>msg.sender</code> are checked in the detector. Addresses set in a constructor or in functions protected by <code>onlyOwner</code> (or similar) are considered trusted.</p>"},{"location":"static-analysis/detectors/unprotected-selfdestruct/#example","title":"Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract VulnerableSelfDestructExample {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function safeSelfDestruct() external {\n        require(msg.sender == owner, \"Only owner can self-destruct\");\n        selfdestruct(payable(owner)); // (1)!\n    }\n\n    function unsafeSelfDestruct() external {\n        selfdestruct(payable(owner)); // (2)!\n    }\n}\n</code></pre> <ol> <li>The selfdestruct call is protected by a <code>require</code> statement and so is not reported.</li> <li>The selfdestruct call is not protected by any access control condition using <code>msg.sender</code> and <code>owner</code> and so is reported.</li> </ol>"},{"location":"static-analysis/detectors/unprotected-selfdestruct/#parameters","title":"Parameters","text":"<p>The detector does not accept any additional parameters.</p>"},{"location":"static-analysis/detectors/unsafe-delegatecall/","title":"Unsafe delegatecall detector","text":"<p>Name: <code>unsafe-delegatecall</code></p> <p>The <code>unsafe-delegatecall</code> detector reports <code>delegatecall</code> calls to possibly untrusted contracts.</p> <p>Calls are ignored if they the <code>delegatecall</code> target is trusted (e.g. <code>this</code>) or if the call is protected by an <code>onlyOwner</code> modifier or similar logic.</p> <p>More precisely, access controls based on <code>msg.sender</code> are checked in the detector. Addresses set in a constructor or in functions protected by <code>onlyOwner</code> (or similar) are considered trusted.</p>"},{"location":"static-analysis/detectors/unsafe-delegatecall/#example","title":"Example","text":"<pre><code>pragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract Storage {\n    using SafeERC20 for IERC20;\n\n    mapping(address =&gt; uint256) public balances;\n    address public computationLogic;\n\n    function setComputationLogic(address _computationLogic) external {\n        computationLogic = _computationLogic;\n    }\n\n    function deposit(IERC20 token, uint256 amount) external {\n        token.safeTransferFrom(msg.sender, address(this), amount);\n        balances[msg.sender] += amount;\n    }\n\n    function recomputeRewards() external {\n        computationLogic.delegatecall(\n            abi.encodeWithSignature(\"recomputeRewards()\")\n        ); // (1)!\n    }\n}\n</code></pre> <ol> <li>The <code>delegatecall</code> call is not protected by any access control condition using <code>msg.sender</code> and <code>owner</code>. The <code>computationLogic</code> variable can be set by anyone, making it possible to call arbitrary code that can modify the storage of the <code>Storage</code> contract.</li> </ol>"},{"location":"static-analysis/detectors/unsafe-delegatecall/#parameters","title":"Parameters","text":"Command-line name TOML name Type Default value Description <code>--proxy/--no-proxy</code> <code>proxy</code> <code>bool</code> <code>false</code> Whether to report <code>delegatecall</code> calls in proxy contracts."},{"location":"static-analysis/detectors/unsafe-erc20-call/","title":"Unsafe ERC-20 call detector","text":"<p>Name: <code>unsafe-erc20-call</code></p> <p>Reports ERC-20 <code>approve</code>, <code>transfer</code>, and <code>transferFrom</code> calls. These calls are unsafe as some non-compliant ERC-20 tokens may revert on failure instead of returning <code>false</code>. On success, the token may not return any data causing an ABI decoding error.</p>"},{"location":"static-analysis/detectors/unsafe-erc20-call/#example","title":"Example","text":"<pre><code>contract C {\n    function withdraw(IERC20 token, uint amount) external {\n        token.transfer(msg.sender, amount);\n    }\n\n    function approve(IERC20 token, address spender, uint amount) external {\n        token.approve(spender, amount);\n    }\n\n    function transferFrom(\n        IERC20 token,\n        address sender,\n        address recipient,\n        uint amount\n    ) external {\n        token.transferFrom(sender, recipient, amount);\n    }\n}\n</code></pre>"},{"location":"static-analysis/detectors/unsafe-erc20-call/#parameters","title":"Parameters","text":"<p>The detector does not accept any additional parameters.</p>"},{"location":"static-analysis/detectors/unused-contract/","title":"Unused contract detector","text":"<p>Name: <code>unused-contract</code></p> <p>Reports abstract contracts, interfaces, and libraries that are not used in the source code.</p>"},{"location":"static-analysis/detectors/unused-contract/#example","title":"Example","text":"<pre><code>abstract contract A { // (1)!\n    function foo() external virtual;\n}\n\ninterface I { // (2)!\n    function bar() external;\n}\n\nlibrary L { // (3)!\n    function baz() external {}\n}\n\ncontract C {\n    function qux() external {}\n}\n</code></pre> <ol> <li>The abstract contract <code>A</code> is not used in the source code.</li> <li>The interface <code>I</code> is not used in the source code.</li> <li>The library <code>L</code> is not used in the source code.</li> </ol>"},{"location":"static-analysis/detectors/unused-contract/#parameters","title":"Parameters","text":"Command-line name TOML name Type Default value Description <code>--abstract/--no-abstract</code> <code>abstract</code> <code>bool</code> <code>true</code> Whether to report unused abstract contracts. <code>--interface/--no-interface</code> <code>interface</code> <code>bool</code> <code>true</code> Whether to report unused interfaces. <code>--library/--no-library</code> <code>library</code> <code>bool</code> <code>true</code> Whether to report unused libraries."},{"location":"static-analysis/detectors/unused-function/","title":"Unused function detector","text":"<p>Name: <code>unused-function</code></p> <p>Reports private and internal functions that are not used in the source code.</p>"},{"location":"static-analysis/detectors/unused-function/#example","title":"Example","text":"<pre><code>contract C {\n    function _withdraw() private {\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\n        require(success, \"Transfer failed.\");\n    }\n}\n</code></pre>"},{"location":"static-analysis/detectors/unused-function/#parameters","title":"Parameters","text":"<p>The detector does not accept any additional parameters.</p>"},{"location":"static-analysis/detectors/unused-import/","title":"Unused import detector","text":"<p>Name: <code>unused-import</code></p> <p>The <code>unused-import</code> detector reports import directives that may be removed from the source code.</p>"},{"location":"static-analysis/detectors/unused-import/#example","title":"Example","text":"<pre><code>import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\"; // (1)!\n\ncontract MyToken is ERC20 {\n    constructor() ERC20(\"MyToken\", \"MTK\") {\n        _mint(msg.sender, 1000000000000000000000000);\n    }\n}\n</code></pre> <ol> <li>The example source code does not use any symbol from this import directive.</li> </ol>"},{"location":"static-analysis/detectors/unused-import/#parameters","title":"Parameters","text":"<p>The detector does not accept any additional parameters.</p>"},{"location":"static-analysis/detectors/unused-modifier/","title":"Unused modifier detector","text":"<p>Name: <code>unused-modifier</code></p> <p>Reports unused modifiers.</p>"},{"location":"static-analysis/detectors/unused-modifier/#example","title":"Example","text":"<pre><code>pragma solidity ^0.8;\n\ncontract C {\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner.\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function withdraw() external /*onlyOwner*/ {\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\n        require(success, \"Transfer failed.\");\n    }\n}\n</code></pre>"},{"location":"static-analysis/detectors/unused-modifier/#parameters","title":"Parameters","text":"<p>The detector does not accept any additional parameters.</p>"},{"location":"static-analysis/printers/abi/","title":"ABI printer","text":"<p>Name: <code>abi</code></p> <p>Prints ABI of contracts in given paths or in the whole project.</p>"},{"location":"static-analysis/printers/abi/#example","title":"Example","text":"wake\u00a0print\u00a0abi ABI\u00a0for\u00a0contracts/Owned.sol:Owned: [ { \"inputs\":\u00a0[], \"stateMutability\":\u00a0\"nonpayable\", \"type\":\u00a0\"constructor\" }, { \"inputs\":\u00a0[], \"name\":\u00a0\"InvalidCaller\", \"type\":\u00a0\"error\" }, { \"anonymous\":\u00a0false, \"inputs\":\u00a0[ { \"indexed\":\u00a0true, \"internalType\":\u00a0\"address\", \"name\":\u00a0\"oldOwner\", \"type\":\u00a0\"address\" }, { \"indexed\":\u00a0true, \"internalType\":\u00a0\"address\", \"name\":\u00a0\"newOwner\", \"type\":\u00a0\"address\" } ], \"name\":\u00a0\"OwnerChanged\", \"type\":\u00a0\"event\" }, { \"inputs\":\u00a0[], \"name\":\u00a0\"owner\", \"outputs\":\u00a0[ { \"internalType\":\u00a0\"address\", \"name\":\u00a0\"\", \"type\":\u00a0\"address\" } ], \"stateMutability\":\u00a0\"view\", \"type\":\u00a0\"function\" }, { \"inputs\":\u00a0[ { \"internalType\":\u00a0\"address\", \"name\":\u00a0\"_owner\", \"type\":\u00a0\"address\" } ], \"name\":\u00a0\"setOwner\", \"outputs\":\u00a0[], \"stateMutability\":\u00a0\"nonpayable\", \"type\":\u00a0\"function\" } ]"},{"location":"static-analysis/printers/abi/#parameters","title":"Parameters","text":"Command-line name TOML name Type Default value Description <code>--name</code> (multiple) <code>names</code> <code>List[str]</code> <code>[]</code> Names of contracts to print ABI for. <code>--skip-empty</code> <code>skip_empty</code> <code>bool</code> <code>False</code> Skip contracts with empty ABI. <code>--out</code> <code>out</code> <code>str</code> <code>abi</code> if <code>--out</code> passed, <code>None</code> otherwise Output directory path. If not specified, the output is printed to the standard output."},{"location":"static-analysis/printers/c3-linearization/","title":"C3 linearization printer","text":"<p>Name: <code>c3-linearization</code></p> <p>Prints the C3 linearization of a contract.</p>"},{"location":"static-analysis/printers/c3-linearization/#example","title":"Example","text":"wake\u00a0print\u00a0c3-linearization PoolManager\u00a0C3\u00a0linearization\u00a0ordered . \u251c\u2500\u2500\u00a0\u00a01.PoolManager \u251c\u2500\u2500\u00a0\u00a02.ERC1155 \u251c\u2500\u2500\u00a0\u00a03.NoDelegateCall \u251c\u2500\u2500\u00a0\u00a04.Fees \u251c\u2500\u2500\u00a0\u00a05.Owned \u251c\u2500\u2500\u00a0\u00a06.ERC165 \u2514\u2500\u2500\u00a0\u00a07.Context"},{"location":"static-analysis/printers/c3-linearization/#parameters","title":"Parameters","text":"Command-line name TOML name Type Default value Description <code>--interfaces</code> <code>interfaces</code> <code>bool</code> <code>False</code> Whether to include interfaces in the output. <code>--verbose</code> <code>verbose</code> <code>bool</code> <code>False</code> Whether to print more verbose input with base contracts and constructor."},{"location":"static-analysis/printers/control-flow-graph/","title":"Control flow graph printer","text":"<p>Name: <code>control-flow-graph</code></p> <p>Generates control flow graphs of functions and modifiers into Graphviz <code>.dot</code> files.</p>"},{"location":"static-analysis/printers/control-flow-graph/#example","title":"Example","text":"PoolManager._accountDelta(Currency,int128) control flow graph 89 92 return; 89-&gt;92 delta == 0 is true 95 address locker = lockData.getActiveLock() int256 current = currencyDelta[locker][currency] int256 next = current + delta 89-&gt;95 delta == 0 is false 90 success 91 revert 92-&gt;90 always 96 lockData.nonzeroDeltaCount-- 95-&gt;96 next == 0 is true 98 95-&gt;98 next == 0 is false 103 currencyDelta[locker][currency] = next 96-&gt;103 always 99 lockData.nonzeroDeltaCount++ 98-&gt;99 current == 0 is true 98-&gt;103 current == 0 is false 99-&gt;103 always 103-&gt;90 always"},{"location":"static-analysis/printers/control-flow-graph/#parameters","title":"Parameters","text":"Command-line name TOML name Type Default value Description <code>--name</code> (multiple) <code>names</code> <code>List[str]</code> <code>[]</code> Names of functions and modifiers to generate control flow graphs for. <code>--out</code> <code>out</code> <code>str</code> <code>.wake/control-flow-graphs</code> Output directory path. <code>--direction</code> <code>direction</code> Choice of <code>TB</code>, <code>BT</code>, <code>LR</code>, <code>RL</code> <code>TB</code> Direction of the graph. <code>--links</code> <code>links</code> <code>bool</code> <code>True</code> Whether to generate links to the source code. <code>--force</code> <code>force</code> <code>bool</code> <code>False</code> Whether to overwrite existing files."},{"location":"static-analysis/printers/imports-graph/","title":"Imports graph printer","text":"<p>Name: <code>imports-graph</code></p> <p>Generates an imports graph of Solidity source files into a Graphviz <code>.dot</code> file.</p>"},{"location":"static-analysis/printers/imports-graph/#example","title":"Example","text":"Imports graph contracts/types/PoolId.sol contracts/types/PoolId.sol contracts/PoolManager.sol contracts/PoolManager.sol contracts/types/PoolId.sol-&gt;contracts/PoolManager.sol contracts/interfaces/IPoolManager.sol contracts/interfaces/IPoolManager.sol contracts/types/PoolId.sol-&gt;contracts/interfaces/IPoolManager.sol contracts/types/PoolKey.sol contracts/types/PoolKey.sol contracts/types/PoolKey.sol-&gt;contracts/types/PoolId.sol contracts/interfaces/IHooks.sol contracts/interfaces/IHooks.sol contracts/types/PoolKey.sol-&gt;contracts/interfaces/IHooks.sol contracts/interfaces/IPoolManager.sol-&gt;contracts/PoolManager.sol contracts/interfaces/IPoolManager.sol-&gt;contracts/interfaces/IHooks.sol contracts/interfaces/IDynamicFeeManager.sol contracts/interfaces/IDynamicFeeManager.sol contracts/interfaces/IPoolManager.sol-&gt;contracts/interfaces/IDynamicFeeManager.sol contracts/libraries/LockDataLibrary.sol contracts/libraries/LockDataLibrary.sol contracts/interfaces/IPoolManager.sol-&gt;contracts/libraries/LockDataLibrary.sol contracts/types/Currency.sol contracts/types/Currency.sol contracts/types/Currency.sol-&gt;contracts/types/PoolKey.sol contracts/interfaces/IHooks.sol-&gt;contracts/types/PoolKey.sol contracts/interfaces/IDynamicFeeManager.sol-&gt;contracts/PoolManager.sol contracts/Fees.sol contracts/Fees.sol contracts/interfaces/IDynamicFeeManager.sol-&gt;contracts/Fees.sol contracts/libraries/LockDataLibrary.sol-&gt;contracts/PoolManager.sol contracts/interfaces/external/IERC20Minimal.sol contracts/interfaces/external/IERC20Minimal.sol contracts/interfaces/external/IERC20Minimal.sol-&gt;contracts/types/Currency.sol contracts/types/BalanceDelta.sol contracts/types/BalanceDelta.sol contracts/types/BalanceDelta.sol-&gt;contracts/interfaces/IHooks.sol contracts/Fees.sol-&gt;contracts/PoolManager.sol"},{"location":"static-analysis/printers/imports-graph/#parameters","title":"Parameters","text":"Command-line name TOML name Type Default value Description <code>--out</code> <code>out</code> <code>str</code> <code>.wake/imports-graphs.dot</code> Output file path. <code>--graph-direction</code> <code>graph_direction</code> Choice of <code>TB</code>, <code>BT</code>, <code>LR</code>, <code>RL</code> <code>TB</code> Direction of the graph. <code>--edge-direction</code> <code>edge_direction</code> Choice of <code>imported-to-importing</code>, <code>importing-to-imported</code> <code>imported-to-importing</code> Direction of the edges. <code>--links</code> <code>links</code> <code>bool</code> <code>True</code> Whether to generate links to the source code. <code>--force</code> <code>force</code> <code>bool</code> <code>False</code> Whether to overwrite existing files. <code>--importers</code>/<code>--no-importers</code> <code>importers</code> <code>bool</code> <code>True</code> Whether to generate files importing the specified files. <code>--imported</code>/<code>--no-imported</code> <code>imported</code> <code>bool</code> <code>True</code> Whether to generate files imported by the specified files."},{"location":"static-analysis/printers/inheritance-graph/","title":"Inheritance graph printer","text":"<p>Name: <code>inheritance-graph</code></p> <p>Generates inheritance graphs of contracts into Graphviz <code>.dot</code> files.</p>"},{"location":"static-analysis/printers/inheritance-graph/#example","title":"Example","text":"PoolManager inheritance graph contracts/PoolManager.sol_PoolManager PoolManager contracts/interfaces/IPoolManager.sol_IPoolManager IPoolManager contracts/PoolManager.sol_PoolManager-&gt;contracts/interfaces/IPoolManager.sol_IPoolManager contracts/Fees.sol_Fees Fees contracts/PoolManager.sol_PoolManager-&gt;contracts/Fees.sol_Fees contracts/NoDelegateCall.sol_NoDelegateCall NoDelegateCall contracts/PoolManager.sol_PoolManager-&gt;contracts/NoDelegateCall.sol_NoDelegateCall lib/openzeppelin-contracts/contracts/token/ERC1155/ERC1155.sol_ERC1155 ERC1155 contracts/PoolManager.sol_PoolManager-&gt;lib/openzeppelin-contracts/contracts/token/ERC1155/ERC1155.sol_ERC1155 lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155Receiver.sol_IERC1155Receiver IERC1155Receiver contracts/PoolManager.sol_PoolManager-&gt;lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155Receiver.sol_IERC1155Receiver contracts/interfaces/IFees.sol_IFees IFees contracts/interfaces/IPoolManager.sol_IPoolManager-&gt;contracts/interfaces/IFees.sol_IFees lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol_IERC1155 IERC1155 contracts/interfaces/IPoolManager.sol_IPoolManager-&gt;lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol_IERC1155 contracts/Fees.sol_Fees-&gt;contracts/interfaces/IFees.sol_IFees contracts/Owned.sol_Owned Owned contracts/Fees.sol_Fees-&gt;contracts/Owned.sol_Owned lib/openzeppelin-contracts/contracts/token/ERC1155/ERC1155.sol_ERC1155-&gt;lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol_IERC1155 lib/openzeppelin-contracts/contracts/utils/Context.sol_Context Context lib/openzeppelin-contracts/contracts/token/ERC1155/ERC1155.sol_ERC1155-&gt;lib/openzeppelin-contracts/contracts/utils/Context.sol_Context lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol_ERC165 ERC165 lib/openzeppelin-contracts/contracts/token/ERC1155/ERC1155.sol_ERC1155-&gt;lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol_ERC165 lib/openzeppelin-contracts/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol_IERC1155MetadataURI IERC1155MetadataURI lib/openzeppelin-contracts/contracts/token/ERC1155/ERC1155.sol_ERC1155-&gt;lib/openzeppelin-contracts/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol_IERC1155MetadataURI lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol_IERC165 IERC165 lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155Receiver.sol_IERC1155Receiver-&gt;lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol_IERC165 lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol_IERC1155-&gt;lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol_IERC165 lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol_ERC165-&gt;lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol_IERC165 lib/openzeppelin-contracts/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol_IERC1155MetadataURI-&gt;lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol_IERC1155"},{"location":"static-analysis/printers/inheritance-graph/#parameters","title":"Parameters","text":"Command-line name TOML name Type Default value Description <code>--name</code> (multiple) <code>names</code> <code>List[str]</code> <code>[]</code> Names of contracts to generate inheritance graphs for. <code>--out</code> <code>out</code> <code>str</code> <code>.wake/inheritance-graphs</code> Output directory path. <code>--direction</code> <code>direction</code> Choice of <code>TB</code>, <code>BT</code>, <code>LR</code>, <code>RL</code> <code>BT</code> Direction of the graph. <code>--links</code> <code>links</code> <code>bool</code> <code>True</code> Whether to generate links to the source code. <code>--force</code> <code>force</code> <code>bool</code> <code>False</code> Whether to overwrite existing files. <code>--children</code> <code>children</code> <code>bool</code> <code>True</code> Whether to generate children of selected contracts. <code>--parents</code> <code>parents</code> <code>bool</code> <code>True</code> Whether to generate parents of selected contracts. <code>--interfaces</code> <code>interfaces</code> <code>bool</code> <code>True</code> Whether to generate interfaces. <code>--single-file</code>/<code>--multiple-files</code> <code>single_file</code> <code>bool</code> <code>True</code> Whether to generate a single file or multiple files per contract."},{"location":"static-analysis/printers/inheritance-tree/","title":"Inheritance tree printer","text":"<p>Name: <code>inheritance-tree</code></p> <p>Prints inheritance trees of contracts in given paths or in the whole project.</p>"},{"location":"static-analysis/printers/inheritance-tree/#example","title":"Example","text":"wake\u00a0print\u00a0inheritance-tree PoolManager\u00a0inheritance\u00a0tree \u251c\u2500\u2500\u00a0IPoolManager \u2502\u00a0\u00a0\u00a0\u251c\u2500\u2500\u00a0IFees \u2502\u00a0\u00a0\u00a0\u2514\u2500\u2500\u00a0IERC1155 \u2502\u00a0\u00a0\u00a0\u2514\u2500\u2500\u00a0IERC165 \u251c\u2500\u2500\u00a0Fees \u2502\u00a0\u00a0\u00a0\u251c\u2500\u2500\u00a0IFees \u2502\u00a0\u00a0\u00a0\u2514\u2500\u2500\u00a0Owned \u251c\u2500\u2500\u00a0NoDelegateCall \u251c\u2500\u2500\u00a0ERC1155 \u2502\u00a0\u00a0\u00a0\u251c\u2500\u2500\u00a0Context \u2502\u00a0\u00a0\u00a0\u251c\u2500\u2500\u00a0ERC165 \u2502\u00a0\u00a0\u00a0\u2502\u00a0\u00a0\u00a0\u2514\u2500\u2500\u00a0IERC165 \u2502\u00a0\u00a0\u00a0\u251c\u2500\u2500\u00a0IERC1155 \u2502\u00a0\u00a0\u00a0\u2502\u00a0\u00a0\u00a0\u2514\u2500\u2500\u00a0IERC165 \u2502\u00a0\u00a0\u00a0\u2514\u2500\u2500\u00a0IERC1155MetadataURI \u2502\u00a0\u00a0\u00a0\u2514\u2500\u2500\u00a0IERC1155 \u2502\u00a0\u00a0\u00a0\u2514\u2500\u2500\u00a0IERC165 \u2514\u2500\u2500\u00a0IERC1155Receiver \u2514\u2500\u2500\u00a0IERC165"},{"location":"static-analysis/printers/inheritance-tree/#parameters","title":"Parameters","text":"Command-line name TOML name Type Default value Description <code>--name</code> (multiple) <code>names</code> <code>List[str]</code> <code>[]</code> Contract names to generate inheritance trees for."},{"location":"static-analysis/printers/lsp-control-flow-graph/","title":"LSP control flow graph","text":"<p>Name: <code>lsp-control-flow-graph</code></p> <p>Generates a control flow graph of a function or modifier by clicking on the code lens using the Language Server Protocol.</p>"},{"location":"static-analysis/printers/lsp-control-flow-graph/#example","title":"Example","text":""},{"location":"static-analysis/printers/lsp-control-flow-graph/#parameters","title":"Parameters","text":"TOML name Type Default value Description <code>direction</code> Choice of <code>TB</code>, <code>BT</code>, <code>LR</code>, <code>RL</code> <code>TB</code> Direction of the graph. <code>urls</code> <code>bool</code> <code>true</code> Whether to generate links to the source code."},{"location":"static-analysis/printers/lsp-inheritance-graph/","title":"LSP inheritance graph","text":"<p>Name: <code>lsp-inheritance-graph</code></p> <p>Generates an inheritance graph of a contract by clicking on the code lens using the Language Server Protocol.</p>"},{"location":"static-analysis/printers/lsp-inheritance-graph/#example","title":"Example","text":""},{"location":"static-analysis/printers/lsp-inheritance-graph/#parameters","title":"Parameters","text":"TOML name Type Default value Description <code>direction</code> Choice of <code>TB</code>, <code>BT</code>, <code>LR</code>, <code>RL</code> <code>BT</code> Direction of the graph. <code>urls</code> <code>bool</code> <code>true</code> Whether to generate links to the source code."},{"location":"static-analysis/printers/lsp-linearized-inheritance-graph/","title":"LSP linearized inheritance graph","text":"<p>Name: <code>lsp-linearized-inheritance-graph</code></p> <p>Generates a linearized inheritance graph of a contract by clicking on the code lens using the Language Server Protocol.</p>"},{"location":"static-analysis/printers/lsp-linearized-inheritance-graph/#example","title":"Example","text":""},{"location":"static-analysis/printers/lsp-linearized-inheritance-graph/#parameters","title":"Parameters","text":"TOML name Type Default value Description <code>direction</code> Choice of <code>TB</code>, <code>BT</code>, <code>LR</code>, <code>RL</code> <code>TB</code> Direction of the graph. <code>urls</code> <code>bool</code> <code>true</code> Whether to generate links to the source code."},{"location":"static-analysis/printers/lsp-openzeppelin-docs/","title":"LSP OpenZeppelin docs","text":"<p>Name: <code>lsp-openzeppelin-docs</code></p> <p>Shows links to OpenZeppelin documentation for OpenZeppelin contracts using the Language Server Protocol hover.</p>"},{"location":"static-analysis/printers/lsp-openzeppelin-docs/#example","title":"Example","text":""},{"location":"static-analysis/printers/lsp-openzeppelin-docs/#parameters","title":"Parameters","text":"<p>The printer does not accept any additional parameters.</p>"},{"location":"static-analysis/printers/lsp-references/","title":"LSP references","text":"<p>Name: <code>lsp-references</code></p> <p>Shows the number of references to a declaration using the Language Server Protocol code lens. Clicking on the code lens shows the references in the editor.</p>"},{"location":"static-analysis/printers/lsp-references/#example","title":"Example","text":""},{"location":"static-analysis/printers/lsp-references/#parameters","title":"Parameters","text":"TOML name Type Default value Description <code>include_declarations</code> <code>bool</code> <code>false</code> Whether to include the declaration in the references. <code>local_variables</code> <code>bool</code> <code>true</code> Whether to show references of local variables. <code>parameter_variables</code> <code>bool</code> <code>true</code> Whether to show references of variables in parameter lists."},{"location":"static-analysis/printers/lsp-selectors/","title":"LSP selectors","text":"<p>Name: <code>lsp-selectors</code></p> <p>Shows selectors of functions, public state variables, events, and errors using the Language Server Protocol code lens. Clicking on the code lens copies the selector to the clipboard.</p>"},{"location":"static-analysis/printers/lsp-selectors/#example","title":"Example","text":""},{"location":"static-analysis/printers/lsp-selectors/#parameters","title":"Parameters","text":"TOML name Type Default value Description <code>functions</code> <code>bool</code> <code>true</code> Whether to show selectors of functions. <code>variables</code> <code>bool</code> <code>true</code> Whether to show selectors of state variables. <code>events</code> <code>bool</code> <code>true</code> Whether to show selectors of events. <code>errors</code> <code>bool</code> <code>true</code> Whether to show selectors of errors."},{"location":"static-analysis/printers/lsp-yul-definitions/","title":"LSP Yul definitions","text":"<p>Name: <code>lsp-yul-definitions</code></p> <p>Shows definitions of built-in Yul functions through the Language Server Protocol hover.</p>"},{"location":"static-analysis/printers/lsp-yul-definitions/#example","title":"Example","text":""},{"location":"static-analysis/printers/lsp-yul-definitions/#parameters","title":"Parameters","text":"<p>The printer does not accept any additional parameters.</p>"},{"location":"static-analysis/printers/modifiers/","title":"Modifiers printer","text":"<p>Name: <code>modifiers</code></p> <p>Prints modifiers with their usages.</p>"},{"location":"static-analysis/printers/modifiers/#example","title":"Example","text":"wake\u00a0print\u00a0modifiers \u256d\u2500\u2500\u2500\u2500\u00a0Modifier\u00a0noDelegateCall\u00a0\u2500\u2500\u2500\u2500\u256e\u256d\u2500\u2500\u00a0Invocations\u00a0\u2500\u2500\u2500\u256e \u2502modifiernoDelegateCall(){\u2502\u2502-\u00a0modifyPosition\u2502 \u2502checkNotDelegateCall();\u2502\u2502-\u00a0take\u2502 \u2502_;\u2502\u2502-\u00a0donate\u2502 \u2502}\u2502\u2502-\u00a0settle\u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\u2502-\u00a0swap\u2502 \u2502-\u00a0mint\u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u00a0Modifier\u00a0onlyOwner\u00a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u00a0Invocations\u00a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502modifieronlyOwner(){\u2502\u2502-\u00a0setProtocolFeeController\u2502 \u2502if(msg.sender!=owner)\u2502\u2502-\u00a0setOwner\u2502 \u2502revertInvalidCaller();\u2502\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u2502_;\u2502 \u2502}\u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u00a0Modifier\u00a0onlyByLocker\u00a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\u256d\u2500\u2500\u00a0Invocations\u00a0\u2500\u2500\u2500\u256e \u2502modifieronlyByLocker(){\u2502\u2502-\u00a0mint\u2502 \u2502addresslocker=\u2502\u2502-\u00a0modifyPosition\u2502 \u2502lockData.getActiveLock();\u2502\u2502-\u00a0donate\u2502 \u2502if(msg.sender!=locker)\u2502\u2502-\u00a0take\u2502 \u2502revertLockedBy(locker);\u2502\u2502-\u00a0settle\u2502 \u2502_;\u2502\u2502-\u00a0swap\u2502 \u2502}\u2502\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f"},{"location":"static-analysis/printers/modifiers/#parameters","title":"Parameters","text":"Command-line name TOML name Type Default value Description <code>--name</code> (multiple) <code>names</code> <code>List[str]</code> <code>[]</code> Modifier names. <code>--canonical-names</code>/<code>--no-canonical-names</code> <code>canonical_names</code> <code>bool</code> <code>True</code> Whether to print (full) canonical names instead of local names. <code>--code-snippets</code>/<code>--no-code-snippets</code> <code>code_snippets</code> <code>bool</code> <code>True</code> Whether to print modifier source code snippets."},{"location":"static-analysis/printers/state-changes/","title":"State changes printer","text":"<p>Name: <code>state-changes</code></p> <p>Prints all blockchain state changes performed by a function/modifier and all subsequent function calls.</p>"},{"location":"static-analysis/printers/state-changes/#example","title":"Example","text":"wake\u00a0print\u00a0state-changes FunctionPoolManager.take(Currency,address,uint256)\u00a0modifies\u00a0state: \u00a0\u00a0-\u00a0in\u00a0function\u00a0PoolManager.take(Currency,address,uint256): \u00a0\u00a0\u00a0\u00a0-\u00a0MODIFIES\u00a0STATE\u00a0VAR reservesOf[currency]-=amount \u00a0\u00a0-\u00a0in\u00a0function\u00a0CurrencyLibrary.transfer(Currency,address,uint256): \u00a0\u00a0\u00a0\u00a0-\u00a0PERFORMS\u00a0CALL call(gas(),to,amount,0,0,0,0) \u00a0\u00a0\u00a0\u00a0-\u00a0SENDS\u00a0ETHER call(gas(),to,amount,0,0,0,0) \u00a0\u00a0\u00a0\u00a0-\u00a0PERFORMS\u00a0CALL call(gas(),currency,0,0,68,0,32) \u00a0\u00a0-\u00a0in\u00a0function\u00a0PoolManager._accountDelta(Currency,int128): \u00a0\u00a0\u00a0\u00a0-\u00a0MODIFIES\u00a0STATE\u00a0VAR lockData.nonzeroDeltaCount-- \u00a0\u00a0\u00a0\u00a0-\u00a0MODIFIES\u00a0STATE\u00a0VAR lockData.nonzeroDeltaCount++ \u00a0\u00a0\u00a0\u00a0-\u00a0MODIFIES\u00a0STATE\u00a0VAR currencyDelta[locker][currency]=next"},{"location":"static-analysis/printers/state-changes/#parameters","title":"Parameters","text":"Command-line name TOML name Type Default value Description <code>--name</code> (multiple) <code>names</code> <code>List[str]</code> <code>[]</code> Function and modifier names to print state changes for. <code>--links</code> <code>links</code> <code>bool</code> <code>True</code> Whether to print links to the source code."},{"location":"static-analysis/printers/storage-layout/","title":"Storage layout printer","text":"<p>Name: <code>storage-layout</code></p> <p>Prints storage layout of contracts in given paths or in the whole project.</p>"},{"location":"static-analysis/printers/storage-layout/#example","title":"Example","text":"wake\u00a0print\u00a0storage-layout \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0PoolManager\u00a0storage\u00a0layout\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503Slot\u2503Offset\u2503Name\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2503Type\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2503Contract\u00a0\u00a0\u00a0\u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u25020\u00a0\u00a0\u00a0\u25020\u00a0\u00a0\u00a0\u00a0\u00a0\u2502owner\u2502address\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2502Owned\u2502 \u2502\u250220\u00a0\u00a0\u00a0\u00a0\u2502STORAGE_PLACEHOLDER\u2502bytes12\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2502Owned\u2502 \u25021\u00a0\u00a0\u00a0\u25020\u00a0\u00a0\u00a0\u00a0\u00a0\u2502protocolFeesAccrued\u2502mapping(Currency\u00a0=&gt;\u00a0uint256)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2502Fees\u2502 \u25022\u00a0\u00a0\u00a0\u25020\u00a0\u00a0\u00a0\u00a0\u00a0\u2502hookFeesAccrued\u2502mapping(address\u00a0=&gt;\u00a0mapping(Currency\u00a0=&gt;\u00a0uint256))\u2502Fees\u2502 \u25023\u00a0\u00a0\u00a0\u25020\u00a0\u00a0\u00a0\u00a0\u00a0\u2502protocolFeeController\u2502contract\u00a0IProtocolFeeController\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2502Fees\u2502 \u25024\u00a0\u00a0\u00a0\u25020\u00a0\u00a0\u00a0\u00a0\u00a0\u2502_balances\u2502mapping(uint256\u00a0=&gt;\u00a0mapping(address\u00a0=&gt;\u00a0uint256))\u00a0\u2502ERC1155\u2502 \u25025\u00a0\u00a0\u00a0\u25020\u00a0\u00a0\u00a0\u00a0\u00a0\u2502_operatorApprovals\u2502mapping(address\u00a0=&gt;\u00a0mapping(address\u00a0=&gt;\u00a0bool))\u00a0\u00a0\u00a0\u00a0\u2502ERC1155\u2502 \u25026\u00a0\u00a0\u00a0\u25020\u00a0\u00a0\u00a0\u00a0\u00a0\u2502_uri\u2502string\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2502ERC1155\u2502 \u25027\u00a0\u00a0\u00a0\u25020\u00a0\u00a0\u00a0\u00a0\u00a0\u2502lockData\u2502struct\u00a0IPoolManager.LockData\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2502PoolManager\u2502 \u25028\u00a0\u00a0\u00a0\u25020\u00a0\u00a0\u00a0\u00a0\u00a0\u2502currencyDelta\u2502mapping(address\u00a0=&gt;\u00a0mapping(Currency\u00a0=&gt;\u00a0int256))\u00a0\u2502PoolManager\u2502 \u25029\u00a0\u00a0\u00a0\u25020\u00a0\u00a0\u00a0\u00a0\u00a0\u2502reservesOf\u2502mapping(Currency\u00a0=&gt;\u00a0uint256)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2502PoolManager\u2502 \u250210\u00a0\u00a0\u25020\u00a0\u00a0\u00a0\u00a0\u00a0\u2502pools\u2502mapping(PoolId\u00a0=&gt;\u00a0struct\u00a0Pool.State)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2502PoolManager\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518"},{"location":"static-analysis/printers/storage-layout/#parameters","title":"Parameters","text":"Command-line name TOML name Type Default value Description <code>--name</code> (multiple) <code>names</code> <code>List[str]</code> <code>[]</code> Names of contracts to print storage layout for. <code>--split-slots</code> <code>split_slots</code> <code>bool</code> <code>False</code> Print a horizontal line between different slots. <code>--table-style</code> <code>table_style</code> <code>str</code> <code>\"\"</code> Rich style of the table. <code>--header-style</code> <code>header_style</code> <code>str</code> <code>\"\"</code> Rich style of the table header. <code>--style</code> <code>style</code> <code>str</code> <code>cyan</code> Rich style of the table cells."},{"location":"static-analysis/printers/tokens/","title":"Tokens printer","text":"<p>Name: <code>tokens</code></p> <p>The printer prints the list of all ERC-20, ERC-721, and ERC-1155 tokens detected in the analyzed contracts.</p>"},{"location":"static-analysis/printers/tokens/#example","title":"Example","text":"wake\u00a0print\u00a0tokens \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Tokens\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503Contract\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2503Type\u00a0\u00a0\u2503Location\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502MockGovernanceToken\u2502ERC-20\u2502contracts/mining/mocks/tokens/\u2026\u2502 \u2502MockLpToken\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2502ERC-20\u2502contracts/mining/mocks/tokens/\u2026\u2502 \u2502MockToken\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2502ERC-20\u2502contracts/mining/mocks/tokens/\u2026\u2502 \u2502MockTokenDai\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2502ERC-20\u2502contracts/mining/mocks/tokens/\u2026\u2502 \u2502MockTokenUsdc\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2502ERC-20\u2502contracts/mining/mocks/tokens/\u2026\u2502 \u2502MockTokenUsdt\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2502ERC-20\u2502contracts/mining/mocks/tokens/\u2026\u2502 \u2502IpToken\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2502ERC-20\u2502contracts/tokens/IpToken.sol\u2502 \u2502IporToken\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2502ERC-20\u2502contracts/tokens/IporToken.sol\u2502 \u2502IvToken\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2502ERC-20\u2502contracts/tokens/IvToken.sol\u2502 \u2502ERC20Upgradeable\u00a0\u00a0\u00a0\u2502ERC-20\u2502node_modules/@openzeppelin/con\u2026\u2502 \u2502ERC20\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2502ERC-20\u2502node_modules/@openzeppelin/con\u2026\u2502 \u2502MockTestnetToken\u00a0\u00a0\u00a0\u2502ERC-20\u2502test/mocks/tokens/MockTestnetT\u2026\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518"},{"location":"static-analysis/printers/tokens/#parameters","title":"Parameters","text":"Command-line name TOML name Type Default value Description <code>--erc20</code> <code>erc20</code> <code>bool</code> <code>True</code> Print ERC-20 tokens. <code>--erc721</code> <code>erc721</code> <code>bool</code> <code>True</code> Print ERC-721 tokens. <code>--erc1155</code> <code>erc1155</code> <code>bool</code> <code>True</code> Print ERC-1155 tokens. <code>--erc20-threshold</code> <code>erc20_threshold</code> <code>int</code> <code>4</code> Number of ERC-20 functions/events required to consider a contract an ERC-20 token. <code>--erc721-threshold</code> <code>erc721_threshold</code> <code>int</code> <code>6</code> Number of ERC-721 functions/events required to consider a contract an ERC-721 token. <code>--erc1155-threshold</code> <code>erc1155_threshold</code> <code>int</code> <code>4</code> Number of ERC-1155 functions/events required to consider a contract an ERC-1155 token. <code>--interface</code>/<code>--no-interface</code> <code>interface</code> <code>bool</code> <code>False</code> Print interfaces. <code>--abstract</code>/<code>--no-abstract</code> <code>abstract</code> <code>bool</code> <code>False</code> Print abstract contracts. <code>--table-style</code> <code>table_style</code> <code>str</code> <code>\"\"</code> Rich style of the table. <code>--header-style</code> <code>header_style</code> <code>str</code> <code>\"\"</code> Rich style of the table header. <code>--style</code> <code>style</code> <code>str</code> <code>cyan</code> Rich style of the table cells."},{"location":"testing-framework/accounts-and-addresses/","title":"Accounts and addresses","text":"<p>Wake testing framework strictly distinguishes between accounts and addresses. However, in most cases, API functions accept both <code>Account</code> and <code>Address</code> types.</p>"},{"location":"testing-framework/accounts-and-addresses/#addresses","title":"Addresses","text":"<p><code>Address</code> is a 20-byte value encoded as a hex string. It can be constructed from a hex string or an integer:</p> <pre><code>from wake.testing import Address\n\nAddress(\"0x0000000000000000000000000000000000000000\")\nAddress(0)\n</code></pre> <p>The hex string does not have to be EIP-55 compliant.</p> <p>Addresses can be compared with each other:</p> <pre><code>from wake.testing import Address\n\nassert Address(1) &gt; Address(0)\n</code></pre>"},{"location":"testing-framework/accounts-and-addresses/#accounts","title":"Accounts","text":"<p><code>Account</code> is an <code>Address</code> bound to a specific <code>Chain</code>. It can be constructed from an <code>Address</code>, a hex string or an integer. Optionally, a chain can be specified, otherwise the <code>default_chain</code> global object is used:</p> <pre><code>from wake.testing import Account, Chain, default_chain\n\nother_chain = Chain()\n\nassert Account(0) == Account(0, default_chain)\nassert Account(0) != Account(0, other_chain)\n</code></pre> <p><code>Address</code> and <code>Account</code> instances cannot be compared with each other. <code>Account</code> instances belonging to different chains cannot be compared using the <code>&lt;</code> and <code>&gt;</code> operators.</p> <p>Using accounts belonging to different chains</p> <p>To save users from accidentally using accounts belonging to different chains, Wake testing framework does not accept <code>Account</code> instances belonging to different chains in most API functions. To overcome this limitation, it is possible to use the <code>address</code> property of an <code>Account</code> instance.</p>"},{"location":"testing-framework/accounts-and-addresses/#importing-accounts-and-addresses","title":"Importing accounts and addresses","text":"<p><code>Account</code> and <code>Address</code> instances can be imported from a private key:</p> <pre><code>from wake.testing import Account, Address\n\nAccount.from_key(\"0x\" + \"a\" * 64)\nAddress.from_key(\"0x\" + \"a\" * 64)\n</code></pre> <p>From a mnemonic:</p> <pre><code>from wake.testing import Account, Address\n\nAccount.from_mnemonic(\" \".join([\"test\"] * 11 + [\"junk\"]))\nAddress.from_mnemonic(\" \".join([\"test\"] * 11 + [\"junk\"]))\n</code></pre> <p>Or from an alias (see Managing accounts with private keys):</p> <pre><code>from wake.testing import Account, Address\n\nAccount.from_alias(\"alice\")\nAddress.from_alias(\"alice\")\n</code></pre> <p>It is also possible to create a new account with a random private key:</p> <pre><code>from wake.testing import Account\n\nAccount.new()\n</code></pre> <p>In all of the above cases, a private key is stored together with the account and can be used to sign transactions or messages.</p>"},{"location":"testing-framework/accounts-and-addresses/#signing-messages","title":"Signing messages","text":"<p><code>Account</code> instances can be used to sign messages. This is only possible if the account has a known private key. The private key must be imported using one of the methods described in the previous section or must be owned by the client (the account must be present in <code>chain.accounts</code>).</p>"},{"location":"testing-framework/accounts-and-addresses/#signing-raw-messages","title":"Signing raw messages","text":"<p>Using <code>account.sign(message)</code> it is possible to sign any message in the form of bytes:</p> <pre><code>from wake.testing import Account\n\naccount = Account.from_mnemonic(\" \".join([\"test\"] * 11 + [\"junk\"]))\nsignature = account.sign(b\"Hello, world!\")\n</code></pre> <p>The message is signed according to the EIP-191 standard (version <code>0x45</code>).</p>"},{"location":"testing-framework/accounts-and-addresses/#signing-structured-messages","title":"Signing structured messages","text":"<p>Using <code>account.sign_structured(message)</code> it is possible to sign structured messages:</p> <pre><code>from wake.testing import *\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass Transfer:\n    sender: Address\n    recipient: Address\n    amount: uint256\n\n\naccount = Account.from_mnemonic(\" \".join([\"test\"] * 11 + [\"junk\"]))\nsignature = account.sign_structured(\n    Transfer(\n        sender=account.address,\n        recipient=Address(1),\n        amount=10,\n    ),\n    domain=Eip712Domain(\n        name=\"Test\",\n        chainId=default_chain.chain_id,\n    )\n)\n</code></pre> <p>See EIP-712 for more information.</p>"},{"location":"testing-framework/accounts-and-addresses/#signing-message-hash","title":"Signing message hash","text":"<p>While it is not recommended to sign message hashes directly, it is sometimes necessary. To sign a message hash, use <code>account.sign_hash(message_hash)</code>:</p> <pre><code>from wake.testing import *\n\naccount = Account.from_mnemonic(\" \".join([\"test\"] * 11 + [\"junk\"]))\nsignature = account.sign_hash(keccak256(b\"Hello, world!\"))\n</code></pre> <p>Warning</p> <p>Always sign a message hash only if you know the original message.</p>"},{"location":"testing-framework/accounts-and-addresses/#assigning-labels","title":"Assigning labels","text":"<p><code>Account</code> instances can be assigned labels. Labels override the default string representation of the account:</p> <pre><code>from wake.testing import Account\n\naccount = Account(0)\naccount.label = \"ZERO\"\n</code></pre> <p>Setting the label to <code>None</code> removes the label.</p>"},{"location":"testing-framework/accounts-and-addresses/#account-properties","title":"Account properties","text":"<p><code>Account</code> instances have the following properties:</p> Property Description <code>address</code> <code>Address</code> of the account <code>balance</code> balance of the account in Wei <code>chain</code> <code>Chain</code> the account is bound to <code>code</code> code of the account <code>label</code> string label of the account <code>nonce</code> nonce of the account <code>private_key</code> private key of the account (if known) <p>Except for <code>address</code>, <code>chain</code> and <code>private_key</code>, all properties can be assigned to. <code>nonce</code> can only be incremented.</p>"},{"location":"testing-framework/accounts-and-addresses/#low-level-calls-and-transactions","title":"Low-level calls and transactions","text":"<p>Each <code>Account</code> instance has <code>call</code>, <code>transact</code>, <code>estimate</code> and <code>access_list</code> methods that can be used to perform arbitrary requests (see Interacting with contracts):</p> <pre><code>from wake.testing import *\n\n\n@default_chain.connect()\ndef test_accounts():\n    alice = default_chain.accounts[0]\n    bob = default_chain.accounts[1]\n\n    alice.balance = 100\n    bob.balance = 0\n\n    bob.transact(value=10, from_=alice)\n    assert alice.balance == 90\n    assert bob.balance == 10\n</code></pre> <p>The previous example shows how to transfer Wei from one account to another.</p> <p>Low-level contract creation</p> <p>To deploy a contract from creation code, use <code>chain.deploy</code>:</p> <pre><code>default_chain.deploy(Counter.get_creation_code())\n</code></pre>"},{"location":"testing-framework/accounts-and-addresses/#contract-accounts","title":"Contract accounts","text":"<p>Contract accounts are accounts that have non-empty code. Everything that applies to <code>Account</code> instances also applies to contract accounts. However, contract accounts have additional methods:</p> <ul> <li><code>get_creation_code</code> - returns the code used to deploy the contract, may require addresses of libraries needed by the contract,</li> <li><code>deploy</code> - deploys the contract, requires equivalent arguments as the constructor of the contract in Solidity,</li> <li>other contract-specific methods generated in <code>pytypes</code>, including getters for public state variables.</li> </ul> <pre><code>from pytypes.contracts.Counter import Counter\n\nassert len(Counter.get_creation_code()) &gt; 0\nprint(Counter.setCount.selector.hex())\n</code></pre> <p>Every method of a contract generated in <code>pytypes</code> has a <code>selector</code> property.</p> <p>Constructing contracts from an address</p> <p>The ability to construct a contract from an address (and an optional <code>Chain</code> instance) can be very useful when interacting with contracts through proxies:</p> <pre><code>from wake.testing import *\nfrom pytypes.contracts.Counter import Counter\nfrom pytypes.openzeppelin.contracts.proxy.ERC1967.ERC1967Proxy import ERC1967Proxy\n\n@default_chain.connect()\ndef test_proxy():\n    impl = Counter.deploy()\n    proxy = ERC1967Proxy.deploy(impl, b\"\")\n\n    # behave as if Counter was deployed at proxy.address\n    counter = Counter(proxy.address)\n    counter.increment()\n    assert counter.count() == 1\n</code></pre>"},{"location":"testing-framework/chains-and-blocks/","title":"Chains and blocks","text":"<p>For single chain tests, Wake provides the global <code>default_chain</code> variable. This variable is a <code>Chain</code> object that can be used to change the chain parameters or access the chain data. Other <code>Chain</code> instances can be created, which is useful in Cross-chain testing.</p>"},{"location":"testing-framework/chains-and-blocks/#chain-properties","title":"Chain properties","text":"<p>The <code>Chain</code> object has the following properties:</p> Property Description <code>accounts</code> list of <code>Account</code> objects owned by the client (private keys are known to the client) <code>automine</code> whether to automatically mine blocks <code>blocks</code> property to access the chain blocks <code>block_gas_limit</code> gas limit of the pending block <code>chain_id</code> chain ID <code>chain_interface</code> low-level chain interface useful for debugging and power users <code>client_version</code> client version as reported by the <code>web3_clientVersion</code> JSON-RPC method <code>coinbase</code> coinbase <code>Account</code>, i.e. account of the miner who mined the block <code>connected</code> whether the chain is connected <code>default_access_list_account</code> default <code>Account</code> used for access list creation requests <code>default_call_account</code> default <code>Account</code> used for calls <code>default_estimate_account</code> default <code>Account</code> used for gas estimations <code>default_tx_account</code> default <code>Account</code> used for transactions <code>default_tx_confirmations</code> default number of confirmations (mined blocks) needed before a transaction object is returned <code>default_tx_type</code> default transaction type (0, 1, or 2) used when sending transactions <code>gas_price</code> gas price used for all type 0 and type 1 transactions sent to the chain <code>max_priority_fee_per_gas</code> max priority fee per gas used for all type 2 transactions sent to the chain <code>require_signed_transactions</code> whether to send signed transactions or unsigned transactions <code>txs</code> dictionary of transaction objects indexed by transaction hash (a string starting with <code>0x</code>) <code>tx_callback</code> callback function to be called when a transaction is mined; applies only to <code>return_tx=False</code> transactions <p><code>automine</code>, <code>block_gas_limit</code>, <code>coinbase</code>, <code>default_call_account</code>, <code>default_tx_account</code>, <code>gas_price</code>, and <code>tx_callback</code> can be assigned to.</p>"},{"location":"testing-framework/chains-and-blocks/#chain-methods","title":"Chain methods","text":"<p>The <code>Chain</code> object has the following methods:</p> Method Description <code>change_automine</code> context manager to temporarily change the <code>automine</code> property <code>connect</code> context manager to launch a chain and connect to it or connect to an already running chain <code>mine</code> mine a block with an optional callback function to set the next block timestamp <code>mine_many</code> mine multiple blocks with an optional timestamp delta between blocks <code>reset</code> reset the chain to its initial state <code>revert</code> revert the chain to a previous state given by a snapshot ID <code>set_default_accounts</code> set the default accounts for <code>tx</code>, <code>call</code>, <code>estimate</code>, and <code>access_list</code> requests at once <code>set_min_gas_price</code> set the minimum gas price accepted by the chain <code>set_next_block_base_fee_per_gas</code> set the base fee per gas for the next block <code>set_next_block_timestamp</code> set the timestamp of the next block <code>snapshot</code> take a snapshot of the chain state; return a snapshot ID <code>snapshot_and_revert</code> context manager to take a snapshot and revert to it after the context ends <code>update_accounts</code> update the accounts list <code>deploy</code> low-level method for deploying contracts from creation code <p>It is recommended to use the context managers <code>change_automine</code> and <code>snapshot_and_revert</code> instead of setting the <code>automine</code> property directly or calling <code>snapshot</code> and <code>revert</code> manually.</p> <p>The following example presents the use of <code>Chain</code> methods:</p> <pre><code>from wake.testing import default_chain\n\n\ndef test_chain():\n    # launch a chain and connect to it\n    with default_chain.connect(), default_chain.snapshot_and_revert():\n        # mine a block with the timestamp 1 greater than the previous block\n        default_chain.mine(lambda x: x + 1)\n</code></pre> <p>All <code>Chain</code> context managers can be used as decorators:</p> <pre><code>from wake.testing import default_chain\n\n\n@default_chain.connect()\n@default_chain.snapshot_and_revert()\n@default_chain.change_automine(False)\ndef test_chain():\n    # mine a block with the timestamp 1 greater than the previous block\n    default_chain.mine(lambda x: x + 1)\n</code></pre>"},{"location":"testing-framework/chains-and-blocks/#connect-keyword-arguments","title":"<code>connect</code> keyword arguments","text":"<p>The <code>connect</code> context manager accepts keyword arguments that can override the command line arguments set in configuration files:</p> Keyword argument Description Default value <code>accounts</code> number of accounts to generate <code>None</code> (do not override) <code>chain_id</code> chain ID assigned to the chain <code>None</code> (do not override) <code>fork</code> URL of the chain to fork from <code>None</code> (do not override) <code>hardfork</code> hardfork to use <code>None</code> (do not override) <code>min_gas_price</code> minimum gas price accepted by the chain <code>0</code> <code>block_base_fee_per_gas</code> base fee per gas for the next block <code>0</code> <p>Warning</p> <p><code>connect</code> keyword arguments can only be used when launching a new development chain. Also, it is not possible to set these keyword arguments when working with Hardhat.</p> <pre><code>from wake.testing import default_chain\n\n\n@default_chain.connect(\n    accounts=15,\n    chain_id=1020,\n)\ndef test_chain():\n    assert len(default_chain.accounts) == 15\n    assert default_chain.chain_id == 1020\n</code></pre>"},{"location":"testing-framework/chains-and-blocks/#accessing-chain-blocks","title":"Accessing chain blocks","text":"<p>The <code>chain.blocks</code> property can be used to access up-to-date chain blocks data. It can be indexed by an integer or string literals <code>latest</code>, <code>pending</code>, <code>earliest</code>, <code>safe</code>, and <code>finalized</code>:</p> <pre><code>from wake.testing import default_chain\nfrom pytypes.contracts.Counter import Counter\n\n\n@default_chain.connect()\ndef test_chain_blocks():\n    default_chain.set_default_accounts(default_chain.accounts[0])\n\n    # get the block 0\n    block0 = default_chain.blocks[0]\n    # block 0 and earliest are the same\n    assert block0 == default_chain.blocks[\"earliest\"]\n\n    counter = Counter.deploy()\n\n    # find the first block with non-zero transactions count\n    block = next(block for block in default_chain.blocks if len(block.txs) &gt; 0)\n\n    assert block.txs[0].return_value == counter\n\n    with default_chain.change_automine(False):\n        # block -1 and latest are the same\n        assert default_chain.blocks[-1] == default_chain.blocks[\"latest\"]\n\n        tx = counter.increment(confirmations=0)\n\n        # pending block contains the transaction\n        assert tx in default_chain.blocks[\"pending\"].txs\n</code></pre>"},{"location":"testing-framework/chains-and-blocks/#block-properties","title":"Block properties","text":"<p>The following table lists the most important block properties:</p> Property Description <code>chain</code> chain the block belongs to <code>hash</code> block hash <code>number</code> block number <code>parent_hash</code> parent block hash <code>miner</code> miner <code>Account</code> of the block <code>gas_used</code> amount of gas used in the block <code>gas_limit</code> block gas limit <code>timestamp</code> block timestamp <code>txs</code> list of transaction objects in the block sorted by transaction index"},{"location":"testing-framework/coverage-analysis/","title":"Coverage analysis","text":"<p>Wake supports code coverage analysis of both Python test scripts and Solidity contracts.</p>"},{"location":"testing-framework/coverage-analysis/#python-scripts-coverage","title":"Python scripts coverage","text":"<p>In order to measure coverage of Python scripts executed using <code>wake test</code>, the <code>pytest-cov</code> plugin can be used.</p> <pre><code>pip3 install pytest-cov\n</code></pre> <p>To analyze scripts located in the <code>tests</code> directory, run:</p> <pre><code>$ wake test -- --cov=tests\n\n---------- coverage: platform linux, python 3.7.12-final-0 -----------\nName                                 Stmts   Miss  Cover\n--------------------------------------------------------\ntests/__init__.py                        0      0   100%\ntests/test_counter.py                   36      4    89%\ntests/test_counter_fuzz.py              34      0   100%\ntests/test_counter_fuzz_failing.py      23      4    83%\ntests/test_crosschain.py                63      0   100%\n--------------------------------------------------------\nTOTAL                                  156      8    95%\n</code></pre> <p>Note that the <code>--</code> is required to separate the arguments passed to <code>wake</code> from the arguments passed to <code>pytest</code>.</p>"},{"location":"testing-framework/coverage-analysis/#solidity-contracts-coverage","title":"Solidity contracts coverage","text":"<p>Wake comes with a built-in coverage analysis module that can be activated by passing the <code>--coverage</code> flag to the <code>wake test</code> command. It can be followed by an optional number of processes to collect coverage data from.</p> <pre><code>wake test --coverage\n</code></pre> <p>By passing the <code>--coverage</code> flag to <code>wake test</code> without specifying the number of processes, the coverage analysis is performed for all testing processes. <pre><code>wake test -P 4 --coverage 2\n</code></pre></p> <p>There are some limitations to this coverage analysis:</p> <ul> <li>code coverage can be inaccurate when analyzing a project with the solc optimizer enabled,</li> <li>multiple executions of the same function in the same transaction/call are counted as a single execution,</li> <li><code>call</code> requests (default for <code>pure</code> and <code>view</code> functions) are not included in the coverage analysis with Ganache and Hardhat,</li> <li>code coverage introduces a significant overhead in the execution time of the tests.</li> </ul> <p>By enabling the coverage collection, a <code>wake-coverage.cov</code> file is generated in the current directory. To analyze this file, install Tools for Solidity, a VS Code extension that can be used to visualize the coverage of Solidity contracts directly in the editor. With the extension installed, execute the <code>Tools for Solidity: Show Coverage</code> command to open the coverage report.</p> <p></p> <p>The coverage report is updated automatically when the <code>wake-coverage.cov</code> file is modified. To hide the coverage report, execute the <code>Tools for Solidity: Hide Coverage</code> command.</p> <p>Warning</p> <p>Contents of Solidity source files must not be modified since the last generation of <code>pytypes</code>, otherwise the coverage highlighting may be rendered incorrectly.</p>"},{"location":"testing-framework/cross-chain-testing/","title":"Cross-chain testing","text":"<p>Wake testing framework supports testing multichain solutions. The API remains the same as for single-chain solutions. The only difference is that a <code>Chain</code> instance must be created for each chain. This instance must be passed to all API functions that accept a <code>chain</code> keyword argument, that is:</p> <ul> <li>when deploying a contract (e.g. <code>Counter.deploy(chain=chain1)</code>),</li> <li>when creating an <code>Account</code> instance (e.g. <code>Account(random_address(), chain=chain1)</code>),<ul> <li>including contract instances (e.g. <code>IERC20(erc20, chain=chain1)</code>),</li> </ul> </li> <li>with <code>random_account()</code> (e.g. <code>random_account(chain=chain1)</code>).</li> </ul> <p>Cross-chain testing and <code>default_chain</code></p> <p>It is highly recommended not to use the <code>default_chain</code> global variable in cross-chain tests. Leaving it unconnected helps to find bugs in the code when <code>chain</code> was forgotten to be passed to a function.</p> <p>In this case, <code>NotConnectedError: Not connected to a chain</code> is raised.</p> <p>It is not possible to use <code>Account</code> instances bound to different chains than the chain being interacted with. This is done to prevent accidental misuse of accounts.</p> <pre><code>from wake.testing import *\nfrom wake.testing.fuzzing import random_account\nfrom pytypes.contracts.Counter import Counter\n\nchain1 = Chain()\nchain2 = Chain()\n\n\n@chain1.connect()\n@chain2.connect()\ndef test_cross_chain():\n    owner = random_account(chain=chain2)\n    counter1 = Counter.deploy(from_=owner, chain=chain1)\n</code></pre> <p>The above code snippet will raise <code>ValueError: from_ account must belong to the chain</code>.</p> <p>To overcome this limitation, it is possible to use <code>Address</code> of the account instead:</p> <pre><code>counter1 = Counter.deploy(from_=owner.address, chain=chain1)\n</code></pre>"},{"location":"testing-framework/cross-chain-testing/#relaying-events","title":"Relaying events","text":"<p>In production, cross-chain solutions usually emit events on a source chain. The events are captured by a relayer and appropriate actions are taken on the other chain.</p> <p>Cross-chain tests have to simulate this behavior. The next code snippet shows an example of how a relay function can be implemented:</p> <pre><code>from wake.testing import *\nfrom pytypes.contracts.Counter import Counter\n\nchain1 = Chain()\nchain2 = Chain()\n\n\ndef relay(other_counter: Counter, events: List):\n    for event in events:\n        if isinstance(event, Counter.Incremented):\n            other_counter.increment()\n        elif isinstance(event, Counter.Decremented):\n            other_counter.decrement()\n        elif isinstance(event, Counter.CountSet):\n            other_counter.setCount(event.count)\n\n\n@chain1.connect()\n@chain2.connect()\ndef test_relay():\n    counter1 = Counter.deploy(chain=chain1)\n    counter2 = Counter.deploy(chain=chain2)\n\n    tx = counter1.increment()\n    relay(counter2, tx.events)\n    assert counter2.count() == 1\n\n    tx = counter2.decrement()\n    relay(counter1, tx.events)\n    assert counter1.count() == 0\n\n    tx = counter1.setCount(5)\n    relay(counter2, tx.events)\n    assert counter2.count() == 5\n</code></pre> <p>A slightly different approach can be to register <code>tx_callback</code> on both chains and implement the relay logic there.</p>"},{"location":"testing-framework/debugging/","title":"Debugging","text":""},{"location":"testing-framework/debugging/#using-python-debugger","title":"Using Python debugger","text":"<p><code>wake test</code> supports entering pdb, the Python debugger, when an error occurs. Wake uses an enhanced version of the Python debugger, ipdb, which provides a more user-friendly interface.</p> <p>It is also possible to enter the debugger manually by inserting a <code>breakpoint()</code> statement in the code.</p> <pre><code>from wake.testing import *\n\n\n@default_chain.connect()\ndef test_breakpoint():\n    breakpoint()\n    block = default_chain.blocks[0]\n</code></pre> <p>Info</p> <p><code>breakpoint()</code> is not currently supported when running <code>wake test</code> in multiprocessing mode (with the <code>-P</code> option set)</p> <p>Inside ipdb, any expression can be evaluated by typing it and pressing <code>Enter</code>. This can be used to get the value of a variable, to call a function, including contract functions, or even to deploy a new contract.</p> <p>Useful commands:</p> <ul> <li><code>h</code> or <code>help</code>: show help</li> <li><code>c</code> or <code>continue</code>: continue execution</li> <li><code>n</code> or <code>next</code>: step over the next line</li> <li><code>l</code> or <code>list</code>: show the current line and a few lines around it</li> <li><code>q</code> or <code>quit</code>: quit the debugger</li> <li><code>up</code> or <code>down</code>: move up or down the call stack</li> </ul>"},{"location":"testing-framework/debugging/#call-traces","title":"Call traces","text":"<p>Every transaction object has a <code>call_trace</code> property that visualizes the call stack of the transaction. It can be used to debug failing transactions.</p> <p>External contracts in forking mode</p> <p>When using forking mode (see <code>connect</code> keyword arguments), already present contracts are printed as unknown contracts in call traces. To show contract and function names, configure your API key for a given chain explorer.</p> <pre><code>from wake.testing import *\nfrom pytypes.contracts.Counter import Counter\nfrom pytypes.contracts.Gateway import Gateway\n\n\n@default_chain.connect()\ndef test_call_trace():\n    gateway = Gateway.deploy()\n    counter = Counter.deploy()\n    counter.addToWhitelist(gateway)\n\n    tx = gateway.execute(\n        counter,\n        Abi.encode_call(counter.decrement, []),\n        confirmations=0,\n    )\n    print(tx.call_trace)\n\n    tx = gateway.execute(\n        counter,\n        Abi.encode_call(counter.increment, []),\n    )\n    print(tx.call_trace)\n</code></pre> wake\u00a0test Gateway.execute(0xe7f1725e7734ce288f8367e1bb143e90bb3f0512,\u00a0b'+\\xae\\xce\\xb7')\u00a0\u2717 \u279e\u00a0Error('call\u00a0failed') \u2514\u2500\u2500\u00a0Counter.decrement()\u00a0\u2717 \u279e\u00a0Panic(&lt;PanicCodeEnum.UNDERFLOW_OVERFLOW:17&gt;) Gateway.execute(0xe7f1725e7734ce288f8367e1bb143e90bb3f0512,\u00a0b'\\xd0\\x9d\\xe0\\x8a')\u00a0\u2713 \u2514\u2500\u2500\u00a0Counter.increment()\u00a0\u2713 \u2514\u2500\u2500\u00a0console.log('Incremented\u00a0count\u00a0to',\u00a01)\u00a0\u2713[STATICCALL] <p>Info</p> <p>Internal calls are not currently visualized in call traces.</p>"},{"location":"testing-framework/debugging/#console-logs","title":"Console logs","text":"<p>Using the <code>console.sol</code> library from Hardhat may be the easiest way to debug a contract. Logs can be accessed through the <code>console_logs</code> property of a transaction object. Console logs are available even for failed transactions.</p> <pre><code>from wake.testing import *\nfrom pytypes.contracts.Counter import Counter\n\n\n@default_chain.connect()\ndef test_console_logs():\n    default_chain.tx_callback = lambda tx: print(tx.console_logs)\n\n    counter = Counter.deploy()\n    counter.increment()\n    counter.setCount(42)\n</code></pre> <p>Wake-integrated <code>console.sol</code></p> <p>Wake integrates the <code>console.sol</code> library implementing the same functionalities as Hardhat's <code>console.sol</code>. It can serve as a drop-in replacement in case that the tested project is not using Hardhat.</p> <pre><code>import \"wake/console.sol\";\n\ncontract MyContract {\n    function myFunction() public view {\n        console.log(\"Hello world!\");\n    }\n}\n</code></pre>"},{"location":"testing-framework/deployment/","title":"Deployment","text":""},{"location":"testing-framework/deployment/#differences-from-testing","title":"Differences from testing","text":"<p>Most information about testing is applicable to deployment as well. However, there are a few key differences. The behavior depends on whether <code>wake.testing</code> or <code>wake.deployment</code> is imported.</p> <p><code>wake.deployment</code> should be used when interacting with a live chain (testnet or mainnet). <code>wake.testing</code> should be used when interacting with a local development chain (like Anvil, Ganache, or Hardhat).</p> <pre><code># use wake.deployment when interacting with a live chain\nfrom wake.deployment import *\n\n# use wake.testing when interacting with a local development chain\nfrom wake.testing import *\n</code></pre>"},{"location":"testing-framework/deployment/#chainconnect-keyword-arguments","title":"<code>chain.connect</code> keyword arguments","text":"<p>The context manager <code>chain.connect</code> takes <code>min_gas_price</code> and <code>block_base_fee_per_gas</code> keyword arguments. In testing, these are set to <code>0</code> by default. In deployment, these are set to <code>None</code> by default.</p>"},{"location":"testing-framework/deployment/#required-signed-transactions","title":"Required signed transactions","text":"<p>In testing, transactions are not required to be signed for performance reasons. In deployment, transactions are required to be signed by default. That is, <code>chain.require_signed_transactions</code> is <code>True</code> by default.</p>"},{"location":"testing-framework/deployment/#chainblock_gas_limit","title":"<code>chain.block_gas_limit</code>","text":"<p>In testing, the value of <code>chain.block_gas_limit</code> is cached for performance reasons. In deployment, the value is always fetched from the chain for the current <code>pending</code> block.</p>"},{"location":"testing-framework/deployment/#chaingas_price","title":"<code>chain.gas_price</code>","text":"<p><code>chain.gas_price</code> is a constant value in testing and can be modified by the user. In deployment, <code>chain.gas_price</code> is a value returned by the <code>eth_gasPrice</code> JSON-RPC method.</p>"},{"location":"testing-framework/deployment/#chainmax_priority_fee_per_gas","title":"<code>chain.max_priority_fee_per_gas</code>","text":"<p><code>chain.max_priority_fee_per_gas</code> is a constant value in testing and can be modified by the user. In deployment, <code>chain.max_priority_fee_per_gas</code> is a value returned by the <code>eth_maxPriorityFeePerGas</code> JSON-RPC method.</p>"},{"location":"testing-framework/deployment/#managing-accounts-with-private-keys","title":"Managing accounts with private keys","text":"<p>While it is possible to import accounts from a private key or mnemonic phrase at runtime, it is not recommended. To protect your private keys, it should be encrypted and stored in a file. To do this, use <code>wake accounts</code> CLI commands.</p> <pre><code>$ wake accounts --help\n\n Usage: wake accounts [OPTIONS] COMMAND [ARGS]...                          \n\n Run Wake accounts manager.                                                \n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --help      Show this message and exit.                                 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Commands \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 export    Export an account's private key.                              \u2502\n\u2502 import    Import an account from a private key or mnemonic.             \u2502\n\u2502 list      List all accounts.                                            \u2502\n\u2502 new       Create a new account.                                         \u2502\n\u2502 remove    Remove an account.                                            \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>Accounts are referenced by their alias, which is a unique identifier, string, defined by the user. Accounts can be imported by their alias in scripts:</p> <pre><code>a = Account.from_alias(\"my-account\")\n</code></pre>"},{"location":"testing-framework/deployment/#writing-deployment-scripts","title":"Writing deployment scripts","text":"<p><code>wake.deployment</code> module can be imported in test files. This can be useful when both interacting with a live chain and pytest features like fixtures are needed. This way, integration tests can be written using the same conventions as unit tests.</p> <p>To distinguish between tests and deployment scripts, it is possible to execute Python scripts using the <code>wake run</code> CLI command. The Python scripts must define a <code>main</code> function, which will be executed when the script is run.</p> <p>When no arguments are passed to <code>wake run</code>, the <code>scripts</code> directory is searched for Python scripts.</p> scripts/deploy.py<pre><code>from wake.deployment import *\nfrom pytypes.contracts.Counter import Counter\n\nALCHEMY_API_KEY = \"YOUR_ALCHEMY_API_KEY\"\n\n\n@default_chain.connect(f\"wss://eth-mainnet.g.alchemy.com/v2/{ALCHEMY_API_KEY}\")\ndef main():\n    acc = Account.from_alias(\"deployment\")\n    default_chain.set_default_accounts(acc)\n\n    counter = Counter.deploy()\n    print(counter)\n\n    counter.increment()\n    assert counter.count() == 1\n</code></pre> <p>And then run the script:</p> <pre><code>wake run scripts/deploy.py\n</code></pre>"},{"location":"testing-framework/deployment/#supported-chains","title":"Supported chains","text":"<p>The following chains are supported (mainnets and testnets):</p> <ul> <li>Ethereum</li> <li>Binance Smart Chain</li> <li>Polygon</li> <li>Avalanche</li> <li>Arbitrum</li> <li>Polygon zkEVM</li> <li>Optimism</li> <li>Base</li> </ul>"},{"location":"testing-framework/events-and-errors/","title":"Events and errors","text":"<p>Wake testing framework provides a way to test events and errors emitted by the tested contract.</p>"},{"location":"testing-framework/events-and-errors/#events","title":"Events","text":"<p>Every Solidity event definition is translated into a Python dataclass with the same name and attributes as the event parameters.</p> <pre><code>event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 value\n);\n</code></pre> <p>In this case, <code>from</code> is a reserved keyword in Python, so it is renamed to <code>from_</code> in the dataclass.</p> <pre><code>@dataclasses.dataclass\nclass Transfer:\n    \"\"\"\n    Attributes:\n        from_ (Address): indexed address\n        to (Address): indexed address\n        value (uint256): uint256\n    \"\"\"\n    _abi = {'anonymous': False, 'inputs': [{'indexed': True, 'internalType': 'address', 'name': 'from', 'type': 'address'}, {'indexed': True, 'internalType': 'address', 'name': 'to', 'type': 'address'}, {'indexed': False, 'internalType': 'uint256', 'name': 'value', 'type': 'uint256'}], 'name': 'Transfer', 'type': 'event'}\n    origin: Account = dataclasses.field(init=False, compare=False, repr=False)\n    original_name = 'Transfer'\n    selector = b'\\xdd\\xf2R\\xad\\x1b\\xe2\\xc8\\x9bi\\xc2\\xb0h\\xfc7\\x8d\\xaa\\x95+\\xa7\\xf1c\\xc4\\xa1\\x16(\\xf5ZM\\xf5#\\xb3\\xef'\n\n    from_: Address = dataclasses.field(metadata={\"original_name\": \"from\"})\n    to: Address\n    value: uint256\n</code></pre>"},{"location":"testing-framework/events-and-errors/#accessing-events","title":"Accessing events","text":"<p>Events can be accessed using the <code>events</code> property of transaction objects:</p> <pre><code>from wake.testing import *\nfrom pytypes.contracts.Counter import Counter\n\n\n@default_chain.connect()\ndef test_events():\n    counter = Counter.deploy()\n    tx = counter.increment()\n    assert tx.events == [Counter.Incremented()]\n</code></pre> <p>Or in <code>tx_callback</code>:</p> <pre><code>from wake.testing import *\nfrom pytypes.contracts.Counter import Counter\n\n\ndef tx_callback(tx: TransactionAbc):\n    for event in tx.events:\n        if isinstance(event, Counter.CountSet):\n            print(f\"Count of Counter({tx.to}) was set to {event.count}\")\n\n\n@default_chain.connect()\ndef test_events():\n    default_chain.tx_callback = tx_callback\n\n    counter = Counter.deploy()\n    counter.setCount(42)\n</code></pre> <p><code>pytypes</code> for unused events are not generated. <code>tx.events</code> may also contain <code>UnknownEvent</code> instances for events that cannot be recognized from the contract ABI.</p> <p>How Solidity events are encoded</p> <p><code>UnknownEvent</code> instances contain the <code>topics</code> and <code>data</code> fields. <code>topics</code> is a list of 32-byte entries where the first entry matches the selector of the event (i.e. Keccak-256 of the event signature). <code>indexed</code> parameters of the event are encoded in the <code>topics[1:]</code> sublist in the same order as they appear in the event definition. Other parameters are ABI-encoded in the <code>data</code> field.</p> <p><code>anonymous</code> events are encoded in the same way, except that the event selector is not included in the <code>topics</code> list.</p> <p>Accessing raw events</p> <p>Transaction objects also offer the <code>raw_events</code> property with a list of <code>UnknownEvent</code> instances for all events. Accessing <code>raw_events</code> can be more efficient than accessing <code>events</code>.</p>"},{"location":"testing-framework/events-and-errors/#errors","title":"Errors","text":"<p>Solidity user-defined errors are translated into Python dataclasses and inherit from <code>TransactionRevertedError</code> which inherits from <code>Exception</code>. <code>TransactionRevertedError</code> also has a <code>tx</code> field that contains a transaction object for the transaction that caused the error. The <code>tx</code> field is set to <code>None</code> if the reverted request was not a transaction.</p> <p><code>pytypes</code> for unused errors are not generated.</p> <pre><code>error NotEnoughFunds(\n    uint256 requested,\n    uint256 available\n);\n</code></pre> <pre><code>@dataclasses.dataclass\nclass NotEnoughFunds(TransactionRevertedError):\n    \"\"\"\n    Attributes:\n        requested (uint256): uint256\n        available (uint256): uint256\n    \"\"\"\n    _abi = {'inputs': [{'internalType': 'uint256', 'name': 'requested', 'type': 'uint256'}, {'internalType': 'uint256', 'name': 'available', 'type': 'uint256'}], 'name': 'NotEnoughFunds', 'type': 'error'}\n    original_name = 'NotEnoughFunds'\n    selector = b'\\x8c\\x90Sh'\n\n    requested: uint256\n    available: uint256\n</code></pre>"},{"location":"testing-framework/events-and-errors/#accessing-errors","title":"Accessing errors","text":"<p>Revert errors are automatically raised in form of exceptions unless a transaction configured to return immediately with <code>confirmations=0</code>.</p> <p>In case of <code>confirmations=0</code>, a revert error can be accessed using the <code>error</code> property of the transaction object. This performs an implicit <code>.wait()</code>. If the transaction did not revert, <code>error</code> is <code>None</code>.</p> <pre><code>from wake.testing import *\nfrom pytypes.contracts.Counter import Counter\n\n\n@default_chain.connect()\ndef test_errors():\n    counter = Counter.deploy(from_=default_chain.accounts[0])\n\n    try:\n        counter.addToWhitelist(\n            default_chain.accounts[1],\n            from_=default_chain.accounts[1],\n        )\n        assert False, \"Should have reverted\"\n    except TransactionRevertedError as e:\n        assert e == Counter.NotOwner()\n        tx = e.tx\n</code></pre> <p>Accessing <code>tx.return_value</code> in case of a revert automatically raises <code>tx.error</code>.</p>"},{"location":"testing-framework/events-and-errors/#internal-error-types","title":"Internal error types","text":"<p>There are two types of internal errors in Solidity:</p> <ul> <li><code>Error(string)</code> - a revert error with a string message, e.g. <code>require(false, \"some error\")</code> or <code>revert(\"some error\")</code>,</li> <li><code>Panic(uint256)</code> - a revert error with a numeric code in case of a failed assertion, division by zero, arithmetic underflow/overflow, etc.</li> </ul> <pre><code>from wake.testing import *\nfrom pytypes.contracts.Counter import Counter\n\n\n@default_chain.connect()\ndef test_errors():\n    counter = Counter.deploy()\n    try:\n        counter.decrement()\n        assert False, \"Should have reverted\"\n    except TransactionRevertedError as e:\n        assert e == Panic(PanicCodeEnum.UNDERFLOW_OVERFLOW)\n        tx = e.tx\n</code></pre> <p>The full list of panic codes is available in the <code>PanicCodeEnum</code> enum:</p> <pre><code>class PanicCodeEnum(IntEnum):\n    GENERIC = 0\n    \"Generic compiler panic\"\n    ASSERT_FAIL = 1\n    \"Assert evaluated to false\"\n    UNDERFLOW_OVERFLOW = 0x11\n    \"Integer underflow or overflow\"\n    DIVISION_MODULO_BY_ZERO = 0x12\n    \"Division or modulo by zero\"\n    INVALID_CONVERSION_TO_ENUM = 0x21\n    \"Too big or negative integer for conversion to enum\"\n    ACCESS_TO_INCORRECTLY_ENCODED_STORAGE_BYTE_ARRAY = 0x22\n    \"Access to incorrectly encoded storage byte array\"\n    POP_EMPTY_ARRAY = 0x31\n    \".pop() on empty array\"\n    INDEX_ACCESS_OUT_OF_BOUNDS = 0x32\n    \"Out-of-bounds or negative index access to fixed-length array\"\n    TOO_MUCH_MEMORY_ALLOCATED = 0x41\n    \"Too much memory allocated\"\n    INVALID_INTERNAL_FUNCTION_CALL = 0x51\n    \"Called invalid internal function\"\n</code></pre>"},{"location":"testing-framework/events-and-errors/#helper-functions","title":"Helper functions","text":"<p>Wake offers two helper functions (context managers) to handle errors - <code>must_revert</code> and <code>may_revert</code>. Both functions can accept:</p> <ul> <li>no arguments - any <code>TransactionRevertedError</code> is handled,</li> <li>a single error type - either <code>Error</code>, <code>Panic</code> or a user-defined type from <code>pytypes</code>,</li> <li>a single error instance - an instance of <code>Error</code>, <code>Panic</code> or a user-defined type from <code>pytypes</code>, e.g. <code>Error(\"some error\")</code> or <code>Panic(PanicCodeEnum.UNDERFLOW_OVERFLOW)</code>,<ul> <li>the error raised by the tested contract must exactly match the provided error instance,</li> </ul> </li> <li>a tuple or list of errors - any mix of error types and error instances.</li> </ul> <pre><code>from wake.testing import *\n\n# handle any Error(str message) or underflow/overflow\nwith must_revert((Error, Panic(PanicCodeEnum.UNDERFLOW_OVERFLOW))) as e:\n    # some code that reverts\n    pass\n\nprint(e.value)\n# get the transaction object (if any)\ntx = e.value.tx\n</code></pre> <p><code>e.value</code> contains the error instance that was raised by the tested contract, or <code>None</code> if no error was raised.</p> <p>Tip</p> <p>For ease of use, both context managers also accept <code>str</code> and <code>PanicCodeEnum</code> instances directly, e.g. <pre><code>with must_revert(\"some error\")\n</code></pre> or <pre><code>with must_revert(PanicCodeEnum.UNDERFLOW_OVERFLOW)\n</code></pre></p> <p>However, <code>e.value</code> will always be an instance of <code>Error</code> or <code>Panic</code> in this case.</p>"},{"location":"testing-framework/fuzzing/","title":"Fuzzing","text":"<p>Fuzzing is a technique for testing software that involves providing invalid, unexpected, or random data as inputs to a computer program.</p>"},{"location":"testing-framework/fuzzing/#introduction","title":"Introduction","text":"<p>The Wake testing framework provides a <code>FuzzTest</code> class that can be used to write fuzz tests. A <code>FuzzTest</code> can be run using the <code>run</code> method with two required arguments:</p> <pre><code>class CounterTest(FuzzTest):\n    ...\n\nCounterTest().run(sequences_count=10, flows_count=100)\n</code></pre> <p>The first argument specifies the number of test sequences to be executed. A sequence is an independent test case - all connected chains are reset after each sequence. Each sequence consists of a given number of flows. A flow is an atomic test step that is executed in a test sequence.</p> <p>The <code>FuzzTest</code> class provides two properties, <code>sequence_num</code> and <code>flow_num</code>, that can be used to obtain the current sequence and flow numbers, both starting from <code>0</code>.</p>"},{"location":"testing-framework/fuzzing/#flows","title":"Flows","text":"<p>A flow is a single test step that is executed in a test sequence. Flows are defined using the <code>@flow</code> decorator:</p> <pre><code>@flow(precondition=lambda self: self.count &gt; 0)\ndef flow_decrement(self) -&gt; None:\n    self.counter.decrement(from_=random_account())\n    self.count -= 1\n</code></pre> <p>Flow functions must be defined inside a test class that inherits from <code>FuzzTest</code>.</p> <p>The <code>@flow</code> decorator accepts the following keyword arguments:</p> Argument Description <code>weight</code> weight defining probability of the flow being executed in a test sequence; defaults to <code>100</code> <code>max_times</code> maximum number of times the flow can be executed in a test sequence; defaults to <code>None</code> <code>precondition</code> function that accepts a single argument <code>self</code> and returns a boolean value; the flow is executed only if the precondition is <code>True</code> <p>How flow weights work</p> <pre><code>If a flow has a weight of `100` and another flow has a weight of `50`, the first flow will be executed twice as often as the second flow.\n\n```python\n@flow(weight=100)\ndef flow_1(self) -&gt; None:\n    ...\n\n@flow(weight=50)\ndef flow_2(self) -&gt; None:\n    ...\n```\n\nThat means that the probability of `flow_1` being executed is `100 / (100 + 50) = 2/3` and the probability of `flow_2` being executed is `50 / (100 + 50) = 1/3`.\n</code></pre>"},{"location":"testing-framework/fuzzing/#invariants","title":"Invariants","text":"<p>An invariant is a test that is executed after each flow in a test sequence. Invariants are defined using the <code>@invariant</code> decorator:</p> <pre><code>@invariant(period=10)\ndef invariant_count(self) -&gt; None:\n    assert self.counter.count() == self.count\n</code></pre> <p>An optional <code>period</code> argument can be passed to the <code>@invariant</code> decorator. If specified, the invariant is executed only after every <code>period</code> flows.</p>"},{"location":"testing-framework/fuzzing/#execution-hooks","title":"Execution hooks","text":"<p>Execution hooks are functions that are executed during the <code>FuzzTest</code> lifecycle. This is the list of all available execution hooks:</p> <ul> <li><code>pre_sequence(self)</code> - executed before each test sequence,</li> <li><code>pre_flow(self, flow: Callable)</code> - executed before each flow, accepts the flow function to be executed as an argument,</li> <li><code>post_flow(self, flow: Callable)</code> - executed after each flow, accepts the flow function that was executed as an argument,</li> <li><code>pre_invariants(self)</code> - executed before each set of invariants,</li> <li><code>pre_invariant(self, invariant: Callable)</code> - executed before each invariant, accepts the invariant function to be executed as an argument,</li> <li><code>post_invariant(self, invariant: Callable)</code> - executed after each invariant, accepts the invariant function that was executed as an argument,</li> <li><code>post_invariants(self)</code> - executed after each set of invariants,</li> <li><code>post_sequence(self)</code> - executed after each test sequence.</li> </ul> <p>The whole <code>FuzzTest</code> lifecycle is visualized in the following diagram:</p> eyJ2ZXJzaW9uIjoiMSIsImVuY29kaW5nIjoiYnN0cmluZyIsImNvbXByZXNzZWQiOnRydWUsImVuY29kZWQiOiJ4nO1d6XLiSpb+30/hqP7TXHUwMDFk06ZzXzp6Ylx1MDAwMm9cdTAwMThcdTAwMWIvXHUwMDE4g5fpXHUwMDBlXHUwMDA3i1xmMoswizF03Fx1MDAxN5l/82rzJJOJy6AlJVx1MDAwNFx1MDAxNpi6XHJxo25cdTAwMTUgIaXOd75zTp7lX3/Y2/sxXHUwMDE4d61cdTAwMWZ/2/thvVfLLbvWK49+/EW//2b1+rbTUVx1MDAxZqHpv/vOsFedfrMxXHUwMDE4dPt/++tf50ekqk774yirZbWtzqCvvvff6t97e/+a/qk+sWv62MvLaveB9uFzpV2lrMJcdTAwMDanJYynh06/9HkxPas6KHfqLWv+0bt6n0My+/dYX1x1MDAxOcWzf4/s2qCh3sOQp4DrXHUwMDA1Z99oWHa9MVBfXHUwMDExPCU9r9lXPn7zb3tg9k5/0HOa1qHTcnr6wv74cdL5ZVXK1Wa951xmO7XZd1x1MDAwNr1yp98t99Q6zL/3bLdahcG49bGC5Wpj2HPd3Mev3P28XHUwMDA16Ht/dlxc31HrPT9K/Wy90bH6fc8xTrdcXLVcdTAwMDd6eSCY34e+xm62Nn0w/3SfoVP7eYbOsNWa/7Bl6edFXHUwMDEwI0RcdTAwMDA0X+a5WFDJ/e9eOp2piECBuEBIgPnK2v0jJVx1MDAxYoPpWZ/Lrb41X0F9XHLHfrlxy45HNFx1MDAwNtb7fFldkiXL+NGGb0O70HjIVyqTo/t+sfJj9r3f/mI+7cfBuZtcdTAwMDJcdTAwMTldg5dreHfb4ZmsPG1cdTAwMDPh/ZXP3y/3es4o7nmf72tH11x1MDAwNbvJ6pXhWbPfusR5dlx1MDAxOO+8P/82f1bDbq38sX6QcUolXHUwMDEzUkgwfzItu9P0P8aWU23Ol/xcdTAwMGauXHUwMDBi9uHSvHpcdTAwMDFcXHpcdTAwMTb/XHUwMDAzkkSmqFx1MDAxN5SCXHUwMDA0QIlcYlx1MDAwYsJcdTAwMTCxXHUwMDFk7kJwXHUwMDA3IVx1MDAwM1hcdTAwMTJKoVx1MDAwMXiEg1DgXHUwMDExJiGmkK5cdTAwMDI8z4V8XdrmwqOFRq3iYaNsd/b6nXK333BcdTAwMDb9vWrPmv7E/Fk5nUHBnuhcdTAwMWJBwPPuSbltt8ae5dZnTbfsul6RXHUwMDFmVXVcdTAwMGJW74d7WVx1MDAwNrZip9lcdTAwMTfadq3mZpNKuW+pW/hQVrN3q+qn1DVavWxcdTAwMWOycnp23e6UW7dcdTAwMGLuL1x1MDAwMnaQONIhXHUwMDA3N5aTh+lcdTAwMWW0zp7az+fx6ZBcdFx1MDAwZvKIXHUwMDBiUTPkuShzhjwsdshcdTAwMGJBXHUwMDFlRYJTwTk1XHUwMDAwXHUwMDBmQlx1MDAxYYo8XHUwMDA0XGLgiFx1MDAwMEpXQN6KlFx1MDAwNzPv9cPSPYf547vKmL3dIWf/NC41ndhcdTAwMTCSXHUwMDE3u5Z9auRyo0z/sX6brWwjNZnvMlx1MDAwZTVx5oVcdTAwMDeGLqr6XHUwMDA0XGKUXCJcYlx1MDAxMMR3XHUwMDAwXHRcdTAwMDGIkFxuXHUwMDFlQLGTXHUwMDExIC5t41x1MDAwM1xiZYJcdTAwMTBIXFxG4/YwU7dnPfWt16GlLvVPf977v//536VIXHR7TphcYimh+cPzkdJcdTAwMDLK8JOS4dZcIrBWejwpZ0a1TqVcdTAwMGZaZNC1XHUwMDBm6UDex+cjl9mh12WfyFx1MDAwMNxcdTAwMTA2WIJ454GFwVxyXHUwMDExRFx0Q8zER5ShMLQxKlx1MDAxMcNcZm/QXHUwMDAx65Toa+dcdTAwMTVnXHUwMDE1fTaUXFw/1nPpy5u4bNRpjlx1MDAxZXOjSefoQjxcdTAwMWSdXVR6XHUwMDE1dNDdRjYy32VcdTAwMWM2XHUwMDEyyOco7ZNg9Fx1MDAwMlxuXHUwMDE5hMeOjcJcdTAwMWQlJFx1MDAxMJCAcVx1MDAxM1x1MDAxZFx1MDAxMVx1MDAxZYpcdTAwMGYogUJcdTAwMTaCYFx1MDAxNXNt3XT0qa+fOsP23n/uge0lo1x1MDAwNXzhJ6PAjUVcdTAwMDDtXHUwMDA0ZPvdYqNSn9S6PVxmnMrlU6VcdTAwMTBcdTAwMDRazS63nU7NhzWEPEjDhjAhMPhFUOxcdTAwMWMj/fZcXEF/rjP6+c5vXHUwMDAxXHUwMDAwMmX0MU6IXHSAXHUwMDE4hUcqINKHuYG7doaqXFy22IW4vTg+uH22XHUwMDBisFx1MDAwMnm2W4jLUNix7t9cdTAwMWOlbtLX9/x5NFx1MDAxONSfLmvxXHUwMDE4KvK8Nny9rlb5ef6QPZT3R0dYXGZcdTAwMGZy28h85tWLxXxe3nPL4oz3uMFcdTAwMGKjZIfGMC+MciRcdTAwMDWURi8sKkpcdTAwMDFcdTAwMDCTjLlcdTAwMTTiltLe3/f+0fl8o/9UVZcy+G5cdTAwMWEkoYHCXHUwMDA1XFxcdTAwMTVJg3/f899mlPVcdTAwMTlpJvtcdTAwMTSFXHUwMDA3hILzXHUwMDE0Rur5Q0gpZj6C3Fx1MDAxNykuIFwis1x1MDAxZLFgnFx1MDAwNKWQVKRJXHUwMDE551i58Vxiclx1MDAwM2BBSlx1MDAxObCQK7tKMMHQXHUwMDBlv8uyKaKAc86MXHUwMDFiboRcdTAwMDScwFx1MDAxOa5cdTAwMDVcdTAwMTecXHUwMDAxsU3Bla5j+9l6/re9uSRM/zH7+z//Yvz2frj46VdA8ObnXHUwMDBikGSr3Fx1MDAxZlx1MDAxYzrttj1QN3qtLzKgY1x1MDAwN+Xe4MDu1OxO3fv8fm5vxzF+p1xuqTrUXHUwMDBisFx1MDAwZlJcdTAwMDAqXHUwMDFmXHUwMDA1ICHVRVLE5namlqByV693XG5Bwels35pcdTAwMDdkxOrU5lx1MDAxN1x1MDAxNbzgtFx1MDAwNn3DKtf8n6rj3J+5zVxiv5aJXGLwuKN8XHUwMDExZp0gXHUwMDFjq1x1MDAwN1x1MDAwNeNI4odOezmtwJKddd6sPuc1ckDObGRvXHUwMDBmvoOa6yO27FxydWGevGabR6hccjlcZni+wJ+RXCKMiVRyM//ykqZFQla2KI/eXHUwMDE47FxcWHftyuuTLN/fXV7fbmDDPPK8v8Buh9mAdsHOXHUwMDEwc5/BTlG3IHpcdTAwMGIqNuzMj2nLYSdcXMv8XHUwMDAxO7o+2LnCc6ZQ3KclXHUwMDBlKMCIuvD4Rditi4+XNpqneGw5o2BcdTAwMTjKXHUwMDFjXHUwMDFi+pqh7TOpXHUwMDE3sILfpPZcXGckvFx1MDAwMlx1MDAwMaM5wphcZt29Uv6pgFxmg1iO01x1MDAwN8D20Vx1MDAwNFxcOlmULuJcdTAwMDfLseVJpZhcdTAwMTPbXHUwMDBlMO6S4+meqcsvT1x1MDAxYWCIXHUwMDE5XHUwMDAwXHUwMDA2XHTwI0zxn9DpZC6nJFx1MDAxOaM7IcLrXHUwMDE3TzO4cnRA73L7XHUwMDA1eHz6yo57OC4xta9cboPJ1Vx1MDAxOFx1MDAxZVx1MDAwZrPpt1eUzedeXHUwMDBipVx1MDAwNFxir1TvdigvTci4p1x1MDAxODVdXHUwMDFmXHUwMDBlO7m3X4vwqCtNxVx1MDAwN0fClCMrXHUwMDEwhrHRaH5IW45GP91R5P/tXHUwMDA06Vx1MDAwZVx1MDAxYqxMV1x1MDAwNO4zP4ZcdTAwMDOClLW7XGZcdTAwMTZ/Qbr7+z86+u+ByJM5XHUwMDFjlCjzLeCNUObzXXIk5Fx1MDAxNvh34Vx0huqZKFx1MDAxN1x1MDAxYon4wDtcdTAwMThlby5AXHUwMDA3XHUwMDFkXHUwMDFlNsdcdTAwMDcvd+SWXGbVc99y4Kkl8O/WXHUwMDEy5M5cdTAwMWVKnFx1MDAwYpGBXHUwMDBigz6eMkNcYqaM4e928sBRsZi9XHUwMDEwvfdiuXHcfbt7IJfnL3G5qeyMnIPK8KrSS2fPT/jTY7mUSYLzhjYqturoofKUyVx1MDAxZHWqd48vtcfCr8V5XHUwMDEw4vCseiSEQJzjOHvWUY9p+8HnzykniK1cdTAwMTN8IDrp4lx1MDAxM3zKweZcdTAwMDK6Y1u/J+7rOv1BaFx1MDAxNtxcdTAwMDY8vlx1MDAwNURcdTAwMTFIbDNcXO7qnMdIIOI+szWBsjMxQ/FRd1C5yljOsXPjXFxcdTAwMWZcdTAwMGWOXHUwMDFk++34NPu8/ajzpMd+lFfJtWHuS2VaP1x1MDAwMcm5clx1MDAxMVx1MDAwMEpcdTAwMGWPK5Jhb3KLx87jSVx1MDAxM1x1MDAxNE9bTDYrp/n05LvJcJTPl09cdTAwMWFHz7dcdTAwMDfZq/akWs0/pItXv1x1MDAxNlx1MDAxOVJcdTAwMTjKhVjo7EZcbuPboeaHtPWgZNhcdTAwMGZKub6dXHUwMDA2dz2lqUzrc6dcdTAwMDFgTDAnrvjNr0uEXjbTS+Sv4+lZ/YHTc1x1MDAxNyqZq4eSZcNoXHUwMDBlWVR7NLtmI/DiaJ6oZFx1MDAwMm2JplxikoJBqlS3O276Ya1cdTAwMDFDoVx1MDAwNUpBXHUwMDAyqaRcdTAwMTIpXHUwMDFilktkyL/zOF27lFx1MDAwMfdjXGJNXHUwMDE5UFx1MDAxZVx1MDAwMVZLaqxXXHUwMDAyLlvNp0BcdTAwMDWT6iFisk2JQElnXGaEyNv0Uy1q81NcdTAwMDRcdTAwMTgvsSSBaKt2b7b773rnM21cdTAwMDCkXHUwMDAwIeoxcaVqsUJcdTAwMTlnXHUwMDAxXHUwMDE58KRcdTAwMDSEXkKkKll0XHRcdTAwMThSQjmBXHUwMDE46axcdTAwMGKIg3KYVPJBXHUwMDFjJz5KK0lcdFNK5JFUeCBcZlx1MDAwMa9SokSkMFx1MDAxMFx1MDAxNFCqXFw44jI4Z1xuStKUpGqxifpcdTAwMDMwyFxyXHUwMDE5Tkrv6cgzI0JQqEszdupqOXVcdTAwMDW5kEqWkDFhXHUwMDFmYlx1MDAxMa6wlC2kN+DiWHy/pMJCXGaldO5cdTAwMTeBglxi9X/uVVhcdTAwMTCmiMRYZ+9hyVxi4mLhXHRD5Xl6woAoJ6lcdTAwMGX9OiBcdTAwMDFF6c6mklxu4Vx1MDAxMFx1MDAwM6pcXFx1MDAwMITw3Fx1MDAwZZ0rs5RcdTAwMDCMXHUwMDExwHROo3rKNJhOteGkKXVcdGGijSBmglx1MDAwM8HjezNnhFx1MDAxNq5cdTAwMGZcdTAwMGXIw/CAZo8qz9dHR6WH7VFcdTAwMTkhm8tU+JxcdTAwMTnlxK0zrlx1MDAwN1xycT1DUJ1BwqaIS8qdWTGOUCy2XHUwMDA2z1x1MDAwZs2nyUtZytd8/6RcXGqzLfTLlSyHJkpoe1x1MDAwYmNcdTAwMWOrrirqrrddlJk3/09p7TVcbvKiXHUwMDFh9U9BXHUwMDE2XGIyXHUwMDAxMPl9bs7qUma9w/kn/cfm49NcdTAwMGJUrqnw2ne1q7OHIKGpXHUwMDEwXHUwMDEwqUeBIUTxU/86qDh65s3O+dXoiVxm0eTo4u02s/WIXHUwMDBi7MgyideIOFx1MDAxYURcdTAwMWNcdGRDMFxilXVcdTAwMDFlYoGwXHUwMDE1maNmtUfg7KpWLmdunEPRXHUwMDE4XHUwMDE1x7nD2JVtt71b+5lcdTAwMWVcdTAwMTZL1mk+c1RqZ67LjV8rUszDU4UgXHUwMDE1XHUwMDAyXHUwMDEwgXl8fJhXc8vxIbDX3+VgnYzkqqyOICSkY4PKadtooJgsIWxfI6Spev/zRklogeo2JVx1MDAwN6krXFydePSedyiygFx1MDAxMFA5LTK+21x1MDAwMlx1MDAwN8W7dPMofdWynlx1MDAwZY/tYXnYLF1vO7I48bstXkcmcbfF2FwiJZh4Llx1MDAxOeNcdTAwMWPyxIy9XHUwMDE1ued8fEybtqhcdTAwMWOc0MbonmdPyPtV7FQgm1x1MDAxY9yfOaVcdTAwMTdr/FguvGbKnbP93kGi3LOMOliJe5TzXHUwMDFlmi5HMFx1MDAxNoyxJdLlzKu57VxiYd5yUu7ZtfymdFx1MDAxZMmBXHUwMDE0Slx1MDAwNDbpXGZtjnum6S/f6FxyLdDkxmydOO7Qz6z4wTMqXj1W+42y3bhcdTAwMDBcdTAwMGbnXbpfXHUwMDBmblx1MDAwMlx1MDAwNHtcckBcdTAwMDCBR1x1MDAxNKlrg/ZTgKjJeNk1I1xy6zXAmZSEXHUwMDAyXHUwMDEyiF/qs6PQmjRcdHXjYLRaQ8QktXrQbtPv/vAgbbW2oy3reVx1MDAxMFx1MDAwMaGB0zViMrTjqOcmXHUwMDAyttz0qiMpKqK2XHQqay3sSVFOXHSjy2S4vT10jnGLZ61BXHUwMDA1XHUwMDE1rs6uT+rD4uX2yHlY+NmfViog8v16kixlSHBwRVx1MDAxNWb93VxilcSd3LZVtU1cdTAwMTe5l6t692pQyp3l705Kk0unwbfRXGKTMtRcdTAwMDbTpUKSXHUwMDEzXHUwMDE5X7rNN73t0i283U5cdTAwMDVZ59ZcbnR1po7KXHUwMDE0g0j5Spjx30NcdTAwMDAgmCl2M+zs2Z23cs8uq6v7r40miC1QwX728F9qJMqiQ1x1MDAwMlxcXHUwMDA2ko3mwTb1KUax+v7/TMtcdTAwMTSn/fODQvXuXHUwMDFjv6fzhdb47OXM2nqsebClj5FkrVx1MDAxZVx1MDAwZo5VXHUwMDFkpLxNXGKQK7Ple1x1MDAwMlx1MDAwMpX8ZY+lr4qw0Vx1MDAxZmT549NcdTAwMTBcdTAwMTROYrdZs586k07m4jl3VK6g4aibr7dO00lcdTAwMDVcdTAwMDQkpFx1MDAwMK5/e5Tz0GJcdTAwMDJcYjGCXHUwMDAyi1htkKOWc9tcdTAwMTFC/bs1kqw1ZoZMfFx1MDAxNNwhhYhChGRyW/3RfCQhYUgsIXDL8JF5h3Su5L+hhmeBNjftkVx1MDAwNq73XHUwMDBizFx1MDAwNHFE57tppVxigPHNwMbTXHUwMDA1LZ9cdTAwMWa1XHUwMDA3zczr3fPTy9FRw9p6J1x1MDAwN0JBfchT+mituVx08bpcdTAwMTOp9Vx1MDAxN4C7XHUwMDFiaHxcdTAwMGY7XZXHMH/brTRQ57B8J+xCxz5cdTAwMWbEZaf+6T56z4yd8lx1MDAwM1x1MDAxZj3XOs7oqDNJtlnn+sPVIJh6OU9EU1x1MDAwNty01UlskJiXc+tBXCK9k1Ogpzl34lx1MDAxMGGm6UdcdTAwMDGIUFxmIaBMbLK8dHNcdTAwMDFrd9PL//iPjbLSXHUwMDAyRVx1MDAxZdWeU13pXHUwMDE3+FxiR3hKgCguYlwiVsvGn5nxgMrz++zxSZpcZp6Kt2+vxfb9eNuhRoG/gI3BtWItXHUwMDFlXHUwMDFkXHUwMDExqbOHXHUwMDEz3Fx1MDAxY1qRjVx1MDAwZeDLVemyUeO3XHUwMDE3XHUwMDE3h/vNm0zOOnbistGTzDt1WL3JXFxfYyuTO76/Q01cdTAwMWWPjVwiz3v0clu7ntxcZlx1MDAxZSRcdTAwMTnlSLr6UD1cdTAwMWW3fzGWwyS0klx1MDAwMFwiQokyXHUwMDA2cXzomVx1MDAxZtO2Q1x1MDAwZvvj3VxmrtVcdTAwMTI0pVtcdTAwMWJ8MImlxJQvXHUwMDE18v51eO6zXHUwMDFmz4Y5blx1MDAwMTmEdVxyXG7jt1x1MDAwZrFcdTAwMWZcdTAwMGbO2OT5XHUwMDFk3Z/mj5xitS+v2dt7cFx1MDAxYjZkXHUwMDFjXHUwMDEwxd6tWFxigoMhITJkNrt2XHUwMDFh/533YoPbPIbiu8/WJFx1MDAxOEHdmstYVVx1MDAxNdHWUPGgcppjOcVcdDHe2fhxcGbfj8ZcdTAwMDWb4PPTXHUwMDFiXFzsX/TiMlx1MDAxMypksq/3LTv34lx1MDAxNJ6bx1Y236BbxkxRd1x1MDAxOUBOMIFBXHUwMDE5JX73XHUwMDFkXHUwMDA2YUN2U4KWyWBghHLd38Q8LSHUUKBcdTAwMThcdTAwMTNE4mVcdTAwMGVvipM+aebI6SyXwrDRuUBcdTAwMGKIw89G05uJQFN02GVBp1x1MDAwMpyCXFxgXGawrp6U3k1Sd/bkvC0pXHUwMDBiOcI152BcdTAwMDc1I0GFl/1CXCKIQOaBJViGpqYgoFveUY7iRKQ2hcFk+1x1MDAxNGDiXHUwMDExNyq8db+ELTxDqMROP6WuS1xikGBifVx1MDAwZaJjLHvullx1MDAwMpAhzpiyV6VywSGBwerdeW+GjU4/iNM4aVFbXHUwMDE0j3pBNJh8OFx1MDAwN5iprminTtyLXHUwMDFjrk4ox1xcMFx1MDAwMMw5iVH2LmerzWj+JZSJ59v7ZCNjUFx1MDAxNrZcdTAwMTfxjEFBXGZcbiRcdTAwMTlFUi3avFB1XHUwMDA2ffh9wH/v9tN2v3rzbj/cVFx1MDAwZlx0bt2Nz0lcdTAwMTD45omD1GdYXHUwMDAwYJrFbigqhC5q26HfvdLh6MdcdTAwMDBxiEUguD790fBqXGaIKVGuXHUwMDAwXFzJoF91Km73spWvXHUwMDE07+BIqpXs9Vx1MDAxYaObXHUwMDA2iOvuXHUwMDE27LOW7D7et8jpoNe5zz11u93XXHUwMDA0XHUwMDAyvM2n91x1MDAxZWneT5x7Wm6mh6XC/XPmJt55XHUwMDAzemStbrR59Vx1MDAwMpA0zFx1MDAxY5T+bVx1MDAwN73hYlx1MDAxYf9OXGaE7CpcdTAwMTD4d4akceAuhpxcdTAwMTBMYSDF6Yfujlx1MDAxNF6Gi1x051x1MDAwNK5cdTAwMTZqWrcznW61XFzJkXv/6FjvVnWofsSV0rl6lcCXZlx1MDAwZc7vy+diL2Arv4vtu8X5XHJGoC96NGn0tEFf00pcdTAwMThkQ9M+3W787rJUXGI4Vlxc6N719PT/XHUwMDBiN4SF+o8yuk2xrWT9auj+OnZ1y/q6Kbx8d6voXHShe273XHUwMDE4IChcdTAwMTV+MGGIXHUwMDAxLJRfXHUwMDFmMJKRSFx1MDAwMcZcdTAwMTjkelx1MDAxMocyaYLSkaxlfMjesm/17lx1MDAxZHwjtXb2nL+e54/u4tCwcMnlh1x1MDAxZZjHf2axbEOdzK5cdTAwMWEvnIApQpyo/0zWb3D/x91cdTAwMDaDccDINlx1MDAwMf6Tf1x1MDAwN73hr1ePN73oXGLQRI8yjGZPZalcdTAwMDJCXGJVZlx1MDAxNkHCN8yeoFx1MDAwMIZAXG5JgFx1MDAwMdA9Xbn+z1R8ttsgWpZdXHUwMDE5ZUBcdTAwMTJ3Xz53hknovlx1MDAxMZdcdTAwMWND9Dum1lxicdMvxOdn+DrZhlHq5WW1+0D78LnSrlJWYYPTXHUwMDEyxiGUXG4kRUJcdTAwMTEqhpRL9afrcuPFncIuXCJ6TOGeN/hFmOSUYUZcdTAwMTBcdTAwMTZYsDjBr4SJ/OFcdTAwMDXuv1x1MDAxY9D+2aSHj1x1MDAwZl+bk+Px+34snURdXHUwMDE1K1x1MDAxZqlEc1x1MDAwN3DuS4uUwJzovuCAXHUwMDE4m8kzlJJKpymAUFx0XHUwMDE5dIVwdirJ/VxiQlVcdTAwMTLlut9cYsUm9jd0XHUwMDAxnzVcItGNXHUwMDAxJVlX99zv10nIXHUwMDFi+mZcdTAwMGJcdTAwMGZcYlx1MDAxNdaP4/1ymqRGXHUwMDBid1x1MDAxZtZcdTAwMTnejs5cdTAwMTaNwj5nPMVcdTAwMDHkUFx1MDAwYlx1MDAxZnXHXaeFxlxmpjBnTJmlXHUwMDE0K1xyXHUwMDE33PKCXHUwMDE0q+PVsYTq3D9cbkz9NyBcYjnLTjG4n09EJFx1MDAwMGFMaXCO0Vx1MDAxNP2hMXGsIEBcdTAwMTWIf696YVx1MDAxZmKeglxiQUpcdTAwMDBkSN2rr6228IpcdTAwMWRAi89cdTAwMTgqztOPXHUwMDAzkrxcdTAwMTnVXHUwMDExZqFEJ4Z6LVx1MDAxNEUtXGZcdTAwMTP13KighMO5XzS3UFxmO/ObbaSNIFx1MDAwZd3exUAwyfhcdTAwMTKtUFx1MDAwZuHFpFxizmnrXHUwMDFldvJcdTAwMTdPt3LYvC5tj4ZcYilfXHUwMDAyXHUwMDAyXHUwMDA0klx1MDAwNF1cdTAwMTHWxGd1YUOSrqGmgkGGXHUwMDEx+/Zcbr+zSa6Mc1xi2dBpPtw99Wuv1zD2POZ1bbmNLl56g0y60Dy06oUqPXWuqlx1MDAxN0nNY1ZIRcxcdTAwMTUlWFNNXHUwMDA1cimEQHhJUFx1MDAwMZWpJOPMk4l6TFtcdTAwMGY9iXzAW+NMZmxKXHUwMDE4MFW1c0EkXHUwMDE1S1xySF+9omJ5cZs/1C9Xtf9p9rfNV7cvIIvI6nb/da9OgFx1MDAxMIf3XFyDQqqHIyiIXHUwMDBmw/rgoVsrlZ/T7JE2L/MjIN9791tcdTAwMGZDXHUwMDE46Mlcblx1MDAwMV1cdTAwMWZcdTAwMTCN7cBccpMkdJ9pwcl3M+B7efJO+bh1e3V8bOVygkv4crNcdTAwMDGmijyvcz5cdTAwMTiObp/eXHUwMDBmT1x1MDAwZi6sa6vb4fmnSlJcZqiMXFzoSsFaV1UhQuFcZkiQ1FeB4vc+Mj+mrYde0PhcdTAwMDR0fcanO85cdTAwMWVZPK/cX2X5b6bR2PLy9jVcbpzTyGbbjS8gXHUwMDA3P+O5L3N1gkOQhVx1MDAxM5yeaSiwXHUwMDAwcVx1MDAwMpk/x1xc9qtcdTAwMTl1w6dAlN9cdTAwMDaFs8pr53Aotlx1MDAxZWWAXHUwMDA1XHUwMDFhKHlwl7ipaSopMzBcdTAwMWNSIINJmporUtxonKPFKmik5V3n1m6fTkpcdTAwMWQr9sSLL+Q/fiPFyU00L1PgXHUwMDBib17GKdGD0GF8ijM/pq1cdTAwMDdcdTAwMWb3Z49KT1elxMHn4rMoP1x1MDAwZulcdTAwMDFPjG3IzVta4L7o5ulcdTAwMTbhW+HnLWBcZmNv83U4eu6iXHUwMDAyf6STM1x1MDAwMsQy3WPeXvO0na4jkLux+EvhXHUwMDFjw9uLxrYjkVx1MDAxMz9cdTAwMGJCSOXacIhILDdcdTAwMGbpUmKM3OVcdTAwMWPf5Oe10vnbYmHYKYLjk0n/xXm/7Vc20OUl8rydtJOv347gdVxy3o1cdTAwMGVykk9qXHUwMDEzKyFcdTAwMTJkknCB1u/ncVx1MDAxY5FIh1x1MDAxOeBgme4x5se09dBcdTAwMGJEWOB872wzLW5cckM9dPJcdTAwMDMhdFP9O4nSwXRcdHFLklx1MDAwMr+jgedcdTAwMDKWiKa+yFx1MDAwZZ5xlE5kXHUwMDEyXHUwMDAy0XN/XHUwMDExXHUwMDA0XHUwMDE0sWlcdTAwMWGXTzY5S+mESS5cdTAwMTmSXHUwMDFjXHUwMDE56vqVYZtChEjEiJ5Jplx1MDAwZVxiXG5cdTAwMWNFyHOWXVx1MDAxYfKyWVxiatH0XHUwMDA0dlNdLqWh5VxiXHUwMDE4ScjoOoqDJIXEVVx1MDAxMfh9aVxihKSQXHUwMDEyP4CQ4FxcQOhNXHUwMDFh0N6+svcoXHUwMDEyXHUwMDAwSkAxX3zCUHGeflx1MDAxY5Dk+Vx0XHUwMDAzLJtYSma09tjz5Fx1MDAxYXBcdTAwMDJcdMdYj+hcdTAwMTaQQVe1xqxcdFx1MDAwMFx1MDAwMVxcKFxyjJkgXGJcYlx1MDAxOOx+lGxcdTAwMDJcdTAwMDRQ66lcdTAwMTCMpX5cYlx1MDAwNGDAg1x1MDAxOZokpWd1fL6EYIFrSjhrK3o/OkphSkZSQImS0Fx1MDAxNUJCYN++JWAyxbm+XVwiuJJcdTAwMTZDby5I1d1cdTAwMTJcdTAwMDZcdTAwMTHjSJE/NzipTH1FibaQTJlFhLKdwlxcNsVcXJdyYFx1MDAxMuzJqz9cdTAwMGLPdFF8p+RPoWKVxK2I6Up6b9ddWvJd+pKilDSKnn4xpUmlVIYgRIQrR3hhh1x1MDAxNMpcIs5G+bKnXHUwMDBiXHUwMDA3xvTq/JDYhOaFzVx1MDAxYpS+T9euXHUwMDFlryuZcd2B3XZ3YtS8MEWwpFx1MDAxY1x1MDAwYqo8WCVApjR0XHUwMDE0slwiS2re6P3y+c+ZXHSCXG6gXHUwMDA3W+tcdTAwMTXkXHUwMDAwkbVcdTAwMTe5RVx1MDAwN4Uj+75cdTAwMDDmLXNTa6d0qy7iXHUwMDEzXHUwMDEy68KroG5cdTAwMDVUXHUwMDExvpRcXIGOqpsztUGkQklcdTAwMTnEUiiTSomv3OnWZY1RpVxcicBcdTAwMDSakuVZeJeYqckkXHRMvIDnXHUwMDBiIdVkrVHiyXbX+lQhnSk5Jlx1MDAxMOqU1sUn8KpQ7DlcdTAwMDNZeHi4+E9P51x1MDAxN/xNaNDooO+eK1x1MDAwMdZoOjKsXHUwMDBijFx1MDAwNOaQSUJWNFWja/r3fNVEYmq96V1vZVx0MJNcdTAwMDFccrl6JFxuXHUwMDAxSn1CpfPXrUGjM0eiO2dhnuKY64GRyldcdTAwMDH+9vzQ1D8gRTlSmldcdTAwMDFcdTAwMTkqo1x1MDAxY1x1MDAwMlOewK6MYOnOWnp7l6JgXHUwMDAwVCvGYFx1MDAwN835pGOl2mjybfqmvVxyxPc78OHSpl/7KNEs/5Vcciq3flBOnWD6XHUwMDBm7dwxXHUwMDFj1Fx1MDAwZiuWPEbnhHiUXCJQdqYuViPahGOu8E7ENSSsk6K35Fx1MDAxN+gkmdL1v1x1MDAxODBlLit73+dAk2AvXHUwMDAzXHUwMDFkc+FUfZ1TobwzXCJNc9vcaVx1MDAxYzut5H5cZuFaSSojQVBmXG4rSteP+r1kKZT2UFxuLU467JJqXHRw92jjb7PkwiVu+rFcdTAwMTa2TWim2Epharlo45phouxcdTAwMTemXHUwMDFlT1ArXHUwMDA05SCWZlpowrkrwrlUvjthQGfsKuuJXHUwMDA3LmLtqim6mXnkXlxi8u1+oKB5xFxmXHUwMDFl5a5t8ZJ6XHUwMDA3M6yseWR0IEW42lx1MDAxMXxabc2S386YVlVugdphXCLk+19XMcuXOEZ3XHUwMDFi9ylcdTAwMWaGhfLuXHUwMDA1R5josu+g8jFcZllIXHUwMDE29ye2cpFf7Fr2qZHLjTL9x/ptNp5JXCKYXHUwMDE398TV/zairVx1MDAxYdx5QUt3XHUwMDE4VVx1MDAxZbXyRYXJ4CDhUXmOXGKF2jP/3Vx1MDAwMt/j9sCNeD2xe6xMW6xgXGYkpkhcdTAwMGaiXHUwMDE2XHUwMDA2dK/o9EDiSIdcdTAwMWPcWE5cdTAwMWWme9A6e2o/n4d7XoBcdTAwMTGkbDLlXHUwMDBmXHUwMDBiXHUwMDFhx/FKWMO0r1xug8nVXHUwMDE4XHUwMDFlXHUwMDBms+m3V5TN515cdTAwMGKlmFx1MDAxYcbb5oWwYJtcdTAwMTdDw1S0a5i6bFx1MDAxZlx1MDAxN0xcdTAwMDTCWJjaNVx1MDAwNJs5zlwi05hcdTAwMDNcdTAwMGVo8v7MtuhcdTAwMTfPt5GrXHUwMDE3w/rUyz6agEsni9JF/GA5tjypXHUwMDE0c2Feg1wibsBcdTAwMDQhOs6tXGaJ+a7tXHUwMDFj2zglXHTlXHUwMDAwKq+MMO3pRCucdXZ8KdW7XHUwMDFkyktcdTAwMTMy7tWOrtP14bCTi1x1MDAxN4/1q1x1MDAwMWaYQWRcbrfuXHUwMDFjjKW7tkCqi1x1MDAwNqnJw+Ch+VJCXHUwMDEwKlx1MDAxOMBratvy/XrAY2agb/YvYmtcYk3+WOexybmmXGJqXGKSwlQo/U/Vo8eIg7U7XHUwMDFj+LZ3az/Tw2LJOs1njkrtzHW5sZpcdTAwMWXgwd6TOz2QRKCBYIKQeZ5cdFx1MDAwYjVcdTAwMDcgwVx1MDAxNENPR66dXHUwMDFlWJ9cdTAwMWXooOLomTc751ejJzJEk6OLt9tMmFx1MDAxZVx1MDAwMIIhpVx1MDAwMSSjVLuFsVpOJoz7l8b4snl1U3hrVcDg8OHw3MrCVlx1MDAxMPfBts1Meid3iqBcdTAwMTNATT3cdlx1MDAxOSqhXZuxXHUwMDA0kiBpzItcdTAwMGW8Od+/kHpiXHUwMDExpdvE87NBt/pd13P5Nbo2f1xcdVx1MDAwNGhscnB/5pRerPFjufCaKXfO9ntcdTAwMDcxydJbL8OxoVxiIcVcdTAwMDXgXHUwMDA0IMFcdTAwMTjDXFxQQ5RcdTAwMWXB3Vx1MDAwNuHydjRhSFx1MDAxMlx1MDAxMJz6rY+KXHUwMDE4S6KVNIVryPXaXHUwMDE2XHUwMDA23Vx1MDAwZlx1MDAxNzn9QjDZXHLC5VlcdTAwMTVcdTAwMGWKd+nmUfqqZT1cdTAwMWRcdTAwMWXbw/KwWbpcdTAwMGUmXqFcdTAwMTTwvtyE6tldhOqBQqLLLDBHWKyxYeGHxiBt+8Qqllxu+2J0VrtcdTAwMWY3m+yuNohHs96UXHUwMDAygYJcdTAwMTlcdTAwMDU7nl2KZ1x1MDAxMeBKXHUwMDBiSGNYzT3s1a9cdTAwMDZcdTAwMTCTXHUwMDE4M7iuMaM7ot1cdTAwMGLCZtItXGZB7cWy7kD9+qxylW/dyphESzy44dLQi9xcdTAwMDCb3ZjNJVlVQC5cdTAwMDTA5p7C4Vx1MDAxNdJcYlx1MDAxMIrWNmVzXHUwMDFiKNXDoIlO2fye3uCWrFrj0sX9oSztn1WuXyb3znO82lx1MDAwN+XlerAogWE6SVx1MDAxMIu7kbdLY1Fwhlx1MDAxMFx0OovTRVx1MDAwZsVcIlx1MDAwNEjq4uht8iDXt2OU7MTb78Gi/dSZdDJcdTAwMTfPuaNyXHUwMDA1XHJH3Xy9dZpeXHKLYi6hUZu3u7lAK6SjMoApNHmbXHUwMDEwh3ftwXquXHUwMDFixGsoc4dbUVjk3b7dyFx1MDAxOKCeOO2fXHUwMDFmXHUwMDE0qnfn+D2dL7TGZy9n7nYznqRP5fxiJpV/wCFcIq7chr0tXHUwMDE4P21dOPvNqzNayjSv65XO2GHDM8O8MMOQPe6tlpEgXGL73ZC9pdxIXHUwMDA2JNOzXHUwMDEwTPhcdTAwMGWGmGZzvyhUWiFeXHUwMDBm9E07kb/LXHUwMDExe527trBE44JWut2MLc6dw/bBWSzI+KdZ7SDzVchcYj1hhbhcdTAwMTcy3iBaQNTDkFKuKfKyUo/e3zdoXCL7s0Xbl9iDXHUwMDFhXGKRaVx1MDAxNKWyjiRV0lx1MDAwMIWySVx1MDAwMFx1MDAxM6bhIbtcco4lTU5cdTAwMDQ4kIBcdTAwMDBjolx1MDAxMFxmou5cdTAwMTNfXGYxXWeTPLqW7sS3XHUwMDFli3M/Qt70XHUwMDBif/PuxjItkVx1MDAwMFx1MDAxNEKZqFx1MDAxNEMoiNKZsSqjXHUwMDEytkJPSXZ8lreHpUH9/Vx1MDAwMlx1MDAxN9uVq2pzXHUwMDFji1JdzmZgMMqOU1fjVI1ehXpTzFx1MDAwN4VmXHJcdTAwMTBCgW58saYtzVx1MDAxZKP6MVx1MDAxM918J1x1MDAwMjOS+muKRZBQdzuAS2GG4mmrJ2nsX1x1MDAxMFx1MDAxZSdV3p6kXHUwMDEy4FV8t5DuvV9cdTAwMWUoXHUwMDE24Ks1XHUwMDAw8tffXFz8w89cdTAwMTX6Ue52XHUwMDBiXHUwMDAztT4zNv7xZlujg6C0//F5+tLHT1x1MDAwMa0l3ZraY7/94bf/XHUwMDA3y588PSJ9 Chain snapshots createdpre_sequence() \u26a1sequence_num = 0sequence_num &lt; sequences_countflow_num = 0flow_num &lt;flows_countpost_sequence() \u26a1Chain snapshots restoredpre_flow(flow) \u26a1flow()post_flow(flow) \u26a1falseRun invariants?pre_invariants() \u26a1sequence_num++flow_num++DoneAll invariants executed?truepre_invariant(invariant) \u26a1invariant()post_invariant(invariant) \u26a1post_invariants() \u26a1falsefalsetruetruetruefalse"},{"location":"testing-framework/fuzzing/#example","title":"Example","text":"<p>Putting all of the above together, here is an example of a <code>FuzzTest</code> that tests the <code>Counter</code> contract:</p> <pre><code>from wake.testing import *\nfrom wake.testing.fuzzing import *\nfrom pytypes.contracts.Counter import Counter\n\n\nclass CounterTest(FuzzTest):\n    counter: Counter\n    count: int\n\n    def pre_sequence(self) -&gt; None:\n        self.counter = Counter.deploy()\n        self.count = 0\n\n    @flow()\n    def flow_increment(self) -&gt; None:\n        self.counter.increment()\n        self.count += 1\n\n    @flow()\n    def flow_decrement(self) -&gt; None:\n        with may_revert(PanicCodeEnum.UNDERFLOW_OVERFLOW) as e:\n            self.counter.decrement()\n\n        if e.value is None:\n            self.count -= 1\n        else:\n            assert self.count == 0\n\n    @invariant(period=10)\n    def invariant_count(self) -&gt; None:\n        assert self.counter.count() == self.count\n\n\n@default_chain.connect()\ndef test_counter():\n    CounterTest().run(sequences_count=30, flows_count=100)\n</code></pre> <p>The test performs 30 test sequences, each consisting of 100 flows. It tests with two flows of the same probability: <code>flow_increment</code> and <code>flow_decrement</code>. The invariant <code>invariant_count</code> is executed after every 10 flows.</p>"},{"location":"testing-framework/fuzzing/#generating-random-data","title":"Generating random data","text":"<p>There are two ways to generate random data in Wake fuzz tests.</p> <p>Warning</p> <p>Do not use the <code>random</code> module from the Python standard library to generate random data in fuzz tests. Instead, use <code>random</code> defined in the <code>wake.testing</code> module.</p>"},{"location":"testing-framework/fuzzing/#flow-arguments","title":"Flow arguments","text":"<p>Every flow function can accept additional arguments to the implicit <code>self</code>. These arguments are generated based on the type hints:</p> <pre><code>@flow()\ndef flow_set_count(self, count: uint) -&gt; None:\n    self.counter.set_count(count, from_=self.counter.owner())\n    self.count = count\n</code></pre> <p>Flow argument types can be any of the following:</p> <ul> <li>integer types ranging from <code>uint8</code> to <code>uint256</code> and from <code>int8</code> to <code>int256</code>, including <code>uint</code> and <code>int</code>,</li> <li>byte types ranging from <code>bytes1</code> to <code>bytes32</code>, including <code>bytes</code> and <code>bytearray</code>,</li> <li><code>List</code>, including <code>List1</code> to <code>List32</code> helper annotations (e.g. <code>List16[uint8]</code>),</li> <li><code>bool</code>,</li> <li><code>str</code>,</li> <li><code>Address</code>, does never generate the zero address,</li> <li>any <code>Enum</code>, including enums generated in <code>pytypes</code>,</li> <li>any <code>dataclass</code>, including dataclasses generated in <code>pytypes</code>.</li> </ul> <p>All flow arguments are generated non-biased, i.e. the probability of generating a value of a given type is the same for all values of that type. For types that have length, the length is generated in the range 0 to 64.</p> <p>For generating fine-tuned random data, it is recommended to use the random functions from the <code>wake.testing.fuzzing</code> module.</p>"},{"location":"testing-framework/fuzzing/#random-functions","title":"Random functions","text":"<p>Additionally to the methods provided by the standard random module, Wake testing framework provides a set of random functions that can be used to generate random data.</p> <p>Warning</p> <p>Never import the standard <code>random</code> module in Wake tests.</p> <pre><code>from wake.testing import *\n\nimport random  # never do this\n</code></pre> <p>Wake already provides a custom isolated <code>random</code> instance that can be imported from <code>wake.testing</code>.</p>"},{"location":"testing-framework/fuzzing/#random_account","title":"random_account()","text":"<p><code>random_account()</code> returns a random account from a given chain. It accepts the following keyword arguments:</p> Argument Description Default value <code>lower_bound</code> lower bound index of <code>chain.accounts</code> to choose from <code>0</code> <code>upper_bound</code> upper bound index of <code>chain.accounts</code> to choose from <code>None</code> (i.e. <code>len(chain.accounts)</code>) <code>predicate</code> predicate that the account must satisfy <code>None</code> (i.e. no predicate) <code>chain</code> chain to choose the account from <code>default_chain</code>"},{"location":"testing-framework/fuzzing/#random_address","title":"random_address()","text":"<p><code>random_address()</code> returns a random address. It accepts the following keyword arguments:</p> Argument Description Default value <code>zero_address_prob</code> probability of generating the zero address <code>0</code>"},{"location":"testing-framework/fuzzing/#random_intmin-max","title":"random_int(min, max)","text":"<p><code>random_int(min, max)</code> returns a random integer in the range <code>min</code> to <code>max</code>. It accepts the following keyword arguments:</p> Argument Description Default value <code>min_prob</code> probability of generating <code>min</code> <code>None</code> (i.e. <code>1 / (max - min + 1))</code> <code>max_prob</code> probability of generating <code>max</code> <code>None</code> (i.e. <code>1 / (max - min + 1))</code> <code>zero_prob</code> probability of generating <code>0</code>, if <code>min</code> &lt; <code>0</code> &lt; <code>max</code> <code>None</code> (i.e. <code>1 / (max - min + 1))</code> <code>edge_values_prob</code> value to use for <code>min_prob</code>, <code>max_prob</code> and <code>zero_prob</code> if not set <code>None</code>"},{"location":"testing-framework/fuzzing/#random_bool","title":"random_bool()","text":"<p><code>random_bool()</code> returns a random boolean value. It accepts the following keyword arguments:</p> Argument Description Default value <code>true_prob</code> probability of generating <code>True</code> <code>0.5</code>"},{"location":"testing-framework/fuzzing/#random_stringmin-max","title":"random_string(min, max)","text":"<p><code>random_string(min, max)</code> returns a random string of length in the range <code>min</code> to <code>max</code>. It accepts the following keyword arguments:</p> Argument Description Default value <code>alphabet</code> alphabet to choose characters from <code>string.printable</code> <code>predicate</code> predicate that the string must satisfy <code>None</code> (i.e. no predicate)"},{"location":"testing-framework/fuzzing/#random_bytesmin-max","title":"random_bytes(min, max)","text":"<p><code>random_bytes(min, max)</code> returns a random byte array of length in the range <code>min</code> to <code>max</code>. If <code>max</code> is not specified, it generates exactly <code>min</code> bytes. It accepts the following keyword arguments:</p> Argument Description Default value <code>predicate</code> predicate that the byte array must satisfy <code>None</code> (i.e. no predicate)"},{"location":"testing-framework/fuzzing/#launching-tests-in-parallel","title":"Launching tests in parallel","text":"<p>Wake testing framework allows running the same test in parallel with different random seeds. Multiprocess tests are launched by setting the <code>-P</code> flag specifying the number of processes to be used:</p> <pre><code>wake test -P 3 tests/test_counter_fuzz.py\n</code></pre> <p>If a test process encounters an error, the user is prompted whether to debug the test or continue testing. While debugging, other processes are still running in the background.</p> <p>By default, nothing but status of each test is printed to the console. Using the <code>--attach-first</code> flag, the output of the first process is printed to the console. Standard output and standard error of all processes are redirected to the <code>.wake/logs/testing</code> directory.</p> <p>Reproducing a failed test</p> <p>For every process, Wake generates a random seed that is used to initialize the random number generator. The seed is printed to the console and can be used to reproduce the test failure:</p> <pre><code>wake test tests/test_counter_fuzz.py -P 5 -S 62061e838798ad0f\n</code></pre> <p>A random seed can be specified using the <code>-S</code> flag. Multiple <code>-S</code> flags are allowed.</p> <p>Non-deterministic tests with <code>set</code></p> <p>Python built-in <code>set</code> is an unordered container. Given the unordered behavior, the following code will lead to different fuzz test results with the same random seed:</p> <pre><code>items = {1, 2, 3}\nitem = random.choice(list(items))\n</code></pre> <p>It is highly recommended to use OrderedSet in fuzz tests instead of the built-in <code>set</code>.</p>"},{"location":"testing-framework/getting-started/","title":"Getting started","text":"<p>This guide explains how to run the first test in Wake development and testing framework.</p> <p>Important</p> <p>Before getting started, make sure to have the latest version of a development chain installed.</p> <p>This is especially important in the case of Anvil, because it is under active development. To install the latest version of Anvil, run the following command:</p> <pre><code>foundryup\n</code></pre> <p>Tip</p> <p>The command <code>wake up --example counter</code> can be used to generate an example project in the empty current working directory.</p> <p>Code snippets in this guide are based on the example project.</p>"},{"location":"testing-framework/getting-started/#generating-pytypes","title":"Generating pytypes","text":"<p><code>pytypes</code> are Python-native equivalents of Solidity types. They are generated from Solidity source code and used in tests and deployment scripts to interact with smart contracts.</p> <p>The first step is to generate <code>pytypes</code> by running the following command:</p> <pre><code>wake up\n</code></pre> <p>The command prepares <code>wake.toml</code> in the current working directory, updates <code>.gitignore</code>, prepares a basic directory structure, and generates <code>pytypes</code> for all Solidity source files found.</p> <p>Configuring compilation</p> <p>Wake uses default configuration options that should work for most projects. However, in some cases, it may be necessary to configure the compilation process. For more information, see the Compilation page.</p> <p>Alternatively, the following commands can be used just to setup the config file and generate <code>pytypes</code>:</p> <pre><code>wake up config\nwake up pytypes -w\n</code></pre> <p>The <code>-w</code> flag tells Wake to watch for changes in the smart contracts and automatically regenerate <code>pytypes</code> when a change is detected.</p> <p>When a compilation error occurs, Wake generates <code>pytypes</code> for the contracts that were successfully compiled. <code>pytypes</code> for the contracts that failed to compile are not generated.</p> <p>Name collisions in <code>pytypes</code></p> <p>In some cases, a name of a Solidity types may be a keyword in Python or otherwise reserved name. In such cases, Wake will append an underscore to the name of the type. For example, <code>class</code> will be renamed to <code>class_</code>.</p> <p>This also applies to overloaded functions. For example, if a contract has a function <code>foo</code> that takes an argument of type <code>uint256</code> and another function <code>foo</code> that takes an argument of type <code>uint8</code>, the generated <code>pytypes</code> will contain two functions <code>foo</code> and <code>foo_</code>.</p>"},{"location":"testing-framework/getting-started/#writing-the-first-test","title":"Writing the first test","text":"<p>Tip</p> <p>Solidity source code for all examples in this guide is available in the Wake repository.</p> <p>To collect and execute tests, Wake uses the pytest framework under the hood. The test files should start with <code>test_</code> or end with <code>_test.py</code> to be collected. It is possible to use all the features of the pytest framework like fixtures.</p> <p>Connecting to a chain from a fixture</p> <p>In order to interact with a chain in a fixture, the chain must already be connected. The best way to achieve this is to prepare a fixture that connects to the chain and use it wherever needed.</p> <pre><code>@fixture\ndef chain():\n    if default_chain.connected:\n        return default_chain\n    else:\n        with default_chain.connect():\n            yield default_chain\n</code></pre> <p>The recommended project structure is as follows:</p> <pre><code>.\n\u251c\u2500\u2500 contracts\n\u2502   \u2514\u2500\u2500 Counter.sol\n\u251c\u2500\u2500 pytypes\n\u251c\u2500\u2500 scripts\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 deploy.py\n\u2514\u2500\u2500 tests\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 test_counter.py\n</code></pre>"},{"location":"testing-framework/getting-started/#connecting-to-a-chain","title":"Connecting to a chain","text":"<p>In single-chain tests, it is recommended to use the <code>default_chain</code> object that is automatically created by Wake. The <code>connect</code> decorator either launches a new development chain or connects to an existing one, if an argument is specified. It is possible to connect using:</p> <ul> <li>an HTTP connection (e.g. <code>http://localhost:8545</code>),</li> <li>a WebSocket connection (e.g. <code>ws://localhost:8545</code>),</li> <li>an IPC socket (e.g. <code>/tmp/anvil.ipc</code>).</li> </ul> <pre><code>from wake.testing import *\n\n\n# launch a new development chain\n@default_chain.connect()\n# or connect to an existing chain\n# @default_chain.connect(\"ws://localhost:8545\")\ndef test_counter():\n    print(default_chain.chain_id)\n</code></pre> <p>To run the test, execute the following command:</p> <pre><code>wake test tests/test_counter.py -d\n</code></pre> <p>The <code>-d</code> flag tells Wake to attach the Python debugger on test failures.</p>"},{"location":"testing-framework/getting-started/#deploying-a-contract","title":"Deploying a contract","text":"<p>Every Solidity source file has its equivalent in the <code>pytypes</code> directory. These directories form a module hierarchy that is similar to the one in the <code>contracts</code> directory. The <code>Counter</code> contract from the previous example is available in the <code>pytypes.contracts.Counter</code> module.</p> <p>Every contract has a <code>deploy</code> method that deploys the contract to the chain. The <code>deploy</code> method accepts the arguments that are required by the contract's constructor. Additionally, it accepts keyword arguments that can be used to configure the transaction that deploys the contract. All keyword arguments are described in the Interacting with contracts section.</p> <pre><code>from wake.testing import *\n\nfrom pytypes.contracts.Counter import Counter\n\n\n@default_chain.connect()\ndef test_example():\n    counter = Counter.deploy()\n    print(counter)\n</code></pre>"},{"location":"testing-framework/getting-started/#interacting-with-a-contract","title":"Interacting with a contract","text":"<p>For every public and external function in Solidity source code, Wake generates a Python method in <code>pytypes</code>. These methods can be used to interact with deployed contracts. Generated methods accept the same arguments as the corresponding Solidity functions. Additional keyword arguments can configure the execution of a function like with the <code>deploy</code> method.</p> <pre><code>from wake.testing import *\nfrom pytypes.contracts.Counter import Counter\n\n\n@default_chain.connect()\ndef test_counter():\n    owner = default_chain.accounts[0]\n    other = default_chain.accounts[1]\n\n    counter = Counter.deploy(from_=owner)\n\n    counter.increment(from_=other)\n    assert counter.count() == 1\n\n    # setCount can only be called by the owner\n    counter.setCount(10, from_=owner)\n    assert counter.count() == 10\n\n    # this will fail because the sender account is not the owner\n    with must_revert():\n        counter.setCount(20, from_=other)\n    assert counter.count() == 10\n</code></pre>"},{"location":"testing-framework/helper-functions/","title":"Helper functions","text":"<p>Wake testing framework provides a set of helper functions to make testing easier.</p>"},{"location":"testing-framework/helper-functions/#abi-encoding-and-decoding","title":"ABI encoding and decoding","text":"<p>The <code>Abi</code> class provides functions to encode and decode data according to the ABI specification.</p>"},{"location":"testing-framework/helper-functions/#abiencode","title":"Abi.encode","text":"<p><code>Abi.encode</code> encodes a list of values given a list of types. It returns <code>bytes</code>:</p> <pre><code>from wake.testing import Abi, Address\n\nAbi.encode(['uint8', 'address'], [0xff, Address(0)])\n</code></pre>"},{"location":"testing-framework/helper-functions/#abiencode_packed","title":"Abi.encode_packed","text":"<p><code>Abi.encode_packed</code> encodes a list of values given a list of types. It returns <code>bytes</code>:</p> <pre><code>from wake.testing import Abi\n\nAbi.encode_packed(['bytes', 'string'], [b'abc', 'def'])\n</code></pre>"},{"location":"testing-framework/helper-functions/#abiencode_with_selector","title":"Abi.encode_with_selector","text":"<p><code>Abi.encode_with_selector</code> encodes a list of values and a selector given a list of types and the selector. It returns <code>bytes</code>:</p> <pre><code>from wake.testing import Abi\nfrom pytypes.contracts.Counter import Counter\n\nAbi.encode_with_selector(Counter.setCount.selector, ['uint256'], [0xff])\n</code></pre>"},{"location":"testing-framework/helper-functions/#abiencode_with_signature","title":"Abi.encode_with_signature","text":"<p><code>Abi.encode_with_signature</code> encodes a list of values and a selector given a list of types and a signature. It returns <code>bytes</code>:</p> <pre><code>from wake.testing import Abi\n\nAbi.encode_with_signature(\"setCount(uint256)\", ['uint256'], [0xff])\n</code></pre> <p>Warning</p> <p>The signature string must conform to the ABI specification. The common mistakes are:</p> <ul> <li><code>uint</code> or <code>int</code> used instead of <code>uint256</code> or <code>int256</code>,</li> <li>return type specified,</li> <li>spaces in the signature string.</li> </ul>"},{"location":"testing-framework/helper-functions/#abiencode_call","title":"Abi.encode_call","text":"<p><code>Abi.encode_call</code> encodes a list of values and a selector given a reference to a function. It returns <code>bytes</code>:</p> <pre><code>from wake.testing import Abi\nfrom pytypes.contracts.Counter import Counter\n\nAbi.encode_call(Counter.setCount, [0xff])\n</code></pre>"},{"location":"testing-framework/helper-functions/#abidecode","title":"Abi.decode","text":"<p><code>Abi.decode</code> decodes a <code>bytes</code> object given a list of types. It returns a list of values:</p> <pre><code>from wake.testing import Abi\n\nAbi.decode(['uint8', 'address'],\n           b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00')\n</code></pre>"},{"location":"testing-framework/helper-functions/#keccak-256","title":"Keccak-256","text":"<p>The <code>keccak256</code> function computes the Keccak-256 hash of a <code>bytes</code> object:</p> <pre><code>from wake.testing import keccak256\n\nkeccak256(b'abc')\n</code></pre>"},{"location":"testing-framework/helper-functions/#computing-create-and-create2-address","title":"Computing <code>CREATE</code> and <code>CREATE2</code> address","text":"<p>In some cases, it may be useful to compute the address of a contract before it is deployed. Wake testing framework provides three functions to do so.</p>"},{"location":"testing-framework/helper-functions/#get_create_address","title":"get_create_address","text":"<p><code>get_create_address</code> computes the address of a contract deployed in a transaction or in a contract using the <code>CREATE</code> opcode. It accepts a deployer (<code>Account</code>, <code>Address</code> or a hex string address) and its nonce.</p> <pre><code>from wake.testing import Account, get_create_address\n\ndeployer = Account(1)\nget_create_address(deployer, deployer.nonce)\n</code></pre>"},{"location":"testing-framework/helper-functions/#get_create2_address_from_code","title":"get_create2_address_from_code","text":"<p><code>get_create2_address_from_code</code> computes the address of a contract deployed using the <code>CREATE2</code> opcode. It accepts a deployer (<code>Account</code>, <code>Address</code> or a hex string address), a salt and the contract creation code.</p> <pre><code>from wake.testing import Account, get_create2_address_from_code\nfrom wake.testing.fuzzing import random_bytes\nfrom pytypes.contracts.Counter import Counter\n\nget_create2_address_from_code(\n    Account(1),\n    random_bytes(32),\n    Counter.get_creation_code()\n)\n</code></pre>"},{"location":"testing-framework/helper-functions/#get_create2_address_from_hash","title":"get_create2_address_from_hash","text":"<p><code>get_create2_address_from_hash</code> computes the address of a contract deployed using the <code>CREATE2</code> opcode. It accepts a deployer (<code>Account</code>, <code>Address</code> or a hex string address), a salt and the hash of the contract creation code.</p> <pre><code>from wake.testing import Account, get_create2_address_from_hash, keccak256\nfrom wake.testing.fuzzing import random_bytes\nfrom pytypes.contracts.Counter import Counter\n\nget_create2_address_from_hash(\n    Account(1),\n    random_bytes(32),\n    keccak256(Counter.get_creation_code())\n)\n</code></pre>"},{"location":"testing-framework/helper-functions/#get-logic-contract-from-proxy","title":"Get logic contract from proxy","text":"<p><code>get_logic_contract</code> returns the logic contract <code>Account</code> from a proxy <code>Account</code>. If the input account is not a proxy, it returns the input account.</p> <pre><code>from wake.testing import Account, get_logic_contract\n\nusdc_proxy = Account(\"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\")\nusdc_logic = get_logic_contract(usdc_proxy)\n</code></pre>"},{"location":"testing-framework/helper-functions/#read-write-storage-variable","title":"Read &amp; write storage variable","text":"<p><code>read_storage_variable</code> and <code>write_storage_variable</code> read and write storage variables of a contract. They accept a contract <code>Account</code> and a variable name. The <code>keys</code> argument is used to specify the array indexes, mapping keys and struct member names needed to access the variable.</p> <p>Info</p> <p>Reading and writing arrays is done using lists, while reading and writing structs is done using dictionaries.</p> <p>Reading and writing whole mappings is not supported.</p> <p>If the provided contract is a proxy, the variable definition is searched in the logic contract and the proxy storage is used. This behavior can be overridden by setting the <code>storage_layout_contract</code> argument. In this case, the variable definition is searched in the provided <code>storage_layout_contract</code>.</p> <pre><code>from wake.testing import Account, Address, read_storage_variable, write_storage_variable\n\nusdc_proxy = Account(\"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\")\nwrite_storage_variable(usdc_proxy, \"balances\", 1000, keys=[Address(1)])\nassert read_storage_variable(usdc_proxy, \"balances\", keys=[Address(1)]) == 1000\n</code></pre>"},{"location":"testing-framework/helper-functions/#erc-20-mint-and-burn","title":"ERC-20 mint and burn","text":"<p><code>mint_erc20</code> and <code>burn_erc20</code> mint and burn ERC-20 tokens. They detect the <code>totalSupply</code> and <code>balances</code> variables using heuristics and may not work for all contracts. Optionally, <code>balance_slot</code> and <code>total_supply_slot</code> arguments can be used to specify the storage slot where the balance of the given account and the total supply are stored.</p> <pre><code>from wake.testing import Account, mint_erc20, burn_erc20\nfrom pytypes.contracts.IERC20 import IERC20\n\nusdc_proxy = IERC20(\"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\")\nburn_erc20(usdc_proxy, Account(1), usdc_proxy.balanceOf(Account(1)))\nmint_erc20(usdc_proxy, Account(1), 1000)\nassert usdc_proxy.balanceOf(Account(1)) == 1000\n</code></pre>"},{"location":"testing-framework/helper-functions/#decorators","title":"Decorators","text":""},{"location":"testing-framework/helper-functions/#on_revert","title":"on_revert","text":"<p><code>on_revert</code> is a decorator that simplifies handling of revert exceptions. It accepts a callback function that will be called if the decorated function reverts.</p> <pre><code>from wake.testing import *\n\n\ndef revert_handler(e: TransactionRevertedError):\n    if e.tx is not None:\n        print(e.tx.call_trace)\n        print(e.tx.console_logs)\n\n\n@default_chain.connect()\n@on_revert(revert_handler)\ndef test_reverts():\n    ...\n</code></pre>"},{"location":"testing-framework/interacting-with-contracts/","title":"Interacting with contracts","text":"<p>Contracts can be interacted with either using methods generated in <code>pytypes</code> or using low-level methods.</p>"},{"location":"testing-framework/interacting-with-contracts/#request-types","title":"Request types","text":"<p>There are 4 low-level methods that represent different request types:</p> <ul> <li><code>tx</code> - a request that sends a transaction (even if the function being called does not modify the blockchain state),</li> <li><code>call</code> - a request that returns the return value of the function being called, does not modify the blockchain state (even if the function being called modifies the blockchain state),</li> <li><code>estimate</code> - a request that returns an estimated amount of gas needed to perform the transaction,</li> <li><code>access_list</code> - a request that returns an access list (addresses and storage keys, see EIP-2930) and an estimated amount of gas needed to perform the transaction when the access list is used.</li> </ul> <p>The low-level methods are named <code>.transact()</code>, <code>.call()</code>, <code>.estimate()</code>, and <code>.access_list()</code> respectively. Each request type has its default account used when no <code>from_</code> argument is provided. The default accounts are properties of the <code>Chain</code> object:</p> <ul> <li><code>chain.default_tx_account</code> for <code>tx</code> request type,</li> <li><code>chain.default_call_account</code> for <code>call</code> request type,</li> <li><code>chain.default_estimate_account</code> for <code>estimate</code> request type,</li> <li><code>chain.default_access_list_account</code> for <code>access_list</code> request type.</li> </ul> <p>All default accounts use <code>chain.accounts[0]</code> as the default value. The default accounts can be changed by assigning a new value to the corresponding property or by using the <code>set_default_accounts()</code> method.</p> <pre><code>from wake.testing import *\n\n\n@default_chain.connect()\ndef test_accounts():\n    # assign each default account manually\n    default_chain.default_tx_account = default_chain.accounts[1]\n    default_chain.default_call_account = default_chain.accounts[1]\n    default_chain.default_estimate_account = default_chain.accounts[1]\n    default_chain.default_access_list_account = default_chain.accounts[1]\n\n    # or assign all default accounts at once\n    default_chain.set_default_accounts(default_chain.accounts[2])\n</code></pre> <p>Note</p> <p>It is recommended to set <code>default_estimate_account</code> and <code>default_access_list_account</code> to the same account as <code>default_tx_account</code> to ensure that the returned gas estimate is accurate.</p> <p>In <code>pytypes</code>, the default request type is <code>tx</code> for non-pure non-view functions and <code>call</code> for pure and view functions.</p> <pre><code>from wake.testing import *\nfrom pytypes.contracts.Counter import Counter\n\n\n@default_chain.connect()\ndef test_accounts():\n    default_chain.set_default_accounts(default_chain.accounts[0])\n    counter = Counter.deploy()\n\n    # performs a call\n    count = counter.count()\n\n    # sends a transaction\n    tx = counter.increment()\n</code></pre> <p>The request type can be changed using the <code>request_type</code> flag.</p> <pre><code># does not increment the counter\nret_val = counter.increment(request_type=\"call\")\n\n# \"tx\" request type is the default for non-pure non-view functions\ntx = counter.increment(request_type=\"tx\")\n\n# amount of gas needed to send as a transaction\ngas_estimate = counter.increment(request_type=\"estimate\")\n\n# access list and amount of gas needed to send as a transaction\naccess_list, gas_estimate = counter.increment(request_type=\"access_list\")\n</code></pre> <p>The <code>call</code> request type used on the <code>.deploy()</code> method returns runtime code of the contract that would be deployed if the method was called with <code>tx</code> request type.</p> <pre><code># does not deploy the contract\nruntime_code = Counter.deploy(request_type=\"call\")\n\n# deploys the contract and returns the contract instance, the default behavior\ncounter = Counter.deploy(request_type=\"tx\")\n\n# deploys the contract and returns the transaction object\ntx = Counter.deploy(request_type=\"tx\", return_tx=True)\n\n# amount of gas needed to deploy the contract\ngas_estimate = Counter.deploy(request_type=\"estimate\")\n\n# access list and amount of gas needed to deploy the contract\naccess_list, gas_estimate = Counter.deploy(request_type=\"access_list\")\n</code></pre> <p>Warning</p> <p>The <code>call</code> request type used to return empty bytes for <code>deploy</code> methods in earlier versions of Anvil.</p>"},{"location":"testing-framework/interacting-with-contracts/#keyword-arguments","title":"Keyword arguments","text":"<p>Both methods generated in <code>pytypes</code> and low-level methods accept the following keyword arguments common for all request types:</p> Argument Description <code>from_</code> <code>Account</code> or <code>Address</code> used as a sender of a transaction/call. If not provided, the default account for the request type will be used. <code>value</code> Amount of Ether to be sent. Can be either an <code>int</code> in Wei or a string with a unit (e.g. <code>\"1 ether\"</code>). <code>gas_limit</code> Maximum amount of gas that can be consumed by the transaction. <code>gas_price</code> Gas price to be used for type 0 and type 1 transactions. Can be either an <code>int</code> in Wei or a string with a unit (e.g. <code>\"10 gwei\"</code>). <code>max_fee_per_gas</code> Maximum fee per gas to be used for type 2 transactions. Can be either an <code>int</code> in Wei or a string with a unit (e.g. <code>\"10 gwei\"</code>). <code>max_priority_fee_per_gas</code> Maximum priority fee per gas to be used for type 2 transactions. Can be either an <code>int</code> in Wei or a string with a unit (e.g. <code>\"10 gwei\"</code>). <code>access_list</code> Access list to be used for type 1 and type 2 transactions. See EIP-2930 for more information. <code>type</code> Transaction type to be used. Can be either <code>0</code>, <code>1</code>, or <code>2</code>. <p>Low-level methods also accept the <code>data</code> keyword argument (of type <code>bytes</code> or <code>bytearray</code>) that can be used to specify the data to be sent to a contract.</p> <p>Encoding data for low-level calls and transactions</p> <p>To prepare the <code>data</code> payload, the <code>Abi</code> helper class can be used. It offers the same ABI encoding functions as the <code>abi</code> global object in Solidity.</p> <pre><code>from wake.testing import *\nfrom pytypes.contracts.Counter import Counter\n\n@default_chain.connect()\ndef test_low_level_transact():\n    default_chain.default_tx_account = default_chain.accounts[0]\n\n    counter = Counter.deploy()\n\n    # execute counter.setCount(100) using a low-level transaction\n    counter.transact(data=Abi.encode_call(Counter.setCount, [100]))\n    assert counter.count() == 100\n</code></pre> <p>Methods generated in <code>pytypes</code> accept the <code>to</code> keyword argument (of type <code>Account</code>, <code>Address</code> or hex-encoded string address) that can be used to override the address of the contract being called.</p> <p>Calling contracts through a proxy</p> <p>Using the <code>to</code> keyword argument can be useful when a contract should be called through a proxy contract.</p> <pre><code>contract.initialize(owner, to=proxy)\n</code></pre>"},{"location":"testing-framework/interacting-with-contracts/#tx-request-type","title":"<code>tx</code> request type","text":"<p>The <code>tx</code> request type is used to send a transaction. It accepts one more keyword argument, <code>confirmations</code>, that can be used to specify the number of blocks that should be mined before a transaction object is returned. Setting <code>confirmations</code> to <code>0</code> returns a transaction object immediately after the transaction is sent.</p> <p>Sending transactions from any account</p> <p>The <code>from_</code> argument can be used to send transactions from any account (including contract) or address. However, this may come at a cost of decreased performance (see Performance considerations).</p> <p>When sending transactions from an account with code (contract), the contract behaves as if it had no code during the execution of the transaction!</p>"},{"location":"testing-framework/interacting-with-contracts/#call-request-type","title":"<code>call</code> request type","text":"<p>The <code>call</code> request type is used to execute a call. It accepts one more keyword argument, <code>block</code>, that can be used to specify the number of the block to be used as a context for the call. The default value is <code>latest</code> which means that the call will be executed in the context of the latest block.</p>"},{"location":"testing-framework/interacting-with-contracts/#estimate-request-type","title":"<code>estimate</code> request type","text":"<p>The <code>estimate</code> request type is used to estimate the amount of gas needed to execute a transaction. It accepts one more keyword argument, <code>block</code>, that can be used to specify the number of the block to be used as a context for the estimation. The default value is <code>pending</code> which means that the estimation will be executed in the context of the pending block.</p>"},{"location":"testing-framework/interacting-with-contracts/#access_list-request-type","title":"<code>access_list</code> request type","text":"<p>The <code>access_list</code> request type is used to estimate the access list and the amount of gas needed to execute a transaction when using the returned access list. It accepts one more keyword argument, <code>block</code>, that can be used to specify the number of the block to be used as a context for the estimation. The default value is <code>pending</code> which means that the estimation will be executed in the context of the pending block.</p>"},{"location":"testing-framework/migrating-from-ape-and-brownie/","title":"Migrating from Ape &amp; Brownie","text":""},{"location":"testing-framework/migrating-from-ape-and-brownie/#importing-contracts","title":"Importing contracts","text":"<p>In Wake, contract types must be imported from <code>pytypes</code>, a directory generated using:</p> <pre><code>wake up pytypes\n</code></pre> <p>An optional <code>-w</code> flag can be used to generate <code>pytypes</code> in a watch mode.</p> <p>If there is a <code>Counter</code> contract in <code>contracts/Counter.sol</code>, then the following import statement can be used:</p> <pre><code>from pytypes.contracts.Counter import Counter\n</code></pre> <p>A contract named <code>ERC1967Proxy</code> in <code>node_modules/@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol</code> can be imported using:</p> <pre><code>from pytypes.node_modules.openzeppelin.contracts.proxy.ERC1967.ERC1967Proxy import ERC1967Proxy\n</code></pre>"},{"location":"testing-framework/migrating-from-ape-and-brownie/#accessing-accounts","title":"Accessing accounts","text":"<p>In Wake, accounts are a property of a chain. With the default chain instance named <code>default_chain</code>:</p> <pre><code>from wake.testing import *\n\n\n@default_chain.connect()\ndef test_accounts():\n    print(default_chain.accounts)\n</code></pre>"},{"location":"testing-framework/migrating-from-ape-and-brownie/#configuring-networks","title":"Configuring networks","text":"<p>Wake does not support configuring networks in configuration files. Instead, a chain instance can be created:</p> <ul> <li>without a URI (<code>@default_chain.connect()</code>), which will launch a new development chain,</li> <li>with a URI (<code>@default_chain.connect(\"http://localhost:8545\")</code>), which will connect to an existing chain.</li> </ul> <p>A development chain executable and its arguments can be configured in <code>wake.toml</code> in the project root:</p> wake.toml<pre><code>[testing]\ncmd = \"anvil\"  # other options: \"hardhat\", \"ganache\"\n\n[testing.anvil]\ncmd_args = \"--prune-history 100 --transaction-block-keeper 10 --steps-tracing --silent\"\n</code></pre> <p>Commonly used parameters can be set as keyword arguments in <code>@default_chain.connect()</code>:</p> <pre><code>@default_chain.connect(\n    accounts=20,  # number of accounts to generate\n    chain_id=1337,  # chain ID\n    fork=\"https://eth-mainnet.alchemyapi.io/v2/...@12345678\",  # fork from a block\n    hardfork=\"london\",  # hardfork to use\n)\n</code></pre>"},{"location":"testing-framework/migrating-from-ape-and-brownie/#events-and-user-defined-errors","title":"Events and user-defined errors","text":"<p>Events and user-defined errors are generated in <code>pytypes</code> in a form of dataclasses.</p> <p>If there is an event named <code>Incremented</code> and error named <code>NotOwner</code> in <code>contracts/Counter.sol</code>, then the following can be used to test the contract:</p> <pre><code>from wake.testing import *\nfrom pytypes.contracts.Counter import Counter\n\n\n@default_chain.connect()\ndef test_counter():\n    counter = Counter.deploy()\n    tx = counter.increment()\n    assert Counter.Incremented() in tx.events\n\n    acc = default_chain.accounts[1]\n    with must_revert(Counter.NotOwner()):\n        counter.addToWhitelist(acc, from_=acc)\n</code></pre>"},{"location":"testing-framework/migrating-from-ape-and-brownie/#transaction-parameters","title":"Transaction parameters","text":"<p>Like in Ape, Wake uses keyword arguments to specify transaction parameters. A transaction sender can be specified using <code>from_</code>:</p> <pre><code># Ape\ncounter.increment(sender=acc)\n\n# Brownie\ncounter.increment({'from': acc})\n\n# Wake\ncounter.increment(from_=acc)\n</code></pre>"},{"location":"testing-framework/migrating-from-ape-and-brownie/#expecting-reverts","title":"Expecting reverts","text":"<p>Wake uses <code>may_revert</code> and <code>must_revert</code> context managers to expect reverts:</p> <pre><code># Ape\nwith ape.reverts(r\"b'NH{q\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x11'\"):\n    counter.decrement()\n\n# Brownie\nwith brownie.reverts(\"Integer overflow\"):\n    counter.decrement()\n\n# Wake\nwith must_revert(PanicCodeEnum.UNDERFLOW_OVERFLOW):\n    counter.decrement()\n</code></pre>"},{"location":"testing-framework/migrating-from-ape-and-brownie/#multi-chain-testing","title":"Multi-chain testing","text":"<p>Wake does not use context managers to change the current chain interface. Instead, the <code>chain</code> keyword argument can be passed when deploying a contract:</p> <pre><code>from wake.testing import *\nfrom pytypes.contracts.Counter import Counter\n\nchain1 = Chain()\nchain2 = Chain()\n\n\n@chain1.connect()\n@chain2.connect()\ndef test_counter():\n    counter1 = Counter.deploy(chain=chain1)\n    counter2 = Counter.deploy(chain=chain2)\n</code></pre>"},{"location":"testing-framework/migrating-from-woke-2/","title":"Migrating from Woke 2.x","text":"<p>Woke 3.x introduces a new deployment module, which gives ability to write deployment scripts in Python. In order to achieve maximum consistency between the deployment and testing modules, a few breaking changes were introduced. This document describes the changes and how to migrate from Woke 2.x to Woke 3.x.</p>"},{"location":"testing-framework/migrating-from-woke-2/#return-value-of-transaction-calls","title":"Return value of transaction calls","text":"<p>In Woke 2.x, the return value of a transaction call was a return value of a function called in the transaction. Using the <code>return_tx=True</code> flag, it was possible to return the transaction object itself. With <code>return_tx=True</code>, a transaction object was returned immediately after the transaction was sent. As a consequence, when using <code>return_tx=True</code>:</p> <ul> <li>the transaction revert exception was not automatically raised,</li> <li><code>chain.tx_callback</code> was not called for the transaction,</li> <li>accessing some transaction fields performed implicit <code>.wait()</code>.</li> </ul> <p>With Woke 3.x, the return value of a transaction call is always a transaction object. Furthermore, the transaction object is returned only after the transaction is mined (unless overridden with <code>confirmations=0</code>). The return value of the <code>.deploy()</code> method is still the contract object. To get the transaction object from the <code>.deploy()</code> method, use the <code>return_tx=True</code> flag. The <code>return_tx</code> flag is no longer supported for other transaction calls.</p> <p>To get the return value of a transaction call: <pre><code># Woke 2.x\nret_val = counter.increment()\n\n# Woke 3.x\nret_val = counter.increment().return_value\n</code></pre></p> <p>To get the transaction object immediately without waiting for the transaction to be mined: <pre><code># Woke 2.x\ntx = counter.increment(return_tx=True)\n\n# Woke 3.x\ntx = counter.increment(confirmations=0)\n</code></pre></p> <p>To get the transaction object after the transaction is mined: <pre><code># Woke 2.x\n# tx_callback is not called\n# revert exception is not raised\ntx = counter.increment(return_tx=True)\ntx.wait()\n\n# Woke 3.x\n# tx_callback is called\n# revert exception is raised if the transaction reverts\ntx = counter.increment()\n</code></pre></p> <p>The <code>.deploy()</code> method behaves the same in Woke 2.x and Woke 3.x: <pre><code># Woke 2.x\ncounter = Counter.deploy()\n\n# Woke 3.x\ncounter = Counter.deploy()\n</code></pre></p>"},{"location":"testing-framework/migrating-from-woke-2/#default-transaction-type","title":"Default transaction type","text":"<p>Woke 2.x supported only legacy (type 0) transactions. With Woke 3.x, all transaction types are supported and the default transaction type is the latest transaction type supported by the chain (types are prioritized in the following order: 2, 1, 0).</p> <p>To achieve the same behavior as in Woke 2.x, set <code>type=0</code> in all transaction calls:</p> <pre><code>counter.increment(type=0)\n</code></pre> <p>or use:</p> <pre><code>default_chain.default_tx_type = 0\n</code></pre> <p>to set the default transaction type for the chain.</p>"},{"location":"testing-framework/migrating-from-woke-2/#deployment_code-renamed-to-get_creation_code","title":"<code>deployment_code()</code> renamed to <code>get_creation_code()</code>","text":"<p><code>ContractType.deployment_code()</code> was renamed to <code>ContractType.get_creation_code()</code> in Woke 3.x:</p> <pre><code># Woke 2.x\ncode = Counter.deployment_code()\n\n# Woke 3.x\ncode = Counter.get_creation_code()\n</code></pre>"},{"location":"testing-framework/migrating-from-woke-3/","title":"Migrating from Woke 3.x","text":"<p>In the version 4.0.0, the framework was renamed from Woke to Wake. This introduced breaking changes in a form of renamed modules (e.g. <code>woke.testing</code> -&gt; <code>wake.testing</code>) and renamed CLI commands (e.g. <code>woke test</code> -&gt; <code>wake test</code>). Except for the name changes, there a few other breaking changes that are described in this document.</p>"},{"location":"testing-framework/migrating-from-woke-3/#configuration-option-changes","title":"Configuration option changes","text":"<p>The <code>ignore_paths</code> configuration options located under <code>[compiler.solc]</code> and <code>[detectors]</code> namespaces were renamed to <code>exclude_paths</code>. The change was made to better reflect the purpose of the option and to be more consistent with other tools (e.g. pyright).</p> <p>The <code>timeout</code> configuration option located under <code>[testing]</code> namespace was renamed to <code>json_rpc_timeout</code> and moved to the <code>[general]</code> namespace.</p> <p>The <code>woke.toml</code> -&gt; <code>wake.toml</code> migration script should automatically rename the options. The same migration process is also performed in the Tools for Solidity VS Code extension.</p>"},{"location":"testing-framework/migrating-from-woke-3/#default-accounts","title":"Default accounts","text":"<p>All 4 default accounts for each request type are now set to <code>chain.accounts[0]</code> (if available).</p> <p>It is no longer needed to set the default accounts manually, like this:</p> <pre><code>default_chain.set_default_accounts(default_chain.accounts[0])\n</code></pre>"},{"location":"testing-framework/migrating-from-woke-3/#detect-cli-command","title":"<code>detect</code> CLI command","text":"<p>The <code>detect</code> CLI command was re-implemented together with the new API for detectors. To run all detectors, use the <code>all</code> subcommand:</p> <pre><code>wake detect all\n</code></pre> <p>See the output of <code>wake detect --help</code> for more information.</p>"},{"location":"testing-framework/migrating-from-woke-3/#fuzz-cli-command","title":"<code>fuzz</code> CLI command","text":"<p>The <code>fuzz</code> CLI command was integrated into the <code>test</code> command. In order to run tests using multiple processes, use the <code>-P</code> flag to specify the number of processes.</p> <pre><code>wake test -P 4\n</code></pre> <p><code>wake test</code> now always runs tests using the pytest framework (including multiprocessing tests). To run tests without pytest, use the <code>--no-pytest</code> flag.</p> <p>The <code>-s</code> shortcut for the <code>--seed</code> flag was renamed to <code>-S</code> to avoid conflicts with the <code>-s</code> pytest flag.</p>"},{"location":"testing-framework/migrating-from-woke-3/#may_revert-and-must_revert-context-managers","title":"<code>may_revert</code> and <code>must_revert</code> context managers","text":"<p>The <code>may_revert</code> and <code>must_revert</code> now re-raise the caught exception if the exception does not match the expected type or value. Previously, the context managers would raise an <code>AssertionError</code> instead.</p>"},{"location":"testing-framework/overview/","title":"Development and testing framework","text":"<p>Wake development and testing framework is a Python-based framework for testing and deploying Solidity smart contracts based on pytest. It utilizes <code>pytypes</code>, Python equivalents of Solidity types, to simplify writing scripts and easily discover typing errors.</p>"},{"location":"testing-framework/overview/#features","title":"Features","text":"<ul> <li>auto-completions when writing tests and deployment scripts thanks to <code>pytypes</code></li> <li>type checking for all types generated in <code>pytypes</code></li> <li>property-based fuzzer leveraging multiprocessing to maximize the amount of inputs tested</li> <li>cross-chain testing support</li> <li>integrated Python debugger (ipdb) attached on test failures</li> <li>call traces and <code>console.log</code> support for easier debugging</li> <li>deployment &amp; mainnet interaction scripts</li> <li>better performance than other Python or JavaScript frameworks</li> </ul> <p>The currently supported development chains are:</p> <ul> <li>Anvil (recommended)</li> <li>Hardhat</li> <li>Ganache</li> </ul>"},{"location":"testing-framework/performance-considerations/","title":"Performance considerations","text":"<p>Wake testing framework is designed to be fast and efficient. However, there are some things to keep in mind to achieve the best performance.</p> <ol> <li>Always prefer to use Anvil whenever possible.</li> <li>Always prefer WebSockets connection over HTTP connection.</li> <li>Avoid accessing transaction events (<code>tx.events</code>) unless necessary. Consider using <code>tx.raw_events</code> instead.</li> <li>Avoid using accounts other than the pre-generated ones (<code>chain.accounts</code>) in <code>from_</code> parameters. If you need more accounts than the default number, change the Wake configuration file or launch the development chain with a higher number of accounts and connect to it.</li> <li>Minimize usage of call traces (<code>tx.call_trace</code>) and console logs (<code>tx.console_logs</code>). These features are useful for debugging, but may slow down the test execution.</li> </ol>"},{"location":"testing-framework/performance-considerations/#profiling-tests","title":"Profiling tests","text":"<p>Every Wake command has the <code>--profile</code> flag that can be used to profile the test execution. The profiling results are saved in the <code>.wake/wake.prof</code> file.</p> <pre><code>wake --profile test tests/test_counter.py\n</code></pre> <p>Warning</p> <p>It is important to specify the <code>--profile</code> flag before the <code>test</code> command.</p> <p>It is not recommended to profile the <code>wake test</code> command in multiprocessing mode (with the <code>-P</code> option set).</p> <p>Wake uses cProfile dump_stats method to save the profiling results.</p> <p>Analyzing <code>wake.prof</code></p> <p>gprof2dot is a great tool for visualizing the profiling results. Together with Graphviz, it can be used to generate a call graph of the test execution.</p> <pre><code>gprof2dot -f pstats .wake/wake.prof | dot -Tsvg -o wake.prof.svg\n</code></pre>"},{"location":"testing-framework/transaction-objects/","title":"Transaction objects","text":"<p>When sending a transaction, a transaction object is returned. This object can be used to access the transaction's properties and wait for it to be mined (if <code>confirmations=0</code> set). Accessing some of the transaction object's properties also performs an implicit <code>wait()</code>.</p> <p>A <code>tx_callback</code> can be registered on a <code>Chain</code> instance. The callback receives a single argument, the transaction object. This can be used to process all transactions in a single place.</p> <pre><code>from wake.testing import *\nfrom pytypes.contracts.Counter import Counter\n\n\ndef tx_callback(tx: TransactionAbc):\n    print(tx.console_logs)\n\n\n@default_chain.connect()\ndef test_callback():\n    default_chain.tx_callback = tx_callback\n\n    counter = Counter.deploy()\n    counter.increment()\n</code></pre> <p>Warning</p> <p><code>tx_callback</code> is not invoked for transactions with <code>confirmations=0</code>!</p>"},{"location":"testing-framework/transaction-objects/#transaction-properties","title":"Transaction properties","text":"<p>Every transaction object has the following properties:</p> Property Description Note <code>block</code> <code>Block</code> the transaction was mined in performs implicit <code>wait()</code> <code>call_trace</code> <code>CallTrace</code> instance representing the call trace of the transaction performs implicit <code>wait()</code> <code>chain</code> <code>Chain</code> the transaction was sent to <code>console_logs</code> list of <code>console.log</code> calls made by the transaction performs implicit <code>wait()</code> <code>cumulative_gas_used</code> gas consumed by this and all previous transactions in the same block performs implicit <code>wait()</code> <code>data</code> data sent in the transaction <code>effective_gas_price</code> effective gas price of the transaction performs implicit <code>wait()</code> <code>error</code> native (<code>pytypes</code>) revert error, <code>None</code> if the transaction succeeded performs implicit <code>wait()</code> <code>events</code> list of native (<code>pytypes</code>) events emitted by the transaction performs implicit <code>wait()</code> <code>from_</code> <code>Account</code> the transaction was sent from <code>gas_limit</code> gas limit specified in the transaction <code>gas_used</code> gas used by the transaction performs implicit <code>wait()</code> <code>nonce</code> nonce specified in the transaction <code>r</code> <code>r</code> part of the ECDSA signature performs implicit <code>wait()</code> <code>raw_error</code> <code>UnknownTransactionRevertedError</code> instance, <code>None</code> if the transaction succeeded performs implicit <code>wait()</code> <code>raw_events</code> list of <code>UnknownEvent</code> instances emitted by the transaction performs implicit <code>wait()</code> <code>raw_return_value</code> raw return value of the transaction; <code>Account</code> for contract deployment, <code>bytearray</code> otherwise performs implicit <code>wait()</code>, raises <code>error</code> if the transaction failed <code>return_value</code> return value of the transaction performs implicit <code>wait()</code>, raises <code>error</code> if the transaction failed <code>s</code> <code>s</code> part of the ECDSA signature performs implicit <code>wait()</code> <code>status</code> status of the transaction, <code>1</code> for success, <code>0</code> for failure, <code>-1</code> for pending <code>to</code> <code>Account</code> the transaction was sent to <code>tx_hash</code> string hash of the transaction <code>tx_index</code> index of the transaction in the block performs implicit <code>wait()</code> <code>type</code> type of the transaction, <code>0</code> for legacy, <code>1</code> for EIP-2930, <code>2</code> for EIP-1559 <code>value</code> amount of Wei sent in the transaction <p>Legacy transactions (type <code>0</code>) have the following additional properties:</p> Property Description Note <code>gas_price</code> gas price specified in the transaction <code>v</code> ECDSA signature recovery ID <p>EIP-2930 transactions (type <code>1</code>) have the following additional properties:</p> Property Description Note <code>access_list</code> access list of the transaction (see EIP-2930) <code>chain_id</code> chain ID of the transaction <code>gas_price</code> gas price specified in the transaction <code>y_parity</code> <code>y</code> parity of the ECDSA signature <p>EIP-1559 transactions (type <code>2</code>) have the following additional properties:</p> Property Description Note <code>access_list</code> access list of the transaction (see EIP-2930) <code>chain_id</code> chain ID of the transaction <code>max_fee_per_gas</code> maximum fee per gas specified in the transaction (see EIP-1559) <code>max_priority_fee_per_gas</code> maximum priority fee per gas specified in the transaction (see EIP-1559) <code>y_parity</code> <code>y</code> parity of the ECDSA signature"},{"location":"testing-framework/transaction-objects/#multiple-transactions-in-a-single-block","title":"Multiple transactions in a single block","text":"<p>It is possible to send multiple transactions in a way that they are mined in the same block. This can be achieved in the following steps:</p> <ol> <li>Disable <code>automine</code> on the <code>Chain</code> instance</li> <li>Send any number of transactions with <code>confirmations=0</code> and <code>gas_limit=\"auto\"</code></li> <li>Re-enable <code>automine</code></li> <li>Call <code>.mine()</code> on the <code>Chain</code> instance</li> <li>Wait for the block to be mined</li> </ol> <pre><code>from wake.testing import *\nfrom pytypes.contracts.Counter import Counter\n\n\n@default_chain.connect()\ndef test_multiple_txs():\n    counter = Counter.deploy()\n\n    # temporarily disable automine\n    with default_chain.change_automine(False):\n        tx1 = counter.increment(confirmations=0, gas_limit=\"auto\")\n        tx2 = counter.increment(confirmations=0, gas_limit=\"auto\")\n        tx3 = counter.increment(confirmations=0, gas_limit=\"auto\")\n\n    default_chain.mine()\n\n    assert tx1.block == tx2.block == tx3.block\n</code></pre> <p>Changing <code>automine</code></p> <p>While it is possible to change the <code>automine</code> property of a <code>Chain</code> instance manually, it is not recommended. In a case when a test connects to an existing chain and an exception is raised before <code>automine</code> is re-enabled, the chain will be left in <code>automine</code> disabled state. This can be overcome by using the <code>change_automine</code> context manager.</p>"},{"location":"testing-framework/troubleshooting/","title":"Troubleshooting","text":""},{"location":"testing-framework/troubleshooting/#unknowntransactionrevertederrordatab","title":"<code>UnknownTransactionRevertedError(data=b'')</code>","text":"<p>In many different cases, a development chain or compiler auto-generated code does not provide any useful information about the revert reason. This section describes the most common cases and how to debug them.</p>"},{"location":"testing-framework/troubleshooting/#abi-decoding-error","title":"ABI decoding error","text":"<p>Failed ABI decoding reverts without reason data. The decoding can be explicit (e.g. <code>abi.decode(data, (uint256))</code>) or implicit when performing an external call, for example:</p> <pre><code>contract Reverting {\n    uint256 public immutable initialTotalSupply;\n\n    constructor(address token) {\n        initialTotalSupply = IERC20(token).totalSupply();\n    }\n}\n</code></pre> <p>To debug the latter case, print the call trace of the failing transaction. The trace should contain the failing call in a malformed way.</p> <pre><code>from wake.testing import *\nfrom pytypes.contracts.Reverting import Reverting\n\n\ndef revert_handler(e: TransactionRevertedError):\n    if e.tx is not None:\n        print(e.tx.call_trace)\n\n\n@default_chain.connect()\n@on_revert(revert_handler)\ndef test_reverting():\n    r = Reverting.deploy(Address(\"0x9a6A6920008318b3556702b5115680E048c2c8dB\"))\n</code></pre> wake\u00a0test Reverting.&lt;constructor&gt;(0x9a6a6920008318b3556702b5115680e048c2c8db)\u00a0\u2717[CREATE] \u279e\u00a0UnknownTransactionRevertedError(b'') \u2514\u2500\u2500\u00a0Unknown.&lt;???&gt;(b'\\x18\\x16\\r\\xdd')\u00a0\u2713[STATICCALL]"},{"location":"testing-framework/troubleshooting/#contract-code-size-limit","title":"Contract code size limit","text":"<p>The Spurious Dragon hard fork introduced a limit on the size of a contract. The limit is 24,576 bytes of bytecode. Due to the limit, a deployment transaction may fail with the <code>UnknownTransactionRevertedError</code> error without any reason data. In this case, the transaction call trace does not contain any red cross, but the transaction itself still fails.</p> <p>To debug this error, compile the project and search for a warning message similar to the following:</p> <pre><code>Warning: Contract code size exceeds 24576 bytes (a limit introduced in Spurious Dragon). This contract may not be deployable on mainnet.\nConsider enabling the optimizer (with a low \"runs\" value!), turning off revert strings, or using libraries.\n</code></pre>"},{"location":"testing-framework/troubleshooting/#invalid-opcode","title":"Invalid opcode","text":"<p>When EVM encounters an invalid opcode, it reverts without any reason data. Under normal circumstances, an invalid opcode should never be encountered unless explicitly triggered by the contract code.</p> <p>However, the <code>PUSH0</code> opcode may behave as invalid if the chain is not configured for the Shanghai hard fork or later. To debug this issue, try to set a different pre-Shanghai EVM version in the Wake config file.</p> <pre><code>[compiler.solc]\nevm_version = \"paris\"\n</code></pre>"},{"location":"testing-framework/troubleshooting/#websockettimeoutexception","title":"<code>WebSocketTimeoutException</code>","text":""},{"location":"testing-framework/troubleshooting/#insufficient-timeout-configured","title":"Insufficient timeout configured","text":"<p>Occasionally, the default timeout may be insufficient, especially when performing complex transactions or when fork testing.</p> <p>To work around this issue, increase the timeout in the Wake config file.</p> <pre><code>[general]\njson_rpc_timeout = 60\n</code></pre>"},{"location":"testing-framework/troubleshooting/#test-freezes-without-timeout-error","title":"Test freezes without timeout error","text":""},{"location":"testing-framework/troubleshooting/#contract-initcode-size-limit","title":"Contract initcode size limit","text":"<p>Due to faulty implementations of development chains, a test may freeze without any error message. Especially, a timeout error is not raised. The reason may be that the transaction is trying to deploy a contract with initcode larger than the limit introduced in the Shanghai hard fork.</p> <p>To debug this issue, compile the project and search for a warning message similar to the following:</p> <pre><code>Warning: Contract initcode size is 151670 bytes and exceeds 49152 bytes (a limit introduced in Shanghai).\nThis contract may not be deployable on Mainnet. Consider enabling the optimizer (with a low \"runs\" value!), turning off revert strings, or using libraries.\n</code></pre>"}]}